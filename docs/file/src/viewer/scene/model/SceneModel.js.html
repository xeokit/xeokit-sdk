<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/viewer/scene/model/SceneModel.js | xeokit-sdk</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="3D engineering graphics in the browser"><meta property="og:type" content="website"><meta property="og:url" content="http://xeokit.io"><meta property="og:site_name" content="xeokit-sdk"><meta property="og:title" content="xeokit-sdk"><meta property="og:image" content="./images/logo.jpg"><meta property="og:description" content="3D engineering graphics in the browser"><meta property="og:author" content="http://xeolabs.com"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="xeokit-sdk"><meta property="twitter:description" content="3D engineering graphics in the browser"><meta property="twitter:image" content="./images/logo.jpg"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.jpg" style="width:34px;"></a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/xeokit/xeokit-sdk"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-contextmenu">extras/ContextMenu</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/extras/ContextMenu/ContextMenu.js~ContextMenu.html">ContextMenu</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-marqueepicker">extras/MarqueePicker</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/extras/MarqueePicker/MarqueePicker.js~MarqueePicker.html">MarqueePicker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/extras/MarqueePicker/MarqueePickerMouseControl.js~MarqueePickerMouseControl.html">MarqueePickerMouseControl</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-pointercircle">extras/PointerCircle</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/extras/PointerCircle/PointerCircle.js~PointerCircle.html">PointerCircle</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-pointerlens">extras/PointerLens</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/extras/PointerLens/PointerLens.js~PointerLens.html">PointerLens</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-skybox">extras/Skybox</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createCombinedTexture">createCombinedTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createSkyboxMesh">createSkyboxMesh</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-spheremap">extras/SphereMap</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createSphereMapMesh">createSphereMapMesh</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extras-collision">extras/collision</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/extras/collision/ObjectsKdTree3.js~ObjectsKdTree3.html">ObjectsKdTree3</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-anglemeasurementsplugin">plugins/AngleMeasurementsPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/AngleMeasurement.js~AngleMeasurement.html">AngleMeasurement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/AngleMeasurementsMouseControl.js~AngleMeasurementsMouseControl.html">AngleMeasurementsMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/AngleMeasurementsPlugin.js~AngleMeasurementsPlugin.html">AngleMeasurementsPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/AngleMeasurementsTouchControl.js~AngleMeasurementsTouchControl.html">AngleMeasurementsTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/index.js~AngleMeasurementEditControl.html">AngleMeasurementEditControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/index.js~AngleMeasurementEditMouseControl.html">AngleMeasurementEditMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/index.js~AngleMeasurementEditTouchControl.html">AngleMeasurementEditTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/plugins/AngleMeasurementsPlugin/AngleMeasurementsControl.js~AngleMeasurementsControl.html">AngleMeasurementsControl</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-annotationsplugin">plugins/AnnotationsPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AnnotationsPlugin/Annotation.js~Annotation.html">Annotation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AnnotationsPlugin/AnnotationsPlugin.js~AnnotationsPlugin.html">AnnotationsPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-axisgizmoplugin">plugins/AxisGizmoPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/AxisGizmoPlugin/AxisGizmoPlugin.js~AxisGizmoPlugin.html">AxisGizmoPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-bcfviewpointsplugin">plugins/BCFViewpointsPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/BCFViewpointsPlugin/BCFViewpointsPlugin.js~BCFViewpointsPlugin.html">BCFViewpointsPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-cityjsonloaderplugin">plugins/CityJSONLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/CityJSONLoaderPlugin/CityJSONDefaultDataSource.js~CityJSONDefaultDataSource.html">CityJSONDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/CityJSONLoaderPlugin/CityJSONLoaderPlugin.js~CityJSONLoaderPlugin.html">CityJSONLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-cxconverterifcloaderplugin">plugins/CxConverterIFCLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/CxConverterIFCLoaderPlugin/CxConverterIFCLoaderPlugin.js~CxConverterIFCLoaderPlugin.html">CxConverterIFCLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-distancemeasurementsplugin">plugins/DistanceMeasurementsPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/DistanceMeasurement.js~DistanceMeasurement.html">DistanceMeasurement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/DistanceMeasurementsMouseControl.js~DistanceMeasurementsMouseControl.html">DistanceMeasurementsMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/DistanceMeasurementsPlugin.js~DistanceMeasurementsPlugin.html">DistanceMeasurementsPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/DistanceMeasurementsTouchControl.js~DistanceMeasurementsTouchControl.html">DistanceMeasurementsTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/index.js~DistanceMeasurementEditControl.html">DistanceMeasurementEditControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/index.js~DistanceMeasurementEditMouseControl.html">DistanceMeasurementEditMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/index.js~DistanceMeasurementEditTouchControl.html">DistanceMeasurementEditTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/plugins/DistanceMeasurementsPlugin/DistanceMeasurementsControl.js~DistanceMeasurementsControl.html">DistanceMeasurementsControl</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-dotbimloaderplugin">plugins/DotBIMLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DotBIMLoaderPlugin/DotBIMDefaultDataSource.js~DotBIMDefaultDataSource.html">DotBIMDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/DotBIMLoaderPlugin/DotBIMLoaderPlugin.js~DotBIMLoaderPlugin.html">DotBIMLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-facealignedsectionplanesplugin">plugins/FaceAlignedSectionPlanesPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/FaceAlignedSectionPlanesPlugin/FaceAlignedSectionPlanesControl.js~FaceAlignedSectionPlanesControl.html">FaceAlignedSectionPlanesControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/FaceAlignedSectionPlanesPlugin/FaceAlignedSectionPlanesPlugin.js~FaceAlignedSectionPlanesPlugin.html">FaceAlignedSectionPlanesPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-fastnavplugin">plugins/FastNavPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/FastNavPlugin/FastNavPlugin.js~FastNavPlugin.html">FastNavPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-gltfloaderplugin">plugins/GLTFLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/GLTFLoaderPlugin/GLTFDefaultDataSource.js~GLTFDefaultDataSource.html">GLTFDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/GLTFLoaderPlugin/GLTFLoaderPlugin.js~GLTFLoaderPlugin.html">GLTFLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-lasloaderplugin">plugins/LASLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/LASLoaderPlugin/LASDefaultDataSource.js~LASDefaultDataSource.html">LASDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/LASLoaderPlugin/LASLoaderPlugin.js~LASLoaderPlugin.html">LASLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-navcubeplugin">plugins/NavCubePlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/NavCubePlugin/NavCubePlugin.js~NavCubePlugin.html">NavCubePlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-objloaderplugin">plugins/OBJLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/OBJLoaderPlugin/OBJLoaderPlugin.js~OBJLoaderPlugin.html">OBJLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-stlloaderplugin">plugins/STLLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/STLLoaderPlugin/STLDefaultDataSource.js~STLDefaultDataSource.html">STLDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/STLLoaderPlugin/STLLoaderPlugin.js~STLLoaderPlugin.html">STLLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-sectionplanesplugin">plugins/SectionPlanesPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/SectionPlanesPlugin/SectionPlanesPlugin.js~SectionPlanesPlugin.html">SectionPlanesPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-storeyviewsplugin">plugins/StoreyViewsPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/StoreyViewsPlugin/Storey.js~Storey.html">Storey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/StoreyViewsPlugin/StoreyMap.js~StoreyMap.html">StoreyMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/StoreyViewsPlugin/StoreyViewsPlugin.js~StoreyViewsPlugin.html">StoreyViewsPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-treeviewplugin">plugins/TreeViewPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/TreeViewPlugin/RenderService.js~RenderService.html">RenderService</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/plugins/TreeViewPlugin/TreeViewNode.js~TreeViewNode.html">TreeViewNode</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-viewcullplugin">plugins/ViewCullPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ViewCullPlugin/ViewCullPlugin.js~ViewCullPlugin.html">ViewCullPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-webifcloaderplugin">plugins/WebIFCLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/WebIFCLoaderPlugin/WebIFCDefaultDataSource.js~WebIFCDefaultDataSource.html">WebIFCDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/WebIFCLoaderPlugin/WebIFCLoaderPlugin.js~WebIFCLoaderPlugin.html">WebIFCLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-xktloaderplugin">plugins/XKTLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/XKTLoaderPlugin/XKTDefaultDataSource.js~XKTDefaultDataSource.html">XKTDefaultDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html">XKTLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-xml3dloaderplugin">plugins/XML3DLoaderPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/XML3DLoaderPlugin/XML3DLoaderPlugin.js~XML3DLoaderPlugin.html">XML3DLoaderPlugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-zonesplugin">plugins/ZonesPlugin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZoneEditControl.html">ZoneEditControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZoneEditMouseControl.html">ZoneEditMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZoneEditTouchControl.html">ZoneEditTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZoneTranslateControl.html">ZoneTranslateControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZoneTranslateMouseControl.html">ZoneTranslateMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZoneTranslateTouchControl.html">ZoneTranslateTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZonesAAZoneControl.html">ZonesAAZoneControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZonesMouseControl.html">ZonesMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZonesPlugin.html">ZonesPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZonesPolysurfaceMouseControl.html">ZonesPolysurfaceMouseControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZonesPolysurfaceTouchControl.html">ZonesPolysurfaceTouchControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/ZonesPlugin/ZonesPlugin.js~ZonesTouchControl.html">ZonesTouchControl</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-lib-html">plugins/lib/html</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addContextMenuListener">addContextMenuListener</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#plugins-lib-ui">plugins/lib/ui</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/lib/ui/index.js~Dot3D.html">Dot3D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/lib/ui/index.js~Label3D.html">Label3D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/lib/ui/index.js~Wire3D.html">Wire3D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-activateDraggableDot">activateDraggableDot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-activateDraggableDots">activateDraggableDots</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addMousePressListener">addMousePressListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addTouchPressListener">addTouchPressListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-marker3D">marker3D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-startPolygonCreate">startPolygonCreate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-touchPointSelector">touchPointSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-transformToNode">transformToNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-triangulateEarClipping">triangulateEarClipping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-wire3D">wire3D</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer">viewer</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/Configs.js~Configs.html">Configs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/Plugin.js~Plugin.html">Plugin</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-localization">viewer/localization</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/localization/LocaleService.js~LocaleService.html">LocaleService</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-metadata">viewer/metadata</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/metadata/MetaModel.js~MetaModel.html">MetaModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/metadata/MetaObject.js~MetaObject.html">MetaObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/metadata/MetaScene.js~MetaScene.html">MetaScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/metadata/Property.js~Property.html">Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/metadata/PropertySet.js~PropertySet.html">PropertySet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IFCObjectDefaultColors">IFCObjectDefaultColors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IFCObjectDefaults">IFCObjectDefaults</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene">viewer/scene</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/Component.js~Component.html">Component</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/viewer/scene/Entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-stats">stats</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-bitmap">viewer/scene/Bitmap</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/Bitmap/Bitmap.js~Bitmap.html">Bitmap</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-imageplane">viewer/scene/ImagePlane</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/ImagePlane/ImagePlane.js~ImagePlane.html">ImagePlane</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-lineset">viewer/scene/LineSet</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/LineSet/LineSet.js~LineSet.html">LineSet</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-camera">viewer/scene/camera</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/Camera.js~Camera.html">Camera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/CameraFlightAnimation.js~CameraFlightAnimation.html">CameraFlightAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/CameraPath.js~CameraPath.html">CameraPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/CameraPathAnimation.js~CameraPathAnimation.html">CameraPathAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/CustomProjection.js~CustomProjection.html">CustomProjection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/Frustum.js~Frustum.html">Frustum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/Ortho.js~Ortho.html">Ortho</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/camera/Perspective.js~Perspective.html">Perspective</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-canvas">viewer/scene/canvas</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/canvas/Canvas.js~Canvas.html">Canvas</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/canvas/Spinner.js~Spinner.html">Spinner</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-constants">viewer/scene/constants</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AlphaFormat">AlphaFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ByteType">ByteType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ClampToEdgeWrapping">ClampToEdgeWrapping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CompressedMediaType">CompressedMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DepthFormat">DepthFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DepthStencilFormat">DepthStencilFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FloatType">FloatType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-GIFMediaType">GIFMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HalfFloatType">HalfFloatType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IntType">IntType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-JPEGMediaType">JPEGMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearEncoding">LinearEncoding</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearFilter">LinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipMapLinearFilter">LinearMipMapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipMapNearestFilter">LinearMipMapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipmapLinearFilter">LinearMipmapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipmapNearestFilter">LinearMipmapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LuminanceAlphaFormat">LuminanceAlphaFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LuminanceFormat">LuminanceFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MirroredRepeatWrapping">MirroredRepeatWrapping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestFilter">NearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipMapLinearFilter">NearestMipMapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipMapNearestFilter">NearestMipMapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipmapLinearFilter">NearestMipmapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipmapNearestFilter">NearestMipmapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PNGMediaType">PNGMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBAFormat">RGBAFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBAIntegerFormat">RGBAIntegerFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_10x10_Format">RGBA_ASTC_10x10_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_10x5_Format">RGBA_ASTC_10x5_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_10x6_Format">RGBA_ASTC_10x6_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_10x8_Format">RGBA_ASTC_10x8_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_12x10_Format">RGBA_ASTC_12x10_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_12x12_Format">RGBA_ASTC_12x12_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_4x4_Format">RGBA_ASTC_4x4_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_5x4_Format">RGBA_ASTC_5x4_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_5x5_Format">RGBA_ASTC_5x5_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_6x5_Format">RGBA_ASTC_6x5_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_6x6_Format">RGBA_ASTC_6x6_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_8x5_Format">RGBA_ASTC_8x5_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_8x6_Format">RGBA_ASTC_8x6_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ASTC_8x8_Format">RGBA_ASTC_8x8_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_BPTC_Format">RGBA_BPTC_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_ETC2_EAC_Format">RGBA_ETC2_EAC_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_PVRTC_2BPPV1_Format">RGBA_PVRTC_2BPPV1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_PVRTC_4BPPV1_Format">RGBA_PVRTC_4BPPV1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_S3TC_DXT1_Format">RGBA_S3TC_DXT1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_S3TC_DXT3_Format">RGBA_S3TC_DXT3_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBA_S3TC_DXT5_Format">RGBA_S3TC_DXT5_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGBFormat">RGBFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGB_ETC1_Format">RGB_ETC1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGB_ETC2_Format">RGB_ETC2_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGB_PVRTC_2BPPV1_Format">RGB_PVRTC_2BPPV1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGB_PVRTC_4BPPV1_Format">RGB_PVRTC_4BPPV1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGB_S3TC_DXT1_Format">RGB_S3TC_DXT1_Format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGFormat">RGFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RGIntegerFormat">RGIntegerFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RedFormat">RedFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RedIntegerFormat">RedIntegerFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RepeatWrapping">RepeatWrapping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ShortType">ShortType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsignedByteType">UnsignedByteType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsignedInt248Type">UnsignedInt248Type</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsignedIntType">UnsignedIntType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsignedShort4444Type">UnsignedShort4444Type</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsignedShort5551Type">UnsignedShort5551Type</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsignedShortType">UnsignedShortType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sRGBEncoding">sRGBEncoding</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-geometry">viewer/scene/geometry</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/geometry/Geometry.js~Geometry.html">Geometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/geometry/ReadableGeometry.js~ReadableGeometry.html">ReadableGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/geometry/VBOGeometry.js~VBOGeometry.html">VBOGeometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-geometry-builders">viewer/scene/geometry/builders</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxGeometry">buildBoxGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxLinesGeometry">buildBoxLinesGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxLinesGeometryFromAABB">buildBoxLinesGeometryFromAABB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildCylinderGeometry">buildCylinderGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildGridGeometry">buildGridGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildLineGeometry">buildLineGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildPlaneGeometry">buildPlaneGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildPolylineGeometry">buildPolylineGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildPolylineGeometryFromCurve">buildPolylineGeometryFromCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildSphereGeometry">buildSphereGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildTorusGeometry">buildTorusGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildVectorTextGeometry">buildVectorTextGeometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-geometry-loaders">viewer/scene/geometry/loaders</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-load3DSGeometry">load3DSGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadOBJGeometry">loadOBJGeometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-input">viewer/scene/input</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/input/Input.js~Input.html">Input</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-libs">viewer/scene/libs</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deviation">deviation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-earcut">earcut</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-flatten">flatten</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-lights">viewer/scene/lights</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/AmbientLight.js~AmbientLight.html">AmbientLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/CubeTexture.js~CubeTexture.html">CubeTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/DirLight.js~DirLight.html">DirLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/Light.js~Light.html">Light</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/LightMap.js~LightMap.html">LightMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/PointLight.js~PointLight.html">PointLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/ReflectionMap.js~ReflectionMap.html">ReflectionMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/lights/Shadow.js~Shadow.html">Shadow</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-marker">viewer/scene/marker</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/marker/Marker.js~Marker.html">Marker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/marker/SpriteMarker.js~SpriteMarker.html">SpriteMarker</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-materials">viewer/scene/materials</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/EdgeMaterial.js~EdgeMaterial.html">EdgeMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/EmphasisMaterial.js~EmphasisMaterial.html">EmphasisMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/Fresnel.js~Fresnel.html">Fresnel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/LambertMaterial.js~LambertMaterial.html">LambertMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/LinesMaterial.js~LinesMaterial.html">LinesMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/Material.js~Material.html">Material</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/MetallicMaterial.js~MetallicMaterial.html">MetallicMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/PhongMaterial.js~PhongMaterial.html">PhongMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/PointsMaterial.js~PointsMaterial.html">PointsMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/SpecularMaterial.js~SpecularMaterial.html">SpecularMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/materials/Texture.js~Texture.html">Texture</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-math">viewer/scene/math</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/math/MeshSurfaceArea.js~MeshSurfaceArea.html">MeshSurfaceArea</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/math/MeshVolume.js~MeshVolume.html">MeshVolume</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-meshSurfaceArea">meshSurfaceArea</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-meshVolume">meshVolume</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-mementos">viewer/scene/mementos</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/mementos/CameraMemento.js~CameraMemento.html">CameraMemento</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/mementos/ModelMemento.js~ModelMemento.html">ModelMemento</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/mementos/ObjectsMemento.js~ObjectsMemento.html">ObjectsMemento</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-mesh">viewer/scene/mesh</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/mesh/Mesh.js~Mesh.html">Mesh</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-mesh-draw">viewer/scene/mesh/draw</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-DrawShaderSource">DrawShaderSource</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-metriqs">viewer/scene/metriqs</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/metriqs/Metriqs.js~Metrics.html">Metrics</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-model">viewer/scene/model</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/PerformanceModel.js~PerformanceModel.html">PerformanceModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/SceneModel.js~SceneModel.html">SceneModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/SceneModelEntity.js~SceneModelEntity.html">SceneModelEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/SceneModelMesh.js~SceneModelMesh.html">SceneModelMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/SceneModelTexture.js~SceneModelTexture.html">SceneModelTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/SceneModelTextureSet.js~SceneModelTextureSet.html">SceneModelTextureSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/SceneModelTransform.js~SceneModelTransform.html">SceneModelTransform</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/model/VBOSceneModel.js~VBOSceneModel.html">VBOSceneModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-uniquifyPositions">uniquifyPositions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-rebucketPositions">rebucketPositions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-model-dtx-lines">viewer/scene/model/dtx/lines</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-rebucketPositions">rebucketPositions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataTextureRamStats">dataTextureRamStats</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-model-dtx-triangles-lib">viewer/scene/model/dtx/triangles/lib</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataTextureRamStats">dataTextureRamStats</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-nodes">viewer/scene/nodes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/nodes/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-paths">viewer/scene/paths</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/paths/CubicBezierCurve.js~CubicBezierCurve.html">CubicBezierCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/paths/Curve.js~Curve.html">Curve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/paths/Path.js~Path.html">Path</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/paths/QuadraticBezierCurve.js~QuadraticBezierCurve.html">QuadraticBezierCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/paths/SplineCurve.js~SplineCurve.html">SplineCurve</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-postfx">viewer/scene/postfx</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/postfx/CrossSections.js~CrossSections.html">CrossSections</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/postfx/SAO.js~SAO.html">SAO</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-scene">viewer/scene/scene</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/scene/Scene.js~Scene.html">Scene</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-sectioncaps">viewer/scene/sectionCaps</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/sectionCaps/SectionCaps.js~SectionCaps.html">SectionCaps</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-sectionplane">viewer/scene/sectionPlane</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/sectionPlane/SectionPlane.js~SectionPlane.html">SectionPlane</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/sectionPlane/SectionPlaneCache.js~SectionPlaneCache.html">SectionPlaneCache</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-utils">viewer/scene/utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/utils/FileLoader.js~FileLoader.html">FileLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/utils/Loader.js~Loader.html">Loader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/utils/LoadingManager.js~LoadingManager.html">LoadingManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/utils/WorkerPool.js~WorkerPool.html">WorkerPool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Cache">Cache</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DefaultLoadingManager">DefaultLoadingManager</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-utils-texturetranscoders">viewer/scene/utils/textureTranscoders</a><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/viewer/scene/utils/textureTranscoders/TextureTranscoder.js~TextureTranscoder.html">TextureTranscoder</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-utils-texturetranscoders-ktx2texturetranscoder">viewer/scene/utils/textureTranscoders/KTX2TextureTranscoder</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/utils/textureTranscoders/KTX2TextureTranscoder/KTX2TextureTranscoder.js~KTX2TextureTranscoder.html">KTX2TextureTranscoder</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-viewport">viewer/scene/viewport</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/viewport/Viewport.js~Viewport.html">Viewport</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-scene-webgl">viewer/scene/webgl</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/viewer/scene/webgl/PickResult.js~PickResult.html">PickResult</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#viewer-utils">viewer/utils</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-os">os</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/viewer/scene/model/SceneModel.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {Component} from &quot;../Component.js&quot;;
import {math} from &quot;../math/math.js&quot;;
import {buildEdgeIndices} from &apos;../math/buildEdgeIndices.js&apos;;
import {SceneModelMesh} from &apos;./SceneModelMesh.js&apos;;
import {getScratchMemory, putScratchMemory} from &quot;./vbo/ScratchMemory.js&quot;;
import {VBOBatchingTrianglesLayer} from &apos;./vbo/batching/triangles/VBOBatchingTrianglesLayer.js&apos;;
import {VBOInstancingTrianglesLayer} from &apos;./vbo/instancing/triangles/VBOInstancingTrianglesLayer.js&apos;;
import {VBOBatchingLinesLayer} from &apos;./vbo/batching/lines/VBOBatchingLinesLayer.js&apos;;
import {VBOInstancingLinesLayer} from &apos;./vbo/instancing/lines/VBOInstancingLinesLayer.js&apos;;
import {VBOBatchingPointsLayer} from &apos;./vbo/batching/points/VBOBatchingPointsLayer.js&apos;;
import {VBOInstancingPointsLayer} from &apos;./vbo/instancing/points/VBOInstancingPointsLayer.js&apos;;
import {DTXLinesLayer} from &quot;./dtx/lines/DTXLinesLayer.js&quot;;
import {DTXTrianglesLayer} from &quot;./dtx/triangles/DTXTrianglesLayer.js&quot;;
import {ENTITY_FLAGS} from &apos;./ENTITY_FLAGS.js&apos;;
import {RenderFlags} from &quot;../webgl/RenderFlags.js&quot;;
import {worldToRTCPositions} from &quot;../math/rtcCoords.js&quot;;
import {SceneModelTextureSet} from &quot;./SceneModelTextureSet.js&quot;;
import {SceneModelTexture} from &quot;./SceneModelTexture.js&quot;;
import {Texture2D} from &quot;../webgl/Texture2D.js&quot;;
import {utils} from &quot;../utils.js&quot;;
import {getKTX2TextureTranscoder} from &quot;../utils/textureTranscoders/KTX2TextureTranscoder/KTX2TextureTranscoder.js&quot;;
import {
    ClampToEdgeWrapping,
    LinearEncoding,
    LinearFilter,
    LinearMipmapLinearFilter,
    LinearMipMapNearestFilter,
    MirroredRepeatWrapping,
    NearestFilter,
    NearestMipMapLinearFilter,
    NearestMipMapNearestFilter,
    RepeatWrapping,
    sRGBEncoding
} from &quot;../constants/constants.js&quot;;
import {createPositionsDecodeMatrix, quantizePositions} from &quot;./compression.js&quot;;
import {uniquifyPositions} from &quot;./calculateUniquePositions.js&quot;;
import {rebucketPositions} from &quot;./rebucketPositions.js&quot;;
import {SceneModelEntity} from &quot;./SceneModelEntity.js&quot;;
import {geometryCompressionUtils} from &quot;../math/geometryCompressionUtils.js&quot;;
import {SceneModelTransform} from &quot;./SceneModelTransform.js&quot;;


const tempVec3a = math.vec3();

const tempOBB3 = math.OBB3();
const tempQuaternion = math.vec4();

const DEFAULT_SCALE = math.vec3([1, 1, 1]);
const DEFAULT_POSITION = math.vec3([0, 0, 0]);
const DEFAULT_ROTATION = math.vec3([0, 0, 0]);
const DEFAULT_QUATERNION = math.identityQuaternion();
const DEFAULT_MATRIX = math.identityMat4();

const DEFAULT_COLOR_TEXTURE_ID = &quot;defaultColorTexture&quot;;
const DEFAULT_METAL_ROUGH_TEXTURE_ID = &quot;defaultMetalRoughTexture&quot;;
const DEFAULT_NORMALS_TEXTURE_ID = &quot;defaultNormalsTexture&quot;;
const DEFAULT_EMISSIVE_TEXTURE_ID = &quot;defaultEmissiveTexture&quot;;
const DEFAULT_OCCLUSION_TEXTURE_ID = &quot;defaultOcclusionTexture&quot;;
const DEFAULT_TEXTURE_SET_ID = &quot;defaultTextureSet&quot;;

const defaultCompressedColor = new Uint8Array([255, 255, 255]);

const VBO_INSTANCED = 0;
const VBO_BATCHED = 1;
const DTX = 2;

/**
 * @desc A high-performance model representation for efficient rendering and low memory usage.
 *
 * # Examples
 *
 * Internally, SceneModel uses a combination of several different techniques to render and represent
 * the different parts of a typical model. Each of the live examples at these links is designed to &quot;unit test&quot; one of these
 * techniques, in isolation. If some bug occurs in SceneModel, we use these tests to debug, but they also
 * serve to demonstrate how to use the capabilities of SceneModel programmatically.
 *
 * * [Loading building models into SceneModels](/examples/buildings)
 * * [Loading city models into SceneModels](/examples/cities)
 * * [Loading LiDAR scans into SceneModels](/examples/lidar)
 * * [Loading CAD models into SceneModels](/examples/cad)
 * * [SceneModel feature tests](/examples/scenemodel)
 *
 * # Overview
 *
 * While xeokit&apos;s standard [scene graph](https://github.com/xeokit/xeokit-sdk/wiki/Scene-Graphs) is great for gizmos and medium-sized models, it doesn&apos;t scale up to millions of objects in terms of memory and rendering efficiency.
 *
 * For huge models, we have the ````SceneModel```` representation, which is optimized to pack large amounts of geometry into memory and render it efficiently using WebGL.
 *
 * ````SceneModel```` is the default model representation loaded by  (at least) {@link GLTFLoaderPlugin}, {@link XKTLoaderPlugin} and  {@link WebIFCLoaderPlugin}.
 *
 * In this tutorial you&apos;ll learn how to use ````SceneModel```` to create high-detail content programmatically. Ordinarily you&apos;d be learning about ````SceneModel```` if you were writing your own model loader plugins.
 *
 * # Contents
 *
 * - [SceneModel](#DataTextureSceneModel)
 * - [GPU-Resident Geometry](#gpu-resident-geometry)
 * - [Picking](#picking)
 * - [Example 1: Geometry Instancing](#example-1--geometry-instancing)
 * - [Finalizing a SceneModel](#finalizing-a-DataTextureSceneModel)
 * - [Finding Entities](#finding-entities)
 * - [Example 2: Geometry Batching](#example-2--geometry-batching)
 * - [Classifying with Metadata](#classifying-with-metadata)
 * - [Querying Metadata](#querying-metadata)
 * - [Metadata Structure](#metadata-structure)
 * - [RTC Coordinates](#rtc-coordinates-for-double-precision)
 *   - [Example 3: RTC Coordinates with Geometry Instancing](#example-2--rtc-coordinates-with-geometry-instancing)
 *   - [Example 4: RTC Coordinates with Geometry Batching](#example-2--rtc-coordinates-with-geometry-batching)
 *
 * ## SceneModel
 *
 * ````SceneModel```` uses two rendering techniques internally:
 *
 * 1. ***Geometry batching*** for unique geometries, combining those into a single WebGL geometry buffer, to render in one draw call, and
 * 2. ***geometry instancing*** for geometries that are shared by multiple meshes, rendering all instances of each shared geometry in one draw call.
 *
 * &lt;br&gt;
 * These techniques come with certain limitations:
 *
 * * Non-realistic rendering - while scene graphs can use xeokit&apos;s full set of material workflows, ````SceneModel```` uses simple Lambertian shading without textures.
 * * Static transforms - transforms within a ````SceneModel```` are static and cannot be dynamically translated, rotated and scaled the way {@link Node}s and {@link Mesh}es in scene graphs can.
 * * Immutable model representation - while scene graph {@link Node}s and
 * {@link Mesh}es can be dynamically plugged together, ````SceneModel```` is immutable,
 * since it packs its geometries into buffers and instanced arrays.
 *
 * ````SceneModel````&apos;s API allows us to exploit batching and instancing, while exposing its elements as
 * abstract {@link Entity} types.
 *
 * {@link Entity} is the abstract base class for
 * the various xeokit components that represent models, objects, or anonymous visible elements. An Entity has a unique ID and can be
 * individually shown, hidden, selected, highlighted, ghosted, culled, picked and clipped, and has its own World-space boundary.
 *
 * * A ````SceneModel```` is an {@link Entity} that represents a model.
 * * A ````SceneModel```` represents each of its objects with an {@link Entity}.
 * * Each {@link Entity} has one or more meshes that define its shape.
 * * Each mesh has either its own unique geometry, or shares a geometry with other meshes.
 *
 * ## GPU-Resident Geometry
 *
 * For a low memory footprint, ````SceneModel```` stores its geometries in GPU memory only, compressed (quantized) as integers. Unfortunately, GPU-resident geometry is
 * not readable by JavaScript.
 *
 *
 * ## Example 1: Geometry Instancing
 *
 * In the example below, we&apos;ll use a ````SceneModel````
 * to build a simple table model using geometry instancing.
 *
 * We&apos;ll start by adding a reusable box-shaped geometry to our ````SceneModel````.
 *
 * Then, for each object in our model we&apos;ll add an {@link Entity}
 * that has a mesh that instances our box geometry, transforming and coloring the instance.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/index.html#sceneRepresentation_SceneModel_instancing)
 *
 * ````javascript
 * import {Viewer, SceneModel} from &quot;xeokit-sdk.es.js&quot;;
 *
 * const viewer = new Viewer({
 *     canvasId: &quot;myCanvas&quot;,
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * // Build a SceneModel representing a table
 * // with four legs, using geometry instancing
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *     id: &quot;table&quot;,
 *     isModel: true, // &lt;--- Registers SceneModel in viewer.scene.models
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * // Create a reusable geometry within the SceneModel
 * // We&apos;ll instance this geometry by five meshes
 *
 * sceneModel.createGeometry({
 *
 *     id: &quot;myBoxGeometry&quot;,
 *
 *     // The primitive type - allowed values are &quot;points&quot;, &quot;lines&quot; and &quot;triangles&quot;.
 *     // See the OpenGL/WebGL specification docs
 *     // for how the coordinate arrays are supposed to be laid out.
 *     primitive: &quot;triangles&quot;,
 *
 *     // The vertices - eight for our cube, each
 *     // one spanning three array elements for X,Y and Z
 *     positions: [
 *          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
 *          1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v1 right
 *          1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v1-v6-v1 top
 *          -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
 *          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // v7-v4-v3-v2 bottom
 *          1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v1 back
 *     ],
 *
 *     // Normal vectors, one for each vertex
 *     normals: [
 *         0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v1-v2-v3 front
 *         1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right
 *         0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v0-v5-v6-v1 top
 *         -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v1-v6-v7-v2 left
 *         0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v7-v4-v3-v2 bottom
 *         0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 // v4-v7-v6-v5 back
 *     ],
 *
 *     // Indices - these organise the positions and and normals
 *     // into geometric primitives in accordance with the &quot;primitive&quot; parameter,
 *     // in this case a set of three indices for each triangle.
 *     //
 *     // Note that each triangle is specified in counter-clockwise winding order.
 *     //
 *     indices: [
 *         0, 1, 2, 0, 2, 3, // front
 *         4, 5, 6, 4, 6, 7, // right
 *         8, 9, 10, 8, 10, 11, // top
 *         12, 13, 14, 12, 14, 15, // left
 *         16, 17, 18, 16, 18, 19, // bottom
 *         20, 21, 22, 20, 22, 23
 *     ]
 * });
 *
 * // Red table leg
 *
 * sceneModel.createMesh({
 *     id: &quot;redLegMesh&quot;,
 *     geometryId: &quot;myBoxGeometry&quot;,
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;redLeg&quot;,
 *     meshIds: [&quot;redLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Green table leg
 *
 * sceneModel.createMesh({
 *     id: &quot;greenLegMesh&quot;,
 *     geometryId: &quot;myBoxGeometry&quot;,
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;greenLeg&quot;,
 *     meshIds: [&quot;greenLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Blue table leg
 *
 * sceneModel.createMesh({
 *     id: &quot;blueLegMesh&quot;,
 *     geometryId: &quot;myBoxGeometry&quot;,
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;blueLeg&quot;,
 *     meshIds: [&quot;blueLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Yellow table leg
 *
 * sceneModel.createMesh({
 *      id: &quot;yellowLegMesh&quot;,
 *      geometryId: &quot;myBoxGeometry&quot;,
 *      position: [-4, -6, 4],
 *      scale: [1, 3, 1],
 *      rotation: [0, 0, 0],
 *      color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;yellowLeg&quot;,
 *     meshIds: [&quot;yellowLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Purple table top
 *
 * sceneModel.createMesh({
 *     id: &quot;purpleTableTopMesh&quot;,
 *     geometryId: &quot;myBoxGeometry&quot;,
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;purpleTableTop&quot;,
 *     meshIds: [&quot;purpleTableTopMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *  ````
 *
 * ## Finalizing a SceneModel
 *
 * Before we can view and interact with our ````SceneModel````, we need to **finalize** it. Internally, this causes the ````SceneModel```` to build the
 * vertex buffer objects (VBOs) that support our geometry instances. When using geometry batching (see next example),
 * this causes ````SceneModel```` to build the VBOs that combine the batched geometries. Note that you can do both instancing and
 * batching within the same ````SceneModel````.
 *
 * Once finalized, we can&apos;t add anything more to our ````SceneModel````.
 *
 * ```` javascript
 * SceneModel.finalize();
 * ````
 *
 * ## Finding Entities
 *
 * As mentioned earlier, {@link Entity} is
 * the abstract base class for components that represent models, objects, or just
 * anonymous visible elements.
 *
 * Since we created configured our ````SceneModel```` with ````isModel: true````,
 * we&apos;re able to find it as an Entity by ID in ````viewer.scene.models````. Likewise, since
 * we configured each of its Entities with ````isObject: true````, we&apos;re able to
 * find them in  ````viewer.scene.objects````.
 *
 *
 * ````javascript
 * // Get the whole table model Entity
 * const table = viewer.scene.models[&quot;table&quot;];
 *
 *  // Get some leg object Entities
 * const redLeg = viewer.scene.objects[&quot;redLeg&quot;];
 * const greenLeg = viewer.scene.objects[&quot;greenLeg&quot;];
 * const blueLeg = viewer.scene.objects[&quot;blueLeg&quot;];
 * ````
 *
 * ## Example 2: Geometry Batching
 *
 * Let&apos;s once more use a ````SceneModel````
 * to build the simple table model, this time exploiting geometry batching.
 *
 *  [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/index.html#sceneRepresentation_SceneModel_batching)
 *
 * ````javascript
 * import {Viewer, SceneModel} from &quot;xeokit-sdk.es.js&quot;;
 *
 * const viewer = new Viewer({
 *     canvasId: &quot;myCanvas&quot;,
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * // Create a SceneModel representing a table with four legs, using geometry batching
 * const sceneModel = new SceneModel(viewer.scene, {
 *     id: &quot;table&quot;,
 *     isModel: true,  // &lt;--- Registers SceneModel in viewer.scene.models
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * // Red table leg
 *
 * sceneModel.createMesh({
 *     id: &quot;redLegMesh&quot;,
 *
 *     // Geometry arrays are same as for the earlier batching example
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;redLeg&quot;,
 *     meshIds: [&quot;redLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Green table leg
 *
 * sceneModel.createMesh({
 *     id: &quot;greenLegMesh&quot;,
 *     primitive: &quot;triangles&quot;,
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;greenLeg&quot;,
 *     meshIds: [&quot;greenLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Blue table leg
 *
 * sceneModel.createMesh({
 *     id: &quot;blueLegMesh&quot;,
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;blueLeg&quot;,
 *     meshIds: [&quot;blueLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Yellow table leg object
 *
 * sceneModel.createMesh({
 *     id: &quot;yellowLegMesh&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;yellowLeg&quot;,
 *     meshIds: [&quot;yellowLegMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Purple table top
 *
 * sceneModel.createMesh({
 *     id: &quot;purpleTableTopMesh&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: &quot;purpleTableTop&quot;,
 *     meshIds: [&quot;purpleTableTopMesh&quot;],
 *     isObject: true // &lt;---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Finalize the SceneModel.
 *
 * SceneModel.finalize();
 *
 * // Find BigModelNodes by their model and object IDs
 *
 * // Get the whole table model
 * const table = viewer.scene.models[&quot;table&quot;];
 *
 * // Get some leg objects
 * const redLeg = viewer.scene.objects[&quot;redLeg&quot;];
 * const greenLeg = viewer.scene.objects[&quot;greenLeg&quot;];
 * const blueLeg = viewer.scene.objects[&quot;blueLeg&quot;];
 * ````
 *
 * ## Classifying with Metadata
 *
 * In the previous examples, we used ````SceneModel```` to build
 * two versions of the same table model, to demonstrate geometry batching and geometry instancing.
 *
 * We&apos;ll now classify our {@link Entity}s with metadata. This metadata
 * will work the same for both our examples, since they create the exact same structure of {@link Entity}s
 * to represent their models and objects. The abstract Entity type is, after all, intended to provide an abstract interface through which differently-implemented scene content can be accessed uniformly.
 *
 * To create the metadata, we&apos;ll create a {@link MetaModel} for our model,
 * with a {@link MetaObject} for each of it&apos;s objects. The MetaModel and MetaObjects
 * get the same IDs as the {@link Entity}s that represent their model and objects within our scene.
 *
 * ```` javascript
 * const furnitureMetaModel = viewer.metaScene.createMetaModel(&quot;furniture&quot;, {         // Creates a MetaModel in the MetaScene
 *
 *      &quot;projectId&quot;: &quot;myTableProject&quot;,
 *      &quot;revisionId&quot;: &quot;V1.0&quot;,
 *
 *      &quot;metaObjects&quot;: [
 *          {                               // Creates a MetaObject in the MetaModel
 *              &quot;id&quot;: &quot;table&quot;,
 *              &quot;name&quot;: &quot;Table&quot;,            // Same ID as an object Entity
 *              &quot;type&quot;: &quot;furniture&quot;,        // Arbitrary type, could be IFC type
 *              &quot;properties&quot;: {             // Arbitrary properties, could be IfcPropertySet
 *                  &quot;cost&quot;: &quot;200&quot;
 *              }
 *          },
 *          {
 *              &quot;id&quot;: &quot;redLeg&quot;,
 *              &quot;name&quot;: &quot;Red table Leg&quot;,
 *              &quot;type&quot;: &quot;leg&quot;,
 *              &quot;parent&quot;: &quot;table&quot;,           // References first MetaObject as parent
 *              &quot;properties&quot;: {
 *                  &quot;material&quot;: &quot;wood&quot;
 *              }
 *          },
 *          {
 *              &quot;id&quot;: &quot;greenLeg&quot;,           // Node with corresponding id does not need to exist
 *              &quot;name&quot;: &quot;Green table leg&quot;,  // and MetaObject does not need to exist for Node with an id
 *              &quot;type&quot;: &quot;leg&quot;,
 *              &quot;parent&quot;: &quot;table&quot;,
 *              &quot;properties&quot;: {
 *                  &quot;material&quot;: &quot;wood&quot;
 *              }
 *          },
 *          {
 *              &quot;id&quot;: &quot;blueLeg&quot;,
 *              &quot;name&quot;: &quot;Blue table leg&quot;,
 *              &quot;type&quot;: &quot;leg&quot;,
 *              &quot;parent&quot;: &quot;table&quot;,
 *              &quot;properties&quot;: {
 *                  &quot;material&quot;: &quot;wood&quot;
 *              }
 *          },
 *          {
 *              &quot;id&quot;: &quot;yellowLeg&quot;,
 *              &quot;name&quot;: &quot;Yellow table leg&quot;,
 *              &quot;type&quot;: &quot;leg&quot;,
 *              &quot;parent&quot;: &quot;table&quot;,
 *              &quot;properties&quot;: {
 *                  &quot;material&quot;: &quot;wood&quot;
 *              }
 *          },
 *          {
 *              &quot;id&quot;: &quot;tableTop&quot;,
 *              &quot;name&quot;: &quot;Purple table top&quot;,
 *              &quot;type&quot;: &quot;surface&quot;,
 *              &quot;parent&quot;: &quot;table&quot;,
 *              &quot;properties&quot;: {
 *                  &quot;material&quot;: &quot;formica&quot;,
 *                  &quot;width&quot;: &quot;60&quot;,
 *                  &quot;depth&quot;: &quot;60&quot;,
 *                  &quot;thickness&quot;: &quot;5&quot;
 *              }
 *          }
 *      ]
 *  });
 * ````
 *
 * ## Querying Metadata
 *
 * Having created and classified our model (either the instancing or batching example), we can now find the {@link MetaModel}
 * and {@link MetaObject}s using the IDs of their
 * corresponding {@link Entity}s.
 *
 * ````JavaScript
 * const furnitureMetaModel = scene.metaScene.metaModels[&quot;furniture&quot;];
 *
 * const redLegMetaObject = scene.metaScene.metaObjects[&quot;redLeg&quot;];
 * ````
 *
 * In the snippet below, we&apos;ll log metadata on each {@link Entity} we click on:
 *
 * ````JavaScript
 * viewer.scene.input.on(&quot;mouseclicked&quot;, function (coords) {
 *
 *      const hit = viewer.scene.pick({
 *          canvasPos: coords
 *      });
 *
 *      if (hit) {
 *          const entity = hit.entity;
 *          const metaObject = viewer.metaScene.metaObjects[entity.id];
 *          if (metaObject) {
 *              console.log(JSON.stringify(metaObject.getJSON(), null, &quot;\t&quot;));
 *          }
 *      }
 *  });
 * ````
 *
 * ## Metadata Structure
 *
 * The {@link MetaModel}
 * organizes its {@link MetaObject}s in
 * a tree that describes their structural composition:
 *
 * ````JavaScript
 * // Get metadata on the root object
 * const tableMetaObject = furnitureMetaModel.rootMetaObject;
 *
 * // Get metadata on the leg objects
 * const redLegMetaObject = tableMetaObject.children[0];
 * const greenLegMetaObject = tableMetaObject.children[1];
 * const blueLegMetaObject = tableMetaObject.children[2];
 * const yellowLegMetaObject = tableMetaObject.children[3];
 * ````
 *
 * Given an {@link Entity}, we can find the object or model of which it is a part, or the objects that comprise it. We can also generate UI
 * components from the metadata, such as the tree view demonstrated in [this demo](https://xeokit.github.io/xeokit-sdk/examples/index.html#BIMOffline_glTF_OTCConferenceCenter).
 *
 * This hierarchy allows us to express the hierarchical structure of a model while representing it in
 * various ways in the 3D scene (such as with ````SceneModel````, which
 * has a non-hierarchical scene representation).
 *
 * Note also that a {@link MetaObject} does not need to have a corresponding
 * {@link Entity} and vice-versa.
 *
 * # RTC Coordinates for Double Precision
 *
 * ````SceneModel```` can emulate 64-bit precision on GPUs using relative-to-center (RTC) coordinates.
 *
 * Consider a model that contains many small objects, but with such large spatial extents that 32 bits of GPU precision (accurate to ~7 digits) will not be sufficient to render all of the the objects without jittering.
 *
 * To prevent jittering, we could spatially subdivide the objects into &quot;tiles&quot;. Each tile would have a center position, and the positions of the objects within the tile would be relative to that center (&quot;RTC coordinates&quot;).
 *
 * While the center positions of the tiles would be 64-bit values, the object positions only need to be 32-bit.
 *
 * Internally, when rendering an object with RTC coordinates, xeokit first temporarily translates the camera viewing matrix by the object&apos;s tile&apos;s RTC center, on the CPU, using 64-bit math.
 *
 * Then xeokit loads the viewing matrix into its WebGL shaders, where math happens at 32-bit precision. Within the shaders, the matrix is effectively down-cast to 32-bit precision, and the object&apos;s 32-bit vertex positions are transformed by the matrix.
 *
 * We see no jittering, because with RTC a detectable loss of GPU accuracy only starts happening to objects as they become very distant from the camera viewpoint, at which point they are too small to be discernible anyway.
 *
 * ## RTC Coordinates with Geometry Instancing
 *
 * To use RTC with ````SceneModel```` geometry instancing, we specify an RTC center for the geometry via its ````origin```` parameter. Then ````SceneModel```` assumes that all meshes that instance that geometry are within the same RTC coordinate system, ie. the meshes ````position```` and ````rotation```` properties are assumed to be relative to the geometry&apos;s ````origin````.
 *
 * For simplicity, our example&apos;s meshes all instance the same geometry. Therefore, our example model has only one RTC center.
 *
 * Note that the axis-aligned World-space boundary (AABB) of our model is ````[&#xA0;-6, -9, -6, 1000000006, -2.5, 1000000006]````.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/index.html#sceneRepresentation_SceneModel_batching)
 *
 * ````javascript
 * const origin = [100000000, 0, 100000000];
 *
 * sceneModel.createGeometry({
 *     id: &quot;box&quot;,
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg1&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg1&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg2&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg2&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg3&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg3&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg4&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg4&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;top&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;top&quot;],
 *     isObject: true
 * });
 * ````
 *
 * ## RTC Coordinates with Geometry Batching
 *
 * To use RTC with ````SceneModel```` geometry batching, we specify an RTC center (````origin````) for each mesh. For performance, we try to have as many meshes share the same value for ````origin```` as possible. Each mesh&apos;s ````positions````, ````position```` and ````rotation```` properties are assumed to be relative to ````origin````.
 *
 * For simplicity, the meshes in our example all share the same RTC center.
 *
 * The axis-aligned World-space boundary (AABB) of our model is ````[&#xA0;-6, -9, -6, 1000000006, -2.5, 1000000006]````.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/index.html#sceneRepresentation_SceneModel_batching)
 *
 * ````javascript
 * const origin = [100000000, 0, 100000000];
 *
 * sceneModel.createMesh({
 *     id: &quot;leg1&quot;,
 *     origin: origin, // This mesh&apos;s positions and transforms are relative to the RTC center
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg1&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg2&quot;,
 *     origin: origin, // This mesh&apos;s positions and transforms are relative to the RTC center
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg2&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg3&quot;,
 *     origin: origin, // This mesh&apos;s positions and transforms are relative to the RTC center
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg3&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg4&quot;,
 *     origin: origin, // This mesh&apos;s positions and transforms are relative to the RTC center
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg4&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;top&quot;,
 *     origin: origin, // This mesh&apos;s positions and transforms are relative to the RTC center
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;top&quot;],
 *     isObject: true
 * });
 * ````
 *
 * ## Positioning at World-space coordinates
 *
 * To position a SceneModel at given double-precision World coordinates, we can
 * configure the ````origin```` of the SceneModel itself. The ````origin```` is a double-precision
 * 3D World-space position at which the SceneModel will be located.
 *
 * Note that ````position```` is a single-precision offset relative to ````origin````.
 *
 * ````javascript
 * const origin = [100000000, 0, 100000000];
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *     id: &quot;table&quot;,
 *     isModel: true,
 *     origin: origin, // Everything in this SceneModel is relative to this RTC center
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * sceneModel.createGeometry({
 *     id: &quot;box&quot;,
 *     primitive: &quot;triangles&quot;,
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg1&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg1&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg2&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg2&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg3&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg3&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;leg4&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;leg4&quot;],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: &quot;top&quot;,
 *     geometryId: &quot;box&quot;,
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: [&quot;top&quot;],
 *     isObject: true
 * });
 * ````
 *
 * # Textures
 *
 * ## Loading KTX2 Texture Files into a SceneModel
 *
 * A {@link SceneModel} that is configured with a {@link KTX2TextureTranscoder} will
 * allow us to load textures into it from KTX2 buffers or files.
 *
 * In the example below, we&apos;ll create a {@link Viewer}, containing a {@link SceneModel} configured with a
 * {@link KTX2TextureTranscoder}. We&apos;ll then programmatically create a simple object within the SceneModel, consisting of
 * a single mesh with a texture loaded from a KTX2 file, which our SceneModel internally transcodes, using
 * its {@link KTX2TextureTranscoder}. Note how we configure our {@link KTX2TextureTranscoder} with a path to the Basis Universal
 * transcoder WASM module.
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: &quot;myCanvas&quot;,
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: &quot;https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/&quot; // &lt;------ Path to BasisU transcoder module
 * });
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *      id: &quot;myModel&quot;,
 *      textureTranscoder // &lt;&lt;-------------------- Configure model with our transcoder
 *  });
 *
 * sceneModel.createTexture({
 *      id: &quot;myColorTexture&quot;,
 *      src: &quot;../assets/textures/compressed/sample_uastc_zstd.ktx2&quot; // &lt;&lt;----- KTX2 texture asset
 * });
 *
 * sceneModel.createTexture({
 *      id: &quot;myMetallicRoughnessTexture&quot;,
 *      src: &quot;../assets/textures/alpha/crosshatchAlphaMap.jpg&quot; // &lt;&lt;----- JPEG texture asset
 * });
 *
 * sceneModel.createTextureSet({
 *      id: &quot;myTextureSet&quot;,
 *      colorTextureId: &quot;myColorTexture&quot;,
 *      metallicRoughnessTextureId: &quot;myMetallicRoughnessTexture&quot;
 *  });
 *
 * sceneModel.createMesh({
 *      id: &quot;myMesh&quot;,
 *      textureSetId: &quot;myTextureSet&quot;,
 *      primitive: &quot;triangles&quot;,
 *      positions: [1, 1, 1, ...],
 *      normals: [0, 0, 1, 0, ...],
 *      uv: [1, 0, 0, ...],
 *      indices: [0, 1, 2, ...],
 *  });
 *
 * sceneModel.createEntity({
 *      id: &quot;myEntity&quot;,
 *      meshIds: [&quot;myMesh&quot;]
 *  });
 *
 * sceneModel.finalize();
 * ````
 *
 * ## Loading KTX2 Textures from ArrayBuffers into a SceneModel
 *
 * A SceneModel that is configured with a {@link KTX2TextureTranscoder} will allow us to load textures into
 * it from KTX2 ArrayBuffers.
 *
 * In the example below, we&apos;ll create a {@link Viewer}, containing a {@link SceneModel} configured with a
 * {@link KTX2TextureTranscoder}. We&apos;ll then programmatically create a simple object within the SceneModel, consisting of
 * a single mesh with a texture loaded from a KTX2 ArrayBuffer, which our SceneModel internally transcodes, using
 * its {@link KTX2TextureTranscoder}.
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: &quot;myCanvas&quot;,
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: &quot;https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/&quot; // &lt;------ Path to BasisU transcoder module
 * });
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *      id: &quot;myModel&quot;,
 *      textureTranscoder // &lt;&lt;-------------------- Configure model with our transcoder
 * });
 *
 * utils.loadArraybuffer(&quot;../assets/textures/compressed/sample_uastc_zstd.ktx2&quot;,(arrayBuffer) =&gt; {
 *
 *     sceneModel.createTexture({
 *         id: &quot;myColorTexture&quot;,
 *         buffers: [arrayBuffer] // &lt;&lt;----- KTX2 texture asset
 *     });
 *
 *     sceneModel.createTexture({
 *         id: &quot;myMetallicRoughnessTexture&quot;,
 *         src: &quot;../assets/textures/alpha/crosshatchAlphaMap.jpg&quot; // &lt;&lt;----- JPEG texture asset
 *     });
 *
 *     sceneModel.createTextureSet({
 *        id: &quot;myTextureSet&quot;,
 *        colorTextureId: &quot;myColorTexture&quot;,
 *        metallicRoughnessTextureId: &quot;myMetallicRoughnessTexture&quot;
 *     });
 *
 *     sceneModel.createMesh({
 *          id: &quot;myMesh&quot;,
 *          textureSetId: &quot;myTextureSet&quot;,
 *          primitive: &quot;triangles&quot;,
 *          positions: [1, 1, 1, ...],
 *          normals: [0, 0, 1, 0, ...],
 *          uv: [1, 0, 0, ...],
 *          indices: [0, 1, 2, ...],
 *     });
 *
 *     sceneModel.createEntity({
 *         id: &quot;myEntity&quot;,
 *         meshIds: [&quot;myMesh&quot;]
 *     });
 *
 *     sceneModel.finalize();
 * });
 * ````
 *
 * @implements {Entity}
 */
export class SceneModel extends Component {

    /**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent scene, generated automatically when omitted.
     * @param {Boolean} [cfg.isModel] Specify ````true```` if this SceneModel represents a model, in which case the SceneModel will be registered by {@link SceneModel#id} in {@link Scene#models} and may also have a corresponding {@link MetaModel} with matching {@link MetaModel#id}, registered by that ID in {@link MetaScene#metaModels}.
     * @param {Number[]} [cfg.origin=[0,0,0]] World-space double-precision 3D origin.
     * @param {Number[]} [cfg.position=[0,0,0]] Local, single-precision 3D position, relative to the origin parameter.
     * @param {Number[]} [cfg.scale=[1,1,1]] Local scale.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1] Local modelling transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [cfg.visible=true] Indicates if the SceneModel is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the SceneModel is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the SceneModel is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the SceneModel is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the SceneModel is initially included in boundary calculations.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the SceneModel is initially xrayed.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the SceneModel is initially highlighted.
     * @param {Boolean} [cfg.selected=false] Indicates if the SceneModel is initially selected.
     * @param {Boolean} [cfg.edges=false] Indicates if the SceneModel&apos;s edges are initially emphasized.
     * @param {Number[]} [cfg.colorize=[1.0,1.0,1.0]] SceneModel&apos;s initial RGB colorize color, multiplies by the rendered fragment colors.
     * @param {Number} [cfg.opacity=1.0] SceneModel&apos;s initial opacity factor, multiplies by the rendered fragment alpha.
     * @param {Number} [cfg.backfaces=false] When we set this ````true````, then we force rendering of backfaces for this SceneModel. When
     * we leave this ````false````, then we allow the Viewer to decide when to render backfaces. In that case, the
     * Viewer will hide backfaces on watertight meshes, show backfaces on open meshes, and always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     * @param {Boolean} [cfg.saoEnabled=true] Indicates if Scalable Ambient Obscurance (SAO) will apply to this SceneModel. SAO is configured by the Scene&apos;s {@link SAO} component.
     * @param {Boolean} [cfg.pbrEnabled=true] Indicates if physically-based rendering (PBR) will apply to the SceneModel when {@link Scene#pbrEnabled} is ````true````.
     * @param {Boolean} [cfg.colorTextureEnabled=true] Indicates if base color textures will be rendered for the SceneModel when {@link Scene#colorTextureEnabled} is ````true````.
     * @param {Number} [cfg.edgeThreshold=10] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Number} [cfg.maxGeometryBatchSize=50000000] Maximum geometry batch size, as number of vertices. This is optionally supplied
     * to limit the size of the batched geometry arrays that SceneModel internally creates for batched geometries.
     * A lower value means less heap allocation/de-allocation while creating/loading batched geometries, but more draw calls and
     * slower rendering speed. A high value means larger heap allocation/de-allocation while creating/loading, but less draw calls
     * and faster rendering speed. It&apos;s recommended to keep this somewhere roughly between ````50000```` and ````50000000```.
     * @param {TextureTranscoder} [cfg.textureTranscoder] Transcoder that will be used internally by {@link SceneModel#createTexture}
     * to convert transcoded texture data. Only required when we&apos;ll be providing transcoded data
     * to {@link SceneModel#createTexture}. We assume that all transcoded texture data added to a  ````SceneModel````
     * will then in a format supported by this transcoder.
     * @param {Boolean} [cfg.dtxEnabled=true] When ````true```` (default) use data textures (DTX), where appropriate, to
     * represent the returned model. Set false to always use vertex buffer objects (VBOs). Note that DTX is only applicable
     * to non-textured triangle meshes, and that VBOs are always used for meshes that have textures, line segments, or point
     * primitives. Only works while {@link DTX#enabled} is also ````true````.
     * @param {Number} [cfg.renderOrder=0] Specifies the rendering order for this SceneModel. This is used to control the order in which
     * SceneModels are drawn when they have transparent objects, to give control over the order in which those objects are blended within the transparent
     * render pass.
     */
    constructor(owner, cfg = {}) {

        super(owner, cfg);

        this.renderOrder = cfg.renderOrder || 0;

        this._dtxEnabled = this.scene.dtxEnabled &amp;&amp; (cfg.dtxEnabled !== false);

        this._enableVertexWelding = false; // Not needed for most objects, and very expensive, so disabled
        this._enableIndexBucketing = false; // Until fixed: https://github.com/xeokit/xeokit-sdk/issues/1204

        this._vboBatchingLayerScratchMemory = getScratchMemory();
        this._textureTranscoder = cfg.textureTranscoder || getKTX2TextureTranscoder(this.scene.viewer);

        this._maxGeometryBatchSize = cfg.maxGeometryBatchSize;

        this._aabb = math.collapseAABB3();
        this._aabbDirty = true;

        this._quantizationRanges = {};

        this._vboInstancingLayers = {};
        this._vboBatchingLayers = {};
        this._dtxLayers = {};

        this._meshList = [];

        this.layerList = []; // For GL state efficiency when drawing, InstancingLayers are in first part, BatchingLayers are in second
        this._layersToFinalize = [];

        this._entityList = [];
        this._entitiesToFinalize = [];

        this._geometries = {};
        this._dtxBuckets = {}; // Geometries with optimizations used for data texture representation
        this._textures = {};
        this._textureSets = {};
        this._transforms = {};
        this._meshes = {};
        this._unusedMeshes = {};
        this._entities = {};

        /** @private **/
        this.renderFlags = new RenderFlags();

        /**
         * @private
         */
        this.numGeometries = 0; // Number of geometries created with createGeometry()

        // These counts are used to avoid unnecessary render passes
        // They are incremented or decremented exclusively by BatchingLayer and InstancingLayer

        /**
         * @private
         */
        this.numPortions = 0;

        /**
         * @private
         */
        this.numVisibleLayerPortions = 0;

        /**
         * @private
         */
        this.numTransparentLayerPortions = 0;

        /**
         * @private
         */
        this.numXRayedLayerPortions = 0;

        /**
         * @private
         */
        this.numHighlightedLayerPortions = 0;

        /**
         * @private
         */
        this.numSelectedLayerPortions = 0;

        /**
         * @private
         */
        this.numEdgesLayerPortions = 0;

        /**
         * @private
         */
        this.numPickableLayerPortions = 0;

        /**
         * @private
         */
        this.numClippableLayerPortions = 0;

        /**
         * @private
         */
        this.numCulledLayerPortions = 0;

        this.numEntities = 0;
        this._numTriangles = 0;
        this._numLines = 0;
        this._numPoints = 0;
        this._layersFinalized = false;

        this._edgeThreshold = cfg.edgeThreshold || 10;

        // Build static matrix

        this._origin = math.vec3(cfg.origin || [0, 0, 0]);
        this._position = math.vec3(cfg.position || [0, 0, 0]);
        this._rotation = math.vec3(cfg.rotation || [0, 0, 0]);
        this._quaternion = math.vec4(cfg.quaternion || [0, 0, 0, 1]);
        this._conjugateQuaternion = math.vec4(cfg.quaternion || [0, 0, 0, 1]);

        if (cfg.rotation) {
            math.eulerToQuaternion(this._rotation, &quot;XYZ&quot;, this._quaternion);
        }
        this._scale = math.vec3(cfg.scale || [1, 1, 1]);

        this._worldRotationMatrix = math.mat4();
        this._worldRotationMatrixConjugate = math.mat4();
        this._matrix = math.mat4();
        this._matrixDirty = true;

        this._rebuildMatrices();

        this._worldNormalMatrix = math.mat4();
        math.inverseMat4(this._matrix, this._worldNormalMatrix);
        math.transposeMat4(this._worldNormalMatrix);

        if (cfg.matrix || cfg.position || cfg.rotation || cfg.scale || cfg.quaternion) {
            this._viewMatrix = math.mat4();
            this._viewNormalMatrix = math.mat4();
            this._viewMatrixDirty = true;
            this._matrixNonIdentity = true;
        }

        this._opacity = 1.0;
        this._colorize = [1, 1, 1];

        this._saoEnabled = (cfg.saoEnabled !== false);
        this._pbrEnabled = (cfg.pbrEnabled !== false);
        this._colorTextureEnabled = (cfg.colorTextureEnabled !== false);

        this._isModel = cfg.isModel;
        if (this._isModel) {
            this.scene._registerModel(this);
        }

        this._onCameraViewMatrix = this.scene.camera.on(&quot;matrix&quot;, () =&gt; {
            this._viewMatrixDirty = true;
        });

        this._meshesWithDirtyMatrices = [];
        this._numMeshesWithDirtyMatrices = 0;

        this._onTick = this.scene.on(&quot;tick&quot;, () =&gt; {
            while (this._numMeshesWithDirtyMatrices &gt; 0) {
                this._meshesWithDirtyMatrices[--this._numMeshesWithDirtyMatrices]._updateMatrix();
            }
        });

        this._createDefaultTextureSet();

        this.visible = cfg.visible;
        this.culled = cfg.culled;
        this.pickable = cfg.pickable;
        this.clippable = cfg.clippable;
        this.collidable = cfg.collidable;
        this.castsShadow = cfg.castsShadow;
        this.receivesShadow = cfg.receivesShadow;
        this.xrayed = cfg.xrayed;
        this.highlighted = cfg.highlighted;
        this.selected = cfg.selected;
        this.edges = cfg.edges;
        this.colorize = cfg.colorize;
        this.opacity = cfg.opacity;
        this.backfaces = cfg.backfaces;
    }

    _meshMatrixDirty(mesh) {
        this._meshesWithDirtyMatrices[this._numMeshesWithDirtyMatrices++] = mesh;
    }

    _createDefaultTextureSet() {
        // Every SceneModelMesh gets at least the default TextureSet,
        // which contains empty default textures filled with color
        const defaultColorTexture = new SceneModelTexture({
            id: DEFAULT_COLOR_TEXTURE_ID,
            texture: new Texture2D({
                gl: this.scene.canvas.gl,
                preloadColor: [1, 1, 1, 1] // [r, g, b, a]})
            })
        });
        const defaultMetalRoughTexture = new SceneModelTexture({
            id: DEFAULT_METAL_ROUGH_TEXTURE_ID,
            texture: new Texture2D({
                gl: this.scene.canvas.gl,
                preloadColor: [0, 1, 1, 1] // [unused, roughness, metalness, unused]
            })
        });
        const defaultNormalsTexture = new SceneModelTexture({
            id: DEFAULT_NORMALS_TEXTURE_ID,
            texture: new Texture2D({
                gl: this.scene.canvas.gl,
                preloadColor: [0, 0, 0, 0] // [x, y, z, unused] - these must be zeros
            })
        });
        const defaultEmissiveTexture = new SceneModelTexture({
            id: DEFAULT_EMISSIVE_TEXTURE_ID,
            texture: new Texture2D({
                gl: this.scene.canvas.gl,
                preloadColor: [0, 0, 0, 1] // [x, y, z, unused]
            })
        });
        const defaultOcclusionTexture = new SceneModelTexture({
            id: DEFAULT_OCCLUSION_TEXTURE_ID,
            texture: new Texture2D({
                gl: this.scene.canvas.gl,
                preloadColor: [1, 1, 1, 1] // [x, y, z, unused]
            })
        });
        this._textures[DEFAULT_COLOR_TEXTURE_ID] = defaultColorTexture;
        this._textures[DEFAULT_METAL_ROUGH_TEXTURE_ID] = defaultMetalRoughTexture;
        this._textures[DEFAULT_NORMALS_TEXTURE_ID] = defaultNormalsTexture;
        this._textures[DEFAULT_EMISSIVE_TEXTURE_ID] = defaultEmissiveTexture;
        this._textures[DEFAULT_OCCLUSION_TEXTURE_ID] = defaultOcclusionTexture;
        this._textureSets[DEFAULT_TEXTURE_SET_ID] = new SceneModelTextureSet({
            id: DEFAULT_TEXTURE_SET_ID,
            model: this,
            colorTexture: defaultColorTexture,
            metallicRoughnessTexture: defaultMetalRoughTexture,
            normalsTexture: defaultNormalsTexture,
            emissiveTexture: defaultEmissiveTexture,
            occlusionTexture: defaultOcclusionTexture
        });
    }

    //------------------------------------------------------------------------------------------------------------------
    // SceneModel members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that this Component is a SceneModel.
     * @type {Boolean}
     */
    get isPerformanceModel() {
        return true;
    }

    /**
     * The {@link SceneModelTransform}s in this SceneModel.
     *
     * Each {#link SceneModelTransform} is stored here against its {@link SceneModelTransform.id}.
     *
     * @returns {*|{}}
     */
    get transforms() {
        return this._transforms;
    }

    /**
     * The {@link SceneModelTexture}s in this SceneModel.
     *
     * * Each {@link SceneModelTexture} is created with {@link SceneModel.createTexture}.
     * * Each {@link SceneModelTexture} is stored here against its {@link SceneModelTexture.id}.
     *
     * @returns {*|{}}
     */
    get textures() {
        return this._textures;
    }

    /**
     * The {@link SceneModelTextureSet}s in this SceneModel.
     *
     * Each {@link SceneModelTextureSet} is stored here against its {@link SceneModelTextureSet.id}.
     *
     * @returns {*|{}}
     */
    get textureSets() {
        return this._textureSets;
    }

    /**
     * The {@link SceneModelMesh}es in this SceneModel.
     *
     * Each {@SceneModelMesh} is stored here against its {@link SceneModelMesh.id}.
     *
     * @returns {*|{}}
     */
    get meshes() {
        return this._meshes;
    }

    /**
     * The {@link SceneModelEntity}s in this SceneModel.
     *
     * Each {#link SceneModelEntity} in this SceneModel that represents an object is
     * stored here against its {@link SceneModelTransform.id}.
     *
     * @returns {*|{}}
     */
    get objects() {
        return this._entities;
    }

    /**
     * Gets the 3D World-space origin for this SceneModel.
     *
     * Each {@link SceneModelMesh.origin}, if supplied, is relative to this origin.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Float64Array}
     */
    get origin() {
        return this._origin;
    }

    /**
     * Sets the SceneModel&apos;s local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    set position(value) {
        this._position.set(value || [0, 0, 0]);
        this._setWorldMatrixDirty();
        this._sceneModelDirty();
        this.glRedraw();
    }

    /**
     * Gets the SceneModel&apos;s local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    get position() {
        return this._position;
    }

    /**
     * Sets the SceneModel&apos;s local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    set rotation(value) {
        this._rotation.set(value || [0, 0, 0]);
        math.eulerToQuaternion(this._rotation, &quot;XYZ&quot;, this._quaternion);
        this._setWorldMatrixDirty();
        this._sceneModelDirty();
        this.glRedraw();
    }

    /**
     * Gets the SceneModel&apos;s local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    get rotation() {
        return this._rotation;
    }

    /**
     * Sets the SceneModel&apos;s local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    set quaternion(value) {
        this._quaternion.set(value || [0, 0, 0, 1]);
        math.quaternionToEuler(this._quaternion, &quot;XYZ&quot;, this._rotation);
        this._setWorldMatrixDirty();
        this._sceneModelDirty();
        this.glRedraw();
    }

    /**
     * Gets the SceneModel&apos;s local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    get quaternion() {
        return this._quaternion;
    }

    /**
     * Sets the SceneModel&apos;s local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     * @deprecated
     */
    set scale(value) {
        // NOP - deprecated
    }

    /**
     * Gets the SceneModel&apos;s local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     * @deprecated
     */
    get scale() {
        return this._scale;
    }

    /**
     * Sets the SceneModel&apos;s local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    set matrix(value) {
        this._matrix.set(value || DEFAULT_MATRIX);
        math.decomposeMat4(this._matrix, this._position, this._quaternion, this._scale);
        math.quaternionToEuler(this._quaternion, &quot;XYZ&quot;, this._rotation);
        this._matrixDirty = false;
        this._setWorldMatrixDirty();
        this._sceneModelDirty();
        this.glRedraw();
    }

    /**
     * Gets the SceneModel&apos;s local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    get matrix() {
        this._rebuildMatrices();
        return this._matrix;
    }

    /**
     * Gets the SceneModel&apos;s local modeling rotation transform matrix.
     *
     * @type {Number[]}
     */
    get rotationMatrix() {
        this._rebuildMatrices();
        return this._worldRotationMatrix;
    }

    _rebuildMatrices() {
        if (this._matrixDirty) {
            math.quaternionToRotationMat4(this._quaternion, this._worldRotationMatrix);
            math.conjugateQuaternion(this._quaternion, this._conjugateQuaternion);
            math.quaternionToRotationMat4(this._conjugateQuaternion, this._worldRotationMatrixConjugate);
            math.scaleMat4v(this._scale, this._worldRotationMatrix);
            math.scaleMat4v(this._scale, this._worldRotationMatrixConjugate);
            this._matrix.set(this._worldRotationMatrix);
            math.translateMat4v(this._position, this._matrix);
            this._matrixDirty = false;
            this._viewMatrixDirty = true;
        }
    }

    /**
     * Gets the conjugate of the SceneModel&apos;s local modeling rotation transform matrix.
     *
     * This is used for RTC view matrix management in renderers.
     *
     * @type {Number[]}
     */
    get rotationMatrixConjugate() {
        this._rebuildMatrices();
        return this._worldRotationMatrixConjugate;
    }

    _setWorldMatrixDirty() {
        this._matrixDirty = true;
        this._aabbDirty = true;
    }

    _transformDirty() {
        this._matrixDirty = true;
        this._aabbDirty = true;
        this.scene._aabbDirty = true;
    }

    _sceneModelDirty() {
        this.scene._aabbDirty = true;
        this._aabbDirty = true;
        this.scene._aabbDirty = true;
        this._matrixDirty = true;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i]._sceneModelDirty(); // Entities need to retransform their World AABBs by SceneModel&apos;s worldMatrix
        }
    }

    /**
     * Gets the SceneModel&apos;s World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */
    get worldMatrix() {
        return this.matrix;
    }

    /**
     * Gets the SceneModel&apos;s World normal matrix.
     *
     * @type {Number[]}
     */
    get worldNormalMatrix() {
        return this._worldNormalMatrix;
    }

    _rebuildViewMatrices() {
        this._rebuildMatrices();
        if (this._viewMatrixDirty) {
            math.mulMat4(this.scene.camera.viewMatrix, this._matrix, this._viewMatrix);
            math.inverseMat4(this._viewMatrix, this._viewNormalMatrix);
            math.transposeMat4(this._viewNormalMatrix);
            this._viewMatrixDirty = false;
        }
    }

    /**
     * Called by private renderers in ./lib, returns the view matrix with which to
     * render this SceneModel. The view matrix is the concatenation of the
     * Camera view matrix with the Performance model&apos;s world (modeling) matrix.
     *
     * @private
     */
    get viewMatrix() {
        if (!this._viewMatrix) {
            return this.scene.camera.viewMatrix;
        }
        this._rebuildViewMatrices();
        return this._viewMatrix;
    }

    /**
     * Called by private renderers in ./lib, returns the view normal matrix with which to render this SceneModel.
     *
     * @private
     */
    get viewNormalMatrix() {
        if (!this._viewNormalMatrix) {
            return this.scene.camera.viewNormalMatrix;
        }
        this._rebuildViewMatrices();
        return this._viewNormalMatrix;
    }

    /**
     * Sets if backfaces are rendered for this SceneModel.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    get backfaces() {
        return this._backfaces;
    }

    /**
     * Sets if backfaces are rendered for this SceneModel.
     *
     * Default is ````false````.
     *
     * When we set this ````true````, then backfaces are always rendered for this SceneModel.
     *
     * When we set this ````false````, then we allow the Viewer to decide whether to render backfaces. In this case,
     * the Viewer will:
     *
     *  * hide backfaces on watertight meshes,
     *  * show backfaces on open meshes, and
     *  * always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     *
     * @type {Boolean}
     */
    set backfaces(backfaces) {
        backfaces = !!backfaces;
        this._backfaces = backfaces;
        this.glRedraw();
    }

    /**
     * Gets the list of {@link SceneModelEntity}s within this SceneModel.
     *
     * @returns {SceneModelEntity[]}
     */
    get entityList() {
        return this._entityList;
    }

    /**
     * Returns true to indicate that SceneModel is an {@link Entity}.
     * @type {Boolean}
     */
    get isEntity() {
        return true;
    }

    /**
     * Returns ````true```` if this SceneModel represents a model.
     *
     * When ````true```` the SceneModel will be registered by {@link SceneModel#id} in
     * {@link Scene#models} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.
     *
     * @type {Boolean}
     */
    get isModel() {
        return this._isModel;
    }

    //------------------------------------------------------------------------------------------------------------------
    // SceneModel members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns ````false```` to indicate that SceneModel never represents an object.
     *
     * @type {Boolean}
     */
    get isObject() {
        return false;
    }

    /**
     * Gets the SceneModel&apos;s World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */
    get aabb() {
        if (this._aabbDirty) {
            math.collapseAABB3(this._aabb);
            for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
                math.expandAABB3(this._aabb, this._entityList[i].aabb);
            }
            this._aabbDirty = false;
        }
        return this._aabb;
    }

    /**
     * The approximate number of triangle primitives in this SceneModel.
     *
     * @type {Number}
     */
    get numTriangles() {
        return this._numTriangles;
    }

    //------------------------------------------------------------------------------------------------------------------
    // Entity members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * The approximate number of line primitives in this SceneModel.
     *
     * @type {Number}
     */
    get numLines() {
        return this._numLines;
    }

    /**
     * The approximate number of point primitives in this SceneModel.
     *
     * @type {Number}
     */
    get numPoints() {
        return this._numPoints;
    }

    /**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are visible.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is ````true```` and {@link SceneModel#culled} is ````false````.
     *
     * @type {Boolean}
     */
    get visible() {
        return (this.numVisibleLayerPortions &gt; 0);
    }

    /**
     * Sets if this SceneModel is visible.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is ````true```` and {@link SceneModel#culled} is ````false````.
     **
     * @type {Boolean}
     */
    set visible(visible) {
        visible = visible !== false;
        this._visible = visible;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].visible = visible;
        }
        this.glRedraw();
    }

    /**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are xrayed.
     *
     * @type {Boolean}
     */
    get xrayed() {
        return (this.numXRayedLayerPortions &gt; 0);
    }

    /**
     * Sets if all {@link SceneModelEntity}s in this SceneModel are xrayed.
     *
     * @type {Boolean}
     */
    set xrayed(xrayed) {
        xrayed = !!xrayed;
        this._xrayed = xrayed;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].xrayed = xrayed;
        }
        this.glRedraw();
    }

    /**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are highlighted.
     *
     * @type {Boolean}
     */
    get highlighted() {
        return (this.numHighlightedLayerPortions &gt; 0);
    }

    /**
     * Sets if all {@link SceneModelEntity}s in this SceneModel are highlighted.
     *
     * @type {Boolean}
     */
    set highlighted(highlighted) {
        highlighted = !!highlighted;
        this._highlighted = highlighted;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].highlighted = highlighted;
        }
        this.glRedraw();
    }

    /**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are selected.
     *
     * @type {Boolean}
     */
    get selected() {
        return (this.numSelectedLayerPortions &gt; 0);
    }

    /**
     * Sets if all {@link SceneModelEntity}s in this SceneModel are selected.
     *
     * @type {Boolean}
     */
    set selected(selected) {
        selected = !!selected;
        this._selected = selected;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].selected = selected;
        }
        this.glRedraw();
    }

    /**
     * Gets if any {@link SceneModelEntity}s in this SceneModel have edges emphasised.
     *
     * @type {Boolean}
     */
    get edges() {
        return (this.numEdgesLayerPortions &gt; 0);
    }

    /**
     * Sets if all {@link SceneModelEntity}s in this SceneModel have edges emphasised.
     *
     * @type {Boolean}
     */
    set edges(edges) {
        edges = !!edges;
        this._edges = edges;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].edges = edges;
        }
        this.glRedraw();
    }

    /**
     * Gets if this SceneModel is culled from view.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is true and {@link SceneModel#culled} is false.
     *
     * @type {Boolean}
     */
    get culled() {
        return this._culled;
    }

    /**
     * Sets if this SceneModel is culled from view.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is true and {@link SceneModel#culled} is false.
     *
     * @type {Boolean}
     */
    set culled(culled) {
        culled = !!culled;
        this._culled = culled;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].culled = culled;
        }
        this.glRedraw();
    }

    /**
     * Gets if {@link SceneModelEntity}s in this SceneModel are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */
    get clippable() {
        return this._clippable;
    }

    /**
     * Sets if {@link SceneModelEntity}s in this SceneModel are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */
    set clippable(clippable) {
        clippable = clippable !== false;
        this._clippable = clippable;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].clippable = clippable;
        }
        this.glRedraw();
    }

    /**
     * Gets if this SceneModel is collidable.
     *
     * @type {Boolean}
     */
    get collidable() {
        return this._collidable;
    }

    /**
     * Sets if {@link SceneModelEntity}s in this SceneModel are collidable.
     *
     * @type {Boolean}
     */
    set collidable(collidable) {
        collidable = collidable !== false;
        this._collidable = collidable;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].collidable = collidable;
        }
    }

    /**
     * Gets if this SceneModel is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    get pickable() {
        return (this.numPickableLayerPortions &gt; 0);
    }

    /**
     * Sets if {@link SceneModelEntity}s in this SceneModel are pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    set pickable(pickable) {
        pickable = pickable !== false;
        this._pickable = pickable;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].pickable = pickable;
        }
    }

    /**
     * Gets the RGB colorize color for this SceneModel.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    get colorize() {
        return this._colorize;
    }

    /**
     * Sets the RGB colorize color for this SceneModel.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    set colorize(colorize) {
        this._colorize = colorize;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].colorize = colorize;
        }
    }

    /**
     * Gets this SceneModel&apos;s opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    get opacity() {
        return this._opacity;
    }

    /**
     * Sets the opacity factor for this SceneModel.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    set opacity(opacity) {
        this._opacity = opacity;
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i].opacity = opacity;
        }
    }

    /**
     * Gets if this SceneModel casts a shadow.
     *
     * @type {Boolean}
     */
    get castsShadow() {
        return this._castsShadow;
    }

    /**
     * Sets if this SceneModel casts a shadow.
     *
     * @type {Boolean}
     */
    set castsShadow(castsShadow) {
        castsShadow = (castsShadow !== false);
        if (castsShadow !== this._castsShadow) {
            this._castsShadow = castsShadow;
            this.glRedraw();
        }
    }

    /**
     * Sets if this SceneModel can have shadow cast upon it.
     *
     * @type {Boolean}
     */
    get receivesShadow() {
        return this._receivesShadow;
    }

    /**
     * Sets if this SceneModel can have shadow cast upon it.
     *
     * @type {Boolean}
     */
    set receivesShadow(receivesShadow) {
        receivesShadow = (receivesShadow !== false);
        if (receivesShadow !== this._receivesShadow) {
            this._receivesShadow = receivesShadow;
            this.glRedraw();
        }
    }

    /**
     * Gets if Scalable Ambient Obscurance (SAO) will apply to this SceneModel.
     *
     * SAO is configured by the Scene&apos;s {@link SAO} component.
     *
     *  Only works when {@link SAO#enabled} is also true.
     *
     * @type {Boolean}
     */
    get saoEnabled() {
        return this._saoEnabled;
    }

    /**
     * Gets if physically-based rendering (PBR) is enabled for this SceneModel.
     *
     * Only works when {@link Scene#pbrEnabled} is also true.
     *
     * @type {Boolean}
     */
    get pbrEnabled() {
        return this._pbrEnabled;
    }

    /**
     * Gets if color textures are enabled for this SceneModel.
     *
     * Only works when {@link Scene#colorTextureEnabled} is also true.
     *
     * @type {Boolean}
     */
    get colorTextureEnabled() {
        return this._colorTextureEnabled;
    }

    /**
     * Returns true to indicate that SceneModel is implements {@link Drawable}.
     *
     * @type {Boolean}
     */
    get isDrawable() {
        return true;
    }

    /** @private */
    get isStateSortable() {
        return false
    }

    /**
     * Configures the appearance of xrayed {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#xrayMaterial}.
     *
     * @type {EmphasisMaterial}
     */
    get xrayMaterial() {
        return this.scene.xrayMaterial;
    }

    /**
     * Configures the appearance of highlighted {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#highlightMaterial}.
     *
     * @type {EmphasisMaterial}
     */
    get highlightMaterial() {
        return this.scene.highlightMaterial;
    }

    /**
     * Configures the appearance of selected {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#selectedMaterial}.
     *
     * @type {EmphasisMaterial}
     */
    get selectedMaterial() {
        return this.scene.selectedMaterial;
    }

    /**
     * Configures the appearance of edges of {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#edgeMaterial}.
     *
     * @type {EdgeMaterial}
     */
    get edgeMaterial() {
        return this.scene.edgeMaterial;
    }

    //------------------------------------------------------------------------------------------------------------------
    // Drawable members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Called by private renderers in ./lib, returns the picking view matrix with which to
     * ray-pick on this SceneModel.
     *
     * @private
     */
    getPickViewMatrix(pickViewMatrix) {
        if (!this._viewMatrix) {
            return pickViewMatrix;
        }
        return this._viewMatrix;
    }

    /**
     *
     * @param cfg
     */
    createQuantizationRange(cfg) {
        if (cfg.id === undefined || cfg.id === null) {
            this.error(&quot;[createQuantizationRange] Config missing: id&quot;);
            return;
        }
        if (cfg.aabb) {
            this.error(&quot;[createQuantizationRange] Config missing: aabb&quot;);
            return;
        }
        if (this._quantizationRanges[cfg.id]) {
            this.error(&quot;[createQuantizationRange] QuantizationRange already created: &quot; + cfg.id);
            return;
        }
        this._quantizationRanges[cfg.id] = {
            id: cfg.id,
            aabb: cfg.aabb,
            matrix: createPositionsDecodeMatrix(cfg.aabb, math.mat4())
        }
    }

    /**
     * Creates a reusable geometry within this SceneModel.
     *
     * We can then supply the geometry ID to {@link SceneModel#createMesh} when we want to create meshes that
     * instance the geometry.
     *
     * @param {*} cfg Geometry properties.
     * @param {String|Number} cfg.id Mandatory ID for the geometry, to refer to with {@link SceneModel#createMesh}.
     * @param {String} cfg.primitive The primitive type. Accepted values are &apos;points&apos;, &apos;lines&apos;, &apos;triangles&apos;, &apos;solid&apos; and &apos;surface&apos;.
     * @param {Number[]} [cfg.positions] Flat array of uncompressed 3D vertex positions positions. Required for all primitive types. Overridden by ````positionsCompressed````.
     * @param {Number[]} [cfg.positionsCompressed] Flat array of quantized 3D vertex positions. Overrides ````positions````, and must be accompanied by ````positionsDecodeMatrix````.
     * @param {Number[]} [cfg.positionsDecodeMatrix] A 4x4 matrix for decompressing ````positionsCompressed````. Must be accompanied by ````positionsCompressed````.
     * @param {Number[]} [cfg.normals] Flat array of normal vectors. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.normalsCompressed] Flat array of oct-encoded normal vectors. Overrides ````normals````. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.colors] Flat array of uncompressed RGBA vertex colors, as float values in range ````[0..1]````. Ignored when ````geometryId```` is given. Overridden by ````color```` and ````colorsCompressed````.
     * @param {Number[]} [cfg.colorsCompressed] Flat array of compressed RGBA vertex colors, as unsigned short integers in range ````[0..255]````. Ignored when ````geometryId```` is given. Overrides ````colors```` and is overridden by ````color````.
     * @param {Number[]} [cfg.uv] Flat array of uncompressed vertex UV coordinates. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvCompressed] Flat array of compressed vertex UV coordinates. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. Overrides ````uv````. Must be accompanied by ````uvDecodeMatrix````. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvDecodeMatrix] A 3x3 matrix for decompressing ````uvCompressed````.
     * @param {Number[]} [cfg.indices] Array of primitive connectivity indices. Not required for `points` primitives.
     * @param {Number[]} [cfg.edgeIndices] Array of edge line indices. Used only with &apos;triangles&apos;, &apos;solid&apos; and &apos;surface&apos; primitives. Automatically generated internally if not supplied, using the optional ````edgeThreshold```` given to the ````SceneModel```` constructor.
     */
    createGeometry(cfg) {
        if (cfg.id === undefined || cfg.id === null) {
            this.error(&quot;[createGeometry] Config missing: id&quot;);
            return;
        }
        if (this._geometries[cfg.id]) {
            this.error(&quot;[createGeometry] Geometry already created: &quot; + cfg.id);
            return;
        }
        if (cfg.primitive === undefined || cfg.primitive === null) {
            cfg.primitive = &quot;triangles&quot;;
        }
        if (cfg.primitive !== &quot;points&quot; &amp;&amp; cfg.primitive !== &quot;lines&quot; &amp;&amp; cfg.primitive !== &quot;triangles&quot; &amp;&amp; cfg.primitive !== &quot;solid&quot; &amp;&amp; cfg.primitive !== &quot;surface&quot;) {
            this.error(`[createGeometry] Unsupported value for &apos;primitive&apos;: &apos;${cfg.primitive}&apos; - supported values are &apos;points&apos;, &apos;lines&apos;, &apos;triangles&apos;, &apos;solid&apos; and &apos;surface&apos;. Defaulting to &apos;triangles&apos;.`);
            return;
        }
        if (!cfg.positions &amp;&amp; !cfg.positionsCompressed &amp;&amp; !cfg.buckets) {
            this.error(&quot;[createGeometry] Param expected: `positions`,  `positionsCompressed&apos; or &apos;buckets&quot;);
            return null;
        }
        if (cfg.positionsCompressed &amp;&amp; !cfg.positionsDecodeMatrix &amp;&amp; !cfg.positionsDecodeBoundary) {
            this.error(&quot;[createGeometry] Param expected: `positionsDecodeMatrix` or &apos;positionsDecodeBoundary&apos; (required for `positionsCompressed&apos;)&quot;);
            return null;
        }
        if (cfg.positionsDecodeMatrix &amp;&amp; cfg.positionsDecodeBoundary) {
            this.error(&quot;[createGeometry] Only one of these params expected: `positionsDecodeMatrix` or &apos;positionsDecodeBoundary&apos; (required for `positionsCompressed&apos;)&quot;);
            return null;
        }
        if (cfg.uvCompressed &amp;&amp; !cfg.uvDecodeMatrix) {
            this.error(&quot;[createGeometry] Param expected: `uvDecodeMatrix` (required for `uvCompressed&apos;)&quot;);
            return null;
        }
        if (!cfg.buckets &amp;&amp; !cfg.indices &amp;&amp; (cfg.primitive === &quot;triangles&quot; || cfg.primitive === &quot;solid&quot; || cfg.primitive === &quot;surface&quot;)) {
            const numPositions = (cfg.positions || cfg.positionsCompressed).length / 3;
            cfg.indices = this._createDefaultIndices(numPositions);
        }
        if (!cfg.buckets &amp;&amp; !cfg.indices &amp;&amp; cfg.primitive !== &quot;points&quot;) {
            this.error(`[createGeometry] Param expected: indices (required for &apos;${cfg.primitive}&apos; primitive type)`);
            return null;
        }
        if (cfg.positionsDecodeBoundary) {
            cfg.positionsDecodeMatrix = createPositionsDecodeMatrix(cfg.positionsDecodeBoundary, math.mat4());
        }
        if (cfg.positions) {
            const aabb = math.collapseAABB3();
            cfg.positionsDecodeMatrix = math.mat4();
            math.expandAABB3Points3(aabb, cfg.positions);
            cfg.positionsCompressed = quantizePositions(cfg.positions, aabb, cfg.positionsDecodeMatrix);
            cfg.aabb = aabb;
        } else if (cfg.positionsCompressed) {
            const aabb = math.collapseAABB3();
            cfg.positionsDecodeMatrix = new Float64Array(cfg.positionsDecodeMatrix);
            cfg.positionsCompressed = new Uint16Array(cfg.positionsCompressed);
            math.expandAABB3Points3(aabb, cfg.positionsCompressed);
            geometryCompressionUtils.decompressAABB(aabb, cfg.positionsDecodeMatrix);
            cfg.aabb = aabb;
        } else if (cfg.buckets) {
            const aabb = math.collapseAABB3();
            this._dtxBuckets[cfg.id] = cfg.buckets;
            for (let i = 0, len = cfg.buckets.length; i &lt; len; i++) {
                const bucket = cfg.buckets[i];
                if (bucket.positions) {
                    math.expandAABB3Points3(aabb, bucket.positions);
                } else if (bucket.positionsCompressed) {
                    math.expandAABB3Points3(aabb, bucket.positionsCompressed);
                }
            }
            if (cfg.positionsDecodeMatrix) {
                geometryCompressionUtils.decompressAABB(aabb, cfg.positionsDecodeMatrix);
            }
            cfg.aabb = aabb;
        }
        if (cfg.colorsCompressed &amp;&amp; cfg.colorsCompressed.length &gt; 0) {
            cfg.colorsCompressed = new Uint8Array(cfg.colorsCompressed);
        } else if (cfg.colors &amp;&amp; cfg.colors.length &gt; 0) {
            const colors = cfg.colors;
            const colorsCompressed = new Uint8Array(colors.length);
            for (let i = 0, len = colors.length; i &lt; len; i++) {
                colorsCompressed[i] = colors[i] * 255;
            }
            cfg.colorsCompressed = colorsCompressed;
        }
        if (!cfg.buckets &amp;&amp; !cfg.edgeIndices &amp;&amp; (cfg.primitive === &quot;triangles&quot; || cfg.primitive === &quot;solid&quot; || cfg.primitive === &quot;surface&quot;)) {
            if (cfg.positions) {
                cfg.edgeIndices = buildEdgeIndices(cfg.positions, cfg.indices, null, 5.0);
            } else {
                cfg.edgeIndices = buildEdgeIndices(cfg.positionsCompressed, cfg.indices, cfg.positionsDecodeMatrix, 2.0);
            }
        }
        if (cfg.uv) {
            const bounds = geometryCompressionUtils.getUVBounds(cfg.uv);
            const result = geometryCompressionUtils.compressUVs(cfg.uv, bounds.min, bounds.max);
            cfg.uvCompressed = result.quantized;
            cfg.uvDecodeMatrix = result.decodeMatrix;
        } else if (cfg.uvCompressed) {
            cfg.uvCompressed = new Uint16Array(cfg.uvCompressed);
            cfg.uvDecodeMatrix = new Float64Array(cfg.uvDecodeMatrix);
        }
        if (cfg.normals) { // HACK
            cfg.normals = null;
        }
        this._geometries [cfg.id] = cfg;
        this._numTriangles += (cfg.indices ? Math.round(cfg.indices.length / 3) : 0);
        this.numGeometries++;
    }

    /**
     * Creates a texture within this SceneModel.
     *
     * We can then supply the texture ID to {@link SceneModel#createTextureSet} when we want to create texture sets that use the texture.
     *
     * @param {*} cfg Texture properties.
     * @param {String|Number} cfg.id Mandatory ID for the texture, to refer to with {@link SceneModel#createTextureSet}.
     * @param {String} [cfg.src] Image file for the texture. Assumed to be transcoded if not having a recognized image file
     * extension (jpg, jpeg, png etc.). If transcoded, then assumes ````SceneModel```` is configured with a {@link TextureTranscoder}.
     * @param {ArrayBuffer[]} [cfg.buffers] Transcoded texture data. Assumes ````SceneModel```` is
     * configured with a {@link TextureTranscoder}. This parameter is given as an array of buffers so we can potentially support multi-image textures, such as cube maps.
     * @param {HTMLImageElement} [cfg.image] HTML Image object to load into this texture. Overrides ````src```` and ````buffers````. Never transcoded.
     * @param {Number} [cfg.minFilter=LinearMipmapLinearFilter] How the texture is sampled when a texel covers less than one pixel.
     * Supported values are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter}, {@link NearestMipMapNearestFilter}, {@link NearestMipMapLinearFilter} and {@link LinearMipMapLinearFilter}.
     * @param {Number} [cfg.magFilter=LinearFilter] How the texture is sampled when a texel covers more than one pixel. Supported values are {@link LinearFilter} and {@link NearestFilter}.
     * @param {Number} [cfg.wrapS=RepeatWrapping] Wrap parameter for texture coordinate *S*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.
     * @param {Number} [cfg.wrapT=RepeatWrapping] Wrap parameter for texture coordinate *T*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}..
     * @param {Number} [cfg.wrapR=RepeatWrapping] Wrap parameter for texture coordinate *R*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.
     * @param {Boolean} [cfg.flipY=false] Flips this Texture&apos;s source data along its vertical axis when ````true````.
     * @param  {Number} [cfg.encoding=LinearEncoding] Encoding format. Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.
     */
    createTexture(cfg) {
        const textureId = cfg.id;
        if (textureId === undefined || textureId === null) {
            this.error(&quot;[createTexture] Config missing: id&quot;);
            return;
        }
        if (this._textures[textureId]) {
            this.error(&quot;[createTexture] Texture already created: &quot; + textureId);
            return;
        }
        if (!cfg.src &amp;&amp; !cfg.image &amp;&amp; !cfg.buffers) {
            this.error(&quot;[createTexture] Param expected: `src`, `image&apos; or &apos;buffers&apos;&quot;);
            return null;
        }
        let minFilter = cfg.minFilter || LinearMipmapLinearFilter;
        if (minFilter !== LinearFilter &amp;&amp;
            minFilter !== LinearMipMapNearestFilter &amp;&amp;
            minFilter !== LinearMipmapLinearFilter &amp;&amp;
            minFilter !== NearestMipMapLinearFilter &amp;&amp;
            minFilter !== NearestMipMapNearestFilter) {
            this.error(`[createTexture] Unsupported value for &apos;minFilter&apos; - 
            supported values are LinearFilter, LinearMipMapNearestFilter, NearestMipMapNearestFilter, 
            NearestMipMapLinearFilter and LinearMipmapLinearFilter. Defaulting to LinearMipmapLinearFilter.`);
            minFilter = LinearMipmapLinearFilter;
        }
        let magFilter = cfg.magFilter || LinearFilter;
        if (magFilter !== LinearFilter &amp;&amp; magFilter !== NearestFilter) {
            this.error(`[createTexture] Unsupported value for &apos;magFilter&apos; - supported values are LinearFilter and NearestFilter. Defaulting to LinearFilter.`);
            magFilter = LinearFilter;
        }
        let wrapS = cfg.wrapS || RepeatWrapping;
        if (wrapS !== ClampToEdgeWrapping &amp;&amp; wrapS !== MirroredRepeatWrapping &amp;&amp; wrapS !== RepeatWrapping) {
            this.error(`[createTexture] Unsupported value for &apos;wrapS&apos; - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.`);
            wrapS = RepeatWrapping;
        }
        let wrapT = cfg.wrapT || RepeatWrapping;
        if (wrapT !== ClampToEdgeWrapping &amp;&amp; wrapT !== MirroredRepeatWrapping &amp;&amp; wrapT !== RepeatWrapping) {
            this.error(`[createTexture] Unsupported value for &apos;wrapT&apos; - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.`);
            wrapT = RepeatWrapping;
        }
        let wrapR = cfg.wrapR || RepeatWrapping;
        if (wrapR !== ClampToEdgeWrapping &amp;&amp; wrapR !== MirroredRepeatWrapping &amp;&amp; wrapR !== RepeatWrapping) {
            this.error(`[createTexture] Unsupported value for &apos;wrapR&apos; - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.`);
            wrapR = RepeatWrapping;
        }
        let encoding = cfg.encoding || LinearEncoding;
        if (encoding !== LinearEncoding &amp;&amp; encoding !== sRGBEncoding) {
            this.error(&quot;[createTexture] Unsupported value for &apos;encoding&apos; - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding.&quot;);
            encoding = LinearEncoding;
        }
        const texture = new Texture2D({
            gl: this.scene.canvas.gl,
            minFilter,
            magFilter,
            wrapS,
            wrapT,
            wrapR,
            // flipY: cfg.flipY,
            encoding
        });
        if (cfg.preloadColor) {
            texture.setPreloadColor(cfg.preloadColor);
        }
        if (cfg.image) { // Ignore transcoder for Images
            const image = cfg.image;
            image.crossOrigin = &quot;Anonymous&quot;;
            if (image.compressed) {
                // see `parsedImage` in @loaders.gl/gltf/src/lib/parsers/parse-gltf.ts
                // NOTE: @loaders.gl in its current version discards potential mipmaps, leaving only a single one
                const data = image.data;
                texture.setCompressedData({
                    mipmaps: data,
                    props: {
                        format: data[0].format,
                        minFilter: minFilter,
                        magFilter: magFilter
                    }
                });
            } else {
                texture.setImage(image, {minFilter, magFilter, wrapS, wrapT, wrapR, flipY: cfg.flipY, encoding});
            }
        } else if (cfg.src) {
            const ext = cfg.src.split(&apos;.&apos;).pop();
            switch (ext) { // Don&apos;t transcode recognized image file types
                case &quot;jpeg&quot;:
                case &quot;jpg&quot;:
                case &quot;png&quot;:
                case &quot;gif&quot;:
                    const image = new Image();
                    image.onload = () =&gt; {
                        texture.setImage(image, {
                            minFilter,
                            magFilter,
                            wrapS,
                            wrapT,
                            wrapR,
                            flipY: cfg.flipY,
                            encoding
                        });
                        this.glRedraw();
                    };
                    image.src = cfg.src; // URL or Base64 string
                    break;
                default: // Assume other file types need transcoding
                    if (!this._textureTranscoder) {
                        this.error(`[createTexture] Can&apos;t create texture from &apos;src&apos; - SceneModel needs to be configured with a TextureTranscoder for this file type (&apos;${ext}&apos;)`);
                    } else {
                        utils.loadArraybuffer(cfg.src, (arrayBuffer) =&gt; {
                                if (!arrayBuffer.byteLength) {
                                    this.error(`[createTexture] Can&apos;t create texture from &apos;src&apos;: file data is zero length`);
                                    return;
                                }
                                this._textureTranscoder.transcode([arrayBuffer], texture).then(() =&gt; {
                                    this.glRedraw();
                                });
                            },
                            function (errMsg) {
                                this.error(`[createTexture] Can&apos;t create texture from &apos;src&apos;: ${errMsg}`);
                            });
                    }
                    break;
            }
        } else if (cfg.buffers) { // Buffers implicitly require transcoding
            if (!this._textureTranscoder) {
                this.error(`[createTexture] Can&apos;t create texture from &apos;buffers&apos; - SceneModel needs to be configured with a TextureTranscoder for this option`);
            } else {
                this._textureTranscoder.transcode(cfg.buffers, texture).then(() =&gt; {
                    this.glRedraw();
                });
            }
        }
        this._textures[textureId] = new SceneModelTexture({id: textureId, texture});
    }

    /**
     * Creates a texture set within this SceneModel.
     *
     * * Stores the new {@link SceneModelTextureSet} in {@link SceneModel#textureSets}.
     *
     * A texture set is a collection of textures that can be shared among meshes. We can then supply the texture set
     * ID to {@link SceneModel#createMesh} when we want to create meshes that use the texture set.
     *
     * The textures can work as a texture atlas, where each mesh can have geometry UVs that index
     * a different part of the textures. This allows us to minimize the number of textures in our models, which
     * means faster rendering.
     *
     * @param {*} cfg Texture set properties.
     * @param {String|Number} cfg.id Mandatory ID for the texture set, to refer to with {@link SceneModel#createMesh}.
     * @param {*} [cfg.colorTextureId] ID of *RGBA* base color texture, with color in *RGB* and alpha in *A*.
     * @param {*} [cfg.metallicRoughnessTextureId] ID of *RGBA* metal-roughness texture, with the metallic factor in *R*, and roughness factor in *G*.
     * @param {*} [cfg.normalsTextureId] ID of *RGBA* normal map texture, with normal map vectors in *RGB*.
     * @param {*} [cfg.emissiveTextureId] ID of *RGBA* emissive map texture, with emissive color in *RGB*.
     * @param {*} [cfg.occlusionTextureId] ID of *RGBA* occlusion map texture, with occlusion factor in *R*.
     * @returns {SceneModelTransform} The new texture set.
     */
    createTextureSet(cfg) {
        const textureSetId = cfg.id;
        if (textureSetId === undefined || textureSetId === null) {
            this.error(&quot;[createTextureSet] Config missing: id&quot;);
            return;
        }
        if (this._textureSets[textureSetId]) {
            this.error(`[createTextureSet] Texture set already created: ${textureSetId}`);
            return;
        }
        let colorTexture;
        if (cfg.colorTextureId !== undefined &amp;&amp; cfg.colorTextureId !== null) {
            colorTexture = this._textures[cfg.colorTextureId];
            if (!colorTexture) {
                this.error(`[createTextureSet] Texture not found: ${cfg.colorTextureId} - ensure that you create it first with createTexture()`);
                return;
            }
        } else {
            colorTexture = this._textures[DEFAULT_COLOR_TEXTURE_ID];
        }
        let metallicRoughnessTexture;
        if (cfg.metallicRoughnessTextureId !== undefined &amp;&amp; cfg.metallicRoughnessTextureId !== null) {
            metallicRoughnessTexture = this._textures[cfg.metallicRoughnessTextureId];
            if (!metallicRoughnessTexture) {
                this.error(`[createTextureSet] Texture not found: ${cfg.metallicRoughnessTextureId} - ensure that you create it first with createTexture()`);
                return;
            }
        } else {
            metallicRoughnessTexture = this._textures[DEFAULT_METAL_ROUGH_TEXTURE_ID];
        }
        let normalsTexture;
        if (cfg.normalsTextureId !== undefined &amp;&amp; cfg.normalsTextureId !== null) {
            normalsTexture = this._textures[cfg.normalsTextureId];
            if (!normalsTexture) {
                this.error(`[createTextureSet] Texture not found: ${cfg.normalsTextureId} - ensure that you create it first with createTexture()`);
                return;
            }
        } else {
            normalsTexture = this._textures[DEFAULT_NORMALS_TEXTURE_ID];
        }
        let emissiveTexture;
        if (cfg.emissiveTextureId !== undefined &amp;&amp; cfg.emissiveTextureId !== null) {
            emissiveTexture = this._textures[cfg.emissiveTextureId];
            if (!emissiveTexture) {
                this.error(`[createTextureSet] Texture not found: ${cfg.emissiveTextureId} - ensure that you create it first with createTexture()`);
                return;
            }
        } else {
            emissiveTexture = this._textures[DEFAULT_EMISSIVE_TEXTURE_ID];
        }
        let occlusionTexture;
        if (cfg.occlusionTextureId !== undefined &amp;&amp; cfg.occlusionTextureId !== null) {
            occlusionTexture = this._textures[cfg.occlusionTextureId];
            if (!occlusionTexture) {
                this.error(`[createTextureSet] Texture not found: ${cfg.occlusionTextureId} - ensure that you create it first with createTexture()`);
                return;
            }
        } else {
            occlusionTexture = this._textures[DEFAULT_OCCLUSION_TEXTURE_ID];
        }
        const textureSet = new SceneModelTextureSet({
            id: textureSetId,
            model: this,
            colorTexture,
            alphaCutoff: cfg.alphaCutoff,
            metallicRoughnessTexture,
            normalsTexture,
            emissiveTexture,
            occlusionTexture
        });
        this._textureSets[textureSetId] = textureSet;
        return textureSet;
    }

    /**
     * Creates a new {@link SceneModelTransform} within this SceneModel.
     *
     * * Stores the new {@link SceneModelTransform} in {@link SceneModel#transforms}.
     * * Can be connected into hierarchies
     * * Each {@link SceneModelTransform} can be used by unlimited {@link SceneModelMesh}es
     *
     * @param {*} cfg Transform creation parameters.
     * @param {String} cfg.id Mandatory ID for the new transform. Must not clash with any existing components within the {@link Scene}.
     * @param {String} [cfg.parentTransformId] ID of a parent transform, previously created with {@link SceneModel#createTextureSet}.
     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position of the mesh. Overridden by ````transformId````.
     * @param {Number[]} [cfg.scale=[1,1,1]] Scale of the transform.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Rotation of the transform as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Modelling transform matrix. Overrides the ````position````, ````scale```` and ````rotation```` parameters.
     * @returns {SceneModelTransform} The new transform.
     */
    createTransform(cfg) {
        if (cfg.id === undefined || cfg.id === null) {
            this.error(&quot;[createTransform] SceneModel.createTransform() config missing: id&quot;);
            return;
        }
        if (this._transforms[cfg.id]) {
            this.error(`[createTransform] SceneModel already has a transform with this ID: ${cfg.id}`);
            return;
        }
        let parentTransform;
        if (cfg.parentTransformId) {
            parentTransform = this._transforms[cfg.parentTransformId];
            if (!parentTransform) {
                this.error(&quot;[createTransform] SceneModel.createTransform() config missing: id&quot;);
                return;
            }
        }
        const transform = new SceneModelTransform({
            id: cfg.id,
            model: this,
            parent: parentTransform,
            matrix: cfg.matrix,
            position: cfg.position,
            scale: cfg.scale,
            rotation: cfg.rotation,
            quaternion: cfg.quaternion
        });
        this._transforms[transform.id] = transform;
        return transform;
    }

    /**
     * Creates a new {@link SceneModelMesh} within this SceneModel.
     *
     * * It prepares and saves data for a SceneModelMesh {@link SceneModel#meshes} creation. SceneModelMesh will be created only once the SceneModelEntity (which references this particular SceneModelMesh) will be created.
     * * The SceneModelMesh can either define its own geometry or share it with other SceneModelMeshes. To define own geometry, provide the
     * various geometry arrays to this method. To share a geometry, provide the ID of a geometry created earlier
     * with {@link SceneModel#createGeometry}.
     * * If you accompany the arrays with an  ````origin````, then ````createMesh()```` will assume
     * that the geometry ````positions```` are in relative-to-center (RTC) coordinates, with ````origin```` being the
     * origin of their RTC coordinate system.
     *
     * @param {object} cfg Object properties.
     * @param {String} cfg.id Mandatory ID for the new mesh. Must not clash with any existing components within the {@link Scene}.
     * @param {String|Number} [cfg.textureSetId] ID of a {@link SceneModelTextureSet} previously created with {@link SceneModel#createTextureSet}.
     * @param {String|Number} [cfg.transformId] ID of a {@link SceneModelTransform} to instance, previously created with {@link SceneModel#createTransform}. Overrides all other transform parameters given to this method.
     * @param {String|Number} [cfg.geometryId] ID of a geometry to instance, previously created with {@link SceneModel#createGeometry}. Overrides all other geometry parameters given to this method.
     * @param {String} cfg.primitive The primitive type. Accepted values are &apos;points&apos;, &apos;lines&apos;, &apos;triangles&apos;, &apos;solid&apos; and &apos;surface&apos;.
     * @param {Number[]} [cfg.positions] Flat array of uncompressed 3D vertex positions positions. Required for all primitive types. Overridden by ````positionsCompressed````.
     * @param {Number[]} [cfg.positionsCompressed] Flat array of quantized 3D vertex positions. Overrides ````positions````, and must be accompanied by ````positionsDecodeMatrix````.
     * @param {Number[]} [cfg.positionsDecodeMatrix] A 4x4 matrix for decompressing ````positionsCompressed````. Must be accompanied by ````positionsCompressed````.
     * @param {Number[]} [cfg.normals] Flat array of normal vectors. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.normalsCompressed] Flat array of oct-encoded normal vectors. Overrides ````normals````. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.colors] Flat array of uncompressed RGBA vertex colors, as float values in range ````[0..1]````. Ignored when ````geometryId```` is given. Overridden by ````color```` and ````colorsCompressed````.
     * @param {Number[]} [cfg.colorsCompressed] Flat array of compressed RGBA vertex colors, as unsigned short integers in range ````[0..255]````. Ignored when ````geometryId```` is given. Overrides ````colors```` and is overridden by ````color````.
     * @param {Number[]} [cfg.uv] Flat array of uncompressed vertex UV coordinates. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvCompressed] Flat array of compressed vertex UV coordinates. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. Overrides ````uv````. Must be accompanied by ````uvDecodeMatrix````. Only used with &quot;triangles&quot;, &quot;solid&quot; and &quot;surface&quot; primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvDecodeMatrix] A 3x3 matrix for decompressing ````uvCompressed````.
     * @param {Number[]} [cfg.indices] Array of primitive connectivity indices. Not required for `points` primitives.
     * @param {Number[]} [cfg.edgeIndices] Array of edge line indices. Used only with &apos;triangles&apos;, &apos;solid&apos; and &apos;surface&apos; primitives. Automatically generated internally if not supplied, using the optional ````edgeThreshold```` given to the ````SceneModel```` constructor.
     * @param {Number[]} [cfg.origin] Optional geometry origin, relative to {@link SceneModel#origin}. When this is given, then ````positions```` are assumed to be relative to this.
     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position of the mesh. Overridden by ````transformId````.
     * @param {Number[]} [cfg.scale=[1,1,1]] Scale of the mesh.  Overridden by ````transformId````.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Rotation of the mesh as Euler angles given in degrees, for each of the X, Y and Z axis.  Overridden by ````transformId````.
     * @param {Number[]} [cfg.quaternion] Rotation of the mesh as a quaternion.  Overridden by ````rotation````.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Mesh modelling transform matrix. Overrides the ````position````, ````scale```` and ````rotation```` parameters. Also  overridden by ````transformId````.
     * @param {Number[]} [cfg.color=[1,1,1]] RGB color in range ````[0..1, 0..1, 0..1]````. Overridden by texture set ````colorTexture````. Overrides ````colors```` and ````colorsCompressed````.
     * @param {Number} [cfg.opacity=1] Opacity in range ````[0..1]````. Overridden by texture set ````colorTexture````.
     * @param {Number} [cfg.metallic=0] Metallic factor in range ````[0..1]````. Overridden by texture set ````metallicRoughnessTexture````.
     * @param {Number} [cfg.roughness=1] Roughness factor in range ````[0..1]````. Overridden by texture set ````metallicRoughnessTexture````.
     * @returns {SceneModelMesh} The new mesh.
     */
    createMesh(cfg) {

        if (cfg.id === undefined || cfg.id === null) {
            this.error(&quot;[createMesh] SceneModel.createMesh() config missing: id&quot;);
            return false;
        }

        if (this._meshes[cfg.id]) {
            this.error(`[createMesh] SceneModel already has a mesh with this ID: ${cfg.id}`);
            return false;
        }

        const instancing = (cfg.geometryId !== undefined);
        const batching = !instancing;

        if (batching) {

            // Batched geometry

            if (cfg.primitive === undefined || cfg.primitive === null) {
                cfg.primitive = &quot;triangles&quot;;
            }
            if (cfg.primitive !== &quot;points&quot; &amp;&amp; cfg.primitive !== &quot;lines&quot; &amp;&amp; cfg.primitive !== &quot;triangles&quot; &amp;&amp; cfg.primitive !== &quot;solid&quot; &amp;&amp; cfg.primitive !== &quot;surface&quot;) {
                this.error(`Unsupported value for &apos;primitive&apos;: &apos;${primitive}&apos;  (&apos;geometryId&apos; is absent) - supported values are &apos;points&apos;, &apos;lines&apos;, &apos;triangles&apos;, &apos;solid&apos; and &apos;surface&apos;.`);
                return false;
            }
            if (!cfg.positions &amp;&amp; !cfg.positionsCompressed &amp;&amp; !cfg.buckets) {
                this.error(&quot;Param expected: &apos;positions&apos;,  &apos;positionsCompressed&apos; or `buckets`  (&apos;geometryId&apos; is absent)&quot;);
                return false;
            }
            if (cfg.positions &amp;&amp; (cfg.positionsDecodeMatrix || cfg.positionsDecodeBoundary)) {
                this.error(&quot;Illegal params: &apos;positions&apos; not expected with &apos;positionsDecodeMatrix&apos;/&apos;positionsDecodeBoundary&apos; (&apos;geometryId&apos; is absent)&quot;);
                return false;
            }
            if (cfg.positionsCompressed &amp;&amp; !cfg.positionsDecodeMatrix &amp;&amp; !cfg.positionsDecodeBoundary) {
                this.error(&quot;Param expected: &apos;positionsCompressed&apos; should be accompanied by &apos;positionsDecodeMatrix&apos;/&apos;positionsDecodeBoundary&apos; (&apos;geometryId&apos; is absent)&quot;);
                return false;
            }
            if (cfg.uvCompressed &amp;&amp; !cfg.uvDecodeMatrix) {
                this.error(&quot;Param expected: &apos;uvCompressed&apos; should be accompanied by `uvDecodeMatrix` (&apos;geometryId&apos; is absent)&quot;);
                return false;
            }
            if (!cfg.buckets &amp;&amp; !cfg.indices &amp;&amp; (cfg.primitive === &quot;triangles&quot; || cfg.primitive === &quot;solid&quot; || cfg.primitive === &quot;surface&quot;)) {
                const numPositions = (cfg.positions || cfg.positionsCompressed).length / 3;
                cfg.indices = this._createDefaultIndices(numPositions);
            }
            if (!cfg.buckets &amp;&amp; !cfg.indices &amp;&amp; cfg.primitive !== &quot;points&quot;) {
                cfg.indices = this._createDefaultIndices(numIndices)
                this.error(`Param expected: indices (required for &apos;${cfg.primitive}&apos; primitive type)`);
                return false;
            }
            if ((cfg.matrix || cfg.position || cfg.rotation || cfg.scale) &amp;&amp; (cfg.positionsCompressed || cfg.positionsDecodeBoundary)) {
                this.error(&quot;Unexpected params: &apos;matrix&apos;, &apos;rotation&apos;, &apos;scale&apos;, &apos;position&apos; not allowed with &apos;positionsCompressed&apos;&quot;);
                return false;
            }

            const useDTX = (!!this._dtxEnabled &amp;&amp; (cfg.primitive === &quot;triangles&quot;
                    || cfg.primitive === &quot;solid&quot;
                    || cfg.primitive === &quot;surface&quot;))
                &amp;&amp; (!cfg.textureSetId);

            cfg.origin = cfg.origin ? math.addVec3(this._origin, cfg.origin, math.vec3()) : this._origin;

            // MATRIX - optional for batching

            if (cfg.matrix) {
                cfg.meshMatrix = cfg.matrix;
            } else if (cfg.scale || cfg.rotation || cfg.position || cfg.quaternion) {
                const scale = cfg.scale || DEFAULT_SCALE;
                const position = cfg.position || DEFAULT_POSITION;
                if (cfg.rotation) {
                    math.eulerToQuaternion(cfg.rotation, &quot;XYZ&quot;, tempQuaternion);
                    cfg.meshMatrix = math.composeMat4(position, tempQuaternion, scale, math.mat4());
                } else {
                    cfg.meshMatrix = math.composeMat4(position, cfg.quaternion || DEFAULT_QUATERNION, scale, math.mat4());
                }
            }

            if (cfg.positionsDecodeBoundary) {
                cfg.positionsDecodeMatrix = createPositionsDecodeMatrix(cfg.positionsDecodeBoundary, math.mat4());
            }

            if (useDTX) {

                // DTX

                cfg.type = DTX;

                // NPR

                cfg.color = (cfg.color) ? new Uint8Array([Math.floor(cfg.color[0] * 255), Math.floor(cfg.color[1] * 255), Math.floor(cfg.color[2] * 255)]) : defaultCompressedColor;
                cfg.opacity = (cfg.opacity !== undefined &amp;&amp; cfg.opacity !== null) ? Math.floor(cfg.opacity * 255) : 255;

                // RTC

                if (cfg.positions) {
                    const rtcCenter = math.vec3();
                    const rtcPositions = [];
                    const rtcNeeded = worldToRTCPositions(cfg.positions, rtcPositions, rtcCenter);
                    if (rtcNeeded) {
                        cfg.positions = rtcPositions;
                        cfg.origin = math.addVec3(cfg.origin, rtcCenter, rtcCenter);
                    }
                }

                // COMPRESSION

                if (cfg.positions) {
                    const aabb = math.collapseAABB3();
                    cfg.positionsDecodeMatrix = math.mat4();
                    math.expandAABB3Points3(aabb, cfg.positions);
                    cfg.positionsCompressed = quantizePositions(cfg.positions, aabb, cfg.positionsDecodeMatrix);
                    cfg.aabb = aabb;

                } else if (cfg.positionsCompressed) {
                    const aabb = math.collapseAABB3();
                    math.expandAABB3Points3(aabb, cfg.positionsCompressed);
                    geometryCompressionUtils.decompressAABB(aabb, cfg.positionsDecodeMatrix);
                    cfg.aabb = aabb;

                }
                if (cfg.buckets) {
                    const aabb = math.collapseAABB3();
                    for (let i = 0, len = cfg.buckets.length; i &lt; len; i++) {
                        const bucket = cfg.buckets[i];
                        if (bucket.positions) {
                            math.expandAABB3Points3(aabb, bucket.positions);
                        } else if (bucket.positionsCompressed) {
                            math.expandAABB3Points3(aabb, bucket.positionsCompressed);
                        }
                    }
                    if (cfg.positionsDecodeMatrix) {
                        geometryCompressionUtils.decompressAABB(aabb, cfg.positionsDecodeMatrix);
                    }
                    cfg.aabb = aabb;
                }

                if (cfg.meshMatrix) {
                    math.AABB3ToOBB3(cfg.aabb, tempOBB3);
                    math.transformOBB3(cfg.meshMatrix, tempOBB3);
                    math.OBB3ToAABB3(tempOBB3, cfg.aabb);
                }

                // EDGES

                if (!cfg.buckets &amp;&amp; !cfg.edgeIndices &amp;&amp; (cfg.primitive === &quot;triangles&quot; || cfg.primitive === &quot;solid&quot; || cfg.primitive === &quot;surface&quot;)) {
                    if (cfg.positions) { // Faster
                        cfg.edgeIndices = buildEdgeIndices(cfg.positions, cfg.indices, null, 2.0);
                    } else {
                        cfg.edgeIndices = buildEdgeIndices(cfg.positionsCompressed, cfg.indices, cfg.positionsDecodeMatrix, 2.0);
                    }
                }

                // BUCKETING

                if (!cfg.buckets) {
                    cfg.buckets = createDTXBuckets(cfg, this._enableVertexWelding &amp;&amp; this._enableIndexBucketing);
                }

            } else {

                // VBO

                cfg.type = VBO_BATCHED;

                // PBR

                cfg.color = (cfg.color) ? new Uint8Array([Math.floor(cfg.color[0] * 255), Math.floor(cfg.color[1] * 255), Math.floor(cfg.color[2] * 255)]) : [255, 255, 255];
                cfg.opacity = (cfg.opacity !== undefined &amp;&amp; cfg.opacity !== null) ? Math.floor(cfg.opacity * 255) : 255;
                cfg.metallic = (cfg.metallic !== undefined &amp;&amp; cfg.metallic !== null) ? Math.floor(cfg.metallic * 255) : 0;
                cfg.roughness = (cfg.roughness !== undefined &amp;&amp; cfg.roughness !== null) ? Math.floor(cfg.roughness * 255) : 255;

                // RTC

                if (cfg.positions) {
                    const rtcPositions = [];
                    const rtcNeeded = worldToRTCPositions(cfg.positions, rtcPositions, tempVec3a);
                    if (rtcNeeded) {
                        cfg.positions = rtcPositions;
                        cfg.origin = math.addVec3(cfg.origin, tempVec3a, math.vec3());
                    }
                }

                if (cfg.positions) {
                    const aabb = math.collapseAABB3();
                    if (cfg.meshMatrix) {
                        math.transformPositions3(cfg.meshMatrix, cfg.positions, cfg.positions);
                        cfg.meshMatrix = null; // Positions now baked, don&apos;t need any more
                    }
                    math.expandAABB3Points3(aabb, cfg.positions);
                    cfg.aabb = aabb;

                } else {
                    const aabb = math.collapseAABB3();
                    math.expandAABB3Points3(aabb, cfg.positionsCompressed);
                    geometryCompressionUtils.decompressAABB(aabb, cfg.positionsDecodeMatrix);
                    cfg.aabb = aabb;
                }

                if (cfg.meshMatrix) {
                    math.AABB3ToOBB3(cfg.aabb, tempOBB3);
                    math.transformOBB3(cfg.meshMatrix, tempOBB3);
                    math.OBB3ToAABB3(tempOBB3, cfg.aabb);
                }

                // EDGES

                if (!cfg.buckets &amp;&amp; !cfg.edgeIndices &amp;&amp; (cfg.primitive === &quot;triangles&quot; || cfg.primitive === &quot;solid&quot; || cfg.primitive === &quot;surface&quot;)) {
                    if (cfg.positions) {
                        cfg.edgeIndices = buildEdgeIndices(cfg.positions, cfg.indices, null, 2.0);
                    } else {
                        cfg.edgeIndices = buildEdgeIndices(cfg.positionsCompressed, cfg.indices, cfg.positionsDecodeMatrix, 2.0);
                    }
                }

                // TEXTURE

                // cfg.textureSetId = cfg.textureSetId || DEFAULT_TEXTURE_SET_ID;
                if (cfg.textureSetId) {
                    cfg.textureSet = this._textureSets[cfg.textureSetId];
                    if (!cfg.textureSet) {
                        this.error(`[createMesh] Texture set not found: ${cfg.textureSetId} - ensure that you create it first with createTextureSet()`);
                        return false;
                    }
                }
            }

        } else {

            // INSTANCING

            if (cfg.positions || cfg.positionsCompressed || cfg.indices || cfg.edgeIndices || cfg.normals || cfg.normalsCompressed || cfg.uv || cfg.uvCompressed || cfg.positionsDecodeMatrix) {
                this.error(`Mesh geometry parameters not expected when instancing a geometry (not expected: positions, positionsCompressed, indices, edgeIndices, normals, normalsCompressed, uv, uvCompressed, positionsDecodeMatrix)`);
                return false;
            }

            cfg.geometry = this._geometries[cfg.geometryId];
            if (!cfg.geometry) {
                this.error(`[createMesh] Geometry not found: ${cfg.geometryId} - ensure that you create it first with createGeometry()`);
                return false;
            }

            cfg.origin = cfg.origin ? math.addVec3(this._origin, cfg.origin, math.vec3()) : this._origin;
            cfg.positionsDecodeMatrix = cfg.geometry.positionsDecodeMatrix;

            if (cfg.transformId) {

                // TRANSFORM

                cfg.transform = this._transforms[cfg.transformId];

                if (!cfg.transform) {
                    this.error(`[createMesh] Transform not found: ${cfg.transformId} - ensure that you create it first with createTransform()`);
                    return false;
                }

                cfg.aabb = cfg.geometry.aabb;

            } else {

                // MATRIX

                if (cfg.matrix) {
                    cfg.meshMatrix = cfg.matrix;
                } else if (cfg.scale || cfg.rotation || cfg.position || cfg.quaternion) {
                    const scale = cfg.scale || DEFAULT_SCALE;
                    const position = cfg.position || DEFAULT_POSITION;
                    if (cfg.rotation) {
                        math.eulerToQuaternion(cfg.rotation, &quot;XYZ&quot;, tempQuaternion);
                        cfg.meshMatrix = math.composeMat4(position, tempQuaternion, scale, math.mat4());
                    } else {
                        cfg.meshMatrix = math.composeMat4(position, cfg.quaternion || DEFAULT_QUATERNION, scale, math.mat4());
                    }
                }

                math.AABB3ToOBB3(cfg.geometry.aabb, tempOBB3);
                math.transformOBB3(cfg.meshMatrix, tempOBB3);
                cfg.aabb = math.OBB3ToAABB3(tempOBB3, math.AABB3());
            }

            const useDTX = (!!this._dtxEnabled
                    &amp;&amp; (cfg.geometry.primitive === &quot;triangles&quot;
                        || cfg.geometry.primitive === &quot;solid&quot;
                        || cfg.geometry.primitive === &quot;surface&quot;))
                &amp;&amp; (!cfg.textureSetId);

            if (useDTX) {

                // DTX

                cfg.type = DTX;

                // NPR

                cfg.color = (cfg.color) ? new Uint8Array([Math.floor(cfg.color[0] * 255), Math.floor(cfg.color[1] * 255), Math.floor(cfg.color[2] * 255)]) : defaultCompressedColor;
                cfg.opacity = (cfg.opacity !== undefined &amp;&amp; cfg.opacity !== null) ? Math.floor(cfg.opacity * 255) : 255;

                // BUCKETING - lazy generated, reused

                let buckets = this._dtxBuckets[cfg.geometryId];
                if (!buckets) {
                    buckets = createDTXBuckets(cfg.geometry, this._enableVertexWelding, this._enableIndexBucketing);
                    this._dtxBuckets[cfg.geometryId] = buckets;
                }
                cfg.buckets = buckets;

            } else {

                // VBO

                cfg.type = VBO_INSTANCED;

                // PBR

                cfg.color = (cfg.color) ? new Uint8Array([Math.floor(cfg.color[0] * 255), Math.floor(cfg.color[1] * 255), Math.floor(cfg.color[2] * 255)]) : defaultCompressedColor;
                cfg.opacity = (cfg.opacity !== undefined &amp;&amp; cfg.opacity !== null) ? Math.floor(cfg.opacity * 255) : 255;
                cfg.metallic = (cfg.metallic !== undefined &amp;&amp; cfg.metallic !== null) ? Math.floor(cfg.metallic * 255) : 0;
                cfg.roughness = (cfg.roughness !== undefined &amp;&amp; cfg.roughness !== null) ? Math.floor(cfg.roughness * 255) : 255;

                // TEXTURE

                if (cfg.textureSetId) {
                    cfg.textureSet = this._textureSets[cfg.textureSetId];
                    // if (!cfg.textureSet) {
                    //     this.error(`[createMesh] Texture set not found: ${cfg.textureSetId} - ensure that you create it first with createTextureSet()`);
                    //     return false;
                    // }
                }
            }
        }

        cfg.numPrimitives = this._getNumPrimitives(cfg);

        return this._createMesh(cfg);
    }

    _createDefaultIndices(numIndices) {
        const indices = [];
        for (let i = 0; i &lt; numIndices; i++) {
            indices.push(i);
        }
        return indices;
    }

    _createMesh(cfg) {
        const mesh = new SceneModelMesh(this, cfg.id, cfg.color, cfg.opacity, cfg.transform, cfg.textureSet);
        mesh.pickId = this.scene._renderer.getPickID(mesh);
        const pickId = mesh.pickId;
        const a = pickId &gt;&gt; 24 &amp; 0xFF;
        const b = pickId &gt;&gt; 16 &amp; 0xFF;
        const g = pickId &gt;&gt; 8 &amp; 0xFF;
        const r = pickId &amp; 0xFF;
        cfg.pickColor = new Uint8Array([r, g, b, a]); // Quantized pick color
        cfg.solid = (cfg.primitive === &quot;solid&quot;);
        mesh.origin = math.vec3(cfg.origin);
        switch (cfg.type) {
            case DTX:
                mesh.layer = this._getDTXLayer(cfg);
                mesh.aabb = cfg.aabb;
                break;
            case VBO_BATCHED:
                mesh.layer = this._getVBOBatchingLayer(cfg);
                mesh.aabb = cfg.aabb;
                break;
            case VBO_INSTANCED:
                mesh.layer = this._getVBOInstancingLayer(cfg);
                mesh.aabb = cfg.aabb;
                break;
        }
        if (cfg.transform) {
            cfg.meshMatrix = cfg.transform.worldMatrix;
        }
        mesh.portionId = mesh.layer.createPortion(mesh, cfg);
        mesh.numPrimitives = cfg.numPrimitives;
        this._meshes[cfg.id] = mesh;
        this._unusedMeshes[cfg.id] = mesh;
        this._meshList.push(mesh);
        return mesh;
    }

    _getNumPrimitives(cfg) {
        let countIndices = 0;
        const primitive = cfg.geometry ? cfg.geometry.primitive : cfg.primitive;
        switch (primitive) {
            case &quot;triangles&quot;:
            case &quot;solid&quot;:
            case &quot;surface&quot;:
                switch (cfg.type) {
                    case DTX:
                        for (let i = 0, len = cfg.buckets.length; i &lt; len; i++) {
                            countIndices += cfg.buckets[i].indices.length;
                        }
                        break;
                    case VBO_BATCHED:
                        countIndices += cfg.indices.length;
                        break;
                    case VBO_INSTANCED:
                        countIndices += cfg.geometry.indices.length;
                        break;
                }
                return Math.round(countIndices / 3);
            case &quot;points&quot;:
                switch (cfg.type) {
                    case DTX:
                        for (let i = 0, len = cfg.buckets.length; i &lt; len; i++) {
                            countIndices += cfg.buckets[i].positionsCompressed.length;
                        }
                        break;
                    case VBO_BATCHED:
                        countIndices += cfg.positions ? cfg.positions.length : cfg.positionsCompressed.length;
                        break;
                    case VBO_INSTANCED:
                        const geometry = cfg.geometry;
                        countIndices += geometry.positions ? geometry.positions.length : geometry.positionsCompressed.length;
                        break;
                }
                return Math.round(countIndices);
            case &quot;lines&quot;:
            case &quot;line-strip&quot;:
                switch (cfg.type) {
                    case DTX:
                        for (let i = 0, len = cfg.buckets.length; i &lt; len; i++) {
                            countIndices += cfg.buckets[i].indices.length;
                        }
                        break;
                    case VBO_BATCHED:
                        countIndices += cfg.indices.length;
                        break;
                    case VBO_INSTANCED:
                        countIndices += cfg.geometry.indices.length;
                        break;
                }
                return Math.round(countIndices / 2);
        }
        return 0;
    }

    _getDTXLayer(cfg) {
        const origin = cfg.origin;
        const primitive = cfg.geometry ? cfg.geometry.primitive : cfg.primitive;
        const layerId = `.${primitive}.${Math.round(origin[0])}.${Math.round(origin[1])}.${Math.round(origin[2])}`;
        let dtxLayer = this._dtxLayers[layerId];
        if (dtxLayer) {
            if (!dtxLayer.canCreatePortion(cfg)) {
                //  dtxLayer.finalize();
                delete this._dtxLayers[layerId];
                dtxLayer = null;
            } else {
                return dtxLayer;
            }
        }
        switch (primitive) {
            case &quot;triangles&quot;:
            case &quot;solid&quot;:
            case &quot;surface&quot;:
                dtxLayer = new DTXTrianglesLayer(this, {layerIndex: 0, origin, primitive}); // layerIndex is set in #finalize()
                break;
            case &quot;lines&quot;:
                dtxLayer = new DTXLinesLayer(this, {layerIndex: 0, origin, primitive}); // layerIndex is set in #finalize()
                break;
            default:
                return;
        }
        this._dtxLayers[layerId] = dtxLayer;
        this.layerList.push(dtxLayer);
        this._layersToFinalize.push(dtxLayer);
        return dtxLayer;
    }

    _getVBOBatchingLayer(cfg) {
        const model = this;
        const origin = cfg.origin;
        const renderLayer = cfg.renderLayer || 0;
        const positionsDecodeHash = cfg.positionsDecodeMatrix || cfg.positionsDecodeBoundary ?
            this._createHashStringFromMatrix(cfg.positionsDecodeMatrix || cfg.positionsDecodeBoundary)
            : &quot;-&quot;;
        const textureSetId = cfg.textureSetId || &quot;-&quot;;
        const layerId = `${Math.round(origin[0])}.${Math.round(origin[1])}.${Math.round(origin[2])}.${cfg.primitive}.${positionsDecodeHash}.${textureSetId}`;
        let vboBatchingLayer = this._vboBatchingLayers[layerId];
        if (vboBatchingLayer) {
            return vboBatchingLayer;
        }
        let textureSet = cfg.textureSet;
        while (!vboBatchingLayer) {
            switch (cfg.primitive) {
                case &quot;triangles&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating TrianglesBatchingLayer`);
                    vboBatchingLayer = new VBOBatchingTrianglesLayer({
                        model,
                        textureSet,
                        layerIndex: 0, // This is set in #finalize()
                        scratchMemory: this._vboBatchingLayerScratchMemory,
                        positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                        uvDecodeMatrix: cfg.uvDecodeMatrix, // Can be undefined
                        origin,
                        maxGeometryBatchSize: this._maxGeometryBatchSize,
                        solid: (cfg.primitive === &quot;solid&quot;),
                        autoNormals: true,
                        primitive: cfg.primitive
                    });
                    break;
                case &quot;solid&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating TrianglesBatchingLayer`);
                    vboBatchingLayer = new VBOBatchingTrianglesLayer({
                        model,
                        textureSet,
                        layerIndex: 0, // This is set in #finalize()
                        scratchMemory: this._vboBatchingLayerScratchMemory,
                        positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                        uvDecodeMatrix: cfg.uvDecodeMatrix, // Can be undefined
                        origin,
                        maxGeometryBatchSize: this._maxGeometryBatchSize,
                        solid: (cfg.primitive === &quot;solid&quot;),
                        autoNormals: true,
                        primitive: cfg.primitive
                    });
                    break;
                case &quot;surface&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating TrianglesBatchingLayer`);
                    vboBatchingLayer = new VBOBatchingTrianglesLayer({
                        model,
                        textureSet,
                        layerIndex: 0, // This is set in #finalize()
                        scratchMemory: this._vboBatchingLayerScratchMemory,
                        positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                        uvDecodeMatrix: cfg.uvDecodeMatrix, // Can be undefined
                        origin,
                        maxGeometryBatchSize: this._maxGeometryBatchSize,
                        solid: (cfg.primitive === &quot;solid&quot;),
                        autoNormals: true,
                        primitive: cfg.primitive
                    });
                    break;
                case &quot;lines&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating VBOBatchingLinesLayer`);
                    vboBatchingLayer = new VBOBatchingLinesLayer({
                        model,
                        layerIndex: 0, // This is set in #finalize()
                        scratchMemory: this._vboBatchingLayerScratchMemory,
                        positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                        uvDecodeMatrix: cfg.uvDecodeMatrix, // Can be undefined
                        origin,
                        maxGeometryBatchSize: this._maxGeometryBatchSize,
                        primitive: cfg.primitive
                    });
                    break;
                case &quot;points&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating VBOBatchingPointsLayer`);
                    vboBatchingLayer = new VBOBatchingPointsLayer({
                        model,
                        layerIndex: 0, // This is set in #finalize()
                        scratchMemory: this._vboBatchingLayerScratchMemory,
                        positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                        uvDecodeMatrix: cfg.uvDecodeMatrix, // Can be undefined
                        origin,
                        maxGeometryBatchSize: this._maxGeometryBatchSize,
                        primitive: cfg.primitive
                    });
                    break;
            }
            const lenPositions = cfg.positionsCompressed ? cfg.positionsCompressed.length : cfg.positions.length;
            const canCreatePortion = (cfg.primitive === &quot;points&quot;)
                ? vboBatchingLayer.canCreatePortion(lenPositions)
                : vboBatchingLayer.canCreatePortion(lenPositions, cfg.indices.length);
            if (!canCreatePortion) {
                vboBatchingLayer.finalize();
                delete this._vboBatchingLayers[layerId];
                vboBatchingLayer = null;
            }
        }
        this._vboBatchingLayers[layerId] = vboBatchingLayer;
        this.layerList.push(vboBatchingLayer);
        this._layersToFinalize.push(vboBatchingLayer);
        return vboBatchingLayer;
    }

    _createHashStringFromMatrix(matrix) {
        const matrixString = matrix.join(&apos;&apos;);
        let hash = 0;
        for (let i = 0; i &lt; matrixString.length; i++) {
            const char = matrixString.charCodeAt(i);
            hash = (hash &lt;&lt; 5) - hash + char;
            hash |= 0; // Convert to 32-bit integer
        }
        const hashString = (hash &gt;&gt;&gt; 0).toString(16);
        return hashString;
    }

    _getVBOInstancingLayer(cfg) {
        const model = this;
        const origin = cfg.origin;
        const textureSetId = cfg.textureSetId || &quot;-&quot;;
        const geometryId = cfg.geometryId;
        const layerId = `${Math.round(origin[0])}.${Math.round(origin[1])}.${Math.round(origin[2])}.${textureSetId}.${geometryId}`;
        let vboInstancingLayer = this._vboInstancingLayers[layerId];
        if (vboInstancingLayer) {
            return vboInstancingLayer;
        }
        let textureSet = cfg.textureSet;
        const geometry = cfg.geometry;
        while (!vboInstancingLayer) {
            switch (geometry.primitive) {
                case &quot;triangles&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating TrianglesInstancingLayer`);
                    vboInstancingLayer = new VBOInstancingTrianglesLayer({
                        model,
                        textureSet,
                        geometry,
                        origin,
                        layerIndex: 0,
                        solid: false
                    });
                    break;
                case &quot;solid&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating TrianglesInstancingLayer`);
                    vboInstancingLayer = new VBOInstancingTrianglesLayer({
                        model,
                        textureSet,
                        geometry,
                        origin,
                        layerIndex: 0,
                        solid: true
                    });
                    break;
                case &quot;surface&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating TrianglesInstancingLayer`);
                    vboInstancingLayer = new VBOInstancingTrianglesLayer({
                        model,
                        textureSet,
                        geometry,
                        origin,
                        layerIndex: 0,
                        solid: false
                    });
                    break;
                case &quot;lines&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating VBOInstancingLinesLayer`);
                    vboInstancingLayer = new VBOInstancingLinesLayer({
                        model,
                        textureSet,
                        geometry,
                        origin,
                        layerIndex: 0
                    });
                    break;
                case &quot;points&quot;:
                    // console.info(`[SceneModel ${this.id}]: creating PointsInstancingLayer`);
                    vboInstancingLayer = new VBOInstancingPointsLayer({
                        model,
                        textureSet,
                        geometry,
                        origin,
                        layerIndex: 0
                    });
                    break;
            }
            // const lenPositions = geometry.positionsCompressed.length;
            // if (!vboInstancingLayer.canCreatePortion(lenPositions, geometry.indices.length)) { // FIXME: indices should be optional
            //     vboInstancingLayer.finalize();
            //     delete this._vboInstancingLayers[layerId];
            //     vboInstancingLayer = null;
            // }
        }
        this._vboInstancingLayers[layerId] = vboInstancingLayer;
        this.layerList.push(vboInstancingLayer);
        this._layersToFinalize.push(vboInstancingLayer);
        return vboInstancingLayer;
    }

    /**
     * Creates a {@link SceneModelEntity} within this SceneModel.
     *
     * * Gives the SceneModelEntity one or more {@link SceneModelMesh}es previously created with
     * {@link SceneModel#createMesh}. A SceneModelMesh can only belong to one SceneModelEntity, so you&apos;ll get an
     * error if you try to reuse a mesh among multiple SceneModelEntitys.
     * * The SceneModelEntity can have a {@link SceneModelTextureSet}, previously created with
     * {@link SceneModel#createTextureSet}. A SceneModelTextureSet can belong to multiple SceneModelEntitys.
     * * The SceneModelEntity can have a geometry, previously created with
     * {@link SceneModel#createTextureSet}. A geometry is a &quot;virtual component&quot; and can belong to multiple SceneModelEntitys.
     *
     * @param {Object} cfg SceneModelEntity configuration.
     * @param {String} cfg.id Optional ID for the new SceneModelEntity. Must not clash with any existing components within the {@link Scene}.
     * @param {String[]} cfg.meshIds IDs of one or more meshes created previously with {@link SceneModel@createMesh}.
     * @param {Boolean} [cfg.isObject] Set ````true```` if the {@link SceneModelEntity} represents an object, in which case it will be registered by {@link SceneModelEntity#id} in {@link Scene#objects} and can also have a corresponding {@link MetaObject} with matching {@link MetaObject#id}, registered by that ID in {@link MetaScene#metaObjects}.
     * @param {Boolean} [cfg.visible=true] Indicates if the SceneModelEntity is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the SceneModelEntity is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the SceneModelEntity is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the SceneModelEntity is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the SceneModelEntity is initially included in boundary calculations.
     * @param {Boolean} [cfg.castsShadow=true] Indicates if the SceneModelEntity initially casts shadows.
     * @param {Boolean} [cfg.receivesShadow=true]  Indicates if the SceneModelEntity initially receives shadows.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the SceneModelEntity is initially xrayed. XRayed appearance is configured by {@link SceneModel#xrayMaterial}.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the SceneModelEntity is initially highlighted. Highlighted appearance is configured by {@link SceneModel#highlightMaterial}.
     * @param {Boolean} [cfg.selected=false] Indicates if the SceneModelEntity is initially selected. Selected appearance is configured by {@link SceneModel#selectedMaterial}.
     * @param {Boolean} [cfg.edges=false] Indicates if the SceneModelEntity&apos;s edges are initially emphasized. Edges appearance is configured by {@link SceneModel#edgeMaterial}.
     * @returns {SceneModelEntity} The new SceneModelEntity.
     */
    createEntity(cfg) {
        if (cfg.id === undefined) {
            cfg.id = math.createUUID();
        } else if (this.scene.components[cfg.id]) {
            this.error(`Scene already has a Component with this ID: ${cfg.id} - will assign random ID`);
            cfg.id = math.createUUID();
        }
        if (cfg.meshIds === undefined) {
            this.error(&quot;Config missing: meshIds&quot;);
            return;
        }
        let flags = 0;
        if (this._visible &amp;&amp; cfg.visible !== false) {
            flags = flags | ENTITY_FLAGS.VISIBLE;
        }
        if (this._pickable &amp;&amp; cfg.pickable !== false) {
            flags = flags | ENTITY_FLAGS.PICKABLE;
        }
        if (this._culled &amp;&amp; cfg.culled !== false) {
            flags = flags | ENTITY_FLAGS.CULLED;
        }
        if (this._clippable &amp;&amp; cfg.clippable !== false) {
            flags = flags | ENTITY_FLAGS.CLIPPABLE;
        }
        if (this._collidable &amp;&amp; cfg.collidable !== false) {
            flags = flags | ENTITY_FLAGS.COLLIDABLE;
        }
        if (this._edges &amp;&amp; cfg.edges !== false) {
            flags = flags | ENTITY_FLAGS.EDGES;
        }
        if (this._xrayed &amp;&amp; cfg.xrayed !== false) {
            flags = flags | ENTITY_FLAGS.XRAYED;
        }
        if (this._highlighted &amp;&amp; cfg.highlighted !== false) {
            flags = flags | ENTITY_FLAGS.HIGHLIGHTED;
        }
        if (this._selected &amp;&amp; cfg.selected !== false) {
            flags = flags | ENTITY_FLAGS.SELECTED;
        }
        cfg.flags = flags;
        return this._createEntity(cfg);
    }

    _createEntity(cfg) {
        let meshes = [];
        for (let i = 0, len = cfg.meshIds.length; i &lt; len; i++) {
            const meshId = cfg.meshIds[i];
            let mesh = this._meshes[meshId]; // Trying to get already created mesh
            if (!mesh) { // Checks if there is already created mesh for this meshId
                this.error(`Mesh with this ID not found: &quot;${meshId}&quot; - ignoring this mesh`); // There is no such cfg
                continue;
            }
            if (mesh.parent) {
                this.error(`Mesh with ID &quot;${meshId}&quot; already belongs to object with ID &quot;${mesh.parent.id}&quot; - ignoring this mesh`);
                continue;
            }
            meshes.push(mesh);
            delete this._unusedMeshes[meshId];
        }
        const lodCullable = true;
        const entity = new SceneModelEntity(
            this,
            cfg.isObject,
            cfg.id,
            meshes,
            cfg.flags,
            lodCullable); // Internally sets SceneModelEntity#parent to this SceneModel
        this._entityList.push(entity);
        this._entities[cfg.id] = entity;
        this._entitiesToFinalize.push(entity);
        this.numEntities++;
        return entity;
    }

    /**
     * Pre-renders all meshes that have been added, even if the SceneModel has not bee finalized yet.
     * This is use for progressively showing the SceneModel while it is being loaded or constructed.
     * @returns {boolean}
     */
    preFinalize() {
        if (this.destroyed) {
            return false;
        }
        if (this._layersToFinalize.length === 0) {
            return false;
        }
        this._createDummyEntityForUnusedMeshes();
        for (let i = 0, len = this._layersToFinalize.length; i &lt; len; i++) {
            const layer = this._layersToFinalize[i];
            layer.finalize();
        }
        this._vboBatchingLayers = {};
        this._vboInstancingLayers = {};
        this._dtxLayers = {};
        this._layersToFinalize = [];
        for (let i = 0, len = this._entitiesToFinalize.length; i &lt; len; i++) {
            const entity = this._entitiesToFinalize[i];
            entity._finalize();
        }
        for (let i = 0, len = this._entitiesToFinalize.length; i &lt; len; i++) {
            const entity = this._entitiesToFinalize[i];
            entity._finalize2();
        }
        this._entitiesToFinalize = [];
        this.scene._aabbDirty = true;
        this._viewMatrixDirty = true;
        this._matrixDirty = true;
        this._aabbDirty = true;
        this._setWorldMatrixDirty();
        this._sceneModelDirty();
        this.position = this._position;
        // Sort layers to reduce WebGL shader switching when rendering them
        this.layerList.sort((a, b) =&gt; {
            if (a.sortId &lt; b.sortId) {
                return -1;
            }
            if (a.sortId &gt; b.sortId) {
                return 1;
            }
            return 0;
        });
        for (let i = 0, len = this.layerList.length; i &lt; len; i++) {
            const layer = this.layerList[i];
            layer.layerIndex = i;
        }
        this.glRedraw();
        this._layersFinalized = true;
    }

    /**
     * Finalizes this SceneModel.
     *
     * Once finalized, you can&apos;t add anything more to this SceneModel.
     */
    finalize() {
        if (this.destroyed) {
            return;
        }
        this.preFinalize();
        this._geometries = {};
        this._dtxBuckets = {};
        this._textures = {};
        this._textureSets = {};
    }

    /** @private */
    stateSortCompare(drawable1, drawable2) {
    }

    /** @private */
    rebuildRenderFlags() {
        this.renderFlags.reset();
        this._updateRenderFlagsVisibleLayers();
        if (this.renderFlags.numLayers &gt; 0 &amp;&amp; this.renderFlags.numVisibleLayers === 0) {
            this.renderFlags.culled = true;
            return;
        }
        this._updateRenderFlags();
    }

    /**
     * @private
     */
    _updateRenderFlagsVisibleLayers() {
        const renderFlags = this.renderFlags;
        renderFlags.numLayers = this.layerList.length;
        renderFlags.numVisibleLayers = 0;
        for (let layerIndex = 0, len = this.layerList.length; layerIndex &lt; len; layerIndex++) {
            const layer = this.layerList[layerIndex];
            const layerVisible = this._getActiveSectionPlanesForLayer(layer);
            if (layerVisible) {
                renderFlags.visibleLayers[renderFlags.numVisibleLayers++] = layerIndex;
            }
        }
    }

    /** @private */
    _createDummyEntityForUnusedMeshes() {
        const unusedMeshIds = Object.keys(this._unusedMeshes);
        if (unusedMeshIds.length &gt; 0) {
            const entityId = `${this.id}-${math.createUUID()}`;
            this.warn(`Creating dummy SceneModelEntity &quot;${entityId}&quot; for unused SceneMeshes: [${unusedMeshIds.join(&quot;,&quot;)}]`)
            this.createEntity({
                id: entityId,
                meshIds: unusedMeshIds,
                isObject: true
            });
        }
        this._unusedMeshes = {};
    }

    _getActiveSectionPlanesForLayer(layer) {
        const renderFlags = this.renderFlags;
        const sectionPlanes = this.scene._sectionPlanesState.sectionPlanes;
        const numSectionPlanes = sectionPlanes.length;
        const baseIndex = layer.layerIndex * numSectionPlanes;
        if (numSectionPlanes &gt; 0) {
            for (let i = 0; i &lt; numSectionPlanes; i++) {
                const sectionPlane = sectionPlanes[i];
                if (!sectionPlane.active) {
                    renderFlags.sectionPlanesActivePerLayer[baseIndex + i] = false;
                } else {
                    renderFlags.sectionPlanesActivePerLayer[baseIndex + i] = true;
                    renderFlags.sectioned = true;
                }
            }
        }
        return true;
    }

    _updateRenderFlags() {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        if (this.numCulledLayerPortions === this.numPortions) {
            return;
        }
        const renderFlags = this.renderFlags;
        renderFlags.colorOpaque = (this.numTransparentLayerPortions &lt; this.numPortions);
        if (this.numTransparentLayerPortions &gt; 0) {
            renderFlags.colorTransparent = true;
        }
        if (this.numXRayedLayerPortions &gt; 0) {
            const xrayMaterial = this.scene.xrayMaterial._state;
            if (xrayMaterial.fill) {
                if (xrayMaterial.fillAlpha &lt; 1.0) {
                    renderFlags.xrayedSilhouetteTransparent = true;
                } else {
                    renderFlags.xrayedSilhouetteOpaque = true;
                }
            }
            if (xrayMaterial.edges) {
                if (xrayMaterial.edgeAlpha &lt; 1.0) {
                    renderFlags.xrayedEdgesTransparent = true;
                } else {
                    renderFlags.xrayedEdgesOpaque = true;
                }
            }
        }
        if (this.numEdgesLayerPortions &gt; 0) {
            const edgeMaterial = this.scene.edgeMaterial._state;
            if (edgeMaterial.edges) {
                renderFlags.edgesOpaque = (this.numTransparentLayerPortions &lt; this.numPortions);
                if (this.numTransparentLayerPortions &gt; 0) {
                    renderFlags.edgesTransparent = true;
                }
            }
        }
        if (this.numSelectedLayerPortions &gt; 0) {
            const selectedMaterial = this.scene.selectedMaterial._state;
            if (selectedMaterial.fill) {
                if (selectedMaterial.fillAlpha &lt; 1.0) {
                    renderFlags.selectedSilhouetteTransparent = true;
                } else {
                    renderFlags.selectedSilhouetteOpaque = true;
                }
            }
            if (selectedMaterial.edges) {
                if (selectedMaterial.edgeAlpha &lt; 1.0) {
                    renderFlags.selectedEdgesTransparent = true;
                } else {
                    renderFlags.selectedEdgesOpaque = true;
                }
            }
        }
        if (this.numHighlightedLayerPortions &gt; 0) {
            const highlightMaterial = this.scene.highlightMaterial._state;
            if (highlightMaterial.fill) {
                if (highlightMaterial.fillAlpha &lt; 1.0) {
                    renderFlags.highlightedSilhouetteTransparent = true;
                } else {
                    renderFlags.highlightedSilhouetteOpaque = true;
                }
            }
            if (highlightMaterial.edges) {
                if (highlightMaterial.edgeAlpha &lt; 1.0) {
                    renderFlags.highlightedEdgesTransparent = true;
                } else {
                    renderFlags.highlightedEdgesOpaque = true;
                }
            }
        }
    }

    // -------------- RENDERING ---------------------------------------------------------------------------------------

    /** @private */
    drawColorOpaque(frameCtx, layerList) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawColorOpaque(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawColorTransparent(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawColorTransparent(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawDepth(frameCtx) { // Dedicated to SAO because it skips transparent objects
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawDepth(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawNormals(frameCtx) { // Dedicated to SAO because it skips transparent objects
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawNormals(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawSilhouetteXRayed(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawSilhouetteXRayed(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawSilhouetteHighlighted(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawSilhouetteHighlighted(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawSilhouetteSelected(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawSilhouetteSelected(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawEdgesColorOpaque(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawEdgesColorOpaque(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawEdgesColorTransparent(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawEdgesColorTransparent(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawEdgesXRayed(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawEdgesXRayed(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawEdgesHighlighted(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawEdgesHighlighted(renderFlags, frameCtx);
        }
    }

    /** @private */
    drawEdgesSelected(frameCtx) {
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawEdgesSelected(renderFlags, frameCtx);
        }
    }

    /**
     * @private
     */
    drawOcclusion(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawOcclusion(renderFlags, frameCtx);
        }
    }

    /**
     * @private
     */
    drawShadow(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawShadow(renderFlags, frameCtx);
        }
    }

    /** @private */
    setPickMatrices(pickViewMatrix, pickProjMatrix) {
        if (this._numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            const layer = this.layerList[layerIndex];
            if (layer.setPickMatrices) {
                layer.setPickMatrices(pickViewMatrix, pickProjMatrix);
            }
        }
    }

    /** @private */
    drawPickMesh(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawPickMesh(renderFlags, frameCtx);
        }
    }

    /**
     * Called by SceneModelMesh.drawPickDepths()
     * @private
     */
    drawPickDepths(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawPickDepths(renderFlags, frameCtx);
        }
    }

    /**
     * Called by SceneModelMesh.drawPickNormals()
     * @private
     */
    drawPickNormals(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            this.layerList[layerIndex].drawPickNormals(renderFlags, frameCtx);
        }
    }

    /**
     * @private
     */
    drawSnapInit(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            const layer = this.layerList[layerIndex];
            if (layer.drawSnapInit) {
                frameCtx.snapPickOrigin = [0, 0, 0];
                frameCtx.snapPickCoordinateScale = [1, 1, 1];
                frameCtx.snapPickLayerNumber++;
                layer.drawSnapInit(renderFlags, frameCtx);
                frameCtx.snapPickLayerParams[frameCtx.snapPickLayerNumber] = {
                    origin: frameCtx.snapPickOrigin.slice(),
                    coordinateScale: frameCtx.snapPickCoordinateScale.slice(),
                };
            }
        }
    }

    /**
     * @private
     */
    drawSnap(frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        const renderFlags = this.renderFlags;
        for (let i = 0, len = renderFlags.visibleLayers.length; i &lt; len; i++) {
            const layerIndex = renderFlags.visibleLayers[i];
            const layer = this.layerList[layerIndex];
            if (layer.drawSnap) {
                frameCtx.snapPickOrigin = [0, 0, 0];
                frameCtx.snapPickCoordinateScale = [1, 1, 1];
                frameCtx.snapPickLayerNumber++;
                layer.drawSnap(renderFlags, frameCtx);
                frameCtx.snapPickLayerParams[frameCtx.snapPickLayerNumber] = {
                    origin: frameCtx.snapPickOrigin.slice(),
                    coordinateScale: frameCtx.snapPickCoordinateScale.slice(),
                };
            }
        }
    }

    /**
     * Destroys this SceneModel.
     */
    destroy() {
        for (let layerId in this._vboBatchingLayers) {
            if (this._vboBatchingLayers.hasOwnProperty(layerId)) {
                this._vboBatchingLayers[layerId].destroy();
            }
        }
        this._vboBatchingLayers = {};
        for (let layerId in this._vboInstancingLayers) {
            if (this._vboInstancingLayers.hasOwnProperty(layerId)) {
                this._vboInstancingLayers[layerId].destroy();
            }
        }
        this._vboInstancingLayers = {};
        this.scene.camera.off(this._onCameraViewMatrix);
        this.scene.off(this._onTick);
        for (let i = 0, len = this.layerList.length; i &lt; len; i++) {
            this.layerList[i].destroy();
        }
        this.layerList = [];
        for (let i = 0, len = this._entityList.length; i &lt; len; i++) {
            this._entityList[i]._destroy();
        }
        this._layersToFinalize = {};
        // Object.entries(this._geometries).forEach(([id, geometry]) =&gt; {
        //     geometry.destroy();
        // });
        this._geometries = {};
        this._dtxBuckets = {};
        this._textures = {};
        this._textureSets = {};
        this._meshes = {};
        this._entities = {};
        this.scene._aabbDirty = true;
        if (this._isModel) {
            this.scene._deregisterModel(this);
        }
        putScratchMemory();
        super.destroy();
    }
}


/**
 * This function applies two steps to the provided mesh geometry data:
 *
 * - 1st, it reduces its `.positions` to unique positions, thus removing duplicate vertices. It will adjust the `.indices` and `.edgeIndices` array accordingly to the unique `.positions`.
 *
 * - 2nd, it tries to do an optimization called `index rebucketting`
 *
 *   _Rebucketting minimizes the amount of RAM usage for a given mesh geometry by trying do demote its needed index bitness._
 *
 *   - _for 32 bit indices, will try to demote them to 16 bit indices_
 *   - _for 16 bit indices, will try to demote them to 8 bits indices_
 *   - _8 bits indices are kept as-is_
 *
 *   The fact that 32/16/8 bits are needed for indices, depends on the number of maximumm indexable vertices within the mesh geometry: this is, the number of vertices in the mesh geometry.
 *
 * The function returns the same provided input `geometry`, enrichened with the additional key `.preparedBukets`.
 *
 * @param {object} geometry The mesh information containing `.positions`, `.indices`, `.edgeIndices` arrays.
 *
 * @param enableVertexWelding
 * @param enableIndexBucketing
 * @returns {object} The mesh information enrichened with `.buckets` key.
 */
function createDTXBuckets(geometry, enableVertexWelding, enableIndexBucketing) {
    let uniquePositionsCompressed, uniqueIndices, uniqueEdgeIndices;
    if (enableVertexWelding || enableIndexBucketing) { // Expensive - careful!
        [
            uniquePositionsCompressed,
            uniqueIndices,
            uniqueEdgeIndices,
        ] = uniquifyPositions({
            positionsCompressed: geometry.positionsCompressed,
            indices: geometry.indices,
            edgeIndices: geometry.edgeIndices
        });
    } else {
        uniquePositionsCompressed = geometry.positionsCompressed;
        uniqueIndices = geometry.indices;
        uniqueEdgeIndices = geometry.edgeIndices;
    }
    let buckets;
    if (enableIndexBucketing) {
        let numUniquePositions = uniquePositionsCompressed.length / 3;
        buckets = rebucketPositions({
                positionsCompressed: uniquePositionsCompressed,
                indices: uniqueIndices,
                edgeIndices: uniqueEdgeIndices,
            },
            (numUniquePositions &gt; (1 &lt;&lt; 16)) ? 16 : 8,
            // true
        );
    } else {
        buckets = [{
            positionsCompressed: uniquePositionsCompressed,
            indices: uniqueIndices,
            edgeIndices: uniqueEdgeIndices,
        }];
    }
    return buckets;
}

function

createGeometryOBB(geometry) {
    geometry.obb = math.OBB3();
    if (geometry.positionsCompressed &amp;&amp; geometry.positionsCompressed.length &gt; 0) {
        const localAABB = math.collapseAABB3();
        math.expandAABB3Points3(localAABB, geometry.positionsCompressed);
        geometryCompressionUtils.decompressAABB(localAABB, geometry.positionsDecodeMatrix);
        math.AABB3ToOBB3(localAABB, geometry.obb);
    } else if (geometry.positions &amp;&amp; geometry.positions.length &gt; 0) {
        const localAABB = math.collapseAABB3();
        math.expandAABB3Points3(localAABB, geometry.positions);
        math.AABB3ToOBB3(localAABB, geometry.obb);
    } else if (geometry.buckets) {
        const localAABB = math.collapseAABB3();
        for (let i = 0, len = geometry.buckets.length; i &lt; len; i++) {
            const bucket = geometry.buckets[i];
            math.expandAABB3Points3(localAABB, bucket.positionsCompressed);
        }
        geometryCompressionUtils.decompressAABB(localAABB, geometry.positionsDecodeMatrix);
        math.AABB3ToOBB3(localAABB, geometry.obb);
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
