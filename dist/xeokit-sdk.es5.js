var _DEFAULT_SAMPLER;var _marked=/*#__PURE__*/_regeneratorRuntime().mark(makeStringIterator),_marked2=/*#__PURE__*/_regeneratorRuntime().mark(makeArrayBufferIterator),_marked3=/*#__PURE__*/_regeneratorRuntime().mark(makeMeshPrimitiveIterator);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty2(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}function _defineProperty2(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _regeneratorRuntime(){"use strict";/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function _regeneratorRuntime(){return exports;};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key];}try{define({},"");}catch(err){define=function define(obj,key,value){return obj[key]=value;};}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return generator._invoke=function(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult();}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult;}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg);}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done};}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg);}};}(innerFn,self,context),generator;}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)};}catch(err){return{type:"throw",arg:err};}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,function(){return this;});var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach(function(method){define(prototype,method,function(arg){return this._invoke(method,arg);});});}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==_typeof(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then(function(value){invoke("next",value,resolve,reject);},function(err){invoke("throw",err,resolve,reject);}):PromiseImpl.resolve(value).then(function(unwrapped){result.value=unwrapped,resolve(result);},function(error){return invoke("throw",error,resolve,reject);});}reject(record.arg);}var previousPromise;this._invoke=function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl(function(resolve,reject){invoke(method,arg,resolve,reject);});}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();};}function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(undefined===method){if(context.delegate=null,"throw"===context.method){if(delegate.iterator["return"]&&(context.method="return",context.arg=undefined,maybeInvokeDelegate(delegate,context),"throw"===context.method))return ContinueSentinel;context.method="throw",context.arg=new TypeError("The iterator does not provide a 'throw' method");}return ContinueSentinel;}var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=undefined),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel);}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry);}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record;}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0);}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;){if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;}return next.value=undefined,next.done=!0,next;};return next.next=next;}}return{next:doneResult};}function doneResult(){return{value:undefined,done:!0};}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(Gp,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name));},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun;},exports.awrap=function(arg){return{__await:arg};},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,function(){return this;}),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then(function(result){return result.done?result.value:iter.next();});},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,function(){return this;}),define(Gp,"toString",function(){return"[object Generator]";}),exports.keys=function(object){var keys=[];for(var key in object){keys.push(key);}return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next;}return next.done=!0,next;};},exports.values=values,Context.prototype={constructor:Context,reset:function reset(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=undefined,this.done=!1,this.delegate=null,this.method="next",this.arg=undefined,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this){"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=undefined);}},stop:function stop(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval;},dispatchException:function dispatchException(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=undefined),!!caught;}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc);}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc);}}}},abrupt:function abrupt(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break;}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record);},complete:function complete(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel;},finish:function finish(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel;}},"catch":function _catch(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry);}return thrown;}}throw new Error("illegal catch attempt");},delegateYield:function delegateYield(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=undefined),ContinueSentinel;}},exports;}function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{Promise.resolve(value).then(_next,_throw);}}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise(function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value);}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err);}_next(undefined);});};}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArray(iter){if(typeof Symbol!=="undefined"&&iter[Symbol.iterator]!=null||iter["@@iterator"]!=null)return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr);}function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e13){throw _e13;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e14){didErr=true;err=_e14;},f:function f(){try{if(!normalCompletion&&it["return"]!=null)it["return"]();}finally{if(didErr)throw err;}}};}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _iterableToArrayLimit(arr,i){var _i=arr==null?null:typeof Symbol!=="undefined"&&arr[Symbol.iterator]||arr["@@iterator"];if(_i==null)return;var _arr=[];var _n=true;var _d=false;var _s,_e;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function _get(){if(typeof Reflect!=="undefined"&&Reflect.get){_get=Reflect.get.bind();}else{_get=function _get(target,property,receiver){var base=_superPropBase(target,property);if(!base)return;var desc=Object.getOwnPropertyDescriptor(base,property);if(desc.get){return desc.get.call(arguments.length<3?target:receiver);}return desc.value;};}return _get.apply(this,arguments);}function _superPropBase(object,property){while(!Object.prototype.hasOwnProperty.call(object,property)){object=_getPrototypeOf(object);if(object===null)break;}return object;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});Object.defineProperty(subClass,"prototype",{writable:false});if(superClass)_setPrototypeOf(subClass,superClass);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}else if(call!==void 0){throw new TypeError("Derived constructors may only return object or undefined");}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;},_typeof(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);Object.defineProperty(Constructor,"prototype",{writable:false});return Constructor;}function _awaitAsyncGenerator(value){return new _AwaitValue(value);}function _wrapAsyncGenerator(fn){return function(){return new _AsyncGenerator(fn.apply(this,arguments));};}function _AsyncGenerator(gen){var front,back;function send(key,arg){return new Promise(function(resolve,reject){var request={key:key,arg:arg,resolve:resolve,reject:reject,next:null};if(back){back=back.next=request;}else{front=back=request;resume(key,arg);}});}function resume(key,arg){try{var result=gen[key](arg);var value=result.value;var wrappedAwait=value instanceof _AwaitValue;Promise.resolve(wrappedAwait?value.wrapped:value).then(function(arg){if(wrappedAwait){resume(key==="return"?"return":"next",arg);return;}settle(result.done?"return":"normal",arg);},function(err){resume("throw",err);});}catch(err){settle("throw",err);}}function settle(type,value){switch(type){case"return":front.resolve({value:value,done:true});break;case"throw":front.reject(value);break;default:front.resolve({value:value,done:false});break;}front=front.next;if(front){resume(front.key,front.arg);}else{back=null;}}this._invoke=send;if(typeof gen["return"]!=="function"){this["return"]=undefined;}}_AsyncGenerator.prototype[typeof Symbol==="function"&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this;};_AsyncGenerator.prototype.next=function(arg){return this._invoke("next",arg);};_AsyncGenerator.prototype["throw"]=function(arg){return this._invoke("throw",arg);};_AsyncGenerator.prototype["return"]=function(arg){return this._invoke("return",arg);};function _AwaitValue(value){this.wrapped=value;}function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator";}throw new TypeError("Object is not async iterable");}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then(function(value){return{value:value,done:done};});}return AsyncFromSyncIterator=function AsyncFromSyncIterator(s){this.s=s,this.n=s.next;},AsyncFromSyncIterator.prototype={s:null,n:null,next:function next(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments));},"return":function _return(value){var ret=this.s["return"];return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments));},"throw":function _throw(value){var thr=this.s["return"];return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments));}},new AsyncFromSyncIterator(s);}/** @private */var Map$1=/*#__PURE__*/function(){function Map$1(items,baseId){_classCallCheck(this,Map$1);this.items=items||[];this._lastUniqueId=(baseId||0)+1;}/**
     * Usage:
     *
     * id = myMap.addItem("foo") // ID internally generated
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     */_createClass(Map$1,[{key:"addItem",value:function addItem(){var item;if(arguments.length===2){var id=arguments[0];item=arguments[1];if(this.items[id]){// Won't happen if given ID is string
throw"ID clash: '"+id+"'";}this.items[id]=item;return id;}else{item=arguments[0]||{};while(true){var findId=this._lastUniqueId++;if(!this.items[findId]){this.items[findId]=item;return findId;}}}}},{key:"removeItem",value:function removeItem(id){var item=this.items[id];delete this.items[id];return item;}}]);return Map$1;}();var idMap=new Map$1();/**
 * Internal data class that represents the state of a menu or a submenu.
 * @private
 */var Menu=/*#__PURE__*/_createClass(function Menu(id){_classCallCheck(this,Menu);this.id=id;this.parentItem=null;// Set to an Item when this Menu is a submenu
this.groups=[];this.menuElement=null;this.shown=false;this.mouseOver=0;});/**
 * Internal data class that represents a group of Items in a Menu.
 * @private
 */var Group=/*#__PURE__*/_createClass(function Group(){_classCallCheck(this,Group);this.items=[];});/**
 * Internal data class that represents the state of a menu item.
 * @private
 */var Item=/*#__PURE__*/_createClass(function Item(id,getTitle,doAction,getEnabled,getShown){_classCallCheck(this,Item);this.id=id;this.getTitle=getTitle;this.doAction=doAction;this.getEnabled=getEnabled;this.getShown=getShown;this.itemElement=null;this.subMenu=null;this.enabled=true;});/**
 * @desc A customizable HTML context menu.
 *
 * [<img src="http://xeokit.io/img/docs/ContextMenu/ContextMenu.gif">](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]
 *
 * ## Overview
 *
 * * A pure JavaScript, lightweight context menu
 * * Dynamically configure menu items
 * * Dynamically enable or disable items
 * * Dynamically show or hide items
 * * Supports cascading sub-menus
 * * Configure custom style with CSS (see examples above)
 *
 * ## Usage
 *
 * In the example below we'll create a ````ContextMenu```` that pops up whenever we right-click on an {@link Entity} within
 * our {@link Scene}.
 *
 * First, we'll create the ````ContextMenu````, configuring it with a list of menu items.
 *
 * Each item has:
 *
 * * a ````title```` for the item,
 * * a ````doAction()```` callback to fire when the item's title is clicked,
 * * an optional ````getShown()```` callback that indicates if the item should shown in the menu or not, and
 * * an optional ````getEnabled()```` callback that indicates if the item should be shown enabled in the menu or not.
 *
 * <br>
 *
 * The ````getShown()```` and ````getEnabled()```` callbacks are invoked whenever the menu is shown.
 *
 * When an item's ````getShown()```` callback
 * returns ````true````, then the item is shown. When it returns ````false````, then the item is hidden. An item without
 * a ````getShown()```` callback is always shown.
 *
 * When an item's ````getEnabled()```` callback returns ````true````, then the item is enabled and clickable (as long as it's also shown). When it
 * returns ````false````, then the item is disabled and cannot be clicked. An item without a ````getEnabled()````
 * callback is always enabled and clickable.
 *
 * Note how the ````doAction()````,  ````getShown()```` and ````getEnabled()```` callbacks accept a ````context````
 * object. That must be set on the ````ContextMenu```` before we're able to we show it. The context object can be anything. In this example,
 * we'll use the context object to provide the callbacks with the Entity that we right-clicked.
 *
 * We'll also initially enable the ````ContextMenu````.
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_Custom)]
 *
 * ````javascript
 * const canvasContextMenu = new ContextMenu({
 *
 *    enabled: true,
 *
 *    items: [
 *       [
 *          {
 *             title: "Hide Object",
 *             getEnabled: (context) => {
 *                 return context.entity.visible; // Can't hide entity if already hidden
 *             },
 *             doAction: function (context) {
 *                 context.entity.visible = false;
 *             }
 *          }
 *       ],
 *       [
 *          {
 *             title: "Select Object",
 *             getEnabled: (context) => {
 *                 return (!context.entity.selected); // Can't select an entity that's already selected
 *             },
 *             doAction: function (context) {
 *                 context.entity.selected = true;
 *             }
 *          }
 *       ],
 *       [
 *          {
 *             title: "X-Ray Object",
 *             getEnabled: (context) => {
 *                 return (!context.entity.xrayed); // Can't X-ray an entity that's already X-rayed
 *             },
 *             doAction: (context) => {
 *                 context.entity.xrayed = true;
 *             }
 *          }
 *       ]
 *    ]
 * });
 * ````
 *
 * Next, we'll make the ````ContextMenu```` appear whenever we right-click on an Entity. Whenever we right-click
 * on the canvas, we'll attempt to pick the Entity at those mouse coordinates. If we succeed, we'll feed the
 * Entity into ````ContextMenu```` via the context object, then show the ````ContextMenu````.
 *
 * From there, each ````ContextMenu```` item's ````getEnabled()```` callback will be invoked (if provided), to determine if the item should
 * be enabled. If we click an item, its ````doAction()```` callback will be invoked with our context object.
 *
 * Remember that we must set the context on our ````ContextMenu```` before we show it, otherwise it will log an error to the console,
 * and ignore our attempt to show it.
 *
 * ````javascript*
 * viewer.scene.canvas.canvas.oncontextmenu = (e) => { // Right-clicked on the canvas
 *
 *     if (!objectContextMenu.enabled) {
 *         return;
 *     }
 *
 *     var hit = viewer.scene.pick({ // Try to pick an Entity at the coordinates
 *         canvasPos: [e.pageX, e.pageY]
 *     });
 *
 *     if (hit) { // Picked an Entity
 *
 *         objectContextMenu.context = { // Feed entity to ContextMenu
 *             entity: hit.entity
 *         };
 *
 *         objectContextMenu.show(e.pageX, e.pageY); // Show the ContextMenu
 *     }
 *
 *     e.preventDefault();
 * });
 * ````
 *
 * Note how we only show the ````ContextMenu```` if it's enabled. We can use that mechanism to switch between multiple
 * ````ContextMenu```` instances depending on what we clicked.
 *
 * ## Dynamic Item Titles
 *
 * To make an item dynamically regenerate its title text whenever we show the ````ContextMenu````, provide its title with a
 * ````getTitle()```` callback. The callback will fire each time you show ````ContextMenu````, which will dynamically
 * set the item title text.
 *
 * In the example below, we'll create a simple ````ContextMenu```` that allows us to toggle the selection of an object
 * via its first item, which changes text depending on whether we are selecting or deselecting the object.
 *
 * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_dynamicItemTitles)]
 *
 * ````javascript
 * const canvasContextMenu = new ContextMenu({
 *
 *    enabled: true,
 *
 *    items: [
 *       [
 *          {
 *              getTitle: (context) => {
 *                  return (!context.entity.selected) ? "Select" : "Undo Select";
 *              },
 *              doAction: function (context) {
 *                  context.entity.selected = !context.entity.selected;
 *              }
 *          },
 *          {
 *              title: "Clear Selection",
 *              getEnabled: function (context) {
 *                  return (context.viewer.scene.numSelectedObjects > 0);
 *              },
 *              doAction: function (context) {
 *                  context.viewer.scene.setObjectsSelected(context.viewer.scene.selectedObjectIds, false);
 *              }
 *          }
 *       ]
 *    ]
 * });
 * ````
 *
 * ## Sub-menus
 *
 * Each menu item can optionally have a sub-menu, which will appear when we hover over the item.
 *
 * In the example below, we'll create a much simpler ````ContextMenu```` that has only one item, called "Effects", which
 * will open a cascading sub-menu whenever we hover over that item.
 *
 * Note that our "Effects" item has no ````doAction```` callback, because an item with a sub-menu performs no
 * action of its own.
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_subMenus)]
 *
 * ````javascript
 * const canvasContextMenu = new ContextMenu({
 *     items: [ // Top level items
 *         [
 *             {
 *                 getTitle: (context) => {
 *                     return "Effects";
 *                 },
 *
 *                 items: [ // Sub-menu
 *                     [
 *                         {
 *                             getTitle: (context) => {
 *                                 return (!context.entity.visible) ? "Show" : "Hide";
 *                             },
 *                             doAction: function (context) {
 *                                 context.entity.visible = !context.entity.visible;
 *                             }
 *                         },
 *                         {
 *                             getTitle: (context) => {
 *                                 return (!context.entity.selected) ? "Select" : "Undo Select";
 *                             },
 *                             doAction: function (context) {
 *                                 context.entity.selected = !context.entity.selected;
 *                             }
 *                         },
 *                         {
 *                             getTitle: (context) => {
 *                                 return (!context.entity.highlighted) ? "Highlight" : "Undo Highlight";
 *                             },
 *                             doAction: function (context) {
 *                                 context.entity.highlighted = !context.entity.highlighted;
 *                             }
 *                         }
 *                     ]
 *                 ]
 *             }
 *          ]
 *      ]
 * });
 * ````
 */var ContextMenu=/*#__PURE__*/function(){/**
     * Creates a ````ContextMenu````.
     *
     * The ````ContextMenu```` will be initially hidden.
     *
     * @param {Object} [cfg] ````ContextMenu```` configuration.
     * @param {Object} [cfg.items] The context menu items. These can also be dynamically set on {@link ContextMenu#items}. See the class documentation for an example.
     * @param {Object} [cfg.context] The context, which is passed into the item callbacks. This can also be dynamically set on {@link ContextMenu#context}. This must be set before calling {@link ContextMenu#show}.
     * @param {Boolean} [cfg.enabled=true] Whether this ````ContextMenu```` is initially enabled. {@link ContextMenu#show} does nothing while this is ````false````.
     * @param {Boolean} [cfg.hideOnMouseDown=true] Whether this ````ContextMenu```` automatically hides whenever we mouse-down or tap anywhere in the page.
     * @param {Boolean} [cfg.hideOnAction=true] Whether this ````ContextMenu```` automatically hides after we select a menu item. Se false if we want the menu to remain shown and show any updates to its item titles, after we've selected an item.
     */function ContextMenu(){var _this2=this;var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,ContextMenu);this._id=idMap.addItem();this._context=null;this._enabled=false;// True when the ContextMenu is enabled
this._itemsCfg=[];// Items as given as configs
this._rootMenu=null;// The root Menu in the tree
this._menuList=[];// List of Menus
this._menuMap={};// Menus mapped to their IDs
this._itemList=[];// List of Items
this._itemMap={};// Items mapped to their IDs
this._shown=false;// True when the ContextMenu is visible
this._nextId=0;/**
         * Subscriptions to events fired at this ContextMenu.
         * @private
         */this._eventSubs={};if(cfg.hideOnMouseDown!==false){document.addEventListener("mousedown",function(event){if(!event.target.classList.contains("xeokit-context-menu-item")){_this2.hide();}});document.addEventListener("touchstart",this._canvasTouchStartHandler=function(event){if(!event.target.classList.contains("xeokit-context-menu-item")){_this2.hide();}});}if(cfg.items){this.items=cfg.items;}this._hideOnAction=cfg.hideOnAction!==false;this.context=cfg.context;this.enabled=cfg.enabled!==false;this.hide();}/**
     Subscribes to an event fired at this ````ContextMenu````.

     @param {String} event The event
     @param {Function} callback Callback fired on the event
     */_createClass(ContextMenu,[{key:"on",value:function on(event,callback){var subs=this._eventSubs[event];if(!subs){subs=[];this._eventSubs[event]=subs;}subs.push(callback);}/**
     Fires an event at this ````ContextMenu````.

     @param {String} event The event type name
     @param {Object} value The event parameters
     */},{key:"fire",value:function fire(event,value){var subs=this._eventSubs[event];if(subs){for(var _i2=0,len=subs.length;_i2<len;_i2++){subs[_i2](value);}}}/**
     * Sets the ````ContextMenu```` items.
     *
     * These can be updated dynamically at any time.
     *
     * See class documentation for an example.
     *
     * @type {Object[]}
     */},{key:"items",get:/**
     * Gets the ````ContextMenu```` items.
     *
     * @type {Object[]}
     */function get(){return this._itemsCfg;}/**
     * Sets whether this ````ContextMenu```` is enabled.
     *
     * Hides the menu when disabling.
     *
     * @type {Boolean}
     */,set:function set(itemsCfg){this._clear();this._itemsCfg=itemsCfg||[];this._parseItems(itemsCfg);this._createUI();}},{key:"enabled",get:/**
     * Gets whether this ````ContextMenu```` is enabled.
     *
     * {@link ContextMenu#show} does nothing while this is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._enabled;}/**
     * Sets the ````ContextMenu```` context.
     *
     * The context can be any object that you need to be provides to the callbacks configured on {@link ContextMenu#items}.
     *
     * This must be set before calling {@link ContextMenu#show}.
     *
     * @type {Object}
     */,set:function set(enabled){enabled=!!enabled;if(enabled===this._enabled){return;}this._enabled=enabled;if(!this._enabled){this.hide();}}},{key:"context",get:/**
     * Gets the ````ContextMenu```` context.
     *
     * @type {Object}
     */function get(){return this._context;}/**
     * Shows this ````ContextMenu```` at the given page coordinates.
     *
     * Does nothing when {@link ContextMenu#enabled} is ````false````.
     *
     * Logs error to console and does nothing if {@link ContextMenu#context} has not been set.
     *
     * Fires a "shown" event when shown.
     *
     * @param {Number} pageX Page X-coordinate.
     * @param {Number} pageY Page Y-coordinate.
     */,set:function set(context){this._context=context;}},{key:"show",value:function show(pageX,pageY){if(!this._context){console.error("ContextMenu cannot be shown without a context - set context first");return;}if(!this._enabled){return;}if(this._shown){return;}this._hideAllMenus();this._updateItemsTitles();this._updateItemsEnabledStatus();this._showMenu(this._rootMenu.id,pageX,pageY);this._shown=true;this.fire("shown",{});}/**
     * Gets whether this ````ContextMenu```` is currently shown or not.
     *
     * @returns {Boolean} Whether this ````ContextMenu```` is shown.
     */},{key:"shown",get:function get(){return this._shown;}/**
     * Hides this ````ContextMenu````.
     *
     * Fires a "hidden" event when hidden.
     */},{key:"hide",value:function hide(){if(!this._enabled){return;}if(!this._shown){return;}this._hideAllMenus();this._shown=false;this.fire("hidden",{});}/**
     * Destroys this ````ContextMenu````.
     */},{key:"destroy",value:function destroy(){this._context=null;this._clear();if(this._id!==null){idMap.removeItem(this._id);this._id=null;}}},{key:"_clear",value:function _clear(){// Destroys DOM elements, clears menu data
for(var _i3=0,len=this._menuList.length;_i3<len;_i3++){var menu=this._menuList[_i3];var menuElement=menu.menuElement;menuElement.parentElement.removeChild(menuElement);}this._itemsCfg=[];this._rootMenu=null;this._menuList=[];this._menuMap={};this._itemList=[];this._itemMap={};}},{key:"_parseItems",value:function _parseItems(itemsCfg){var _this3=this;// Parses "items" config into menu data
var visitItems=function visitItems(itemsCfg){var menuId=_this3._getNextId();var menu=new Menu(menuId);for(var _i4=0,len=itemsCfg.length;_i4<len;_i4++){var itemsGroupCfg=itemsCfg[_i4];var group=new Group();menu.groups.push(group);var _loop=function _loop(j,lenj){var itemCfg=itemsGroupCfg[j];var subItemsCfg=itemCfg.items;var hasSubItems=subItemsCfg&&subItemsCfg.length>0;var itemId=_this3._getNextId();var getTitle=itemCfg.getTitle||function(){return itemCfg.title||"";};var doAction=itemCfg.doAction||itemCfg.callback||function(){};var getEnabled=itemCfg.getEnabled||function(){return true;};var getShown=itemCfg.getShown||function(){return true;};var item=new Item(itemId,getTitle,doAction,getEnabled,getShown);item.parentMenu=menu;group.items.push(item);if(hasSubItems){var subMenu=visitItems(subItemsCfg);item.subMenu=subMenu;subMenu.parentItem=item;}_this3._itemList.push(item);_this3._itemMap[item.id]=item;};for(var j=0,lenj=itemsGroupCfg.length;j<lenj;j++){_loop(j,lenj);}}_this3._menuList.push(menu);_this3._menuMap[menu.id]=menu;return menu;};this._rootMenu=visitItems(itemsCfg);}},{key:"_getNextId",value:function _getNextId(){// Returns a unique ID
return"ContextMenu_"+this._id+"_"+this._nextId++;// Start ID with alpha chars to make a valid DOM element selector
}},{key:"_createUI",value:function _createUI(){var _this4=this;// Builds DOM elements for the entire menu tree
var visitMenu=function visitMenu(menu){_this4._createMenuUI(menu);var groups=menu.groups;for(var _i5=0,len=groups.length;_i5<len;_i5++){var group=groups[_i5];var groupItems=group.items;for(var j=0,lenj=groupItems.length;j<lenj;j++){var item=groupItems[j];var subMenu=item.subMenu;if(subMenu){visitMenu(subMenu);}}}};visitMenu(this._rootMenu);}},{key:"_createMenuUI",value:function _createMenuUI(menu){var _this5=this;// Builds DOM elements for a menu
var groups=menu.groups;var html=[];html.push('<div class="xeokit-context-menu '+menu.id+'" style="z-index:300000; position: absolute;">');html.push('<ul>');if(groups){for(var _i6=0,len=groups.length;_i6<len;_i6++){var group=groups[_i6];var groupIdx=_i6;var groupLen=len;var groupItems=group.items;if(groupItems){for(var j=0,lenj=groupItems.length;j<lenj;j++){var item=groupItems[j];var itemSubMenu=item.subMenu;var actionTitle=item.title||"";if(itemSubMenu){html.push('<li id="'+item.id+'" class="xeokit-context-menu-item" style="'+(groupIdx===groupLen-1||j<lenj-1?'border-bottom: 0':'border-bottom: 1px solid black')+'">'+actionTitle+' [MORE]'+'</li>');}else{html.push('<li id="'+item.id+'" class="xeokit-context-menu-item" style="'+(groupIdx===groupLen-1||j<lenj-1?'border-bottom: 0':'border-bottom: 1px solid black')+'">'+actionTitle+'</li>');}}}}}html.push('</ul>');html.push('</div>');var htmlString=html.join("");document.body.insertAdjacentHTML('beforeend',htmlString);var menuElement=document.querySelector("."+menu.id);menu.menuElement=menuElement;menuElement.style["border-radius"]=4+"px";menuElement.style.display='none';menuElement.style["z-index"]=300000;menuElement.style.background="white";menuElement.style.border="1px solid black";menuElement.style["box-shadow"]="0 4px 5px 0 gray";menuElement.oncontextmenu=function(e){e.preventDefault();};// Bind event handlers
var self=this;var lastSubMenu=null;if(groups){for(var _i7=0,_len2=groups.length;_i7<_len2;_i7++){var _group=groups[_i7];var _groupItems=_group.items;if(_groupItems){var _loop2=function _loop2(_j2,_lenj){var item=_groupItems[_j2];var itemSubMenu=item.subMenu;item.itemElement=document.getElementById(item.id);if(!item.itemElement){console.error("ContextMenu item element not found: "+item.id);return"continue";}item.itemElement.addEventListener("mouseenter",function(event){event.preventDefault();var subMenu=item.subMenu;if(!subMenu){if(lastSubMenu){self._hideMenu(lastSubMenu.id);lastSubMenu=null;}return;}if(lastSubMenu&&lastSubMenu.id!==subMenu.id){self._hideMenu(lastSubMenu.id);lastSubMenu=null;}if(item.enabled===false){return;}var itemElement=item.itemElement;var subMenuElement=subMenu.menuElement;var itemRect=itemElement.getBoundingClientRect();subMenuElement.getBoundingClientRect();var subMenuWidth=200;// TODO
var showOnLeft=itemRect.right+subMenuWidth>window.innerWidth;if(showOnLeft){self._showMenu(subMenu.id,itemRect.left-subMenuWidth,itemRect.top-1);}else{self._showMenu(subMenu.id,itemRect.right-5,itemRect.top-1);}lastSubMenu=subMenu;});if(!itemSubMenu){// Item without sub-menu
// clicking item fires the item's action callback
item.itemElement.addEventListener("click",function(event){event.preventDefault();if(!self._context){return;}if(item.enabled===false){return;}if(item.doAction){item.doAction(self._context);}if(_this5._hideOnAction){self.hide();}else{self._updateItemsTitles();self._updateItemsEnabledStatus();}});item.itemElement.addEventListener("mouseenter",function(event){event.preventDefault();if(item.enabled===false){return;}if(item.doHover){item.doHover(self._context);}});}};for(var _j2=0,_lenj=_groupItems.length;_j2<_lenj;_j2++){var _ret=_loop2(_j2,_lenj);if(_ret==="continue")continue;}}}}}},{key:"_updateItemsTitles",value:function _updateItemsTitles(){// Dynamically updates the title of each Item to the result of Item#getTitle()
if(!this._context){return;}for(var _i8=0,len=this._itemList.length;_i8<len;_i8++){var item=this._itemList[_i8];var itemElement=item.itemElement;if(!itemElement){continue;}var getShown=item.getShown;if(!getShown||!getShown(this._context)){continue;}var title=item.getTitle(this._context);if(item.subMenu){itemElement.innerText=title;}else{itemElement.innerText=title;}}}},{key:"_updateItemsEnabledStatus",value:function _updateItemsEnabledStatus(){// Enables or disables each Item, depending on the result of Item#getEnabled()
if(!this._context){return;}for(var _i9=0,len=this._itemList.length;_i9<len;_i9++){var item=this._itemList[_i9];var itemElement=item.itemElement;if(!itemElement){continue;}var getEnabled=item.getEnabled;if(!getEnabled){continue;}var getShown=item.getShown;if(!getShown){continue;}var shown=getShown(this._context);item.shown=shown;if(!shown){itemElement.style.visibility="hidden";itemElement.style.height="0";itemElement.style.padding="0";continue;}else{itemElement.style.visibility="visible";itemElement.style.height="auto";itemElement.style.padding=null;}var enabled=getEnabled(this._context);item.enabled=enabled;if(!enabled){itemElement.classList.add("disabled");}else{itemElement.classList.remove("disabled");}}}},{key:"_showMenu",value:function _showMenu(menuId,pageX,pageY){// Shows the given menu, at the specified page coordinates
var menu=this._menuMap[menuId];if(!menu){console.error("Menu not found: "+menuId);return;}if(menu.shown){return;}var menuElement=menu.menuElement;if(menuElement){this._showMenuElement(menuElement,pageX,pageY);menu.shown=true;}}},{key:"_hideMenu",value:function _hideMenu(menuId){// Hides the given menu
var menu=this._menuMap[menuId];if(!menu){console.error("Menu not found: "+menuId);return;}if(!menu.shown){return;}var menuElement=menu.menuElement;if(menuElement){this._hideMenuElement(menuElement);menu.shown=false;}}},{key:"_hideAllMenus",value:function _hideAllMenus(){for(var _i10=0,len=this._menuList.length;_i10<len;_i10++){var menu=this._menuList[_i10];this._hideMenu(menu.id);}}},{key:"_showMenuElement",value:function _showMenuElement(menuElement,pageX,pageY){// Shows the given menu element, at the specified page coordinates
menuElement.style.display='block';var menuHeight=menuElement.offsetHeight;var menuWidth=menuElement.offsetWidth;if(pageY+menuHeight>window.innerHeight){pageY=window.innerHeight-menuHeight;}if(pageX+menuWidth>window.innerWidth){pageX=window.innerWidth-menuWidth;}menuElement.style.left=pageX+'px';menuElement.style.top=pageY+'px';}},{key:"_hideMenuElement",value:function _hideMenuElement(menuElement){menuElement.style.display='none';}}]);return ContextMenu;}();/**
 * A PointerLens shows a magnified view of a {@link Viewer}'s canvas, centered at the position of the
 * mouse or touch pointer.
 *
 * This component is used by {@link DistanceMeasurementsControl} and {@link AngleMeasurementsControl}
 * to help position the pointer when snap-to-vertex or snap-toedge is enabled.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/measurements/#distance_modelWithMeasurements)]
 *
 * ````JavaScript
 *
 *  import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin, AngleMeasurementsMouseControl, PointerLens} from "../../dist/xeokit-sdk.es.js";
 *
 *  const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      dtxEnabled: true
 *  });
 *
 *  viewer.camera.eye = [-3.93, 2.85, 27.01];
 *  viewer.camera.look = [4.40, 3.72, 8.89];
 *  viewer.camera.up = [-0.01, 0.99, 0.039];
 *
 *  const xktLoader = new XKTLoaderPlugin(viewer);
 *
 *  const sceneModel = xktLoader.load({
 *      id: "myModel",
 *      src: "../../assets/models/xkt/v10/glTF-Embedded/Duplex_A_20110505.glTFEmbedded.xkt",
 *      edges: true
 *  });
 *
 *  const angleMeasurements = new AngleMeasurementsPlugin(viewer);
 *
 *  const angleMeasurementsMouseControl  = new AngleMeasurementsMouseControl(angleMeasurements, {
 *      pointerLens : new PointerLens(viewer, {
 *          zoomFactor: 2
 *      })
 *  })
 *
 *  angleMeasurementsMouseControl.activate();
 * ````
 */var PointerLens=/*#__PURE__*/function(){/**
     * Constructs a new PointerLens.
     * @param viewer The Viewer
     * @param [cfg] PointerLens configuration.
     * @param [cfg.active=true] Whether PointerLens is active. The PointerLens can only be shown when this is `true` (default).
     */function PointerLens(viewer){var _this6=this;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PointerLens);this.viewer=viewer;this.scene=this.viewer.scene;this._lensCursorDiv=document.createElement('div');this.viewer.scene.canvas.canvas.parentNode.insertBefore(this._lensCursorDiv,this.viewer.scene.canvas.canvas);this._lensCursorDiv.style.background="pink";this._lensCursorDiv.style.border="2px solid red";this._lensCursorDiv.style.borderRadius="20px";this._lensCursorDiv.style.width="10px";this._lensCursorDiv.style.height="10px";this._lensCursorDiv.style.margin="-200px -200px";this._lensCursorDiv.style.zIndex="100000";this._lensCursorDiv.style.position="absolute";this._lensCursorDiv.style.pointerEvents="none";this._lensContainer=document.createElement('div');this._lensContainer.style.border="1px solid black";this._lensContainer.style.background="white";//    this._lensContainer.style.opacity = "0";
this._lensContainer.style.borderRadius="50%";this._lensContainer.style.width="300px";this._lensContainer.style.height="300px";this._lensContainer.style.marginTop="85px";this._lensContainer.style.marginLeft="25px";this._lensContainer.style.zIndex="15000";this._lensContainer.style.position="absolute";this._lensContainer.style.pointerEvents="none";this._lensContainer.style.visibility="hidden";this._lensCanvas=document.createElement('canvas');// this._lensCanvas.style.background = "darkblue";
this._lensCanvas.style.borderRadius="50%";this._lensCanvas.style.width="300px";this._lensCanvas.style.height="300px";this._lensCanvas.style.zIndex="15000";this._lensCanvas.style.pointerEvents="none";document.body.appendChild(this._lensContainer);this._lensContainer.appendChild(this._lensCanvas);this._lensCanvasContext=this._lensCanvas.getContext('2d');this._canvasElement=this.viewer.scene.canvas.canvas;this._canvasPos=null;this._snappedCanvasPos=null;this._lensPosToggle=true;this._zoomLevel=cfg.zoomLevel||2;this._active=cfg.active!==false;this._visible=false;this._snapped=false;this._onViewerRendering=this.viewer.scene.on("rendering",function(){if(_this6._active&&_this6._visible){_this6.update();}});}/**
     * Updates this PointerLens.
     */_createClass(PointerLens,[{key:"update",value:function update(){if(!this._active||!this._visible){return;}if(!this._canvasPos){return;}var lensRect=this._lensContainer.getBoundingClientRect();var canvasRect=this._canvasElement.getBoundingClientRect();var pointerOnLens=this._canvasPos[0]<lensRect.right&&this._canvasPos[0]>lensRect.left&&this._canvasPos[1]<lensRect.bottom&&this._canvasPos[1]>lensRect.top;this._lensContainer.style.marginLeft="25px";if(pointerOnLens){if(this._lensPosToggle){this._lensContainer.style.marginTop="".concat(canvasRect.bottom-canvasRect.top-this._lensCanvas.height-85,"px");}else{this._lensContainer.style.marginTop="85px";}this._lensPosToggle=!this._lensPosToggle;}this._lensCanvasContext.clearRect(0,0,this._lensCanvas.width,this._lensCanvas.height);var size=Math.max(this._lensCanvas.width,this._lensCanvas.height)/this._zoomLevel;this._lensCanvasContext.drawImage(this._canvasElement,// source canvas
this._canvasPos[0]-size/2,// source x (zoom center)
this._canvasPos[1]-size/2,// source y (zoom center)
size,// source width
size,// source height
0,// destination x
0,// destination y
this._lensCanvas.width,// destination width
this._lensCanvas.height// destination height
);var centerLensCanvas=[(lensRect.left+lensRect.right)/2,(lensRect.top+lensRect.bottom)/2];if(this._snappedCanvasPos){var deltaX=this._snappedCanvasPos[0]-this._canvasPos[0];var deltaY=this._snappedCanvasPos[1]-this._canvasPos[1];this._lensCursorDiv.style.marginLeft="".concat(centerLensCanvas[0]+deltaX*this._zoomLevel-10,"px");this._lensCursorDiv.style.marginTop="".concat(centerLensCanvas[1]+deltaY*this._zoomLevel-10,"px");}else{this._lensCursorDiv.style.marginLeft="".concat(centerLensCanvas[0]-10,"px");this._lensCursorDiv.style.marginTop="".concat(centerLensCanvas[1]-10,"px");}}/**
     * Sets the zoom factor for the lens.
     *
     * This is `2` by default.
     *
     * @param zoomFactor
     */},{key:"zoomFactor",get:/**
     * Gets the zoom factor for the lens.
     *
     * This is `2` by default.
     *
     * @returns Number
     */function get(){return this._zoomFactor;}/**
     * Sets the canvas central position of the lens.
     * @param canvasPos
     */,set:function set(zoomFactor){this._zoomFactor=zoomFactor;this.update();}},{key:"canvasPos",get:/**
     * Gets the canvas central position of the lens.
     * @returns {Number[]}
     */function get(){return this._canvasPos;}/**
     * Sets the canvas coordinates of the pointer.
     * @param snappedCanvasPos
     */,set:function set(canvasPos){this._canvasPos=canvasPos;this.update();}},{key:"snappedCanvasPos",get:/**
     * Gets the canvas coordinates of the snapped pointer.
     * @returns {Number[]}
     */function get(){return this._snappedCanvasPos;}/**
     * Sets if the cursor has snapped to anything.
     * This is set by plugins.
     * @param snapped
     * @private
     */,set:function set(snappedCanvasPos){this._snappedCanvasPos=snappedCanvasPos;this.update();}},{key:"snapped",get:/**
     * Gets  if the cursor has snapped to anything.
     * This is called by plugins.
     * @returns {Boolean}
     * @private
     */function get(){return this._snapped;}/**
     * Sets if this PointerLens is active.
     * @param active
     */,set:function set(snapped){this._snapped=snapped;if(snapped){this._lensCursorDiv.style.background="greenyellow";this._lensCursorDiv.style.border="2px solid green";}else{this._lensCursorDiv.style.background="pink";this._lensCursorDiv.style.border="2px solid red";}}},{key:"active",get:/**
     * Gets if this PointerLens is active.
     * @returns {Boolean}
     */function get(){return this._active;}/**
     * Sets if this PointerLens is visible.
     * This is set by plugins.
     * @param visible
     * @private
     */,set:function set(active){this._active=active;this._lensContainer.style.visibility=active&&this._visible?"visible":"hidden";if(!active||!this._visible){this._lensCursorDiv.style.marginLeft="-100px";this._lensCursorDiv.style.marginTop="-100px";}this.update();}},{key:"visible",get:/**
     * Gets if this PointerLens is visible.
     * This is called by plugins.
     * @returns {Boolean}
     * @private
     */function get(){return this._visible;}/**
     * Destroys this PointerLens.
     */,set:function set(visible){this._visible=visible;this._lensContainer.style.visibility=visible&&this._active?"visible":"hidden";if(!visible||!this._active){this._lensCursorDiv.style.marginLeft="-100px";this._lensCursorDiv.style.marginTop="-100px";}this.update();}},{key:"destroy",value:function destroy(){if(!this._destroyed){this.viewer.scene.off(this._onViewerRendering);this._lensContainer.removeChild(this._lensCanvas);document.body.removeChild(this._lensContainer);this._destroyed=true;}}}]);return PointerLens;}();// Some temporary vars to help avoid garbage collection
var doublePrecision=true;var FloatArrayType=doublePrecision?Float64Array:Float32Array;var tempVec3a$N=new FloatArrayType(3);var tempMat1=new FloatArrayType(16);var tempMat2=new FloatArrayType(16);var tempVec4$1=new FloatArrayType(4);/**
 * @private
 */var math={setDoublePrecisionEnabled:function setDoublePrecisionEnabled(enable){doublePrecision=enable;FloatArrayType=doublePrecision?Float64Array:Float32Array;},getDoublePrecisionEnabled:function getDoublePrecisionEnabled(){return doublePrecision;},MIN_DOUBLE:-Number.MAX_SAFE_INTEGER,MAX_DOUBLE:Number.MAX_SAFE_INTEGER,MAX_INT:10000000,/**
     * The number of radiians in a degree (0.0174532925).
     * @property DEGTORAD
     * @type {Number}
     */DEGTORAD:0.0174532925,/**
     * The number of degrees in a radian.
     * @property RADTODEG
     * @type {Number}
     */RADTODEG:57.295779513,unglobalizeObjectId:function unglobalizeObjectId(modelId,globalId){var idx=globalId.indexOf("#");return idx===modelId.length&&globalId.startsWith(modelId)?globalId.substring(idx+1):globalId;},globalizeObjectId:function globalizeObjectId(modelId,objectId){return modelId+"#"+objectId;},/**
     * Returns:
     * - x != 0 => 1/x,
     * - x == 1 => 1
     *
     * @param {number} x
     */safeInv:function safeInv(x){var retVal=1/x;if(isNaN(retVal)||!isFinite(retVal)){return 1;}return retVal;},/**
     * Returns a new, uninitialized two-element vector.
     * @method vec2
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */vec2:function vec2(values){return new FloatArrayType(values||2);},/**
     * Returns a new, uninitialized three-element vector.
     * @method vec3
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */vec3:function vec3(values){return new FloatArrayType(values||3);},/**
     * Returns a new, uninitialized four-element vector.
     * @method vec4
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */vec4:function vec4(values){return new FloatArrayType(values||4);},/**
     * Returns a new, uninitialized 3x3 matrix.
     * @method mat3
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */mat3:function mat3(values){return new FloatArrayType(values||9);},/**
     * Converts a 3x3 matrix to 4x4
     * @method mat3ToMat4
     * @param mat3 3x3 matrix.
     * @param mat4 4x4 matrix
     * @static
     * @returns {Number[]}
     */mat3ToMat4:function mat3ToMat4(mat3){var mat4=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new FloatArrayType(16);mat4[0]=mat3[0];mat4[1]=mat3[1];mat4[2]=mat3[2];mat4[3]=0;mat4[4]=mat3[3];mat4[5]=mat3[4];mat4[6]=mat3[5];mat4[7]=0;mat4[8]=mat3[6];mat4[9]=mat3[7];mat4[10]=mat3[8];mat4[11]=0;mat4[12]=0;mat4[13]=0;mat4[14]=0;mat4[15]=1;return mat4;},/**
     * Returns a new, uninitialized 4x4 matrix.
     * @method mat4
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */mat4:function mat4(values){return new FloatArrayType(values||16);},/**
     * Converts a 4x4 matrix to 3x3
     * @method mat4ToMat3
     * @param mat4 4x4 matrix.
     * @param mat3 3x3 matrix
     * @static
     * @returns {Number[]}
     */mat4ToMat3:function mat4ToMat3(mat4,mat3){// TODO
//return new FloatArrayType(values || 9);
},/**
     * Converts a list of double-precision values to a list of high-part floats and a list of low-part floats.
     * @param doubleVals
     * @param floatValsHigh
     * @param floatValsLow
     */doublesToFloats:function doublesToFloats(doubleVals,floatValsHigh,floatValsLow){var floatPair=new FloatArrayType(2);for(var _i11=0,len=doubleVals.length;_i11<len;_i11++){math.splitDouble(doubleVals[_i11],floatPair);floatValsHigh[_i11]=floatPair[0];floatValsLow[_i11]=floatPair[1];}},/**
     * Splits a double value into two floats.
     * @param value
     * @param floatPair
     */splitDouble:function splitDouble(value,floatPair){var hi=FloatArrayType.from([value])[0];var low=value-hi;floatPair[0]=hi;floatPair[1]=low;},/**
     * Returns a new UUID.
     * @method createUUID
     * @static
     * @return string The new UUID
     */createUUID:function(){var lut=[];for(var _i12=0;_i12<256;_i12++){lut[_i12]=(_i12<16?'0':'')+_i12.toString(16);}return function(){var d0=Math.random()*0xffffffff|0;var d1=Math.random()*0xffffffff|0;var d2=Math.random()*0xffffffff|0;var d3=Math.random()*0xffffffff|0;return"".concat(lut[d0&0xff]+lut[d0>>8&0xff]+lut[d0>>16&0xff]+lut[d0>>24&0xff],"-").concat(lut[d1&0xff]).concat(lut[d1>>8&0xff],"-").concat(lut[d1>>16&0x0f|0x40]).concat(lut[d1>>24&0xff],"-").concat(lut[d2&0x3f|0x80]).concat(lut[d2>>8&0xff],"-").concat(lut[d2>>16&0xff]).concat(lut[d2>>24&0xff]).concat(lut[d3&0xff]).concat(lut[d3>>8&0xff]).concat(lut[d3>>16&0xff]).concat(lut[d3>>24&0xff]);};}(),/**
     * Clamps a value to the given range.
     * @param {Number} value Value to clamp.
     * @param {Number} min Lower bound.
     * @param {Number} max Upper bound.
     * @returns {Number} Clamped result.
     */clamp:function clamp(value,min,max){return Math.max(min,Math.min(max,value));},/**
     * Floating-point modulus
     * @method fmod
     * @static
     * @param {Number} a
     * @param {Number} b
     * @returns {*}
     */fmod:function fmod(a,b){if(a<b){console.error("math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring");return a;}while(b<=a){a-=b;}return a;},/**
     * Returns true if the two 3-element vectors are the same.
     * @param v1
     * @param v2
     * @returns {Boolean}
     */compareVec3:function compareVec3(v1,v2){return v1[0]===v2[0]&&v1[1]===v2[1]&&v1[2]===v2[2];},/**
     * Negates a three-element vector.
     * @method negateVec3
     * @static
     * @param {Array(Number)} v Vector to negate
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */negateVec3:function negateVec3(v,dest){if(!dest){dest=v;}dest[0]=-v[0];dest[1]=-v[1];dest[2]=-v[2];return dest;},/**
     * Negates a four-element vector.
     * @method negateVec4
     * @static
     * @param {Array(Number)} v Vector to negate
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */negateVec4:function negateVec4(v,dest){if(!dest){dest=v;}dest[0]=-v[0];dest[1]=-v[1];dest[2]=-v[2];dest[3]=-v[3];return dest;},/**
     * Adds one four-element vector to another.
     * @method addVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */addVec4:function addVec4(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]+v[0];dest[1]=u[1]+v[1];dest[2]=u[2]+v[2];dest[3]=u[3]+v[3];return dest;},/**
     * Adds a scalar value to each element of a four-element vector.
     * @method addVec4Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */addVec4Scalar:function addVec4Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]+s;dest[1]=v[1]+s;dest[2]=v[2]+s;dest[3]=v[3]+s;return dest;},/**
     * Adds one three-element vector to another.
     * @method addVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */addVec3:function addVec3(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]+v[0];dest[1]=u[1]+v[1];dest[2]=u[2]+v[2];return dest;},/**
     * Adds a scalar value to each element of a three-element vector.
     * @method addVec4Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */addVec3Scalar:function addVec3Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]+s;dest[1]=v[1]+s;dest[2]=v[2]+s;return dest;},/**
     * Subtracts one four-element vector from another.
     * @method subVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Vector to subtract
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */subVec4:function subVec4(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]-v[0];dest[1]=u[1]-v[1];dest[2]=u[2]-v[2];dest[3]=u[3]-v[3];return dest;},/**
     * Subtracts one three-element vector from another.
     * @method subVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Vector to subtract
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */subVec3:function subVec3(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]-v[0];dest[1]=u[1]-v[1];dest[2]=u[2]-v[2];return dest;},/**
     * Subtracts one two-element vector from another.
     * @method subVec2
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Vector to subtract
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */subVec2:function subVec2(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]-v[0];dest[1]=u[1]-v[1];return dest;},/**
     * Get the geometric mean of the vectors.
     * @method geometricMeanVec2
     * @static
     * @param {...Array(Number)} vectors Vec2 to mean
     * @return {Array(Number)} The geometric mean vec2
     */geometricMeanVec2:function geometricMeanVec2(){for(var _len3=arguments.length,vectors=new Array(_len3),_key2=0;_key2<_len3;_key2++){vectors[_key2]=arguments[_key2];}var geometricMean=new FloatArrayType(vectors[0]);for(var _i13=1;_i13<vectors.length;_i13++){geometricMean[0]+=vectors[_i13][0];geometricMean[1]+=vectors[_i13][1];}geometricMean[0]/=vectors.length;geometricMean[1]/=vectors.length;return geometricMean;},/**
     * Subtracts a scalar value from each element of a four-element vector.
     * @method subVec4Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */subVec4Scalar:function subVec4Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]-s;dest[1]=v[1]-s;dest[2]=v[2]-s;dest[3]=v[3]-s;return dest;},/**
     * Sets each element of a 4-element vector to a scalar value minus the value of that element.
     * @method subScalarVec4
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */subScalarVec4:function subScalarVec4(v,s,dest){if(!dest){dest=v;}dest[0]=s-v[0];dest[1]=s-v[1];dest[2]=s-v[2];dest[3]=s-v[3];return dest;},/**
     * Multiplies one three-element vector by another.
     * @method mulVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */mulVec4:function mulVec4(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]*v[0];dest[1]=u[1]*v[1];dest[2]=u[2]*v[2];dest[3]=u[3]*v[3];return dest;},/**
     * Multiplies each element of a four-element vector by a scalar.
     * @method mulVec34calar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */mulVec4Scalar:function mulVec4Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]*s;dest[1]=v[1]*s;dest[2]=v[2]*s;dest[3]=v[3]*s;return dest;},/**
     * Multiplies each element of a three-element vector by a scalar.
     * @method mulVec3Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */mulVec3Scalar:function mulVec3Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]*s;dest[1]=v[1]*s;dest[2]=v[2]*s;return dest;},/**
     * Multiplies each element of a two-element vector by a scalar.
     * @method mulVec2Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */mulVec2Scalar:function mulVec2Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]*s;dest[1]=v[1]*s;return dest;},/**
     * Divides one three-element vector by another.
     * @method divVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */divVec3:function divVec3(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]/v[0];dest[1]=u[1]/v[1];dest[2]=u[2]/v[2];return dest;},/**
     * Divides one four-element vector by another.
     * @method divVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */divVec4:function divVec4(u,v,dest){if(!dest){dest=u;}dest[0]=u[0]/v[0];dest[1]=u[1]/v[1];dest[2]=u[2]/v[2];dest[3]=u[3]/v[3];return dest;},/**
     * Divides a scalar by a three-element vector, returning a new vector.
     * @method divScalarVec3
     * @static
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return [] dest if specified, v otherwise
     */divScalarVec3:function divScalarVec3(s,v,dest){if(!dest){dest=v;}dest[0]=s/v[0];dest[1]=s/v[1];dest[2]=s/v[2];return dest;},/**
     * Divides a three-element vector by a scalar.
     * @method divVec3Scalar
     * @static
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return [] dest if specified, v otherwise
     */divVec3Scalar:function divVec3Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]/s;dest[1]=v[1]/s;dest[2]=v[2]/s;return dest;},/**
     * Divides a four-element vector by a scalar.
     * @method divVec4Scalar
     * @static
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return [] dest if specified, v otherwise
     */divVec4Scalar:function divVec4Scalar(v,s,dest){if(!dest){dest=v;}dest[0]=v[0]/s;dest[1]=v[1]/s;dest[2]=v[2]/s;dest[3]=v[3]/s;return dest;},/**
     * Divides a scalar by a four-element vector, returning a new vector.
     * @method divScalarVec4
     * @static
     * @param s scalar
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return [] dest if specified, v otherwise
     */divScalarVec4:function divScalarVec4(s,v,dest){if(!dest){dest=v;}dest[0]=s/v[0];dest[1]=s/v[1];dest[2]=s/v[2];dest[3]=s/v[3];return dest;},/**
     * Returns the dot product of two four-element vectors.
     * @method dotVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */dotVec4:function dotVec4(u,v){return u[0]*v[0]+u[1]*v[1]+u[2]*v[2]+u[3]*v[3];},/**
     * Returns the cross product of two four-element vectors.
     * @method cross3Vec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The cross product
     */cross3Vec4:function cross3Vec4(u,v){var u0=u[0];var u1=u[1];var u2=u[2];var v0=v[0];var v1=v[1];var v2=v[2];return[u1*v2-u2*v1,u2*v0-u0*v2,u0*v1-u1*v0,0.0];},/**
     * Returns the cross product of two three-element vectors.
     * @method cross3Vec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The cross product
     */cross3Vec3:function cross3Vec3(u,v,dest){if(!dest){dest=u;}var x=u[0];var y=u[1];var z=u[2];var x2=v[0];var y2=v[1];var z2=v[2];dest[0]=y*z2-z*y2;dest[1]=z*x2-x*z2;dest[2]=x*y2-y*x2;return dest;},sqLenVec4:function sqLenVec4(v){// TODO
return math.dotVec4(v,v);},/**
     * Returns the length of a four-element vector.
     * @method lenVec4
     * @static
     * @param {Array(Number)} v The vector
     * @return The length
     */lenVec4:function lenVec4(v){return Math.sqrt(math.sqLenVec4(v));},/**
     * Returns the dot product of two three-element vectors.
     * @method dotVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */dotVec3:function dotVec3(u,v){return u[0]*v[0]+u[1]*v[1]+u[2]*v[2];},/**
     * Returns the dot product of two two-element vectors.
     * @method dotVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */dotVec2:function dotVec2(u,v){return u[0]*v[0]+u[1]*v[1];},sqLenVec3:function sqLenVec3(v){return math.dotVec3(v,v);},sqLenVec2:function sqLenVec2(v){return math.dotVec2(v,v);},/**
     * Returns the length of a three-element vector.
     * @method lenVec3
     * @static
     * @param {Array(Number)} v The vector
     * @return The length
     */lenVec3:function lenVec3(v){return Math.sqrt(math.sqLenVec3(v));},distVec3:function(){var vec=new FloatArrayType(3);return function(v,w){return math.lenVec3(math.subVec3(v,w,vec));};}(),/**
     * Returns the length of a two-element vector.
     * @method lenVec2
     * @static
     * @param {Array(Number)} v The vector
     * @return The length
     */lenVec2:function lenVec2(v){return Math.sqrt(math.sqLenVec2(v));},distVec2:function(){var vec=new FloatArrayType(2);return function(v,w){return math.lenVec2(math.subVec2(v,w,vec));};}(),/**
     * @method rcpVec3
     * @static
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return [] dest if specified, v otherwise
     *
     */rcpVec3:function rcpVec3(v,dest){return math.divScalarVec3(1.0,v,dest);},/**
     * Normalizes a four-element vector
     * @method normalizeVec4
     * @static
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return [] dest if specified, v otherwise
     *
     */normalizeVec4:function normalizeVec4(v,dest){var f=1.0/math.lenVec4(v);return math.mulVec4Scalar(v,f,dest);},/**
     * Normalizes a three-element vector
     * @method normalizeVec4
     * @static
     */normalizeVec3:function normalizeVec3(v,dest){var f=1.0/math.lenVec3(v);return math.mulVec3Scalar(v,f,dest);},/**
     * Normalizes a two-element vector
     * @method normalizeVec2
     * @static
     */normalizeVec2:function normalizeVec2(v,dest){var f=1.0/math.lenVec2(v);return math.mulVec2Scalar(v,f,dest);},/**
     * Gets the angle between two vectors
     * @method angleVec3
     * @param v
     * @param w
     * @returns {number}
     */angleVec3:function angleVec3(v,w){var theta=math.dotVec3(v,w)/Math.sqrt(math.sqLenVec3(v)*math.sqLenVec3(w));theta=theta<-1?-1:theta>1?1:theta;// Clamp to handle numerical problems
return Math.acos(theta);},/**
     * Creates a three-element vector from the rotation part of a sixteen-element matrix.
     * @param m
     * @param dest
     */vec3FromMat4Scale:function(){var tempVec3=new FloatArrayType(3);return function(m,dest){tempVec3[0]=m[0];tempVec3[1]=m[1];tempVec3[2]=m[2];dest[0]=math.lenVec3(tempVec3);tempVec3[0]=m[4];tempVec3[1]=m[5];tempVec3[2]=m[6];dest[1]=math.lenVec3(tempVec3);tempVec3[0]=m[8];tempVec3[1]=m[9];tempVec3[2]=m[10];dest[2]=math.lenVec3(tempVec3);return dest;};}(),/**
     * Converts an n-element vector to a JSON-serializable
     * array with values rounded to two decimal places.
     */vecToArray:function(){function trunc(v){return Math.round(v*100000)/100000;}return function(v){v=Array.prototype.slice.call(v);for(var _i14=0,len=v.length;_i14<len;_i14++){v[_i14]=trunc(v[_i14]);}return v;};}(),/**
     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.
     * @param arr
     * @returns {{x: *, y: *, z: *}}
     */xyzArrayToObject:function xyzArrayToObject(arr){return{"x":arr[0],"y":arr[1],"z":arr[2]};},/**
     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.
     * @param xyz
     * @param  [arry]
     * @returns {*[]}
     */xyzObjectToArray:function xyzObjectToArray(xyz,arry){arry=arry||math.vec3();arry[0]=xyz.x;arry[1]=xyz.y;arry[2]=xyz.z;return arry;},/**
     * Duplicates a 4x4 identity matrix.
     * @method dupMat4
     * @static
     */dupMat4:function dupMat4(m){return m.slice(0,16);},/**
     * Extracts a 3x3 matrix from a 4x4 matrix.
     * @method mat4To3
     * @static
     */mat4To3:function mat4To3(m){return[m[0],m[1],m[2],m[4],m[5],m[6],m[8],m[9],m[10]];},/**
     * Returns a 4x4 matrix with each element set to the given scalar value.
     * @method m4s
     * @static
     */m4s:function m4s(s){return[s,s,s,s,s,s,s,s,s,s,s,s,s,s,s,s];},/**
     * Returns a 4x4 matrix with each element set to zero.
     * @method setMat4ToZeroes
     * @static
     */setMat4ToZeroes:function setMat4ToZeroes(){return math.m4s(0.0);},/**
     * Returns a 4x4 matrix with each element set to 1.0.
     * @method setMat4ToOnes
     * @static
     */setMat4ToOnes:function setMat4ToOnes(){return math.m4s(1.0);},/**
     * Returns a 4x4 matrix with each element set to 1.0.
     * @method setMat4ToOnes
     * @static
     */diagonalMat4v:function diagonalMat4v(v){return new FloatArrayType([v[0],0.0,0.0,0.0,0.0,v[1],0.0,0.0,0.0,0.0,v[2],0.0,0.0,0.0,0.0,v[3]]);},/**
     * Returns a 4x4 matrix with diagonal elements set to the given vector.
     * @method diagonalMat4c
     * @static
     */diagonalMat4c:function diagonalMat4c(x,y,z,w){return math.diagonalMat4v([x,y,z,w]);},/**
     * Returns a 4x4 matrix with diagonal elements set to the given scalar.
     * @method diagonalMat4s
     * @static
     */diagonalMat4s:function diagonalMat4s(s){return math.diagonalMat4c(s,s,s,s);},/**
     * Returns a 4x4 identity matrix.
     * @method identityMat4
     * @static
     */identityMat4:function identityMat4(){var mat=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new FloatArrayType(16);mat[0]=1.0;mat[1]=0.0;mat[2]=0.0;mat[3]=0.0;mat[4]=0.0;mat[5]=1.0;mat[6]=0.0;mat[7]=0.0;mat[8]=0.0;mat[9]=0.0;mat[10]=1.0;mat[11]=0.0;mat[12]=0.0;mat[13]=0.0;mat[14]=0.0;mat[15]=1.0;return mat;},/**
     * Returns a 3x3 identity matrix.
     * @method identityMat3
     * @static
     */identityMat3:function identityMat3(){var mat=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new FloatArrayType(9);mat[0]=1.0;mat[1]=0.0;mat[2]=0.0;mat[3]=0.0;mat[4]=1.0;mat[5]=0.0;mat[6]=0.0;mat[7]=0.0;mat[8]=1.0;return mat;},/**
     * Tests if the given 4x4 matrix is the identity matrix.
     * @method isIdentityMat4
     * @static
     */isIdentityMat4:function isIdentityMat4(m){if(m[0]!==1.0||m[1]!==0.0||m[2]!==0.0||m[3]!==0.0||m[4]!==0.0||m[5]!==1.0||m[6]!==0.0||m[7]!==0.0||m[8]!==0.0||m[9]!==0.0||m[10]!==1.0||m[11]!==0.0||m[12]!==0.0||m[13]!==0.0||m[14]!==0.0||m[15]!==1.0){return false;}return true;},/**
     * Negates the given 4x4 matrix.
     * @method negateMat4
     * @static
     */negateMat4:function negateMat4(m,dest){if(!dest){dest=m;}dest[0]=-m[0];dest[1]=-m[1];dest[2]=-m[2];dest[3]=-m[3];dest[4]=-m[4];dest[5]=-m[5];dest[6]=-m[6];dest[7]=-m[7];dest[8]=-m[8];dest[9]=-m[9];dest[10]=-m[10];dest[11]=-m[11];dest[12]=-m[12];dest[13]=-m[13];dest[14]=-m[14];dest[15]=-m[15];return dest;},/**
     * Adds the given 4x4 matrices together.
     * @method addMat4
     * @static
     */addMat4:function addMat4(a,b,dest){if(!dest){dest=a;}dest[0]=a[0]+b[0];dest[1]=a[1]+b[1];dest[2]=a[2]+b[2];dest[3]=a[3]+b[3];dest[4]=a[4]+b[4];dest[5]=a[5]+b[5];dest[6]=a[6]+b[6];dest[7]=a[7]+b[7];dest[8]=a[8]+b[8];dest[9]=a[9]+b[9];dest[10]=a[10]+b[10];dest[11]=a[11]+b[11];dest[12]=a[12]+b[12];dest[13]=a[13]+b[13];dest[14]=a[14]+b[14];dest[15]=a[15]+b[15];return dest;},/**
     * Adds the given scalar to each element of the given 4x4 matrix.
     * @method addMat4Scalar
     * @static
     */addMat4Scalar:function addMat4Scalar(m,s,dest){if(!dest){dest=m;}dest[0]=m[0]+s;dest[1]=m[1]+s;dest[2]=m[2]+s;dest[3]=m[3]+s;dest[4]=m[4]+s;dest[5]=m[5]+s;dest[6]=m[6]+s;dest[7]=m[7]+s;dest[8]=m[8]+s;dest[9]=m[9]+s;dest[10]=m[10]+s;dest[11]=m[11]+s;dest[12]=m[12]+s;dest[13]=m[13]+s;dest[14]=m[14]+s;dest[15]=m[15]+s;return dest;},/**
     * Adds the given scalar to each element of the given 4x4 matrix.
     * @method addScalarMat4
     * @static
     */addScalarMat4:function addScalarMat4(s,m,dest){return math.addMat4Scalar(m,s,dest);},/**
     * Subtracts the second 4x4 matrix from the first.
     * @method subMat4
     * @static
     */subMat4:function subMat4(a,b,dest){if(!dest){dest=a;}dest[0]=a[0]-b[0];dest[1]=a[1]-b[1];dest[2]=a[2]-b[2];dest[3]=a[3]-b[3];dest[4]=a[4]-b[4];dest[5]=a[5]-b[5];dest[6]=a[6]-b[6];dest[7]=a[7]-b[7];dest[8]=a[8]-b[8];dest[9]=a[9]-b[9];dest[10]=a[10]-b[10];dest[11]=a[11]-b[11];dest[12]=a[12]-b[12];dest[13]=a[13]-b[13];dest[14]=a[14]-b[14];dest[15]=a[15]-b[15];return dest;},/**
     * Subtracts the given scalar from each element of the given 4x4 matrix.
     * @method subMat4Scalar
     * @static
     */subMat4Scalar:function subMat4Scalar(m,s,dest){if(!dest){dest=m;}dest[0]=m[0]-s;dest[1]=m[1]-s;dest[2]=m[2]-s;dest[3]=m[3]-s;dest[4]=m[4]-s;dest[5]=m[5]-s;dest[6]=m[6]-s;dest[7]=m[7]-s;dest[8]=m[8]-s;dest[9]=m[9]-s;dest[10]=m[10]-s;dest[11]=m[11]-s;dest[12]=m[12]-s;dest[13]=m[13]-s;dest[14]=m[14]-s;dest[15]=m[15]-s;return dest;},/**
     * Subtracts the given scalar from each element of the given 4x4 matrix.
     * @method subScalarMat4
     * @static
     */subScalarMat4:function subScalarMat4(s,m,dest){if(!dest){dest=m;}dest[0]=s-m[0];dest[1]=s-m[1];dest[2]=s-m[2];dest[3]=s-m[3];dest[4]=s-m[4];dest[5]=s-m[5];dest[6]=s-m[6];dest[7]=s-m[7];dest[8]=s-m[8];dest[9]=s-m[9];dest[10]=s-m[10];dest[11]=s-m[11];dest[12]=s-m[12];dest[13]=s-m[13];dest[14]=s-m[14];dest[15]=s-m[15];return dest;},/**
     * Multiplies the two given 4x4 matrix by each other.
     * @method mulMat4
     * @static
     */mulMat4:function mulMat4(a,b,dest){if(!dest){dest=a;}// Cache the matrix values (makes for huge speed increases!)
var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];var a30=a[12];var a31=a[13];var a32=a[14];var a33=a[15];var b00=b[0];var b01=b[1];var b02=b[2];var b03=b[3];var b10=b[4];var b11=b[5];var b12=b[6];var b13=b[7];var b20=b[8];var b21=b[9];var b22=b[10];var b23=b[11];var b30=b[12];var b31=b[13];var b32=b[14];var b33=b[15];dest[0]=b00*a00+b01*a10+b02*a20+b03*a30;dest[1]=b00*a01+b01*a11+b02*a21+b03*a31;dest[2]=b00*a02+b01*a12+b02*a22+b03*a32;dest[3]=b00*a03+b01*a13+b02*a23+b03*a33;dest[4]=b10*a00+b11*a10+b12*a20+b13*a30;dest[5]=b10*a01+b11*a11+b12*a21+b13*a31;dest[6]=b10*a02+b11*a12+b12*a22+b13*a32;dest[7]=b10*a03+b11*a13+b12*a23+b13*a33;dest[8]=b20*a00+b21*a10+b22*a20+b23*a30;dest[9]=b20*a01+b21*a11+b22*a21+b23*a31;dest[10]=b20*a02+b21*a12+b22*a22+b23*a32;dest[11]=b20*a03+b21*a13+b22*a23+b23*a33;dest[12]=b30*a00+b31*a10+b32*a20+b33*a30;dest[13]=b30*a01+b31*a11+b32*a21+b33*a31;dest[14]=b30*a02+b31*a12+b32*a22+b33*a32;dest[15]=b30*a03+b31*a13+b32*a23+b33*a33;return dest;},/**
     * Multiplies the two given 3x3 matrices by each other.
     * @method mulMat4
     * @static
     */mulMat3:function mulMat3(a,b,dest){if(!dest){dest=new FloatArrayType(9);}var a11=a[0];var a12=a[3];var a13=a[6];var a21=a[1];var a22=a[4];var a23=a[7];var a31=a[2];var a32=a[5];var a33=a[8];var b11=b[0];var b12=b[3];var b13=b[6];var b21=b[1];var b22=b[4];var b23=b[7];var b31=b[2];var b32=b[5];var b33=b[8];dest[0]=a11*b11+a12*b21+a13*b31;dest[3]=a11*b12+a12*b22+a13*b32;dest[6]=a11*b13+a12*b23+a13*b33;dest[1]=a21*b11+a22*b21+a23*b31;dest[4]=a21*b12+a22*b22+a23*b32;dest[7]=a21*b13+a22*b23+a23*b33;dest[2]=a31*b11+a32*b21+a33*b31;dest[5]=a31*b12+a32*b22+a33*b32;dest[8]=a31*b13+a32*b23+a33*b33;return dest;},/**
     * Multiplies each element of the given 4x4 matrix by the given scalar.
     * @method mulMat4Scalar
     * @static
     */mulMat4Scalar:function mulMat4Scalar(m,s,dest){if(!dest){dest=m;}dest[0]=m[0]*s;dest[1]=m[1]*s;dest[2]=m[2]*s;dest[3]=m[3]*s;dest[4]=m[4]*s;dest[5]=m[5]*s;dest[6]=m[6]*s;dest[7]=m[7]*s;dest[8]=m[8]*s;dest[9]=m[9]*s;dest[10]=m[10]*s;dest[11]=m[11]*s;dest[12]=m[12]*s;dest[13]=m[13]*s;dest[14]=m[14]*s;dest[15]=m[15]*s;return dest;},/**
     * Multiplies the given 4x4 matrix by the given four-element vector.
     * @method mulMat4v4
     * @static
     */mulMat4v4:function mulMat4v4(m,v){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec4();var v0=v[0];var v1=v[1];var v2=v[2];var v3=v[3];dest[0]=m[0]*v0+m[4]*v1+m[8]*v2+m[12]*v3;dest[1]=m[1]*v0+m[5]*v1+m[9]*v2+m[13]*v3;dest[2]=m[2]*v0+m[6]*v1+m[10]*v2+m[14]*v3;dest[3]=m[3]*v0+m[7]*v1+m[11]*v2+m[15]*v3;return dest;},/**
     * Transposes the given 4x4 matrix.
     * @method transposeMat4
     * @static
     */transposeMat4:function transposeMat4(mat,dest){// If we are transposing ourselves we can skip a few steps but have to cache some values
var m4=mat[4];var m14=mat[14];var m8=mat[8];var m13=mat[13];var m12=mat[12];var m9=mat[9];if(!dest||mat===dest){var a01=mat[1];var a02=mat[2];var a03=mat[3];var a12=mat[6];var a13=mat[7];var a23=mat[11];mat[1]=m4;mat[2]=m8;mat[3]=m12;mat[4]=a01;mat[6]=m9;mat[7]=m13;mat[8]=a02;mat[9]=a12;mat[11]=m14;mat[12]=a03;mat[13]=a13;mat[14]=a23;return mat;}dest[0]=mat[0];dest[1]=m4;dest[2]=m8;dest[3]=m12;dest[4]=mat[1];dest[5]=mat[5];dest[6]=m9;dest[7]=m13;dest[8]=mat[2];dest[9]=mat[6];dest[10]=mat[10];dest[11]=m14;dest[12]=mat[3];dest[13]=mat[7];dest[14]=mat[11];dest[15]=mat[15];return dest;},/**
     * Transposes the given 3x3 matrix.
     *
     * @method transposeMat3
     * @static
     */transposeMat3:function transposeMat3(mat,dest){if(dest===mat){var a01=mat[1];var a02=mat[2];var a12=mat[5];dest[1]=mat[3];dest[2]=mat[6];dest[3]=a01;dest[5]=mat[7];dest[6]=a02;dest[7]=a12;}else{dest[0]=mat[0];dest[1]=mat[3];dest[2]=mat[6];dest[3]=mat[1];dest[4]=mat[4];dest[5]=mat[7];dest[6]=mat[2];dest[7]=mat[5];dest[8]=mat[8];}return dest;},/**
     * Returns the determinant of the given 4x4 matrix.
     * @method determinantMat4
     * @static
     */determinantMat4:function determinantMat4(mat){// Cache the matrix values (makes for huge speed increases!)
var a00=mat[0];var a01=mat[1];var a02=mat[2];var a03=mat[3];var a10=mat[4];var a11=mat[5];var a12=mat[6];var a13=mat[7];var a20=mat[8];var a21=mat[9];var a22=mat[10];var a23=mat[11];var a30=mat[12];var a31=mat[13];var a32=mat[14];var a33=mat[15];return a30*a21*a12*a03-a20*a31*a12*a03-a30*a11*a22*a03+a10*a31*a22*a03+a20*a11*a32*a03-a10*a21*a32*a03-a30*a21*a02*a13+a20*a31*a02*a13+a30*a01*a22*a13-a00*a31*a22*a13-a20*a01*a32*a13+a00*a21*a32*a13+a30*a11*a02*a23-a10*a31*a02*a23-a30*a01*a12*a23+a00*a31*a12*a23+a10*a01*a32*a23-a00*a11*a32*a23-a20*a11*a02*a33+a10*a21*a02*a33+a20*a01*a12*a33-a00*a21*a12*a33-a10*a01*a22*a33+a00*a11*a22*a33;},/**
     * Returns the inverse of the given 4x4 matrix.
     * @method inverseMat4
     * @static
     */inverseMat4:function inverseMat4(mat,dest){if(!dest){dest=mat;}// Cache the matrix values (makes for huge speed increases!)
var a00=mat[0];var a01=mat[1];var a02=mat[2];var a03=mat[3];var a10=mat[4];var a11=mat[5];var a12=mat[6];var a13=mat[7];var a20=mat[8];var a21=mat[9];var a22=mat[10];var a23=mat[11];var a30=mat[12];var a31=mat[13];var a32=mat[14];var a33=mat[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant (inlined to avoid double-caching)
var invDet=1/(b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06);dest[0]=(a11*b11-a12*b10+a13*b09)*invDet;dest[1]=(-a01*b11+a02*b10-a03*b09)*invDet;dest[2]=(a31*b05-a32*b04+a33*b03)*invDet;dest[3]=(-a21*b05+a22*b04-a23*b03)*invDet;dest[4]=(-a10*b11+a12*b08-a13*b07)*invDet;dest[5]=(a00*b11-a02*b08+a03*b07)*invDet;dest[6]=(-a30*b05+a32*b02-a33*b01)*invDet;dest[7]=(a20*b05-a22*b02+a23*b01)*invDet;dest[8]=(a10*b10-a11*b08+a13*b06)*invDet;dest[9]=(-a00*b10+a01*b08-a03*b06)*invDet;dest[10]=(a30*b04-a31*b02+a33*b00)*invDet;dest[11]=(-a20*b04+a21*b02-a23*b00)*invDet;dest[12]=(-a10*b09+a11*b07-a12*b06)*invDet;dest[13]=(a00*b09-a01*b07+a02*b06)*invDet;dest[14]=(-a30*b03+a31*b01-a32*b00)*invDet;dest[15]=(a20*b03-a21*b01+a22*b00)*invDet;return dest;},/**
     * Returns the trace of the given 4x4 matrix.
     * @method traceMat4
     * @static
     */traceMat4:function traceMat4(m){return m[0]+m[5]+m[10]+m[15];},/**
     * Returns 4x4 translation matrix.
     * @method translationMat4
     * @static
     */translationMat4v:function translationMat4v(v,dest){var m=dest||math.identityMat4();m[12]=v[0];m[13]=v[1];m[14]=v[2];return m;},/**
     * Returns 3x3 translation matrix.
     * @method translationMat3
     * @static
     */translationMat3v:function translationMat3v(v,dest){var m=dest||math.identityMat3();m[6]=v[0];m[7]=v[1];return m;},/**
     * Returns 4x4 translation matrix.
     * @method translationMat4c
     * @static
     */translationMat4c:function(){var xyz=new FloatArrayType(3);return function(x,y,z,dest){xyz[0]=x;xyz[1]=y;xyz[2]=z;return math.translationMat4v(xyz,dest);};}(),/**
     * Returns 4x4 translation matrix.
     * @method translationMat4s
     * @static
     */translationMat4s:function translationMat4s(s,dest){return math.translationMat4c(s,s,s,dest);},/**
     * Efficiently post-concatenates a translation to the given matrix.
     * @param v
     * @param m
     */translateMat4v:function translateMat4v(xyz,m){return math.translateMat4c(xyz[0],xyz[1],xyz[2],m);},/**
     * Efficiently post-concatenates a translation to the given matrix.
     * @param x
     * @param y
     * @param z
     * @param m
     */translateMat4c:function translateMat4c(x,y,z,m){var m3=m[3];m[0]+=m3*x;m[1]+=m3*y;m[2]+=m3*z;var m7=m[7];m[4]+=m7*x;m[5]+=m7*y;m[6]+=m7*z;var m11=m[11];m[8]+=m11*x;m[9]+=m11*y;m[10]+=m11*z;var m15=m[15];m[12]+=m15*x;m[13]+=m15*y;m[14]+=m15*z;return m;},/**
     * Creates a new matrix that replaces the translation in the rightmost column of the given
     * affine matrix with the given translation.
     * @param m
     * @param translation
     * @param dest
     * @returns {*}
     */setMat4Translation:function setMat4Translation(m,translation,dest){dest[0]=m[0];dest[1]=m[1];dest[2]=m[2];dest[3]=m[3];dest[4]=m[4];dest[5]=m[5];dest[6]=m[6];dest[7]=m[7];dest[8]=m[8];dest[9]=m[9];dest[10]=m[10];dest[11]=m[11];dest[12]=translation[0];dest[13]=translation[1];dest[14]=translation[2];dest[15]=m[15];return dest;},/**
     * Returns 4x4 rotation matrix.
     * @method rotationMat4v
     * @static
     */rotationMat4v:function rotationMat4v(anglerad,axis,m){var ax=math.normalizeVec4([axis[0],axis[1],axis[2],0.0],[]);var s=Math.sin(anglerad);var c=Math.cos(anglerad);var q=1.0-c;var x=ax[0];var y=ax[1];var z=ax[2];var xy;var yz;var zx;var xs;var ys;var zs;//xx = x * x; used once
//yy = y * y; used once
//zz = z * z; used once
xy=x*y;yz=y*z;zx=z*x;xs=x*s;ys=y*s;zs=z*s;m=m||math.mat4();m[0]=q*x*x+c;m[1]=q*xy+zs;m[2]=q*zx-ys;m[3]=0.0;m[4]=q*xy-zs;m[5]=q*y*y+c;m[6]=q*yz+xs;m[7]=0.0;m[8]=q*zx+ys;m[9]=q*yz-xs;m[10]=q*z*z+c;m[11]=0.0;m[12]=0.0;m[13]=0.0;m[14]=0.0;m[15]=1.0;return m;},/**
     * Returns 4x4 rotation matrix.
     * @method rotationMat4c
     * @static
     */rotationMat4c:function rotationMat4c(anglerad,x,y,z,mat){return math.rotationMat4v(anglerad,[x,y,z],mat);},/**
     * Returns 4x4 scale matrix.
     * @method scalingMat4v
     * @static
     */scalingMat4v:function scalingMat4v(v){var m=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.identityMat4();m[0]=v[0];m[5]=v[1];m[10]=v[2];return m;},/**
     * Returns 3x3 scale matrix.
     * @method scalingMat3v
     * @static
     */scalingMat3v:function scalingMat3v(v){var m=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.identityMat3();m[0]=v[0];m[4]=v[1];return m;},/**
     * Returns 4x4 scale matrix.
     * @method scalingMat4c
     * @static
     */scalingMat4c:function(){var xyz=new FloatArrayType(3);return function(x,y,z,dest){xyz[0]=x;xyz[1]=y;xyz[2]=z;return math.scalingMat4v(xyz,dest);};}(),/**
     * Efficiently post-concatenates a scaling to the given matrix.
     * @method scaleMat4c
     * @param x
     * @param y
     * @param z
     * @param m
     */scaleMat4c:function scaleMat4c(x,y,z,m){m[0]*=x;m[4]*=y;m[8]*=z;m[1]*=x;m[5]*=y;m[9]*=z;m[2]*=x;m[6]*=y;m[10]*=z;m[3]*=x;m[7]*=y;m[11]*=z;return m;},/**
     * Efficiently post-concatenates a scaling to the given matrix.
     * @method scaleMat4c
     * @param xyz
     * @param m
     */scaleMat4v:function scaleMat4v(xyz,m){var x=xyz[0];var y=xyz[1];var z=xyz[2];m[0]*=x;m[4]*=y;m[8]*=z;m[1]*=x;m[5]*=y;m[9]*=z;m[2]*=x;m[6]*=y;m[10]*=z;m[3]*=x;m[7]*=y;m[11]*=z;return m;},/**
     * Returns 4x4 scale matrix.
     * @method scalingMat4s
     * @static
     */scalingMat4s:function scalingMat4s(s){return math.scalingMat4c(s,s,s);},/**
     * Creates a matrix from a quaternion rotation and vector translation
     *
     * @param {Number[]} q Rotation quaternion
     * @param {Number[]} v Translation vector
     * @param {Number[]} dest Destination matrix
     * @returns {Number[]} dest
     */rotationTranslationMat4:function rotationTranslationMat4(q,v){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.mat4();var x=q[0];var y=q[1];var z=q[2];var w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;dest[0]=1-(yy+zz);dest[1]=xy+wz;dest[2]=xz-wy;dest[3]=0;dest[4]=xy-wz;dest[5]=1-(xx+zz);dest[6]=yz+wx;dest[7]=0;dest[8]=xz+wy;dest[9]=yz-wx;dest[10]=1-(xx+yy);dest[11]=0;dest[12]=v[0];dest[13]=v[1];dest[14]=v[2];dest[15]=1;return dest;},/**
     * Gets Euler angles from a 4x4 matrix.
     *
     * @param {Number[]} mat The 4x4 matrix.
     * @param {String} order Desired Euler angle order: "XYZ", "YXZ", "ZXY" etc.
     * @param {Number[]} [dest] Destination Euler angles, created by default.
     * @returns {Number[]} The Euler angles.
     */mat4ToEuler:function mat4ToEuler(mat,order){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec4();var clamp=math.clamp;// Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var m11=mat[0];var m12=mat[4];var m13=mat[8];var m21=mat[1];var m22=mat[5];var m23=mat[9];var m31=mat[2];var m32=mat[6];var m33=mat[10];if(order==='XYZ'){dest[1]=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){dest[0]=Math.atan2(-m23,m33);dest[2]=Math.atan2(-m12,m11);}else{dest[0]=Math.atan2(m32,m22);dest[2]=0;}}else if(order==='YXZ'){dest[0]=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){dest[1]=Math.atan2(m13,m33);dest[2]=Math.atan2(m21,m22);}else{dest[1]=Math.atan2(-m31,m11);dest[2]=0;}}else if(order==='ZXY'){dest[0]=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){dest[1]=Math.atan2(-m31,m33);dest[2]=Math.atan2(-m12,m22);}else{dest[1]=0;dest[2]=Math.atan2(m21,m11);}}else if(order==='ZYX'){dest[1]=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){dest[0]=Math.atan2(m32,m33);dest[2]=Math.atan2(m21,m11);}else{dest[0]=0;dest[2]=Math.atan2(-m12,m22);}}else if(order==='YZX'){dest[2]=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){dest[0]=Math.atan2(-m23,m22);dest[1]=Math.atan2(-m31,m11);}else{dest[0]=0;dest[1]=Math.atan2(m13,m33);}}else if(order==='XZY'){dest[2]=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){dest[0]=Math.atan2(m32,m22);dest[1]=Math.atan2(m13,m11);}else{dest[0]=Math.atan2(-m23,m33);dest[1]=0;}}return dest;},composeMat4:function composeMat4(position,quaternion,scale){var mat=arguments.length>3&&arguments[3]!==undefined?arguments[3]:math.mat4();math.quaternionToRotationMat4(quaternion,mat);math.scaleMat4v(scale,mat);math.translateMat4v(position,mat);return mat;},decomposeMat4:function(){var vec=new FloatArrayType(3);var matrix=new FloatArrayType(16);return function decompose(mat,position,quaternion,scale){vec[0]=mat[0];vec[1]=mat[1];vec[2]=mat[2];var sx=math.lenVec3(vec);vec[0]=mat[4];vec[1]=mat[5];vec[2]=mat[6];var sy=math.lenVec3(vec);vec[8]=mat[8];vec[9]=mat[9];vec[10]=mat[10];var sz=math.lenVec3(vec);// if determine is negative, we need to invert one scale
var det=math.determinantMat4(mat);if(det<0){sx=-sx;}position[0]=mat[12];position[1]=mat[13];position[2]=mat[14];// scale the rotation part
matrix.set(mat);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;matrix[0]*=invSX;matrix[1]*=invSX;matrix[2]*=invSX;matrix[4]*=invSY;matrix[5]*=invSY;matrix[6]*=invSY;matrix[8]*=invSZ;matrix[9]*=invSZ;matrix[10]*=invSZ;math.mat4ToQuaternion(matrix,quaternion);scale[0]=sx;scale[1]=sy;scale[2]=sz;return this;};}(),/** @private */getColMat4:function getColMat4(mat,c){var i=c*4;return[mat[i],mat[i+1],mat[i+2],mat[i+3]];},/** @private */setRowMat4:function setRowMat4(mat,r,v){mat[r]=v[0];mat[r+4]=v[1];mat[r+8]=v[2];mat[r+12]=v[3];},/**
     * Returns a 4x4 'lookat' viewing transform matrix.
     * @method lookAtMat4v
     * @param pos vec3 position of the viewer
     * @param target vec3 point the viewer is looking at
     * @param up vec3 pointing "up"
     * @param dest mat4 Optional, mat4 matrix will be written into
     *
     * @return {mat4} dest if specified, a new mat4 otherwise
     */lookAtMat4v:function lookAtMat4v(pos,target,up,dest){if(!dest){dest=math.mat4();}var posx=pos[0];var posy=pos[1];var posz=pos[2];var upx=up[0];var upy=up[1];var upz=up[2];var targetx=target[0];var targety=target[1];var targetz=target[2];if(posx===targetx&&posy===targety&&posz===targetz){return math.identityMat4();}var z0;var z1;var z2;var x0;var x1;var x2;var y0;var y1;var y2;var len;//vec3.direction(eye, center, z);
z0=posx-targetx;z1=posy-targety;z2=posz-targetz;// normalize (no check needed for 0 because of early return)
len=1/Math.sqrt(z0*z0+z1*z1+z2*z2);z0*=len;z1*=len;z2*=len;//vec3.normalize(vec3.cross(up, z, x));
x0=upy*z2-upz*z1;x1=upz*z0-upx*z2;x2=upx*z1-upy*z0;len=Math.sqrt(x0*x0+x1*x1+x2*x2);if(!len){x0=0;x1=0;x2=0;}else{len=1/len;x0*=len;x1*=len;x2*=len;}//vec3.normalize(vec3.cross(z, x, y));
y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;len=Math.sqrt(y0*y0+y1*y1+y2*y2);if(!len){y0=0;y1=0;y2=0;}else{len=1/len;y0*=len;y1*=len;y2*=len;}dest[0]=x0;dest[1]=y0;dest[2]=z0;dest[3]=0;dest[4]=x1;dest[5]=y1;dest[6]=z1;dest[7]=0;dest[8]=x2;dest[9]=y2;dest[10]=z2;dest[11]=0;dest[12]=-(x0*posx+x1*posy+x2*posz);dest[13]=-(y0*posx+y1*posy+y2*posz);dest[14]=-(z0*posx+z1*posy+z2*posz);dest[15]=1;return dest;},/**
     * Returns a 4x4 'lookat' viewing transform matrix.
     * @method lookAtMat4c
     * @static
     */lookAtMat4c:function lookAtMat4c(posx,posy,posz,targetx,targety,targetz,upx,upy,upz){return math.lookAtMat4v([posx,posy,posz],[targetx,targety,targetz],[upx,upy,upz],[]);},/**
     * Returns a 4x4 orthographic projection matrix.
     * @method orthoMat4c
     * @static
     */orthoMat4c:function orthoMat4c(left,right,bottom,top,near,far,dest){if(!dest){dest=math.mat4();}var rl=right-left;var tb=top-bottom;var fn=far-near;dest[0]=2.0/rl;dest[1]=0.0;dest[2]=0.0;dest[3]=0.0;dest[4]=0.0;dest[5]=2.0/tb;dest[6]=0.0;dest[7]=0.0;dest[8]=0.0;dest[9]=0.0;dest[10]=-2.0/fn;dest[11]=0.0;dest[12]=-(left+right)/rl;dest[13]=-(top+bottom)/tb;dest[14]=-(far+near)/fn;dest[15]=1.0;return dest;},/**
     * Returns a 4x4 perspective projection matrix.
     * @method frustumMat4v
     * @static
     */frustumMat4v:function frustumMat4v(fmin,fmax,m){if(!m){m=math.mat4();}var fmin4=[fmin[0],fmin[1],fmin[2],0.0];var fmax4=[fmax[0],fmax[1],fmax[2],0.0];math.addVec4(fmax4,fmin4,tempMat1);math.subVec4(fmax4,fmin4,tempMat2);var t=2.0*fmin4[2];var tempMat20=tempMat2[0];var tempMat21=tempMat2[1];var tempMat22=tempMat2[2];m[0]=t/tempMat20;m[1]=0.0;m[2]=0.0;m[3]=0.0;m[4]=0.0;m[5]=t/tempMat21;m[6]=0.0;m[7]=0.0;m[8]=tempMat1[0]/tempMat20;m[9]=tempMat1[1]/tempMat21;m[10]=-tempMat1[2]/tempMat22;m[11]=-1.0;m[12]=0.0;m[13]=0.0;m[14]=-t*fmax4[2]/tempMat22;m[15]=0.0;return m;},/**
     * Returns a 4x4 perspective projection matrix.
     * @method frustumMat4v
     * @static
     */frustumMat4:function frustumMat4(left,right,bottom,top,near,far,dest){if(!dest){dest=math.mat4();}var rl=right-left;var tb=top-bottom;var fn=far-near;dest[0]=near*2/rl;dest[1]=0;dest[2]=0;dest[3]=0;dest[4]=0;dest[5]=near*2/tb;dest[6]=0;dest[7]=0;dest[8]=(right+left)/rl;dest[9]=(top+bottom)/tb;dest[10]=-(far+near)/fn;dest[11]=-1;dest[12]=0;dest[13]=0;dest[14]=-(far*near*2)/fn;dest[15]=0;return dest;},/**
     * Returns a 4x4 perspective projection matrix.
     * @method perspectiveMat4v
     * @static
     */perspectiveMat4:function perspectiveMat4(fovyrad,aspectratio,znear,zfar,m){var pmin=[];var pmax=[];pmin[2]=znear;pmax[2]=zfar;pmax[1]=pmin[2]*Math.tan(fovyrad/2.0);pmin[1]=-pmax[1];pmax[0]=pmax[1]*aspectratio;pmin[0]=-pmax[0];return math.frustumMat4v(pmin,pmax,m);},/**
     * Returns true if the two 4x4 matrices are the same.
     * @param m1
     * @param m2
     * @returns {Boolean}
     */compareMat4:function compareMat4(m1,m2){return m1[0]===m2[0]&&m1[1]===m2[1]&&m1[2]===m2[2]&&m1[3]===m2[3]&&m1[4]===m2[4]&&m1[5]===m2[5]&&m1[6]===m2[6]&&m1[7]===m2[7]&&m1[8]===m2[8]&&m1[9]===m2[9]&&m1[10]===m2[10]&&m1[11]===m2[11]&&m1[12]===m2[12]&&m1[13]===m2[13]&&m1[14]===m2[14]&&m1[15]===m2[15];},/**
     * Transforms a three-element position by a 4x4 matrix.
     * @method transformPoint3
     * @static
     */transformPoint3:function transformPoint3(m,p){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec3();var x=p[0];var y=p[1];var z=p[2];dest[0]=m[0]*x+m[4]*y+m[8]*z+m[12];dest[1]=m[1]*x+m[5]*y+m[9]*z+m[13];dest[2]=m[2]*x+m[6]*y+m[10]*z+m[14];return dest;},/**
     * Transforms a homogeneous coordinate by a 4x4 matrix.
     * @method transformPoint3
     * @static
     */transformPoint4:function transformPoint4(m,v){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec4();dest[0]=m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3];dest[1]=m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3];dest[2]=m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3];dest[3]=m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3];return dest;},/**
     * Transforms an array of three-element positions by a 4x4 matrix.
     * @method transformPoints3
     * @static
     */transformPoints3:function transformPoints3(m,points,points2){var result=points2||[];var len=points.length;var p0;var p1;var p2;var pi;// cache values
var m0=m[0];var m1=m[1];var m2=m[2];var m3=m[3];var m4=m[4];var m5=m[5];var m6=m[6];var m7=m[7];var m8=m[8];var m9=m[9];var m10=m[10];var m11=m[11];var m12=m[12];var m13=m[13];var m14=m[14];var m15=m[15];var r;for(var _i15=0;_i15<len;++_i15){// cache values
pi=points[_i15];p0=pi[0];p1=pi[1];p2=pi[2];r=result[_i15]||(result[_i15]=[0,0,0]);r[0]=m0*p0+m4*p1+m8*p2+m12;r[1]=m1*p0+m5*p1+m9*p2+m13;r[2]=m2*p0+m6*p1+m10*p2+m14;r[3]=m3*p0+m7*p1+m11*p2+m15;}result.length=len;return result;},/**
     * Transforms an array of positions by a 4x4 matrix.
     * @method transformPositions3
     * @static
     */transformPositions3:function transformPositions3(m,p){var p2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:p;var i;var len=p.length;var x;var y;var z;var m0=m[0];var m1=m[1];var m2=m[2];m[3];var m4=m[4];var m5=m[5];var m6=m[6];m[7];var m8=m[8];var m9=m[9];var m10=m[10];m[11];var m12=m[12];var m13=m[13];var m14=m[14];m[15];for(i=0;i<len;i+=3){x=p[i+0];y=p[i+1];z=p[i+2];p2[i+0]=m0*x+m4*y+m8*z+m12;p2[i+1]=m1*x+m5*y+m9*z+m13;p2[i+2]=m2*x+m6*y+m10*z+m14;}return p2;},/**
     * Transforms an array of positions by a 4x4 matrix.
     * @method transformPositions4
     * @static
     */transformPositions4:function transformPositions4(m,p){var p2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:p;var i;var len=p.length;var x;var y;var z;var m0=m[0];var m1=m[1];var m2=m[2];var m3=m[3];var m4=m[4];var m5=m[5];var m6=m[6];var m7=m[7];var m8=m[8];var m9=m[9];var m10=m[10];var m11=m[11];var m12=m[12];var m13=m[13];var m14=m[14];var m15=m[15];for(i=0;i<len;i+=4){x=p[i+0];y=p[i+1];z=p[i+2];p2[i+0]=m0*x+m4*y+m8*z+m12;p2[i+1]=m1*x+m5*y+m9*z+m13;p2[i+2]=m2*x+m6*y+m10*z+m14;p2[i+3]=m3*x+m7*y+m11*z+m15;}return p2;},/**
     * Transforms a three-element vector by a 4x4 matrix.
     * @method transformVec3
     * @static
     */transformVec3:function transformVec3(m,v,dest){var v0=v[0];var v1=v[1];var v2=v[2];dest=dest||this.vec3();dest[0]=m[0]*v0+m[4]*v1+m[8]*v2;dest[1]=m[1]*v0+m[5]*v1+m[9]*v2;dest[2]=m[2]*v0+m[6]*v1+m[10]*v2;return dest;},/**
     * Transforms a four-element vector by a 4x4 matrix.
     * @method transformVec4
     * @static
     */transformVec4:function transformVec4(m,v,dest){var v0=v[0];var v1=v[1];var v2=v[2];var v3=v[3];dest=dest||math.vec4();dest[0]=m[0]*v0+m[4]*v1+m[8]*v2+m[12]*v3;dest[1]=m[1]*v0+m[5]*v1+m[9]*v2+m[13]*v3;dest[2]=m[2]*v0+m[6]*v1+m[10]*v2+m[14]*v3;dest[3]=m[3]*v0+m[7]*v1+m[11]*v2+m[15]*v3;return dest;},/**
     * Rotate a 2D vector around a center point.
     *
     * @param a
     * @param center
     * @param angle
     * @returns {math}
     */rotateVec2:function rotateVec2(a,center,angle){var dest=arguments.length>3&&arguments[3]!==undefined?arguments[3]:a;var c=Math.cos(angle);var s=Math.sin(angle);var x=a[0]-center[0];var y=a[1]-center[1];dest[0]=x*c-y*s+center[0];dest[1]=x*s+y*c+center[1];return a;},/**
     * Rotate a 3D vector around the x-axis
     *
     * @method rotateVec3X
     * @param {Number[]} a The vec3 point to rotate
     * @param {Number[]} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @param {Number[]} dest The receiving vec3
     * @returns {Number[]} dest
     * @static
     */rotateVec3X:function rotateVec3X(a,b,c,dest){var p=[];var r=[];//Translate point to the origin
p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];//perform rotation
r[0]=p[0];r[1]=p[1]*Math.cos(c)-p[2]*Math.sin(c);r[2]=p[1]*Math.sin(c)+p[2]*Math.cos(c);//translate to correct position
dest[0]=r[0]+b[0];dest[1]=r[1]+b[1];dest[2]=r[2]+b[2];return dest;},/**
     * Rotate a 3D vector around the y-axis
     *
     * @method rotateVec3Y
     * @param {Number[]} a The vec3 point to rotate
     * @param {Number[]} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @param {Number[]} dest The receiving vec3
     * @returns {Number[]} dest
     * @static
     */rotateVec3Y:function rotateVec3Y(a,b,c,dest){var p=[];var r=[];//Translate point to the origin
p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];//perform rotation
r[0]=p[2]*Math.sin(c)+p[0]*Math.cos(c);r[1]=p[1];r[2]=p[2]*Math.cos(c)-p[0]*Math.sin(c);//translate to correct position
dest[0]=r[0]+b[0];dest[1]=r[1]+b[1];dest[2]=r[2]+b[2];return dest;},/**
     * Rotate a 3D vector around the z-axis
     *
     * @method rotateVec3Z
     * @param {Number[]} a The vec3 point to rotate
     * @param {Number[]} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @param {Number[]} dest The receiving vec3
     * @returns {Number[]} dest
     * @static
     */rotateVec3Z:function rotateVec3Z(a,b,c,dest){var p=[];var r=[];//Translate point to the origin
p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];//perform rotation
r[0]=p[0]*Math.cos(c)-p[1]*Math.sin(c);r[1]=p[0]*Math.sin(c)+p[1]*Math.cos(c);r[2]=p[2];//translate to correct position
dest[0]=r[0]+b[0];dest[1]=r[1]+b[1];dest[2]=r[2]+b[2];return dest;},/**
     * Transforms a four-element vector by a 4x4 projection matrix.
     *
     * @method projectVec4
     * @param {Number[]} p 3D View-space coordinate
     * @param {Number[]} q 2D Projected coordinate
     * @returns {Number[]} 2D Projected coordinate
     * @static
     */projectVec4:function projectVec4(p,q){var f=1.0/p[3];q=q||math.vec2();q[0]=p[0]*f;q[1]=p[1]*f;return q;},/**
     * Unprojects a three-element vector.
     *
     * @method unprojectVec3
     * @param {Number[]} p 3D Projected coordinate
     * @param {Number[]} viewMat View matrix
     * @returns {Number[]} projMat Projection matrix
     * @static
     */unprojectVec3:function(){var mat=new FloatArrayType(16);var mat2=new FloatArrayType(16);var mat3=new FloatArrayType(16);return function(p,viewMat,projMat,q){return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat,mat),this.inverseMat4(projMat,mat2),mat3),p,q);};}(),/**
     * Linearly interpolates between two 3D vectors.
     * @method lerpVec3
     * @static
     */lerpVec3:function lerpVec3(t,t1,t2,p1,p2,dest){var result=dest||math.vec3();var f=(t-t1)/(t2-t1);result[0]=p1[0]+f*(p2[0]-p1[0]);result[1]=p1[1]+f*(p2[1]-p1[1]);result[2]=p1[2]+f*(p2[2]-p1[2]);return result;},/**
     * Linearly interpolates between two 4x4 matrices.
     * @method lerpMat4
     * @static
     */lerpMat4:function lerpMat4(t,t1,t2,m1,m2,dest){var result=dest||math.mat4();var f=(t-t1)/(t2-t1);result[0]=m1[0]+f*(m2[0]-m1[0]);result[1]=m1[1]+f*(m2[1]-m1[1]);result[2]=m1[2]+f*(m2[2]-m1[2]);result[3]=m1[3]+f*(m2[3]-m1[3]);result[4]=m1[4]+f*(m2[4]-m1[4]);result[5]=m1[5]+f*(m2[5]-m1[5]);result[6]=m1[6]+f*(m2[6]-m1[6]);result[7]=m1[7]+f*(m2[7]-m1[7]);result[8]=m1[8]+f*(m2[8]-m1[8]);result[9]=m1[9]+f*(m2[9]-m1[9]);result[10]=m1[10]+f*(m2[10]-m1[10]);result[11]=m1[11]+f*(m2[11]-m1[11]);result[12]=m1[12]+f*(m2[12]-m1[12]);result[13]=m1[13]+f*(m2[13]-m1[13]);result[14]=m1[14]+f*(m2[14]-m1[14]);result[15]=m1[15]+f*(m2[15]-m1[15]);return result;},/**
     * Flattens a two-dimensional array into a one-dimensional array.
     *
     * @method flatten
     * @static
     * @param {Array of Arrays} a A 2D array
     * @returns Flattened 1D array
     */flatten:function flatten(a){var result=[];var i;var leni;var j;var lenj;var item;for(i=0,leni=a.length;i<leni;i++){item=a[i];for(j=0,lenj=item.length;j<lenj;j++){result.push(item[j]);}}return result;},identityQuaternion:function identityQuaternion(){var dest=arguments.length>0&&arguments[0]!==undefined?arguments[0]:math.vec4();dest[0]=0.0;dest[1]=0.0;dest[2]=0.0;dest[3]=1.0;return dest;},/**
     * Initializes a quaternion from Euler angles.
     *
     * @param {Number[]} euler The Euler angles.
     * @param {String} order Euler angle order: "XYZ", "YXZ", "ZXY" etc.
     * @param {Number[]} [dest] Destination quaternion, created by default.
     * @returns {Number[]} The quaternion.
     */eulerToQuaternion:function eulerToQuaternion(euler,order){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec4();// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m
var a=euler[0]*math.DEGTORAD/2;var b=euler[1]*math.DEGTORAD/2;var c=euler[2]*math.DEGTORAD/2;var c1=Math.cos(a);var c2=Math.cos(b);var c3=Math.cos(c);var s1=Math.sin(a);var s2=Math.sin(b);var s3=Math.sin(c);if(order==='XYZ'){dest[0]=s1*c2*c3+c1*s2*s3;dest[1]=c1*s2*c3-s1*c2*s3;dest[2]=c1*c2*s3+s1*s2*c3;dest[3]=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){dest[0]=s1*c2*c3+c1*s2*s3;dest[1]=c1*s2*c3-s1*c2*s3;dest[2]=c1*c2*s3-s1*s2*c3;dest[3]=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){dest[0]=s1*c2*c3-c1*s2*s3;dest[1]=c1*s2*c3+s1*c2*s3;dest[2]=c1*c2*s3+s1*s2*c3;dest[3]=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){dest[0]=s1*c2*c3-c1*s2*s3;dest[1]=c1*s2*c3+s1*c2*s3;dest[2]=c1*c2*s3-s1*s2*c3;dest[3]=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){dest[0]=s1*c2*c3+c1*s2*s3;dest[1]=c1*s2*c3+s1*c2*s3;dest[2]=c1*c2*s3-s1*s2*c3;dest[3]=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){dest[0]=s1*c2*c3-c1*s2*s3;dest[1]=c1*s2*c3-s1*c2*s3;dest[2]=c1*c2*s3+s1*s2*c3;dest[3]=c1*c2*c3+s1*s2*s3;}return dest;},mat4ToQuaternion:function mat4ToQuaternion(m){var dest=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec4();// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var m11=m[0];var m12=m[4];var m13=m[8];var m21=m[1];var m22=m[5];var m23=m[9];var m31=m[2];var m32=m[6];var m33=m[10];var s;var trace=m11+m22+m33;if(trace>0){s=0.5/Math.sqrt(trace+1.0);dest[3]=0.25/s;dest[0]=(m32-m23)*s;dest[1]=(m13-m31)*s;dest[2]=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);dest[3]=(m32-m23)/s;dest[0]=0.25*s;dest[1]=(m12+m21)/s;dest[2]=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);dest[3]=(m13-m31)/s;dest[0]=(m12+m21)/s;dest[1]=0.25*s;dest[2]=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);dest[3]=(m21-m12)/s;dest[0]=(m13+m31)/s;dest[1]=(m23+m32)/s;dest[2]=0.25*s;}return dest;},vec3PairToQuaternion:function vec3PairToQuaternion(u,v){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec4();var norm_u_norm_v=Math.sqrt(math.dotVec3(u,u)*math.dotVec3(v,v));var real_part=norm_u_norm_v+math.dotVec3(u,v);if(real_part<0.00000001*norm_u_norm_v){// If u and v are exactly opposite, rotate 180 degrees
// around an arbitrary orthogonal axis. Axis normalisation
// can happen later, when we normalise the quaternion.
real_part=0.0;if(Math.abs(u[0])>Math.abs(u[2])){dest[0]=-u[1];dest[1]=u[0];dest[2]=0;}else{dest[0]=0;dest[1]=-u[2];dest[2]=u[1];}}else{// Otherwise, build quaternion the standard way.
math.cross3Vec3(u,v,dest);}dest[3]=real_part;return math.normalizeQuaternion(dest);},angleAxisToQuaternion:function angleAxisToQuaternion(angleAxis){var dest=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec4();var halfAngle=angleAxis[3]/2.0;var fsin=Math.sin(halfAngle);dest[0]=fsin*angleAxis[0];dest[1]=fsin*angleAxis[1];dest[2]=fsin*angleAxis[2];dest[3]=Math.cos(halfAngle);return dest;},quaternionToEuler:function(){var mat=new FloatArrayType(16);return function(q,order,dest){dest=dest||math.vec3();math.quaternionToRotationMat4(q,mat);math.mat4ToEuler(mat,order,dest);return dest;};}(),mulQuaternions:function mulQuaternions(p,q){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec4();var p0=p[0];var p1=p[1];var p2=p[2];var p3=p[3];var q0=q[0];var q1=q[1];var q2=q[2];var q3=q[3];dest[0]=p3*q0+p0*q3+p1*q2-p2*q1;dest[1]=p3*q1+p1*q3+p2*q0-p0*q2;dest[2]=p3*q2+p2*q3+p0*q1-p1*q0;dest[3]=p3*q3-p0*q0-p1*q1-p2*q2;return dest;},vec3ApplyQuaternion:function vec3ApplyQuaternion(q,vec){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:math.vec3();var x=vec[0];var y=vec[1];var z=vec[2];var qx=q[0];var qy=q[1];var qz=q[2];var qw=q[3];// calculate quat * vector
var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
dest[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy;dest[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz;dest[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx;return dest;},quaternionToMat4:function quaternionToMat4(q,dest){dest=math.identityMat4(dest);var q0=q[0];//x
var q1=q[1];//y
var q2=q[2];//z
var q3=q[3];//w
var tx=2.0*q0;var ty=2.0*q1;var tz=2.0*q2;var twx=tx*q3;var twy=ty*q3;var twz=tz*q3;var txx=tx*q0;var txy=ty*q0;var txz=tz*q0;var tyy=ty*q1;var tyz=tz*q1;var tzz=tz*q2;dest[0]=1.0-(tyy+tzz);dest[1]=txy+twz;dest[2]=txz-twy;dest[4]=txy-twz;dest[5]=1.0-(txx+tzz);dest[6]=tyz+twx;dest[8]=txz+twy;dest[9]=tyz-twx;dest[10]=1.0-(txx+tyy);return dest;},quaternionToRotationMat4:function quaternionToRotationMat4(q,m){var x=q[0];var y=q[1];var z=q[2];var w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;m[0]=1-(yy+zz);m[4]=xy-wz;m[8]=xz+wy;m[1]=xy+wz;m[5]=1-(xx+zz);m[9]=yz-wx;m[2]=xz-wy;m[6]=yz+wx;m[10]=1-(xx+yy);// last column
m[3]=0;m[7]=0;m[11]=0;// bottom row
m[12]=0;m[13]=0;m[14]=0;m[15]=1;return m;},normalizeQuaternion:function normalizeQuaternion(q){var dest=arguments.length>1&&arguments[1]!==undefined?arguments[1]:q;var len=math.lenVec4([q[0],q[1],q[2],q[3]]);dest[0]=q[0]/len;dest[1]=q[1]/len;dest[2]=q[2]/len;dest[3]=q[3]/len;return dest;},conjugateQuaternion:function conjugateQuaternion(q){var dest=arguments.length>1&&arguments[1]!==undefined?arguments[1]:q;dest[0]=-q[0];dest[1]=-q[1];dest[2]=-q[2];dest[3]=q[3];return dest;},inverseQuaternion:function inverseQuaternion(q,dest){return math.normalizeQuaternion(math.conjugateQuaternion(q,dest));},quaternionToAngleAxis:function quaternionToAngleAxis(q){var angleAxis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec4();q=math.normalizeQuaternion(q,tempVec4$1);var q3=q[3];var angle=2*Math.acos(q3);var s=Math.sqrt(1-q3*q3);if(s<0.001){// test to avoid divide by zero, s is always positive due to sqrt
angleAxis[0]=q[0];angleAxis[1]=q[1];angleAxis[2]=q[2];}else{angleAxis[0]=q[0]/s;angleAxis[1]=q[1]/s;angleAxis[2]=q[2]/s;}angleAxis[3]=angle;// * 57.295779579;
return angleAxis;},//------------------------------------------------------------------------------------------------------------------
// Boundaries
//------------------------------------------------------------------------------------------------------------------
/**
     * Returns a new, uninitialized 3D axis-aligned bounding box.
     *
     * @private
     */AABB3:function AABB3(values){return new FloatArrayType(values||6);},/**
     * Returns a new, uninitialized 2D axis-aligned bounding box.
     *
     * @private
     */AABB2:function AABB2(values){return new FloatArrayType(values||4);},/**
     * Returns a new, uninitialized 3D oriented bounding box (OBB).
     *
     * @private
     */OBB3:function OBB3(values){return new FloatArrayType(values||32);},/**
     * Returns a new, uninitialized 2D oriented bounding box (OBB).
     *
     * @private
     */OBB2:function OBB2(values){return new FloatArrayType(values||16);},/** Returns a new 3D bounding sphere */Sphere3:function Sphere3(x,y,z,r){return new FloatArrayType([x,y,z,r]);},/**
     * Transforms an OBB3 by a 4x4 matrix.
     *
     * @private
     */transformOBB3:function transformOBB3(m,p){var p2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:p;var i;var len=p.length;var x;var y;var z;var m0=m[0];var m1=m[1];var m2=m[2];var m3=m[3];var m4=m[4];var m5=m[5];var m6=m[6];var m7=m[7];var m8=m[8];var m9=m[9];var m10=m[10];var m11=m[11];var m12=m[12];var m13=m[13];var m14=m[14];var m15=m[15];for(i=0;i<len;i+=4){x=p[i+0];y=p[i+1];z=p[i+2];p2[i+0]=m0*x+m4*y+m8*z+m12;p2[i+1]=m1*x+m5*y+m9*z+m13;p2[i+2]=m2*x+m6*y+m10*z+m14;p2[i+3]=m3*x+m7*y+m11*z+m15;}return p2;},/** Returns true if the first AABB contains the second AABB.
     * @param aabb1
     * @param aabb2
     * @returns {Boolean}
     */containsAABB3:function containsAABB3(aabb1,aabb2){var result=aabb1[0]<=aabb2[0]&&aabb2[3]<=aabb1[3]&&aabb1[1]<=aabb2[1]&&aabb2[4]<=aabb1[4]&&aabb1[2]<=aabb2[2]&&aabb2[5]<=aabb1[5];return result;},/**
     * Gets the diagonal size of an AABB3 given as minima and maxima.
     *
     * @private
     */getAABB3Diag:function(){var min=new FloatArrayType(3);var max=new FloatArrayType(3);var tempVec3=new FloatArrayType(3);return function(aabb){min[0]=aabb[0];min[1]=aabb[1];min[2]=aabb[2];max[0]=aabb[3];max[1]=aabb[4];max[2]=aabb[5];math.subVec3(max,min,tempVec3);return Math.abs(math.lenVec3(tempVec3));};}(),/**
     * Get a diagonal boundary size that is symmetrical about the given point.
     *
     * @private
     */getAABB3DiagPoint:function(){var min=new FloatArrayType(3);var max=new FloatArrayType(3);var tempVec3=new FloatArrayType(3);return function(aabb,p){min[0]=aabb[0];min[1]=aabb[1];min[2]=aabb[2];max[0]=aabb[3];max[1]=aabb[4];max[2]=aabb[5];var diagVec=math.subVec3(max,min,tempVec3);var xneg=p[0]-aabb[0];var xpos=aabb[3]-p[0];var yneg=p[1]-aabb[1];var ypos=aabb[4]-p[1];var zneg=p[2]-aabb[2];var zpos=aabb[5]-p[2];diagVec[0]+=xneg>xpos?xneg:xpos;diagVec[1]+=yneg>ypos?yneg:ypos;diagVec[2]+=zneg>zpos?zneg:zpos;return Math.abs(math.lenVec3(diagVec));};}(),/**
     * Gets the area of an AABB.
     *
     * @private
     */getAABB3Area:function getAABB3Area(aabb){var width=aabb[3]-aabb[0];var height=aabb[4]-aabb[1];var depth=aabb[5]-aabb[2];return width*height*depth;},/**
     * Gets the center of an AABB.
     *
     * @private
     */getAABB3Center:function getAABB3Center(aabb,dest){var r=dest||math.vec3();r[0]=(aabb[0]+aabb[3])/2;r[1]=(aabb[1]+aabb[4])/2;r[2]=(aabb[2]+aabb[5])/2;return r;},/**
     * Gets the center of a 2D AABB.
     *
     * @private
     */getAABB2Center:function getAABB2Center(aabb,dest){var r=dest||math.vec2();r[0]=(aabb[2]+aabb[0])/2;r[1]=(aabb[3]+aabb[1])/2;return r;},/**
     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.
     * Creates new AABB if none supplied.
     *
     * @private
     */collapseAABB3:function collapseAABB3(){var aabb=arguments.length>0&&arguments[0]!==undefined?arguments[0]:math.AABB3();aabb[0]=math.MAX_DOUBLE;aabb[1]=math.MAX_DOUBLE;aabb[2]=math.MAX_DOUBLE;aabb[3]=math.MIN_DOUBLE;aabb[4]=math.MIN_DOUBLE;aabb[5]=math.MIN_DOUBLE;return aabb;},/**
     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of
     * an array of eight 3D positions, one for each corner of the boundary.
     *
     * @private
     */AABB3ToOBB3:function AABB3ToOBB3(aabb){var obb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.OBB3();obb[0]=aabb[0];obb[1]=aabb[1];obb[2]=aabb[2];obb[3]=1;obb[4]=aabb[3];obb[5]=aabb[1];obb[6]=aabb[2];obb[7]=1;obb[8]=aabb[3];obb[9]=aabb[4];obb[10]=aabb[2];obb[11]=1;obb[12]=aabb[0];obb[13]=aabb[4];obb[14]=aabb[2];obb[15]=1;obb[16]=aabb[0];obb[17]=aabb[1];obb[18]=aabb[5];obb[19]=1;obb[20]=aabb[3];obb[21]=aabb[1];obb[22]=aabb[5];obb[23]=1;obb[24]=aabb[3];obb[25]=aabb[4];obb[26]=aabb[5];obb[27]=1;obb[28]=aabb[0];obb[29]=aabb[4];obb[30]=aabb[5];obb[31]=1;return obb;},/**
     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
     *
     * @private
     */positions3ToAABB3:function(){var p=new FloatArrayType(3);return function(positions,aabb,positionsDecodeMatrix){aabb=aabb||math.AABB3();var xmin=math.MAX_DOUBLE;var ymin=math.MAX_DOUBLE;var zmin=math.MAX_DOUBLE;var xmax=math.MIN_DOUBLE;var ymax=math.MIN_DOUBLE;var zmax=math.MIN_DOUBLE;var x;var y;var z;for(var _i16=0,len=positions.length;_i16<len;_i16+=3){if(positionsDecodeMatrix){p[0]=positions[_i16+0];p[1]=positions[_i16+1];p[2]=positions[_i16+2];math.decompressPosition(p,positionsDecodeMatrix,p);x=p[0];y=p[1];z=p[2];}else{x=positions[_i16+0];y=positions[_i16+1];z=positions[_i16+2];}if(x<xmin){xmin=x;}if(y<ymin){ymin=y;}if(z<zmin){zmin=z;}if(x>xmax){xmax=x;}if(y>ymax){ymax=y;}if(z>zmax){zmax=z;}}aabb[0]=xmin;aabb[1]=ymin;aabb[2]=zmin;aabb[3]=xmax;aabb[4]=ymax;aabb[5]=zmax;return aabb;};}(),/**
     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
     *
     * @private
     */OBB3ToAABB3:function OBB3ToAABB3(obb){var aabb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.AABB3();var xmin=math.MAX_DOUBLE;var ymin=math.MAX_DOUBLE;var zmin=math.MAX_DOUBLE;var xmax=math.MIN_DOUBLE;var ymax=math.MIN_DOUBLE;var zmax=math.MIN_DOUBLE;var x;var y;var z;for(var _i17=0,len=obb.length;_i17<len;_i17+=4){x=obb[_i17+0];y=obb[_i17+1];z=obb[_i17+2];if(x<xmin){xmin=x;}if(y<ymin){ymin=y;}if(z<zmin){zmin=z;}if(x>xmax){xmax=x;}if(y>ymax){ymax=y;}if(z>zmax){zmax=z;}}aabb[0]=xmin;aabb[1]=ymin;aabb[2]=zmin;aabb[3]=xmax;aabb[4]=ymax;aabb[5]=zmax;return aabb;},/**
     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.
     *
     * @private
     */points3ToAABB3:function points3ToAABB3(points){var aabb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.AABB3();var xmin=math.MAX_DOUBLE;var ymin=math.MAX_DOUBLE;var zmin=math.MAX_DOUBLE;var xmax=math.MIN_DOUBLE;var ymax=math.MIN_DOUBLE;var zmax=math.MIN_DOUBLE;var x;var y;var z;for(var _i18=0,len=points.length;_i18<len;_i18++){x=points[_i18][0];y=points[_i18][1];z=points[_i18][2];if(x<xmin){xmin=x;}if(y<ymin){ymin=y;}if(z<zmin){zmin=z;}if(x>xmax){xmax=x;}if(y>ymax){ymax=y;}if(z>zmax){zmax=z;}}aabb[0]=xmin;aabb[1]=ymin;aabb[2]=zmin;aabb[3]=xmax;aabb[4]=ymax;aabb[5]=zmax;return aabb;},/**
     * Finds the minimum boundary sphere enclosing the given 3D points.
     *
     * @private
     */points3ToSphere3:function(){var tempVec3=new FloatArrayType(3);return function(points,sphere){sphere=sphere||math.vec4();var x=0;var y=0;var z=0;var i;var numPoints=points.length;for(i=0;i<numPoints;i++){x+=points[i][0];y+=points[i][1];z+=points[i][2];}sphere[0]=x/numPoints;sphere[1]=y/numPoints;sphere[2]=z/numPoints;var radius=0;var dist;for(i=0;i<numPoints;i++){dist=Math.abs(math.lenVec3(math.subVec3(points[i],sphere,tempVec3)));if(dist>radius){radius=dist;}}sphere[3]=radius;return sphere;};}(),/**
     * Finds the minimum boundary sphere enclosing the given 3D positions.
     *
     * @private
     */positions3ToSphere3:function(){var tempVec3a=new FloatArrayType(3);var tempVec3b=new FloatArrayType(3);return function(positions,sphere){sphere=sphere||math.vec4();var x=0;var y=0;var z=0;var i;var lenPositions=positions.length;var radius=0;for(i=0;i<lenPositions;i+=3){x+=positions[i];y+=positions[i+1];z+=positions[i+2];}var numPositions=lenPositions/3;sphere[0]=x/numPositions;sphere[1]=y/numPositions;sphere[2]=z/numPositions;var dist;for(i=0;i<lenPositions;i+=3){tempVec3a[0]=positions[i];tempVec3a[1]=positions[i+1];tempVec3a[2]=positions[i+2];dist=Math.abs(math.lenVec3(math.subVec3(tempVec3a,sphere,tempVec3b)));if(dist>radius){radius=dist;}}sphere[3]=radius;return sphere;};}(),/**
     * Finds the minimum boundary sphere enclosing the given 3D points.
     *
     * @private
     */OBB3ToSphere3:function(){var point=new FloatArrayType(3);var tempVec3=new FloatArrayType(3);return function(points,sphere){sphere=sphere||math.vec4();var x=0;var y=0;var z=0;var i;var lenPoints=points.length;var numPoints=lenPoints/4;for(i=0;i<lenPoints;i+=4){x+=points[i+0];y+=points[i+1];z+=points[i+2];}sphere[0]=x/numPoints;sphere[1]=y/numPoints;sphere[2]=z/numPoints;var radius=0;var dist;for(i=0;i<lenPoints;i+=4){point[0]=points[i+0];point[1]=points[i+1];point[2]=points[i+2];dist=Math.abs(math.lenVec3(math.subVec3(point,sphere,tempVec3)));if(dist>radius){radius=dist;}}sphere[3]=radius;return sphere;};}(),/**
     * Gets the center of a bounding sphere.
     *
     * @private
     */getSphere3Center:function getSphere3Center(sphere){var dest=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec3();dest[0]=sphere[0];dest[1]=sphere[1];dest[2]=sphere[2];return dest;},/**
     * Gets the 3D center of the given flat array of 3D positions.
     *
     * @private
     */getPositionsCenter:function getPositionsCenter(positions){var center=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec3();var xCenter=0;var yCenter=0;var zCenter=0;for(var i=0,len=positions.length;i<len;i+=3){xCenter+=positions[i+0];yCenter+=positions[i+1];zCenter+=positions[i+2];}var numPositions=positions.length/3;center[0]=xCenter/numPositions;center[1]=yCenter/numPositions;center[2]=zCenter/numPositions;return center;},/**
     * Expands the first axis-aligned 3D boundary to enclose the second, if required.
     *
     * @private
     */expandAABB3:function expandAABB3(aabb1,aabb2){if(aabb1[0]>aabb2[0]){aabb1[0]=aabb2[0];}if(aabb1[1]>aabb2[1]){aabb1[1]=aabb2[1];}if(aabb1[2]>aabb2[2]){aabb1[2]=aabb2[2];}if(aabb1[3]<aabb2[3]){aabb1[3]=aabb2[3];}if(aabb1[4]<aabb2[4]){aabb1[4]=aabb2[4];}if(aabb1[5]<aabb2[5]){aabb1[5]=aabb2[5];}return aabb1;},/**
     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.
     *
     * @private
     */expandAABB3Point3:function expandAABB3Point3(aabb,p){if(aabb[0]>p[0]){aabb[0]=p[0];}if(aabb[1]>p[1]){aabb[1]=p[1];}if(aabb[2]>p[2]){aabb[2]=p[2];}if(aabb[3]<p[0]){aabb[3]=p[0];}if(aabb[4]<p[1]){aabb[4]=p[1];}if(aabb[5]<p[2]){aabb[5]=p[2];}return aabb;},/**
     * Expands an axis-aligned 3D boundary to enclose the given points, if needed.
     *
     * @private
     */expandAABB3Points3:function expandAABB3Points3(aabb,positions){var x;var y;var z;for(var i=0,len=positions.length;i<len;i+=3){x=positions[i];y=positions[i+1];z=positions[i+2];if(aabb[0]>x){aabb[0]=x;}if(aabb[1]>y){aabb[1]=y;}if(aabb[2]>z){aabb[2]=z;}if(aabb[3]<x){aabb[3]=x;}if(aabb[4]<y){aabb[4]=y;}if(aabb[5]<z){aabb[5]=z;}}return aabb;},/**
     * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.
     * Creates new AABB if none supplied.
     *
     * @private
     */collapseAABB2:function collapseAABB2(){var aabb=arguments.length>0&&arguments[0]!==undefined?arguments[0]:math.AABB2();aabb[0]=math.MAX_DOUBLE;aabb[1]=math.MAX_DOUBLE;aabb[2]=math.MIN_DOUBLE;aabb[3]=math.MIN_DOUBLE;return aabb;},point3AABB3Intersect:function point3AABB3Intersect(aabb,p){return aabb[0]>p[0]||aabb[3]<p[0]||aabb[1]>p[1]||aabb[4]<p[1]||aabb[2]>p[2]||aabb[5]<p[2];},/**
     *
     * @param dir
     * @param constant
     * @param aabb
     * @returns {number}
     */planeAABB3Intersect:function planeAABB3Intersect(dir,constant,aabb){var min,max;if(dir[0]>0){min=dir[0]*aabb[0];max=dir[0]*aabb[3];}else{min=dir[0]*aabb[3];max=dir[0]*aabb[0];}if(dir[1]>0){min+=dir[1]*aabb[1];max+=dir[1]*aabb[4];}else{min+=dir[1]*aabb[4];max+=dir[1]*aabb[1];}if(dir[2]>0){min+=dir[2]*aabb[2];max+=dir[2]*aabb[5];}else{min+=dir[2]*aabb[5];max+=dir[2]*aabb[2];}var outside=min<=-constant&&max<=-constant;if(outside){return-1;}var inside=min>=-constant&&max>=-constant;if(inside){return 1;}return 0;},/**
     * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.
     *
     * @private
     */OBB3ToAABB2:function OBB3ToAABB2(points){var aabb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.AABB2();var xmin=math.MAX_DOUBLE;var ymin=math.MAX_DOUBLE;var xmax=math.MIN_DOUBLE;var ymax=math.MIN_DOUBLE;var x;var y;var w;var f;for(var _i19=0,len=points.length;_i19<len;_i19+=4){x=points[_i19+0];y=points[_i19+1];w=points[_i19+3]||1.0;f=1.0/w;x*=f;y*=f;if(x<xmin){xmin=x;}if(y<ymin){ymin=y;}if(x>xmax){xmax=x;}if(y>ymax){ymax=y;}}aabb[0]=xmin;aabb[1]=ymin;aabb[2]=xmax;aabb[3]=ymax;return aabb;},/**
     * Expands the first axis-aligned 2D boundary to enclose the second, if required.
     *
     * @private
     */expandAABB2:function expandAABB2(aabb1,aabb2){if(aabb1[0]>aabb2[0]){aabb1[0]=aabb2[0];}if(aabb1[1]>aabb2[1]){aabb1[1]=aabb2[1];}if(aabb1[2]<aabb2[2]){aabb1[2]=aabb2[2];}if(aabb1[3]<aabb2[3]){aabb1[3]=aabb2[3];}return aabb1;},/**
     * Expands an axis-aligned 2D boundary to enclose the given point, if required.
     *
     * @private
     */expandAABB2Point2:function expandAABB2Point2(aabb,p){if(aabb[0]>p[0]){aabb[0]=p[0];}if(aabb[1]>p[1]){aabb[1]=p[1];}if(aabb[2]<p[0]){aabb[2]=p[0];}if(aabb[3]<p[1]){aabb[3]=p[1];}return aabb;},AABB2ToCanvas:function AABB2ToCanvas(aabb,canvasWidth,canvasHeight){var aabb2=arguments.length>3&&arguments[3]!==undefined?arguments[3]:aabb;var xmin=(aabb[0]+1.0)*0.5;var ymin=(aabb[1]+1.0)*0.5;var xmax=(aabb[2]+1.0)*0.5;var ymax=(aabb[3]+1.0)*0.5;aabb2[0]=Math.floor(xmin*canvasWidth);aabb2[1]=canvasHeight-Math.floor(ymax*canvasHeight);aabb2[2]=Math.floor(xmax*canvasWidth);aabb2[3]=canvasHeight-Math.floor(ymin*canvasHeight);return aabb2;},//------------------------------------------------------------------------------------------------------------------
// Curves
//------------------------------------------------------------------------------------------------------------------
tangentQuadraticBezier:function tangentQuadraticBezier(t,p0,p1,p2){return 2*(1-t)*(p1-p0)+2*t*(p2-p1);},tangentQuadraticBezier3:function tangentQuadraticBezier3(t,p0,p1,p2,p3){return-3*p0*(1-t)*(1-t)+3*p1*(1-t)*(1-t)-6*t*p1*(1-t)+6*t*p2*(1-t)-3*t*t*p2+3*t*t*p3;},tangentSpline:function tangentSpline(t){var h00=6*t*t-6*t;var h10=3*t*t-4*t+1;var h01=-6*t*t+6*t;var h11=3*t*t-2*t;return h00+h10+h01+h11;},catmullRomInterpolate:function catmullRomInterpolate(p0,p1,p2,p3,t){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;},// Bezier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve
// Quad Bezier Functions
b2p0:function b2p0(t,p){var k=1-t;return k*k*p;},b2p1:function b2p1(t,p){return 2*(1-t)*t*p;},b2p2:function b2p2(t,p){return t*t*p;},b2:function b2(t,p0,p1,p2){return this.b2p0(t,p0)+this.b2p1(t,p1)+this.b2p2(t,p2);},// Cubic Bezier Functions
b3p0:function b3p0(t,p){var k=1-t;return k*k*k*p;},b3p1:function b3p1(t,p){var k=1-t;return 3*k*k*t*p;},b3p2:function b3p2(t,p){var k=1-t;return 3*k*t*t*p;},b3p3:function b3p3(t,p){return t*t*t*p;},b3:function b3(t,p0,p1,p2,p3){return this.b3p0(t,p0)+this.b3p1(t,p1)+this.b3p2(t,p2)+this.b3p3(t,p3);},//------------------------------------------------------------------------------------------------------------------
// Geometry
//------------------------------------------------------------------------------------------------------------------
/**
     * Calculates the normal vector of a triangle.
     *
     * @private
     */triangleNormal:function triangleNormal(a,b,c){var normal=arguments.length>3&&arguments[3]!==undefined?arguments[3]:math.vec3();var p1x=b[0]-a[0];var p1y=b[1]-a[1];var p1z=b[2]-a[2];var p2x=c[0]-a[0];var p2y=c[1]-a[1];var p2z=c[2]-a[2];var p3x=p1y*p2z-p1z*p2y;var p3y=p1z*p2x-p1x*p2z;var p3z=p1x*p2y-p1y*p2x;var mag=Math.sqrt(p3x*p3x+p3y*p3y+p3z*p3z);if(mag===0){normal[0]=0;normal[1]=0;normal[2]=0;}else{normal[0]=p3x/mag;normal[1]=p3y/mag;normal[2]=p3z/mag;}return normal;},/**
     * Finds the intersection of a 3D ray with a 3D triangle.
     *
     * @private
     */rayTriangleIntersect:function(){var tempVec3=new FloatArrayType(3);var tempVec3b=new FloatArrayType(3);var tempVec3c=new FloatArrayType(3);var tempVec3d=new FloatArrayType(3);var tempVec3e=new FloatArrayType(3);return function(origin,dir,a,b,c,isect){isect=isect||math.vec3();var EPSILON=0.000001;var edge1=math.subVec3(b,a,tempVec3);var edge2=math.subVec3(c,a,tempVec3b);var pvec=math.cross3Vec3(dir,edge2,tempVec3c);var det=math.dotVec3(edge1,pvec);if(det<EPSILON){return null;}var tvec=math.subVec3(origin,a,tempVec3d);var u=math.dotVec3(tvec,pvec);if(u<0||u>det){return null;}var qvec=math.cross3Vec3(tvec,edge1,tempVec3e);var v=math.dotVec3(dir,qvec);if(v<0||u+v>det){return null;}var t=math.dotVec3(edge2,qvec)/det;isect[0]=origin[0]+t*dir[0];isect[1]=origin[1]+t*dir[1];isect[2]=origin[2]+t*dir[2];return isect;};}(),/**
     * Finds the intersection of a 3D ray with a plane defined by 3 points.
     *
     * @private
     */rayPlaneIntersect:function(){var tempVec3=new FloatArrayType(3);var tempVec3b=new FloatArrayType(3);var tempVec3c=new FloatArrayType(3);var tempVec3d=new FloatArrayType(3);return function(origin,dir,a,b,c,isect){isect=isect||math.vec3();dir=math.normalizeVec3(dir,tempVec3);var edge1=math.subVec3(b,a,tempVec3b);var edge2=math.subVec3(c,a,tempVec3c);var n=math.cross3Vec3(edge1,edge2,tempVec3d);math.normalizeVec3(n,n);var d=-math.dotVec3(a,n);var t=-(math.dotVec3(origin,n)+d)/math.dotVec3(dir,n);isect[0]=origin[0]+t*dir[0];isect[1]=origin[1]+t*dir[1];isect[2]=origin[2]+t*dir[2];return isect;};}(),/**
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     *
     * @private
     */cartesianToBarycentric:function(){var tempVec3=new FloatArrayType(3);var tempVec3b=new FloatArrayType(3);var tempVec3c=new FloatArrayType(3);return function(cartesian,a,b,c,dest){var v0=math.subVec3(c,a,tempVec3);var v1=math.subVec3(b,a,tempVec3b);var v2=math.subVec3(cartesian,a,tempVec3c);var dot00=math.dotVec3(v0,v0);var dot01=math.dotVec3(v0,v1);var dot02=math.dotVec3(v0,v2);var dot11=math.dotVec3(v1,v1);var dot12=math.dotVec3(v1,v2);var denom=dot00*dot11-dot01*dot01;// Colinear or singular triangle
if(denom===0){// Arbitrary location outside of triangle
return null;}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;dest[0]=1-u-v;dest[1]=v;dest[2]=u;return dest;};}(),/**
     * Returns true if the given barycentric coordinates are within their triangle.
     *
     * @private
     */barycentricInsideTriangle:function barycentricInsideTriangle(bary){var v=bary[1];var u=bary[2];return u>=0&&v>=0&&u+v<1;},/**
     * Gets cartesian coordinates from barycentric coordinates within a triangle.
     *
     * @private
     */barycentricToCartesian:function barycentricToCartesian(bary,a,b,c){var cartesian=arguments.length>4&&arguments[4]!==undefined?arguments[4]:math.vec3();var u=bary[0];var v=bary[1];var w=bary[2];cartesian[0]=a[0]*u+b[0]*v+c[0]*w;cartesian[1]=a[1]*u+b[1]*v+c[1]*w;cartesian[2]=a[2]*u+b[2]*v+c[2]*w;return cartesian;},/**
     * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns
     * modified arrays that have duplicate vertices removed.
     *
     * Note: does not work well when co-incident vertices have same positions but different normals and UVs.
     *
     * @param positions
     * @param normals
     * @param uv
     * @param indices
     * @returns {{positions: Array, indices: Array}}
     * @private
     */mergeVertices:function mergeVertices(positions,normals,uv,indices){var positionsMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var indicesLookup=[];var uniquePositions=[];var uniqueNormals=normals?[]:null;var uniqueUV=uv?[]:null;var indices2=[];var vx;var vy;var vz;var key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i;var len;var uvi=0;for(i=0,len=positions.length;i<len;i+=3){vx=positions[i];vy=positions[i+1];vz=positions[i+2];key="".concat(Math.round(vx*precision),"_").concat(Math.round(vy*precision),"_").concat(Math.round(vz*precision));if(positionsMap[key]===undefined){positionsMap[key]=uniquePositions.length/3;uniquePositions.push(vx);uniquePositions.push(vy);uniquePositions.push(vz);if(normals){uniqueNormals.push(normals[i]);uniqueNormals.push(normals[i+1]);uniqueNormals.push(normals[i+2]);}if(uv){uniqueUV.push(uv[uvi]);uniqueUV.push(uv[uvi+1]);}}indicesLookup[i/3]=positionsMap[key];uvi+=2;}for(i=0,len=indices.length;i<len;i++){indices2[i]=indicesLookup[indices[i]];}var result={positions:uniquePositions,indices:indices2};if(uniqueNormals){result.normals=uniqueNormals;}if(uniqueUV){result.uv=uniqueUV;}return result;},/**
     * Builds normal vectors from positions and indices.
     *
     * @private
     */buildNormals:function(){var a=new FloatArrayType(3);var b=new FloatArrayType(3);var c=new FloatArrayType(3);var ab=new FloatArrayType(3);var ac=new FloatArrayType(3);var crossVec=new FloatArrayType(3);return function(positions,indices,normals){var i;var len;var nvecs=new Array(positions.length/3);var j0;var j1;var j2;for(i=0,len=indices.length;i<len;i+=3){j0=indices[i];j1=indices[i+1];j2=indices[i+2];a[0]=positions[j0*3];a[1]=positions[j0*3+1];a[2]=positions[j0*3+2];b[0]=positions[j1*3];b[1]=positions[j1*3+1];b[2]=positions[j1*3+2];c[0]=positions[j2*3];c[1]=positions[j2*3+1];c[2]=positions[j2*3+2];math.subVec3(b,a,ab);math.subVec3(c,a,ac);var normVec=math.vec3();math.normalizeVec3(math.cross3Vec3(ab,ac,crossVec),normVec);if(!nvecs[j0]){nvecs[j0]=[];}if(!nvecs[j1]){nvecs[j1]=[];}if(!nvecs[j2]){nvecs[j2]=[];}nvecs[j0].push(normVec);nvecs[j1].push(normVec);nvecs[j2].push(normVec);}normals=normals&&normals.length===positions.length?normals:new Float32Array(positions.length);var count;var x;var y;var z;for(i=0,len=nvecs.length;i<len;i++){// Now go through and average out everything
count=nvecs[i].length;x=0;y=0;z=0;for(var j=0;j<count;j++){x+=nvecs[i][j][0];y+=nvecs[i][j][1];z+=nvecs[i][j][2];}normals[i*3]=x/count;normals[i*3+1]=y/count;normals[i*3+2]=z/count;}return normals;};}(),/**
     * Builds vertex tangent vectors from positions, UVs and indices.
     *
     * @private
     */buildTangents:function(){var tempVec3=new FloatArrayType(3);var tempVec3b=new FloatArrayType(3);var tempVec3c=new FloatArrayType(3);var tempVec3d=new FloatArrayType(3);var tempVec3e=new FloatArrayType(3);var tempVec3f=new FloatArrayType(3);var tempVec3g=new FloatArrayType(3);return function(positions,indices,uv){var tangents=new Float32Array(positions.length);// The vertex arrays needs to be calculated
// before the calculation of the tangents
for(var location=0;location<indices.length;location+=3){// Recontructing each vertex and UV coordinate into the respective vectors
var index=indices[location];var v0=positions.subarray(index*3,index*3+3);var uv0=uv.subarray(index*2,index*2+2);index=indices[location+1];var v1=positions.subarray(index*3,index*3+3);var uv1=uv.subarray(index*2,index*2+2);index=indices[location+2];var v2=positions.subarray(index*3,index*3+3);var uv2=uv.subarray(index*2,index*2+2);var deltaPos1=math.subVec3(v1,v0,tempVec3);var deltaPos2=math.subVec3(v2,v0,tempVec3b);var deltaUV1=math.subVec2(uv1,uv0,tempVec3c);var deltaUV2=math.subVec2(uv2,uv0,tempVec3d);var _r2=1/(deltaUV1[0]*deltaUV2[1]-deltaUV1[1]*deltaUV2[0]);var tangent=math.mulVec3Scalar(math.subVec3(math.mulVec3Scalar(deltaPos1,deltaUV2[1],tempVec3e),math.mulVec3Scalar(deltaPos2,deltaUV1[1],tempVec3f),tempVec3g),_r2,tempVec3f);// Average the value of the vectors
var addTo=void 0;for(var v=0;v<3;v++){addTo=indices[location+v]*3;tangents[addTo]+=tangent[0];tangents[addTo+1]+=tangent[1];tangents[addTo+2]+=tangent[2];}}return tangents;};}(),/**
     * Builds vertex and index arrays needed by color-indexed triangle picking.
     *
     * @private
     */buildPickTriangles:function buildPickTriangles(positions,indices,compressGeometry){var numIndices=indices.length;var pickPositions=compressGeometry?new Uint16Array(numIndices*9):new Float32Array(numIndices*9);var pickColors=new Uint8Array(numIndices*12);var primIndex=0;var vi;// Positions array index
var pvi=0;// Picking positions array index
var pci=0;// Picking color array index
// Triangle indices
var i;var r;var g;var b;var a;for(var location=0;location<numIndices;location+=3){// Primitive-indexed triangle pick color
a=primIndex>>24&0xFF;b=primIndex>>16&0xFF;g=primIndex>>8&0xFF;r=primIndex&0xFF;// A
i=indices[location];vi=i*3;pickPositions[pvi++]=positions[vi];pickPositions[pvi++]=positions[vi+1];pickPositions[pvi++]=positions[vi+2];pickColors[pci++]=r;pickColors[pci++]=g;pickColors[pci++]=b;pickColors[pci++]=a;// B
i=indices[location+1];vi=i*3;pickPositions[pvi++]=positions[vi];pickPositions[pvi++]=positions[vi+1];pickPositions[pvi++]=positions[vi+2];pickColors[pci++]=r;pickColors[pci++]=g;pickColors[pci++]=b;pickColors[pci++]=a;// C
i=indices[location+2];vi=i*3;pickPositions[pvi++]=positions[vi];pickPositions[pvi++]=positions[vi+1];pickPositions[pvi++]=positions[vi+2];pickColors[pci++]=r;pickColors[pci++]=g;pickColors[pci++]=b;pickColors[pci++]=a;primIndex++;}return{positions:pickPositions,colors:pickColors};},/**
     * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles
     * that don't share vertex array elements. Works by finding groups of vertices that have the same location and
     * averaging their normal vectors.
     *
     * @returns {{positions: Array, normals: *}}
     */faceToVertexNormals:function faceToVertexNormals(positions,normals){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var smoothNormalsAngleThreshold=options.smoothNormalsAngleThreshold||20;var vertexMap={};var vertexNormals=[];var vertexNormalAccum={};var acc;var vx;var vy;var vz;var key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var posi;var i;var j;var len;var a;var b;for(i=0,len=positions.length;i<len;i+=3){posi=i/3;vx=positions[i];vy=positions[i+1];vz=positions[i+2];key="".concat(Math.round(vx*precision),"_").concat(Math.round(vy*precision),"_").concat(Math.round(vz*precision));if(vertexMap[key]===undefined){vertexMap[key]=[posi];}else{vertexMap[key].push(posi);}var normal=math.normalizeVec3([normals[i],normals[i+1],normals[i+2]]);vertexNormals[posi]=normal;acc=math.vec4([normal[0],normal[1],normal[2],1]);vertexNormalAccum[posi]=acc;}for(key in vertexMap){if(vertexMap.hasOwnProperty(key)){var vertices=vertexMap[key];var numVerts=vertices.length;for(i=0;i<numVerts;i++){var ii=vertices[i];acc=vertexNormalAccum[ii];for(j=0;j<numVerts;j++){if(i===j){continue;}var jj=vertices[j];a=vertexNormals[ii];b=vertexNormals[jj];var _angle=Math.abs(math.angleVec3(a,b)/math.DEGTORAD);if(_angle<smoothNormalsAngleThreshold){acc[0]+=b[0];acc[1]+=b[1];acc[2]+=b[2];acc[3]+=1.0;}}}}}for(i=0,len=normals.length;i<len;i+=3){acc=vertexNormalAccum[i/3];normals[i+0]=acc[0]/acc[3];normals[i+1]=acc[1]/acc[3];normals[i+2]=acc[2]/acc[3];}},//------------------------------------------------------------------------------------------------------------------
// Ray casting
//------------------------------------------------------------------------------------------------------------------
/**
     Transforms a ray by a matrix.
     @method transformRay
     @static
     @param {Number[]} matrix 4x4 matrix
     @param {Number[]} rayOrigin The ray origin
     @param {Number[]} rayDir The ray direction
     @param {Number[]} rayOriginDest The transformed ray origin
     @param {Number[]} rayDirDest The transformed ray direction
     */transformRay:function(){var tempVec4a=new FloatArrayType(4);var tempVec4b=new FloatArrayType(4);return function(matrix,rayOrigin,rayDir,rayOriginDest,rayDirDest){tempVec4a[0]=rayOrigin[0];tempVec4a[1]=rayOrigin[1];tempVec4a[2]=rayOrigin[2];tempVec4a[3]=1;math.transformVec4(matrix,tempVec4a,tempVec4b);rayOriginDest[0]=tempVec4b[0];rayOriginDest[1]=tempVec4b[1];rayOriginDest[2]=tempVec4b[2];tempVec4a[0]=rayDir[0];tempVec4a[1]=rayDir[1];tempVec4a[2]=rayDir[2];math.transformVec3(matrix,tempVec4a,tempVec4b);math.normalizeVec3(tempVec4b);rayDirDest[0]=tempVec4b[0];rayDirDest[1]=tempVec4b[1];rayDirDest[2]=tempVec4b[2];};}(),/**
     Transforms a Canvas-space position into a World-space ray, in the context of a Camera.
     @method canvasPosToWorldRay
     @static
     @param {Number[]} viewMatrix View matrix
     @param {Number[]} projMatrix Projection matrix
     @param {Number[]} canvasPos The Canvas-space position.
     @param {Number[]} worldRayOrigin The World-space ray origin.
     @param {Number[]} worldRayDir The World-space ray direction.
     */canvasPosToWorldRay:function(){var tempMat4b=new FloatArrayType(16);var tempMat4c=new FloatArrayType(16);var tempVec4a=new FloatArrayType(4);var tempVec4b=new FloatArrayType(4);var tempVec4c=new FloatArrayType(4);var tempVec4d=new FloatArrayType(4);return function(canvas,viewMatrix,projMatrix,canvasPos,worldRayOrigin,worldRayDir){var pvMat=math.mulMat4(projMatrix,viewMatrix,tempMat4b);var pvMatInverse=math.inverseMat4(pvMat,tempMat4c);// Calculate clip space coordinates, which will be in range
// of x=[-1..1] and y=[-1..1], with y=(+1) at top
var canvasWidth=canvas.width;var canvasHeight=canvas.height;var clipX=(canvasPos[0]-canvasWidth/2)/(canvasWidth/2);// Calculate clip space coordinates
var clipY=-(canvasPos[1]-canvasHeight/2)/(canvasHeight/2);tempVec4a[0]=clipX;tempVec4a[1]=clipY;tempVec4a[2]=-1;tempVec4a[3]=1;math.transformVec4(pvMatInverse,tempVec4a,tempVec4b);math.mulVec4Scalar(tempVec4b,1/tempVec4b[3]);tempVec4c[0]=clipX;tempVec4c[1]=clipY;tempVec4c[2]=1;tempVec4c[3]=1;math.transformVec4(pvMatInverse,tempVec4c,tempVec4d);math.mulVec4Scalar(tempVec4d,1/tempVec4d[3]);worldRayOrigin[0]=tempVec4d[0];worldRayOrigin[1]=tempVec4d[1];worldRayOrigin[2]=tempVec4d[2];math.subVec3(tempVec4d,tempVec4b,worldRayDir);math.normalizeVec3(worldRayDir);};}(),/**
     Transforms a Canvas-space position to a Mesh's Local-space coordinate system, in the context of a Camera.
     @method canvasPosToLocalRay
     @static
     @param {Camera} camera The Camera.
     @param {Mesh} mesh The Mesh.
     @param {Number[]} viewMatrix View matrix
     @param {Number[]} projMatrix Projection matrix
     @param {Number[]} worldMatrix Modeling matrix
     @param {Number[]} canvasPos The Canvas-space position.
     @param {Number[]} localRayOrigin The Local-space ray origin.
     @param {Number[]} localRayDir The Local-space ray direction.
     */canvasPosToLocalRay:function(){var worldRayOrigin=new FloatArrayType(3);var worldRayDir=new FloatArrayType(3);return function(canvas,viewMatrix,projMatrix,worldMatrix,canvasPos,localRayOrigin,localRayDir){math.canvasPosToWorldRay(canvas,viewMatrix,projMatrix,canvasPos,worldRayOrigin,worldRayDir);math.worldRayToLocalRay(worldMatrix,worldRayOrigin,worldRayDir,localRayOrigin,localRayDir);};}(),/**
     Transforms a ray from World-space to a Mesh's Local-space coordinate system.
     @method worldRayToLocalRay
     @static
     @param {Number[]} worldMatrix The World transform matrix
     @param {Number[]} worldRayOrigin The World-space ray origin.
     @param {Number[]} worldRayDir The World-space ray direction.
     @param {Number[]} localRayOrigin The Local-space ray origin.
     @param {Number[]} localRayDir The Local-space ray direction.
     */worldRayToLocalRay:function(){var tempMat4=new FloatArrayType(16);var tempVec4a=new FloatArrayType(4);var tempVec4b=new FloatArrayType(4);return function(worldMatrix,worldRayOrigin,worldRayDir,localRayOrigin,localRayDir){var modelMatInverse=math.inverseMat4(worldMatrix,tempMat4);tempVec4a[0]=worldRayOrigin[0];tempVec4a[1]=worldRayOrigin[1];tempVec4a[2]=worldRayOrigin[2];tempVec4a[3]=1;math.transformVec4(modelMatInverse,tempVec4a,tempVec4b);localRayOrigin[0]=tempVec4b[0];localRayOrigin[1]=tempVec4b[1];localRayOrigin[2]=tempVec4b[2];math.transformVec3(modelMatInverse,worldRayDir,localRayDir);};}(),buildKDTree:function(){var KD_TREE_MAX_DEPTH=10;var KD_TREE_MIN_TRIANGLES=20;var dimLength=new Float32Array();function buildNode(triangles,indices,positions,depth){var aabb=new FloatArrayType(6);var node={triangles:null,left:null,right:null,leaf:false,splitDim:0,aabb:aabb};aabb[0]=aabb[1]=aabb[2]=Number.POSITIVE_INFINITY;aabb[3]=aabb[4]=aabb[5]=Number.NEGATIVE_INFINITY;var t;var len;for(t=0,len=triangles.length;t<len;++t){var ii=triangles[t]*3;for(var j=0;j<3;++j){var pi=indices[ii+j]*3;if(positions[pi]<aabb[0]){aabb[0]=positions[pi];}if(positions[pi]>aabb[3]){aabb[3]=positions[pi];}if(positions[pi+1]<aabb[1]){aabb[1]=positions[pi+1];}if(positions[pi+1]>aabb[4]){aabb[4]=positions[pi+1];}if(positions[pi+2]<aabb[2]){aabb[2]=positions[pi+2];}if(positions[pi+2]>aabb[5]){aabb[5]=positions[pi+2];}}}if(triangles.length<KD_TREE_MIN_TRIANGLES||depth>KD_TREE_MAX_DEPTH){node.triangles=triangles;node.leaf=true;return node;}dimLength[0]=aabb[3]-aabb[0];dimLength[1]=aabb[4]-aabb[1];dimLength[2]=aabb[5]-aabb[2];var dim=0;if(dimLength[1]>dimLength[dim]){dim=1;}if(dimLength[2]>dimLength[dim]){dim=2;}node.splitDim=dim;var mid=(aabb[dim]+aabb[dim+3])/2;var left=new Array(triangles.length);var numLeft=0;var right=new Array(triangles.length);var numRight=0;for(t=0,len=triangles.length;t<len;++t){var ii=triangles[t]*3;var i0=indices[ii];var i1=indices[ii+1];var i2=indices[ii+2];var pi0=i0*3;var pi1=i1*3;var pi2=i2*3;if(positions[pi0+dim]<=mid||positions[pi1+dim]<=mid||positions[pi2+dim]<=mid){left[numLeft++]=triangles[t];}else{right[numRight++]=triangles[t];}}left.length=numLeft;right.length=numRight;node.left=buildNode(left,indices,positions,depth+1);node.right=buildNode(right,indices,positions,depth+1);return node;}return function(indices,positions){var numTris=indices.length/3;var triangles=new Array(numTris);for(var _i20=0;_i20<numTris;++_i20){triangles[_i20]=_i20;}return buildNode(triangles,indices,positions,0);};}(),decompressPosition:function decompressPosition(position,decodeMatrix,dest){dest=dest||position;dest[0]=position[0]*decodeMatrix[0]+decodeMatrix[12];dest[1]=position[1]*decodeMatrix[5]+decodeMatrix[13];dest[2]=position[2]*decodeMatrix[10]+decodeMatrix[14];},decompressPositions:function decompressPositions(positions,decodeMatrix){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Float32Array(positions.length);for(var _i21=0,len=positions.length;_i21<len;_i21+=3){dest[_i21+0]=positions[_i21+0]*decodeMatrix[0]+decodeMatrix[12];dest[_i21+1]=positions[_i21+1]*decodeMatrix[5]+decodeMatrix[13];dest[_i21+2]=positions[_i21+2]*decodeMatrix[10]+decodeMatrix[14];}return dest;},decompressUV:function decompressUV(uv,decodeMatrix,dest){dest[0]=uv[0]*decodeMatrix[0]+decodeMatrix[6];dest[1]=uv[1]*decodeMatrix[4]+decodeMatrix[7];},decompressUVs:function decompressUVs(uvs,decodeMatrix){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Float32Array(uvs.length);for(var _i22=0,len=uvs.length;_i22<len;_i22+=3){dest[_i22+0]=uvs[_i22+0]*decodeMatrix[0]+decodeMatrix[6];dest[_i22+1]=uvs[_i22+1]*decodeMatrix[4]+decodeMatrix[7];}return dest;},octDecodeVec2:function octDecodeVec2(oct,result){var x=oct[0];var y=oct[1];x=(2*x+1)/255;y=(2*y+1)/255;var z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1);}var length=Math.sqrt(x*x+y*y+z*z);result[0]=x/length;result[1]=y/length;result[2]=z/length;return result;},octDecodeVec2s:function octDecodeVec2s(octs,result){for(var _i23=0,j=0,len=octs.length;_i23<len;_i23+=2){var x=octs[_i23+0];var y=octs[_i23+1];x=(2*x+1)/255;y=(2*y+1)/255;var _z=1-Math.abs(x)-Math.abs(y);if(_z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1);}var length=Math.sqrt(x*x+y*y+_z*_z);result[j+0]=x/length;result[j+1]=y/length;result[j+2]=_z/length;j+=3;}return result;}};math.buildEdgeIndices=function(){var uniquePositions=[];var indicesLookup=[];var indicesReverseLookup=[];var weldedIndices=[];// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions
var faces=[];var numFaces=0;var compa=new Uint16Array(3);var compb=new Uint16Array(3);var compc=new Uint16Array(3);var a=math.vec3();var b=math.vec3();var c=math.vec3();var cb=math.vec3();var ab=math.vec3();var cross=math.vec3();var normal=math.vec3();function weldVertices(positions,indices){var positionsMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var vx;var vy;var vz;var key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i;var len;var lenUniquePositions=0;for(i=0,len=positions.length;i<len;i+=3){vx=positions[i];vy=positions[i+1];vz=positions[i+2];key=Math.round(vx*precision)+'_'+Math.round(vy*precision)+'_'+Math.round(vz*precision);if(positionsMap[key]===undefined){positionsMap[key]=lenUniquePositions/3;uniquePositions[lenUniquePositions++]=vx;uniquePositions[lenUniquePositions++]=vy;uniquePositions[lenUniquePositions++]=vz;}indicesLookup[i/3]=positionsMap[key];}for(i=0,len=indices.length;i<len;i++){weldedIndices[i]=indicesLookup[indices[i]];indicesReverseLookup[weldedIndices[i]]=indices[i];}}function buildFaces(numIndices,positionsDecodeMatrix){numFaces=0;for(var _i24=0,len=numIndices;_i24<len;_i24+=3){var ia=weldedIndices[_i24]*3;var ib=weldedIndices[_i24+1]*3;var ic=weldedIndices[_i24+2]*3;if(positionsDecodeMatrix){compa[0]=uniquePositions[ia];compa[1]=uniquePositions[ia+1];compa[2]=uniquePositions[ia+2];compb[0]=uniquePositions[ib];compb[1]=uniquePositions[ib+1];compb[2]=uniquePositions[ib+2];compc[0]=uniquePositions[ic];compc[1]=uniquePositions[ic+1];compc[2]=uniquePositions[ic+2];// Decode
math.decompressPosition(compa,positionsDecodeMatrix,a);math.decompressPosition(compb,positionsDecodeMatrix,b);math.decompressPosition(compc,positionsDecodeMatrix,c);}else{a[0]=uniquePositions[ia];a[1]=uniquePositions[ia+1];a[2]=uniquePositions[ia+2];b[0]=uniquePositions[ib];b[1]=uniquePositions[ib+1];b[2]=uniquePositions[ib+2];c[0]=uniquePositions[ic];c[1]=uniquePositions[ic+1];c[2]=uniquePositions[ic+2];}math.subVec3(c,b,cb);math.subVec3(a,b,ab);math.cross3Vec3(cb,ab,cross);math.normalizeVec3(cross,normal);var face=faces[numFaces]||(faces[numFaces]={normal:math.vec3()});face.normal[0]=normal[0];face.normal[1]=normal[1];face.normal[2]=normal[2];numFaces++;}}return function(positions,indices,positionsDecodeMatrix,edgeThreshold){weldVertices(positions,indices);buildFaces(indices.length,positionsDecodeMatrix);var edgeIndices=[];var thresholdDot=Math.cos(math.DEGTORAD*edgeThreshold);var edges={};var edge1;var edge2;var index1;var index2;var key;var largeIndex=false;var edge;var normal1;var normal2;var dot;var ia;var ib;for(var _i25=0,len=indices.length;_i25<len;_i25+=3){var faceIndex=_i25/3;for(var j=0;j<3;j++){edge1=weldedIndices[_i25+j];edge2=weldedIndices[_i25+(j+1)%3];index1=Math.min(edge1,edge2);index2=Math.max(edge1,edge2);key=index1+","+index2;if(edges[key]===undefined){edges[key]={index1:index1,index2:index2,face1:faceIndex,face2:undefined};}else{edges[key].face2=faceIndex;}}}for(key in edges){edge=edges[key];// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
if(edge.face2!==undefined){normal1=faces[edge.face1].normal;normal2=faces[edge.face2].normal;dot=math.dotVec3(normal1,normal2);if(dot>thresholdDot){continue;}}ia=indicesReverseLookup[edge.index1];ib=indicesReverseLookup[edge.index2];if(!largeIndex&&ia>65535||ib>65535){largeIndex=true;}edgeIndices.push(ia);edgeIndices.push(ib);}return largeIndex?new Uint32Array(edgeIndices):new Uint16Array(edgeIndices);};}();/**
 * Returns `true` if a plane clips the given 3D positions.
 * @param {Number[]} pos Position in plane
 * @param {Number[]} dir Direction of plane
 * @param {number} positions Flat array of 3D positions.
 * @param {number} numElementsPerPosition Number of elements perposition - usually either 3 or 4.
 * @returns {boolean}
 */math.planeClipsPositions3=function(pos,dir,positions){var numElementsPerPosition=arguments.length>3&&arguments[3]!==undefined?arguments[3]:3;for(var _i26=0,len=positions.length;_i26<len;_i26+=numElementsPerPosition){tempVec3a$N[0]=positions[_i26+0]-pos[0];tempVec3a$N[1]=positions[_i26+1]-pos[1];tempVec3a$N[2]=positions[_i26+2]-pos[2];var dotProduct=tempVec3a$N[0]*dir[0]+tempVec3a$N[1]*dir[1]+tempVec3a$N[2]*dir[2];if(dotProduct<0){return true;}}return false;};var MAX_KD_TREE_DEPTH$1=15;// Increase if greater precision needed
var kdTreeDimLength$1=new Float32Array(3);/**
 * Automatically indexes a {@link Viewer}'s {@link Entity}s in a 3D k-d tree
 * to support fast collision detection with 3D World-space axis-aligned boundaries (AABBs) and frustums.
 *
 * See {@link MarqueePicker} for usage example.
 *
 * An ObjectsKdTree3 is configured with a Viewer, and will then automatically
 * keep itself populated with k-d nodes that contain the Viewer's Entitys.
 *
 * We can then traverse the k-d nodes, starting at {@link ObjectsKdTree3#root}, to find
 * the contained Entities.
 */var ObjectsKdTree3=/*#__PURE__*/function(){/**
     * Creates an ObjectsKdTree3.
     *
     * @param {*} cfg Configuration
     * @param {Viewer} cfg.viewer The Viewer that provides the {@link Entity}s in this ObjectsKdTree3.
     * @param {number} [cfg.maxTreeDepth=15] Optional maximum depth for the k-d tree.
     */function ObjectsKdTree3(cfg){var _this7=this;_classCallCheck(this,ObjectsKdTree3);if(!cfg){throw"Parameter expected: cfg";}if(!cfg.viewer){throw"Parameter expected: cfg.viewer";}this.viewer=cfg.viewer;this._maxTreeDepth=cfg.maxTreeDepth||MAX_KD_TREE_DEPTH$1;this._root=null;this._needsRebuild=true;this._onModelLoaded=this.viewer.scene.on("modelLoaded",function(modelId){_this7._needsRebuild=true;});this._onModelUnloaded=this.viewer.scene.on("modelUnloaded",function(modelId){_this7._needsRebuild=true;});}/**
     * Gets the root ObjectsKdTree3 node.
     *
     * Each time this accessor is accessed, it will lazy-rebuild the ObjectsKdTree3
     * if {@link Entity}s have been created or removed in the {@link Viewer} since the last time it was accessed.
     */_createClass(ObjectsKdTree3,[{key:"root",get:function get(){if(this._needsRebuild){this._rebuild();}return this._root;}},{key:"_rebuild",value:function _rebuild(){var viewer=this.viewer;var scene=viewer.scene;var depth=0;this._root={aabb:scene.getAABB()};for(var objectId in scene.objects){var entity=scene.objects[objectId];this._insertEntity(this._root,entity,depth+1);}this._needsRebuild=false;}},{key:"_insertEntity",value:function _insertEntity(node,entity,depth){var entityAABB=entity.aabb;if(depth>=this._maxTreeDepth){node.entities=node.entities||[];node.entities.push(entity);return;}if(node.left){if(math.containsAABB3(node.left.aabb,entityAABB)){this._insertEntity(node.left,entity,depth+1);return;}}if(node.right){if(math.containsAABB3(node.right.aabb,entityAABB)){this._insertEntity(node.right,entity,depth+1);return;}}var nodeAABB=node.aabb;kdTreeDimLength$1[0]=nodeAABB[3]-nodeAABB[0];kdTreeDimLength$1[1]=nodeAABB[4]-nodeAABB[1];kdTreeDimLength$1[2]=nodeAABB[5]-nodeAABB[2];var dim=0;if(kdTreeDimLength$1[1]>kdTreeDimLength$1[dim]){dim=1;}if(kdTreeDimLength$1[2]>kdTreeDimLength$1[dim]){dim=2;}if(!node.left){var aabbLeft=nodeAABB.slice();aabbLeft[dim+3]=(nodeAABB[dim]+nodeAABB[dim+3])/2.0;node.left={aabb:aabbLeft};if(math.containsAABB3(aabbLeft,entityAABB)){this._insertEntity(node.left,entity,depth+1);return;}}if(!node.right){var aabbRight=nodeAABB.slice();aabbRight[dim]=(nodeAABB[dim]+nodeAABB[dim+3])/2.0;node.right={aabb:aabbRight};if(math.containsAABB3(aabbRight,entityAABB)){this._insertEntity(node.right,entity,depth+1);return;}}node.entities=node.entities||[];node.entities.push(entity);}/**
     * Destroys this ObjectsKdTree3.
     *
     * Does not destroy the {@link Viewer} given to the constructor of the ObjectsKdTree3.
     */},{key:"destroy",value:function destroy(){var scene=this.viewer.scene;scene.off(this._onModelLoaded);scene.off(this._onModelUnloaded);this._root=null;this._needsRebuild=true;}}]);return ObjectsKdTree3;}();// Fast queue that avoids using potentially inefficient array .shift() calls
// Based on https://github.com/creationix/fastqueue
/** @private */var Queue=/*#__PURE__*/function(){function Queue(){_classCallCheck(this,Queue);this._head=[];this._headLength=0;this._tail=[];this._index=0;this._length=0;}_createClass(Queue,[{key:"length",get:function get(){return this._length;}},{key:"shift",value:function shift(){if(this._index>=this._headLength){var t=this._head;t.length=0;this._head=this._tail;this._tail=t;this._index=0;this._headLength=this._head.length;if(!this._headLength){return;}}var value=this._head[this._index];if(this._index<0){delete this._head[this._index++];}else{this._head[this._index++]=undefined;}this._length--;return value;}},{key:"push",value:function push(item){this._length++;this._tail.push(item);return this;}},{key:"unshift",value:function unshift(item){this._head[--this._index]=item;this._length++;return this;}}]);return Queue;}();/**
 * xeokit runtime statistics.
 * @type {{components: {models: number, objects: number, scenes: number, meshes: number}, memory: {indices: number, uvs: number, textures: number, materials: number, transforms: number, positions: number, programs: number, normals: number, meshes: number, colors: number}, build: {version: string}, client: {browser: string}, frame: {frameCount: number, useProgram: number, bindTexture: number, drawElements: number, bindArray: number, tasksRun: number, fps: number, drawArrays: number, tasksScheduled: number}}}
 */var stats={build:{version:"0.8"},client:{browser:navigator&&navigator.userAgent?navigator.userAgent:"n/a"},components:{scenes:0,models:0,meshes:0,objects:0},memory:{meshes:0,positions:0,colors:0,normals:0,uvs:0,indices:0,textures:0,transforms:0,materials:0,programs:0},frame:{frameCount:0,fps:0,useProgram:0,bindTexture:0,bindArray:0,drawElements:0,drawArrays:0,tasksRun:0,tasksScheduled:0}};/**
 * @private
 */function xmlToJson(node,attributeRenamer){if(node.nodeType===node.TEXT_NODE){var v=node.nodeValue;if(v.match(/^\s+$/)===null){return v;}}else if(node.nodeType===node.ELEMENT_NODE||node.nodeType===node.DOCUMENT_NODE){var json={type:node.nodeName,children:[]};if(node.nodeType===node.ELEMENT_NODE){for(var j=0;j<node.attributes.length;j++){var attribute=node.attributes[j];var nm=attributeRenamer[attribute.nodeName]||attribute.nodeName;json[nm]=attribute.nodeValue;}}for(var i=0;i<node.childNodes.length;i++){var item=node.childNodes[i];var j=xmlToJson(item,attributeRenamer);if(j)json.children.push(j);}return json;}}/**
 * @private
 */function clone(ob){return JSON.parse(JSON.stringify(ob));}/**
 * @private
 */var guidChars=[["0",10],["A",26],["a",26],["_",1],["$",1]].map(function(a){var li=[];var st=a[0].charCodeAt(0);var en=st+a[1];for(var i=st;i<en;++i){li.push(i);}return String.fromCharCode.apply(null,li);}).join("");/**
 * @private
 */function b64(v,len){var r=!len||len===4?[0,6,12,18]:[0,6];return r.map(function(i){return guidChars.substr(parseInt(v/(1<<i))%64,1);}).reverse().join("");}/**
 * @private
 */function compressGuid(g){var bs=[0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30].map(function(i){return parseInt(g.substr(i,2),16);});return b64(bs[0],2)+[1,4,7,10,13].map(function(i){return b64((bs[i]<<16)+(bs[i+1]<<8)+bs[i+2]);}).join("");}/**
 * @private
 */function findNodeOfType(m,t){var li=[];var _=function _(n){if(n.type===t)li.push(n);(n.children||[]).forEach(function(c){_(c);});};_(m);return li;}/**
 * @private
 */function timeout(dt){return new Promise(function(resolve,reject){setTimeout(resolve,dt);});}/**
 * @private
 */function httpRequest(args){return new Promise(function(resolve,reject){var xhr=new XMLHttpRequest();xhr.open(args.method||"GET",args.url,true);xhr.onload=function(e){if(xhr.readyState===4){if(xhr.status===200){resolve(xhr.responseXML);}else{reject(xhr.statusText);}}};xhr.send(null);});}/**
 * @private
 */var queryString=function(){// This function is anonymous, is executed immediately and
// the return value is assigned to QueryString!
var query_string={};var query=window.location.search.substring(1);var vars=query.split("&");for(var i=0;i<vars.length;i++){var pair=vars[i].split("=");// If first entry with this name
if(typeof query_string[pair[0]]==="undefined"){query_string[pair[0]]=decodeURIComponent(pair[1]);// If second entry with this name
}else if(typeof query_string[pair[0]]==="string"){var arr=[query_string[pair[0]],decodeURIComponent(pair[1])];query_string[pair[0]]=arr;// If third or later entry with this name
}else{query_string[pair[0]].push(decodeURIComponent(pair[1]));}}return query_string;}();/**
 * @private
 */function loadJSON(url,ok,err){// Avoid checking ok and err on each use.
var defaultCallback=function defaultCallback(_value){return undefined;};ok=ok||defaultCallback;err=err||defaultCallback;var request=new XMLHttpRequest();request.overrideMimeType("application/json");request.open('GET',url,true);request.addEventListener('load',function(event){var response=event.target.response;if(this.status===200){var json;try{json=JSON.parse(response);}catch(e){err("utils.loadJSON(): Failed to parse JSON response - ".concat(e));}ok(json);}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
console.warn('loadFile: HTTP Status 0 received.');try{ok(JSON.parse(response));}catch(e){err("utils.loadJSON(): Failed to parse JSON response - ".concat(e));}}else{err(event);}},false);request.addEventListener('error',function(event){err(event);},false);request.send(null);}/**
 * @private
 */function loadArraybuffer$1(url,ok,err){// Check for data: URI
var defaultCallback=function defaultCallback(_value){return undefined;};ok=ok||defaultCallback;err=err||defaultCallback;var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);if(dataUriRegexResult){// Safari can't handle data URIs through XMLHttpRequest
var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64){data=window.atob(data);}try{var buffer=new ArrayBuffer(data.length);var view=new Uint8Array(buffer);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}core.scheduleTask(function(){ok(buffer);});}catch(error){core.scheduleTask(function(){err(error);});}}else{var request=new XMLHttpRequest();request.open('GET',url,true);request.responseType='arraybuffer';request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){ok(request.response);}else{err('loadArrayBuffer error : '+request.response);}}};request.send(null);}}/**
 Tests if the given object is an array
 @private
 */function isArray(value){return value&&!value.propertyIsEnumerable('length')&&_typeof(value)==='object'&&typeof value.length==='number';}/**
 Tests if the given value is a string
 @param value
 @returns {Boolean}
 @private
 */function isString(value){return typeof value==='string'||value instanceof String;}/**
 Tests if the given value is a number
 @param value
 @returns {Boolean}
 @private
 */function isNumeric(value){return!isNaN(parseFloat(value))&&isFinite(value);}/**
 Tests if the given value is an ID
 @param value
 @returns {Boolean}
 @private
 */function isID(value){return utils.isString(value)||utils.isNumeric(value);}/**
 Tests if the given components are the same, where the components can be either IDs or instances.
 @param c1
 @param c2
 @returns {Boolean}
 @private
 */function isSameComponent(c1,c2){if(!c1||!c2){return false;}var id1=utils.isNumeric(c1)||utils.isString(c1)?"".concat(c1):c1.id;var id2=utils.isNumeric(c2)||utils.isString(c2)?"".concat(c2):c2.id;return id1===id2;}/**
 Tests if the given value is a function
 @param value
 @returns {Boolean}
 @private
 */function isFunction$1(value){return typeof value==="function";}/**
 Tests if the given value is a JavaScript JSON object, eg, ````{ foo: "bar" }````.
 @param value
 @returns {Boolean}
 @private
 */function isObject$1(value){var objectConstructor={}.constructor;return!!value&&value.constructor===objectConstructor;}/** Returns a shallow copy
 */function copy(o){return utils.apply(o,{});}/** Add properties of o to o2, overwriting them on o2 if already there
 */function apply(o,o2){for(var _name in o){if(o.hasOwnProperty(_name)){o2[_name]=o[_name];}}return o2;}/**
 Add non-null/defined properties of o to o2
 @private
 */function apply2(o,o2){for(var _name2 in o){if(o.hasOwnProperty(_name2)){if(o[_name2]!==undefined&&o[_name2]!==null){o2[_name2]=o[_name2];}}}return o2;}/**
 Add properties of o to o2 where undefined or null on o2
 @private
 */function applyIf(o,o2){for(var _name3 in o){if(o.hasOwnProperty(_name3)){if(o2[_name3]===undefined||o2[_name3]===null){o2[_name3]=o[_name3];}}}return o2;}/**
 Returns true if the given map is empty.
 @param obj
 @returns {Boolean}
 @private
 */function isEmptyObject$1(obj){for(var _name4 in obj){if(obj.hasOwnProperty(_name4)){return false;}}return true;}/**
 Returns the given ID as a string, in quotes if the ID was a string to begin with.

 This is useful for logging IDs.

 @param {Number| String} id The ID
 @returns {String}
 @private
 */function inQuotes(id){return utils.isNumeric(id)?"".concat(id):"'".concat(id,"'");}/**
 Returns the concatenation of two typed arrays.
 @param a
 @param b
 @returns {*|a}
 @private
 */function concat(a,b){var c=new a.constructor(a.length+b.length);c.set(a);c.set(b,a.length);return c;}function flattenParentChildHierarchy(root){var list=[];function visit(node){node.id=node.uuid;delete node.oid;list.push(node);var children=node.children;if(children){for(var i=0,len=children.length;i<len;i++){var child=children[i];child.parent=node.id;visit(children[i]);}}node.children=[];}visit(root);return list;}/**
 * @private
 */var utils={xmlToJson:xmlToJson,clone:clone,compressGuid:compressGuid,findNodeOfType:findNodeOfType,timeout:timeout,httpRequest:httpRequest,loadJSON:loadJSON,loadArraybuffer:loadArraybuffer$1,queryString:queryString,isArray:isArray,isString:isString,isNumeric:isNumeric,isID:isID,isSameComponent:isSameComponent,isFunction:isFunction$1,isObject:isObject$1,copy:copy,apply:apply,apply2:apply2,applyIf:applyIf,isEmptyObject:isEmptyObject$1,inQuotes:inQuotes,concat:concat,flattenParentChildHierarchy:flattenParentChildHierarchy};var scenesRenderInfo={};// Used for throttling FPS for each Scene
var sceneIDMap=new Map$1();// Ensures unique scene IDs
var taskQueue=new Queue();// Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule
var tickEvent={sceneId:null,time:null,startTime:null,prevTime:null,deltaTime:null};var taskBudget=10;// Millisecs we're allowed to spend on tasks in each frame
var fpsSamples=[];var numFPSSamples=30;var lastTime=0;var elapsedTime;var totalFPS=0;/**
 * @private
 */function Core(){/**
     Semantic version number. The value for this is set by an expression that's concatenated to
     the end of the built binary by the xeokit build script.
     @property version
     @namespace xeokit
     @type {String}
     */this.version="1.0.0";/**
     Existing {@link Scene}s , mapped to their IDs
     @property scenes
     @namespace xeokit
     @type {Scene}
     */this.scenes={};this._superTypes={};// For each component type, a list of its supertypes, ordered upwards in the hierarchy.
/**
     * Registers a scene on xeokit.
     * This is called within the xeokit.Scene constructor.
     * @private
     */this._addScene=function(scene){if(scene.id){// User-supplied ID
if(core.scenes[scene.id]){console.error("[ERROR] Scene ".concat(utils.inQuotes(scene.id)," already exists"));return;}}else{// Auto-generated ID
scene.id=sceneIDMap.addItem({});}core.scenes[scene.id]=scene;var ticksPerOcclusionTest=scene.ticksPerOcclusionTest;var ticksPerRender=scene.ticksPerRender;scenesRenderInfo[scene.id]={ticksPerOcclusionTest:ticksPerOcclusionTest,ticksPerRender:ticksPerRender,renderCountdown:ticksPerRender};stats.components.scenes++;scene.once("destroyed",function(){// Unregister destroyed scenes
sceneIDMap.removeItem(scene.id);delete core.scenes[scene.id];delete scenesRenderInfo[scene.id];stats.components.scenes--;});};/**
     * @private
     */this.clear=function(){var scene;for(var id in core.scenes){if(core.scenes.hasOwnProperty(id)){scene=core.scenes[id];// Only clear the default Scene
// but destroy all the others
if(id==="default.scene"){scene.clear();}else{scene.destroy();delete core.scenes[scene.id];}}}};/**
     * Schedule a task to run at the next frame.
     *
     * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeokit processes the queue
     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not
     * get a chance to run during the task are left in the queue to be run next time.
     *
     * @param {Function} callback Callback that runs the task.
     * @param {Object} [scope] Scope for the callback.
     */this.scheduleTask=function(callback){var scope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;taskQueue.push(callback);taskQueue.push(scope);};this.runTasks=function(){var until=arguments.length>0&&arguments[0]!==undefined?arguments[0]:-1;// Pops and processes tasks in the queue, until the given number of milliseconds has elapsed.
var time=new Date().getTime();var callback;var scope;var tasksRun=0;while(taskQueue.length>0&&(until<0||time<until)){callback=taskQueue.shift();scope=taskQueue.shift();if(scope){callback.call(scope);}else{callback();}time=new Date().getTime();tasksRun++;}return tasksRun;};this.getNumTasks=function(){return taskQueue.length;};}/**
 * @private
 * @type {Core}
 */var core=new Core();var frame=function frame(){var time=Date.now();elapsedTime=time-lastTime;if(lastTime>0&&elapsedTime>0){// Log FPS stats
var newFPS=1000/elapsedTime;// Moving average of FPS
totalFPS+=newFPS;fpsSamples.push(newFPS);if(fpsSamples.length>=numFPSSamples){totalFPS-=fpsSamples.shift();}stats.frame.fps=Math.round(totalFPS/fpsSamples.length);}for(var id in core.scenes){core.scenes[id].compile();}runTasks(time);lastTime=time;};function customSetInterval(callback,interval){var expected=Date.now()+interval;function loop(){var elapsed=Date.now()-expected;callback();expected+=interval;setTimeout(loop,Math.max(0,interval-elapsed));}loop();return{cancel:function cancel(){// No need to do anything, setTimeout cannot be directly cancelled
}};}customSetInterval(function(){frame();},100);var renderFrame=function renderFrame(){var time=Date.now();elapsedTime=time-lastTime;if(lastTime>0&&elapsedTime>0){// Log FPS stats
var newFPS=1000/elapsedTime;// Moving average of FPS
totalFPS+=newFPS;fpsSamples.push(newFPS);if(fpsSamples.length>=numFPSSamples){totalFPS-=fpsSamples.shift();}stats.frame.fps=Math.round(totalFPS/fpsSamples.length);}runTasks(time);fireTickEvents(time);renderScenes();window.requestPostAnimationFrame!==undefined?window.requestPostAnimationFrame(frame):requestAnimationFrame(renderFrame);};renderFrame();function runTasks(time){// Process as many enqueued tasks as we can within the per-frame task budget
var tasksRun=core.runTasks(time+taskBudget);var tasksScheduled=core.getNumTasks();stats.frame.tasksRun=tasksRun;stats.frame.tasksScheduled=tasksScheduled;stats.frame.tasksBudget=taskBudget;}function fireTickEvents(time){// Fire tick event on each Scene
tickEvent.time=time;for(var id in core.scenes){if(core.scenes.hasOwnProperty(id)){var scene=core.scenes[id];tickEvent.sceneId=id;tickEvent.startTime=scene.startTime;tickEvent.deltaTime=tickEvent.prevTime!=null?tickEvent.time-tickEvent.prevTime:0;/**
             * Fired on each game loop iteration.
             *
             * @event tick
             * @param {String} sceneID The ID of this Scene.
             * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.
             * @param {Number} time The time in seconds since 1970 of this "tick" event.
             * @param {Number} prevTime The time of the previous "tick" event from this Scene.
             * @param {Number} deltaTime The time in seconds since the previous "tick" event from this Scene.
             */scene.fire("tick",tickEvent,true);}}tickEvent.prevTime=time;}function renderScenes(){var scenes=core.scenes;var forceRender=false;var scene;var renderInfo;var ticksPerOcclusionTest;var ticksPerRender;var id;for(id in scenes){if(scenes.hasOwnProperty(id)){scene=scenes[id];renderInfo=scenesRenderInfo[id];if(!renderInfo){renderInfo=scenesRenderInfo[id]={};// FIXME
}ticksPerOcclusionTest=scene.ticksPerOcclusionTest;if(renderInfo.ticksPerOcclusionTest!==ticksPerOcclusionTest){renderInfo.ticksPerOcclusionTest=ticksPerOcclusionTest;renderInfo.renderCountdown=ticksPerOcclusionTest;}if(--scene.occlusionTestCountdown<=0){scene.doOcclusionTest();scene.occlusionTestCountdown=ticksPerOcclusionTest;}ticksPerRender=scene.ticksPerRender;if(renderInfo.ticksPerRender!==ticksPerRender){renderInfo.ticksPerRender=ticksPerRender;renderInfo.renderCountdown=ticksPerRender;}if(--renderInfo.renderCountdown===0){scene.render(forceRender);renderInfo.renderCountdown=ticksPerRender;}}}}/**
 * @desc Base class for all xeokit components.
 *
 * ## Component IDs
 *
 * Every Component has an ID that's unique within the parent {@link Scene}. xeokit generates
 * the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a
 * scene comprised of {@link Scene}, {@link Material}, {@link ReadableGeometry} and
 * {@link Mesh} components, while letting xeokit generate its own ID for
 * the {@link ReadableGeometry}:
 *
 *````JavaScript
 * import {Viewer, Mesh, buildTorusGeometry, ReadableGeometry, PhongMaterial, Texture, Fresnel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas"
 *    });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          id: "myMaterial",
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          specularFresnel: new Fresnel(viewer.scene, {
 *              leftColor: [1.0, 1.0, 1.0],
 *              rightColor: [0.0, 0.0, 0.0],
 *              power: 4
 *          })
 *     })
 * });
 *````
 *
 * We can then find those components like this:
 *
 * ````javascript
 * // Find the Material
 * var material = viewer.scene.components["myMaterial"];
 *
 * // Find all PhongMaterials in the Scene
 * var phongMaterials = viewer.scene.types["PhongMaterial"];
 *
 * // Find our Material within the PhongMaterials
 * var materialAgain = phongMaterials["myMaterial"];
 * ````
 *
 * ## Restriction on IDs
 *
 * Auto-generated IDs are of the form ````"__0"````, ````"__1"````, ````"__2"```` ... and so on.
 *
 * Scene maintains a map of these IDs, along with a counter that it increments each time it generates a new ID.
 *
 * If Scene has created the IDs listed above, and we then destroy the ````Component```` with ID ````"__1"````,
 * Scene will mark that ID as available, and will reuse it for the next default ID.
 *
 * Therefore, two restrictions your on IDs:
 *
 * * don't use IDs that begin with two underscores, and
 * * don't reuse auto-generated IDs of destroyed Components.
 *
 * ## Logging
 *
 * Components have methods to log ID-prefixed messages to the JavaScript console:
 *
 * ````javascript
 * material.log("Everything is fine, situation normal.");
 * material.warn("Wait, whats that red light?");
 * material.error("Aw, snap!");
 * ````
 *
 * The logged messages will look like this in the console:
 *
 * ````text
 * [LOG]   myMaterial: Everything is fine, situation normal.
 * [WARN]  myMaterial: Wait, whats that red light..
 * [ERROR] myMaterial: Aw, snap!
 * ````
 *
 * ## Destruction
 *
 * Get notification of destruction of Components:
 *
 * ````javascript
 * material.once("destroyed", function() {
 *     this.log("Component was destroyed: " + this.id);
 * });
 * ````
 *
 * Or get notification of destruction of any Component within its {@link Scene}:
 *
 * ````javascript
 * scene.on("componentDestroyed", function(component) {
 *     this.log("Component was destroyed: " + component.id);
 * });
 * ````
 *
 * Then destroy a component like this:
 *
 * ````javascript
 * material.destroy();
 * ````
 */var Component=/*#__PURE__*/function(){function Component(){var owner=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Component);/**
         * The parent {@link Scene} that contains this Component.
         *
         * @property scene
         * @type {Scene}
         * @final
         */this.scene=null;if(this.type==="Scene"){this.scene=this;/**
             * The viewer that contains this Scene.
             * @property viewer
             * @type {Viewer}
             */this.viewer=cfg.viewer;}else{if(owner.type==="Scene"){this.scene=owner;}else if(owner instanceof Component){this.scene=owner.scene;}else{throw"Invalid param: owner must be a Component";}this._owner=owner;}this._dontClear=!!cfg.dontClear;// Prevent Scene#clear from destroying this component
this._renderer=this.scene._renderer;/**
         Arbitrary, user-defined metadata on this component.

         @property metadata
         @type Object
         */this.meta=cfg.meta||{};/**
         * ID of this Component, unique within the {@link Scene}.
         *
         * Components are mapped by this ID in {@link Scene#components}.
         *
         * @property id
         * @type {String|Number}
         */this.id=cfg.id;// Auto-generated by Scene by default
/**
         True as soon as this Component has been destroyed

         @property destroyed
         @type {Boolean}
         */this.destroyed=false;this._attached={};// Attached components with names.
this._attachments=null;// Attached components keyed to IDs - lazy-instantiated
this._subIdMap=null;// Subscription subId pool
this._subIdEvents=null;// Subscription subIds mapped to event names
this._eventSubs=null;// Event names mapped to subscribers
this._eventSubsNum=null;this._events=null;// Maps names to events
this._eventCallDepth=0;// Helps us catch stack overflows from recursive events
this._ownedComponents=null;// // Components created with #create - lazy-instantiated
if(this!==this.scene){// Don't add scene to itself
this.scene._addComponent(this);// Assigns this component an automatic ID if not yet assigned
}this._updateScheduled=false;// True when #_update will be called on next tick
if(owner){owner._own(this);}}// /**
//  * Unique ID for this Component within its {@link Scene}.
//  *
//  * @property
//  * @type {String}
//  */
// get id() {
//     return this._id;
// }
/**
     Indicates that we need to redraw the scene.

     This is called by certain subclasses after they have made some sort of state update that requires the
     renderer to perform a redraw.

     For example: a {@link Mesh} calls this on itself whenever you update its
     {@link Mesh#layer} property, which manually controls its render order in
     relation to other Meshes.

     If this component has a ````castsShadow```` property that's set ````true````, then this will also indicate
     that the renderer needs to redraw shadow map associated with this component. Components like
     {@link DirLight} have that property set when they produce light that creates shadows, while
     components like {@link Mesh"}}layer{{/crossLink}} have that property set when they cast shadows.

     @protected
     */_createClass(Component,[{key:"type",get:/**
     @private
     */function get(){return"Component";}/**
     * @private
     */},{key:"isComponent",get:function get(){return true;}},{key:"glRedraw",value:function glRedraw(){if(!this._renderer){// Called from a constructor
return;}this._renderer.imageDirty();if(this.castsShadow){// Light source or object
this._renderer.shadowsDirty();}}/**
     Indicates that we need to re-sort the renderer's state-ordered drawables list.

     For efficiency, the renderer keeps its list of drawables ordered so that runs of the same state updates can be
     combined.  This method is called by certain subclasses after they have made some sort of state update that would
     require re-ordering of the drawables list.

     For example: a {@link DirLight} calls this on itself whenever you update {@link DirLight#dir}.

     @protected
     */},{key:"glResort",value:function glResort(){if(!this._renderer){// Called from a constructor
return;}this._renderer.needStateSort();}/**
     * The {@link Component} that owns the lifecycle of this Component, if any.
     *
     * When that component is destroyed, this component will be automatically destroyed also.
     *
     * Will be null if this Component has no owner.
     *
     * @property owner
     * @type {Component}
     */},{key:"owner",get:function get(){return this._owner;}/**
     * Tests if this component is of the given type, or is a subclass of the given type.
     * @type {Boolean}
     */},{key:"isType",value:function isType(type){return this.type===type;}/**
     * Fires an event on this component.
     *
     * Notifies existing subscribers to the event, optionally retains the event to give to
     * any subsequent notifications on the event as they are made.
     *
     * @param {String} event The event type name
     * @param {Object} value The event parameters
     * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers
     */},{key:"fire",value:function fire(event,value,forget){if(!this._events){this._events={};}if(!this._eventSubs){this._eventSubs={};this._eventSubsNum={};}if(forget!==true){this._events[event]=value||true;// Save notification
}var subs=this._eventSubs[event];var sub;if(subs){// Notify subscriptions
for(var subId in subs){if(subs.hasOwnProperty(subId)){sub=subs[subId];this._eventCallDepth++;if(this._eventCallDepth<300){sub.callback.call(sub.scope,value);}else{this.error("fire: potential stack overflow from recursive event '"+event+"' - dropping this event");}this._eventCallDepth--;}}}}/**
     * Subscribes to an event on this component.
     *
     * The callback is be called with this component as scope.
     *
     * @param {String} event The event
     * @param {Function} callback Called fired on the event
     * @param {Object} [scope=this] Scope for the callback
     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
     */},{key:"on",value:function on(event,callback,scope){if(!this._events){this._events={};}if(!this._subIdMap){this._subIdMap=new Map$1();// Subscription subId pool
}if(!this._subIdEvents){this._subIdEvents={};}if(!this._eventSubs){this._eventSubs={};}if(!this._eventSubsNum){this._eventSubsNum={};}var subs=this._eventSubs[event];if(!subs){subs={};this._eventSubs[event]=subs;this._eventSubsNum[event]=1;}else{this._eventSubsNum[event]++;}var subId=this._subIdMap.addItem();// Create unique subId
subs[subId]={callback:callback,scope:scope||this};this._subIdEvents[subId]=event;var value=this._events[event];if(value!==undefined){// A publication exists, notify callback immediately
callback.call(scope||this,value);}return subId;}/**
     * Cancels an event subscription that was previously made with {@link Component#on} or {@link Component#once}.
     *
     * @param {String} subId Subscription ID
     */},{key:"off",value:function off(subId){if(subId===undefined||subId===null){return;}if(!this._subIdEvents){return;}var event=this._subIdEvents[subId];if(event){delete this._subIdEvents[subId];var subs=this._eventSubs[event];if(subs){delete subs[subId];this._eventSubsNum[event]--;}this._subIdMap.removeItem(subId);// Release subId
}}/**
     * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is subIdd.
     *
     * This is equivalent to calling {@link Component#on}, and then calling {@link Component#off} inside the callback function.
     *
     * @param {String} event Data event to listen to
     * @param {Function} callback Called when fresh data is available at the event
     * @param {Object} [scope=this] Scope for the callback
     */},{key:"once",value:function once(event,callback,scope){var self=this;var subId=this.on(event,function(value){self.off(subId);callback.call(scope||this,value);},scope);}/**
     * Returns true if there are any subscribers to the given event on this component.
     *
     * @param {String} event The event
     * @return {Boolean} True if there are any subscribers to the given event on this component.
     */},{key:"hasSubs",value:function hasSubs(event){return this._eventSubsNum&&this._eventSubsNum[event]>0;}/**
     * Logs a console debugging message for this component.
     *
     * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*
     *
     * Also fires the message as a "log" event on the parent {@link Scene}.
     *
     * @param {String} message The message to log
     */},{key:"log",value:function log(message){message="[LOG]"+this._message(message);window.console.log(message);this.scene.fire("log",message);}},{key:"_message",value:function _message(message){return" ["+this.type+" "+utils.inQuotes(this.id)+"]: "+message;}/**
     * Logs a warning for this component to the JavaScript console.
     *
     * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
     *
     * Also fires the message as a "warn" event on the parent {@link Scene}.
     *
     * @param {String} message The message to log
     */},{key:"warn",value:function warn(message){message="[WARN]"+this._message(message);window.console.warn(message);this.scene.fire("warn",message);}/**
     * Logs an error for this component to the JavaScript console.
     *
     * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
     *
     * Also fires the message as an "error" event on the parent {@link Scene}.
     *
     * @param {String} message The message to log
     */},{key:"error",value:function error(message){message="[ERROR]"+this._message(message);window.console.error(message);this.scene.fire("error",message);}/**
     * Adds a child component to this.
     *
     * When component not given, attaches the scene's default instance for the given name (if any).
     * Publishes the new child component on this component, keyed to the given name.
     *
     * @param {*} params
     * @param {String} params.name component name
     * @param {Component} [params.component] The component
     * @param {String} [params.type] Optional expected type of base type of the child; when supplied, will
     * cause an exception if the given child is not the same type or a subtype of this.
     * @param {Boolean} [params.sceneDefault=false]
     * @param {Boolean} [params.sceneSingleton=false]
     * @param {Function} [params.onAttached] Optional callback called when component attached
     * @param {Function} [params.onAttached.callback] Callback function
     * @param {Function} [params.onAttached.scope] Optional scope for callback
     * @param {Function} [params.onDetached] Optional callback called when component is detached
     * @param {Function} [params.onDetached.callback] Callback function
     * @param {Function} [params.onDetached.scope] Optional scope for callback
     * @param {{String:Function}} [params.on] Callbacks to subscribe to properties on component
     * @param {Boolean} [params.recompiles=true] When true, fires "dirty" events on this component
     * @private
     */},{key:"_attach",value:function _attach(params){var name=params.name;if(!name){this.error("Component 'name' expected");return;}var component=params.component;var sceneDefault=params.sceneDefault;var sceneSingleton=params.sceneSingleton;var type=params.type;var on=params.on;var recompiles=params.recompiles!==false;// True when child given as config object, where parent manages its instantiation and destruction
var managingLifecycle=false;if(component){if(utils.isNumeric(component)||utils.isString(component)){// Component ID given
// Both numeric and string IDs are supported
var id=component;component=this.scene.components[id];if(!component){// Quote string IDs in errors
this.error("Component not found: "+utils.inQuotes(id));return;}}}if(!component){if(sceneSingleton===true){// Using the first instance of the component type we find
var instances=this.scene.types[type];for(var id2 in instances){if(instances.hasOwnProperty){component=instances[id2];break;}}if(!component){this.error("Scene has no default component for '"+name+"'");return null;}}else if(sceneDefault===true){// Using a default scene component
component=this.scene[name];if(!component){this.error("Scene has no default component for '"+name+"'");return null;}}}if(component){if(component.scene.id!==this.scene.id){this.error("Not in same scene: "+component.type+" "+utils.inQuotes(component.id));return;}if(type){if(!component.isType(type)){this.error("Expected a "+type+" type or subtype: "+component.type+" "+utils.inQuotes(component.id));return;}}}if(!this._attachments){this._attachments={};}var oldComponent=this._attached[name];var subs;var i;var len;if(oldComponent){if(component&&oldComponent.id===component.id){// Reject attempt to reattach same component
return;}var oldAttachment=this._attachments[oldComponent.id];// Unsubscribe from events on old component
subs=oldAttachment.subs;for(i=0,len=subs.length;i<len;i++){oldComponent.off(subs[i]);}delete this._attached[name];delete this._attachments[oldComponent.id];var onDetached=oldAttachment.params.onDetached;if(onDetached){if(utils.isFunction(onDetached)){onDetached(oldComponent);}else{onDetached.scope?onDetached.callback.call(onDetached.scope,oldComponent):onDetached.callback(oldComponent);}}if(oldAttachment.managingLifecycle){// Note that we just unsubscribed from all events fired by the child
// component, so destroying it won't fire events back at us now.
oldComponent.destroy();}}if(component){// Set and publish the new component on this component
var attachment={params:params,component:component,subs:[],managingLifecycle:managingLifecycle};attachment.subs.push(component.once("destroyed",function(){attachment.params.component=null;this._attach(attachment.params);},this));if(recompiles){attachment.subs.push(component.on("dirty",function(){this.fire("dirty",this);},this));}this._attached[name]=component;this._attachments[component.id]=attachment;// Bind destruct listener to new component to remove it
// from this component when destroyed
var onAttached=params.onAttached;if(onAttached){if(utils.isFunction(onAttached)){onAttached(component);}else{onAttached.scope?onAttached.callback.call(onAttached.scope,component):onAttached.callback(component);}}if(on){var event;var subIdr;var callback;var scope;for(event in on){if(on.hasOwnProperty(event)){subIdr=on[event];if(utils.isFunction(subIdr)){callback=subIdr;scope=null;}else{callback=subIdr.callback;scope=subIdr.scope;}if(!callback){continue;}attachment.subs.push(component.on(event,callback,scope));}}}}if(recompiles){this.fire("dirty",this);// FIXME: May trigger spurous mesh recompilations unless able to limit with param?
}this.fire(name,component);// Component can be null
return component;}},{key:"_checkComponent",value:function _checkComponent(expectedType,component){if(!component.isComponent){if(utils.isID(component)){var id=component;component=this.scene.components[id];if(!component){this.error("Component not found: "+id);return;}}else{this.error("Expected a Component or ID");return;}}if(expectedType!==component.type){this.error("Expected a "+expectedType+" Component");return;}if(component.scene.id!==this.scene.id){this.error("Not in same scene: "+component.type);return;}return component;}},{key:"_checkComponent2",value:function _checkComponent2(expectedTypes,component){if(!component.isComponent){if(utils.isID(component)){var id=component;component=this.scene.components[id];if(!component){this.error("Component not found: "+id);return;}}else{this.error("Expected a Component or ID");return;}}if(component.scene.id!==this.scene.id){this.error("Not in same scene: "+component.type);return;}for(var i=0,len=expectedTypes.length;i<len;i++){if(expectedTypes[i]===component.type){return component;}}this.error("Expected component types: "+expectedTypes);return null;}},{key:"_own",value:function _own(component){var _this8=this;if(!this._ownedComponents){this._ownedComponents={};}if(!this._ownedComponents[component.id]){this._ownedComponents[component.id]=component;}component.once("destroyed",function(){delete _this8._ownedComponents[component.id];},this);}/**
     * Protected method, called by sub-classes to queue a call to _update().
     * @protected
     * @param {Number} [priority=1]
     */},{key:"_needUpdate",value:function _needUpdate(priority){if(!this._updateScheduled){this._updateScheduled=true;if(priority===0){this._doUpdate();}else{core.scheduleTask(this._doUpdate,this);}}}/**
     * @private
     */},{key:"_doUpdate",value:function _doUpdate(){if(this._updateScheduled){this._updateScheduled=false;if(this._update){this._update();}}}/**
     * Schedule a task to perform on the next browser interval
     * @param task
     */},{key:"scheduleTask",value:function scheduleTask(task){core.scheduleTask(task,null);}/**
     * Protected virtual template method, optionally implemented
     * by sub-classes to perform a scheduled task.
     *
     * @protected
     */},{key:"_update",value:function _update(){}/**
     * Destroys all {@link Component}s that are owned by this. These are Components that were instantiated with
     * this Component as their first constructor argument.
     */},{key:"clear",value:function clear(){if(this._ownedComponents){for(var id in this._ownedComponents){if(this._ownedComponents.hasOwnProperty(id)){var component=this._ownedComponents[id];component.destroy();delete this._ownedComponents[id];}}}}/**
     * Destroys this component.
     */},{key:"destroy",value:function destroy(){if(this.destroyed){return;}/**
         * Fired when this Component is destroyed.
         * @event destroyed
         */this.fire("destroyed",this.destroyed=true);// Must fire before we blow away subscription maps, below
// Unsubscribe from child components and destroy then
var id;var attachment;var component;var subs;var i;var len;if(this._attachments){for(id in this._attachments){if(this._attachments.hasOwnProperty(id)){attachment=this._attachments[id];component=attachment.component;subs=attachment.subs;for(i=0,len=subs.length;i<len;i++){component.off(subs[i]);}if(attachment.managingLifecycle){component.destroy();}}}}if(this._ownedComponents){for(id in this._ownedComponents){if(this._ownedComponents.hasOwnProperty(id)){component=this._ownedComponents[id];component.destroy();delete this._ownedComponents[id];}}}this.scene._removeComponent(this);// Memory leak avoidance
this._attached={};this._attachments=null;this._subIdMap=null;this._subIdEvents=null;this._eventSubs=null;this._events=null;this._eventCallDepth=0;this._ownedComponents=null;this._updateScheduled=false;}}]);return Component;}();var tempVec3a$M=math.vec3();var tempVec3b$A=math.vec3();var tempMat4a$s=math.mat4();/**
 * @private
 */var FrustumPlane=/*#__PURE__*/function(){function FrustumPlane(){_classCallCheck(this,FrustumPlane);this.normal=math.vec3();this.offset=0;this.testVertex=math.vec3();}_createClass(FrustumPlane,[{key:"set",value:function set(nx,ny,nz,offset){var s=1.0/Math.sqrt(nx*nx+ny*ny+nz*nz);this.normal[0]=nx*s;this.normal[1]=ny*s;this.normal[2]=nz*s;this.offset=offset*s;this.testVertex[0]=this.normal[0]>=0.0?1:0;this.testVertex[1]=this.normal[1]>=0.0?1:0;this.testVertex[2]=this.normal[2]>=0.0?1:0;}}]);return FrustumPlane;}();/**
 * @private
 */var Frustum$1=/*#__PURE__*/_createClass(function Frustum$1(){_classCallCheck(this,Frustum$1);this.planes=[new FrustumPlane(),new FrustumPlane(),new FrustumPlane(),new FrustumPlane(),new FrustumPlane(),new FrustumPlane()];});Frustum$1.INSIDE=0;Frustum$1.INTERSECT=1;Frustum$1.OUTSIDE=2;/** @private */function setFrustum(frustum,viewMat,projMat){var m=math.mulMat4(projMat,viewMat,tempMat4a$s);var m0=m[0];var m1=m[1];var m2=m[2];var m3=m[3];var m4=m[4];var m5=m[5];var m6=m[6];var m7=m[7];var m8=m[8];var m9=m[9];var m10=m[10];var m11=m[11];var m12=m[12];var m13=m[13];var m14=m[14];var m15=m[15];frustum.planes[0].set(m3-m0,m7-m4,m11-m8,m15-m12);frustum.planes[1].set(m3+m0,m7+m4,m11+m8,m15+m12);frustum.planes[2].set(m3-m1,m7-m5,m11-m9,m15-m13);frustum.planes[3].set(m3+m1,m7+m5,m11+m9,m15+m13);frustum.planes[4].set(m3-m2,m7-m6,m11-m10,m15-m14);frustum.planes[5].set(m3+m2,m7+m6,m11+m10,m15+m14);}/** @private */function frustumIntersectsAABB3(frustum,aabb){var ret=Frustum$1.INSIDE;var min=tempVec3a$M;var max=tempVec3b$A;min[0]=aabb[0];min[1]=aabb[1];min[2]=aabb[2];max[0]=aabb[3];max[1]=aabb[4];max[2]=aabb[5];var bminmax=[min,max];for(var _i27=0;_i27<6;++_i27){var plane=frustum.planes[_i27];if(plane.normal[0]*bminmax[plane.testVertex[0]][0]+plane.normal[1]*bminmax[plane.testVertex[1]][1]+plane.normal[2]*bminmax[plane.testVertex[2]][2]+plane.offset<0.0){return Frustum$1.OUTSIDE;}if(plane.normal[0]*bminmax[1-plane.testVertex[0]][0]+plane.normal[1]*bminmax[1-plane.testVertex[1]][1]+plane.normal[2]*bminmax[1-plane.testVertex[2]][2]+plane.offset<0.0){ret=Frustum$1.INTERSECT;}}return ret;}/**
 * Picks a {@link Viewer}'s {@link Entity}s with a canvas-space 2D marquee box.
 *
 * [<img src="https://xeokit.github.io/xeokit-sdk/assets/images/MarqueeSelect.gif">](https://xeokit.github.io/xeokit-sdk/examples/picking/#marqueePick_select)
 *
 * * [[Example 1: Select Objects with Marquee](https://xeokit.github.io/xeokit-sdk/examples/picking/#marqueePick_select)]
 * * [[Example 2: View-Fit Objects with Marquee](https://xeokit.github.io/xeokit-sdk/examples/picking/#marqueePick_viewFit)]
 *
 * # Usage
 *
 * In the example below, we
 *
 * 1. Create a {@link Viewer}, arrange the {@link Camera}
 * 2. Use an {@link XKTLoaderPlugin} to load a BIM model,
 * 3. Create a {@link ObjectsKdTree3} to automatically index the `Viewer's` {@link Entity}s for fast spatial lookup,
 * 4. Create a `MarqueePicker` to pick {@link Entity}s in the {@link Viewer}, using the {@link ObjectsKdTree3} to accelerate picking
 * 5. Create a {@link MarqueePickerMouseControl} to perform the marquee-picking with the `MarqueePicker`, using mouse input to draw the marquee box on the `Viewer's` canvas.
 *
 * When the {@link MarqueePickerMouseControl} is active:
 *
 * * Long-click, drag and release on the canvas to define a marque box that picks {@link Entity}s.
 * * Drag left-to-right to pick {@link Entity}s that intersect the box.
 * * Drag right-to-left to pick {@link Entity}s that are fully inside the box.
 * * On release, the `MarqueePicker` will fire a "picked" event with IDs of the picked {@link Entity}s, if any.
 * * Handling that event, we mark the {@link Entity}s as selected.
 * * Hold down CTRL to multi-pick.
 *
 * ````javascript
 * import {
 *         Viewer,
 *         XKTLoaderPlugin,
 *         ObjectsKdTree3,
 *         MarqueePicker,
 *         MarqueePickerMouseControl
 * } from "xeokit-sdk.es.js";
 *
 * // 1
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [14.9, 14.3, 5.4];
 * viewer.scene.camera.look = [6.5, 8.3, -4.1];
 * viewer.scene.camera.up = [-0.28, 0.9, -0.3];
 *
 * // 2
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const sceneModel = xktLoader.load({
 *     id: "myModel",
 *     src: "../../assets/models/xkt/v8/ifc/HolterTower.ifc.xkt"
 * });
 *
 * // 3
 *
 * const objectsKdTree3 = new ObjectsKdTree3({viewer});
 *
 * // 4
 *
 * const marqueePicker = new MarqueePicker({viewer, objectsKdTree3});
 *
 * // 5
 *
 * const marqueePickerMouseControl = new MarqueePickerMouseControl({marqueePicker});
 *
 * marqueePicker.on("clear", () => {
 *     viewer.scene.setObjectsSelected(viewer.scene.selectedObjectIds, false);
 * });
 *
 * marqueePicker.on("picked", (objectIds) => {
 *     viewer.scene.setObjectsSelected(objectIds, true);
 * });
 *
 * marqueePickerMouseControl.setActive(true);
 * ````
 *
 * # Design Notes
 *
 * * The {@link ObjectsKdTree3} can be shared with any other components that want to use it to spatially search for {@link Entity}s.
 * * The {@link MarqueePickerMouseControl} can be replaced with other types of controllers (i.e. touch), or used alongside them.
 * * The `MarqueePicker` has no input handlers of its own, and provides an API through which to programmatically control marquee picking. By firing the "picked" events, `MarqueePicker` implements the *Blackboard Pattern*.
 */var MarqueePicker=/*#__PURE__*/function(_Component){_inherits(MarqueePicker,_Component);var _super2=_createSuper(MarqueePicker);/**
     * Creates a MarqueePicker.
     *
     * @param {*} cfg Configuration
     * @param {Viewer} cfg.viewer The Viewer to pick Entities from.
     * @param {ObjectsKdTree3} cfg.objectsKdTree3 A k-d tree that indexes the Entities in the Viewer for fast spatial lookup.
     */function MarqueePicker(){var _this9;var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,MarqueePicker);if(!cfg.viewer){throw"[MarqueePicker] Missing config: viewer";}if(!cfg.objectsKdTree3){throw"[MarqueePicker] Missing config: objectsKdTree3";}_this9=_super2.call(this,cfg.viewer.scene,cfg);_this9.viewer=cfg.viewer;_this9._objectsKdTree3=cfg.objectsKdTree3;_this9._canvasMarqueeCorner1=math.vec2();_this9._canvasMarqueeCorner2=math.vec2();_this9._canvasMarquee=math.AABB2();_this9._marqueeFrustum=new Frustum$1();_this9._marqueeFrustumProjMat=math.mat4();_this9._pickMode=false;_this9._marqueeElement=document.createElement('div');document.body.appendChild(_this9._marqueeElement);_this9._marqueeElement.style.position="absolute";_this9._marqueeElement.style["z-index"]="40000005";_this9._marqueeElement.style.width=8+"px";_this9._marqueeElement.style.height=8+"px";_this9._marqueeElement.style.visibility="hidden";_this9._marqueeElement.style.top=0+"px";_this9._marqueeElement.style.left=0+"px";_this9._marqueeElement.style["box-shadow"]="0 2px 5px 0 #182A3D;";_this9._marqueeElement.style["opacity"]=1.0;_this9._marqueeElement.style["pointer-events"]="none";return _this9;}/**
     * Sets the canvas-space position of the first marquee box corner.
     *
     * @param corner1
     */_createClass(MarqueePicker,[{key:"setMarqueeCorner1",value:function setMarqueeCorner1(corner1){this._canvasMarqueeCorner1.set(corner1);this._canvasMarqueeCorner2.set(corner1);this._updateMarquee();}/**
     * Sets the canvas-space position of the second marquee box corner.
     *
     * @param corner2
     */},{key:"setMarqueeCorner2",value:function setMarqueeCorner2(corner2){this._canvasMarqueeCorner2.set(corner2);this._updateMarquee();}/**
     * Sets both canvas-space corner positions of the marquee box.
     *
     * @param corner1
     * @param corner2
     */},{key:"setMarquee",value:function setMarquee(corner1,corner2){this._canvasMarqueeCorner1.set(corner1);this._canvasMarqueeCorner2.set(corner2);this._updateMarquee();}/**
     * Sets if the marquee box is visible.
     *
     * @param {boolean} visible True if the marquee box is to be visible, else false.
     */},{key:"setMarqueeVisible",value:function setMarqueeVisible(visible){this._marqueVisible=visible;this._marqueeElement.style.visibility=visible?"visible":"hidden";}/**
     * Gets if the marquee box is visible.
     *
     * @returns {boolean} True if the marquee box is visible, else false.
     */},{key:"getMarqueeVisible",value:function getMarqueeVisible(){return this._marqueVisible;}/**
     * Sets the pick mode.
     *
     * Supported pick modes are:
     *
     * * MarqueePicker.PICK_MODE_INSIDE - picks {@link Entity}s that are completely inside the marquee box.
     * * MarqueePicker.PICK_MODE_INTERSECTS - picks {@link Entity}s that intersect the marquee box.
     *
     * @param {number} pickMode The pick mode.
     */},{key:"setPickMode",value:function setPickMode(pickMode){if(pickMode!==MarqueePicker.PICK_MODE_INSIDE&&pickMode!==MarqueePicker.PICK_MODE_INTERSECTS){throw"Illegal MarqueePicker pickMode: must be MarqueePicker.PICK_MODE_INSIDE or MarqueePicker.PICK_MODE_INTERSECTS";}if(pickMode!==this._pickMode){this._marqueeElement.style["background-image"]=pickMode===MarqueePicker.PICK_MODE_INSIDE/* Solid */?"url(\"data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='6' ry='6' stroke='%23333' stroke-width='4'/%3e%3c/svg%3e\")"/* Dashed */:"url(\"data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='6' ry='6' stroke='%23333' stroke-width='4' stroke-dasharray='6%2c 14' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e\")";this._pickMode=pickMode;}}/**
     * Gets the pick mode.
     *
     * Supported pick modes are:
     *
     * * MarqueePicker.PICK_MODE_INSIDE - picks {@link Entity}s that are completely inside the marquee box.
     * * MarqueePicker.PICK_MODE_INTERSECTS - picks {@link Entity}s that intersect the marquee box.
     *
     * @returns {number} The pick mode.
     */},{key:"getPickMode",value:function getPickMode(){return this._pickMode;}/**
     * Fires a "clear" event on this MarqueePicker.
     */},{key:"clear",value:function clear(){this.fire("clear",{});}/**
     * Attempts to pick {@link Entity}s, using the current MarquePicker settings.
     *
     * Fires a "picked" event with the IDs of the {@link Entity}s that were picked, if any.
     *
     * @returns {string[]} IDs of the {@link Entity}s that were picked, if any
     */},{key:"pick",value:function pick(){var _this10=this;this._updateMarquee();this._buildMarqueeFrustum();var entityIds=[];var visitNode=function visitNode(node){var intersects=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Frustum$1.INTERSECT;if(intersects===Frustum$1.INTERSECT){intersects=frustumIntersectsAABB3(_this10._marqueeFrustum,node.aabb);}if(intersects===Frustum$1.OUTSIDE){return;}if(node.entities){var entities=node.entities;for(var _i28=0,len=entities.length;_i28<len;_i28++){var entity=entities[_i28];if(!entity.visible){continue;}var entityAABB=entity.aabb;if(_this10._pickMode===MarqueePicker.PICK_MODE_INSIDE){// Select entities that are completely inside marquee
var intersection=frustumIntersectsAABB3(_this10._marqueeFrustum,entityAABB);if(intersection===Frustum$1.INSIDE){entityIds.push(entity.id);}}else{// Select entities that are partially inside marquee
var _intersection=frustumIntersectsAABB3(_this10._marqueeFrustum,entityAABB);if(_intersection!==Frustum$1.OUTSIDE){entityIds.push(entity.id);}}}}if(node.left){visitNode(node.left,intersects);}if(node.right){visitNode(node.right,intersects);}};if(this._canvasMarquee[2]-this._canvasMarquee[0]>3||this._canvasMarquee[3]-this._canvasMarquee[1]>3){// Marquee pick if rectangle big enough
visitNode(this._objectsKdTree3.root);}this.fire("picked",entityIds);return entityIds;}},{key:"_updateMarquee",value:function _updateMarquee(){this._canvasMarquee[0]=Math.min(this._canvasMarqueeCorner1[0],this._canvasMarqueeCorner2[0]);this._canvasMarquee[1]=Math.min(this._canvasMarqueeCorner1[1],this._canvasMarqueeCorner2[1]);this._canvasMarquee[2]=Math.max(this._canvasMarqueeCorner1[0],this._canvasMarqueeCorner2[0]);this._canvasMarquee[3]=Math.max(this._canvasMarqueeCorner1[1],this._canvasMarqueeCorner2[1]);this._marqueeElement.style.width="".concat(this._canvasMarquee[2]-this._canvasMarquee[0],"px");this._marqueeElement.style.height="".concat(this._canvasMarquee[3]-this._canvasMarquee[1],"px");this._marqueeElement.style.left="".concat(this._canvasMarquee[0],"px");this._marqueeElement.style.top="".concat(this._canvasMarquee[1],"px");}},{key:"_buildMarqueeFrustum",value:function _buildMarqueeFrustum(){// https://github.com/xeokit/xeokit-sdk/issues/869#issuecomment-1165375770
var canvas=this.viewer.scene.canvas.canvas;var canvasWidth=canvas.clientWidth;var canvasHeight=canvas.clientHeight;var canvasLeft=canvas.clientLeft;var canvasTop=canvas.clientTop;var xCanvasToClip=2.0/canvasWidth;var yCanvasToClip=2.0/canvasHeight;var NEAR_SCALING=17;var ratio=canvas.clientHeight/canvas.clientWidth;var FAR_PLANE=10000;var left=(this._canvasMarquee[0]-canvasLeft)*xCanvasToClip+-1;var right=(this._canvasMarquee[2]-canvasLeft)*xCanvasToClip+-1;var bottom=-(this._canvasMarquee[3]-canvasTop)*yCanvasToClip+1;var top=-(this._canvasMarquee[1]-canvasTop)*yCanvasToClip+1;var near=this.viewer.scene.camera.frustum.near*(NEAR_SCALING*ratio);var far=FAR_PLANE;math.frustumMat4(left,right,bottom*ratio,top*ratio,near,far,this._marqueeFrustumProjMat);setFrustum(this._marqueeFrustum,this.viewer.scene.camera.viewMatrix,this._marqueeFrustumProjMat);}/**
     * Destroys this MarqueePicker.
     *
     * Does not destroy the {@link Viewer} or the {@link ObjectsKdTree3} provided to the constructor of this MarqueePicker.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(MarqueePicker.prototype),"destroy",this).call(this);if(this._marqueeElement.parentElement){this._marqueeElement.parentElement.removeChild(this._marqueeElement);this._marqueeElement=null;this._objectsKdTree3=null;}}}]);return MarqueePicker;}(Component);/**
 * Pick mode that picks {@link Entity}s that intersect the marquee box.
 *
 * @type {number}
 */MarqueePicker.PICK_MODE_INTERSECTS=0;/**
 * Pick mode that picks {@link Entity}s that are completely inside the marquee box.
 *
 * @type {number}
 */MarqueePicker.PICK_MODE_INSIDE=1;/**
 * Controls a {@link MarqueePicker} with mouse input.
 *
 * See {@link MarqueePicker} for usage example.
 *
 * When the MarqueePickerMouseControl is active:
 *
 * * Long-click, drag and release on the canvas to define a marque box that picks {@link Entity}s.
 * * Drag left-to-right to pick Entities that intersect the box.
 * * Drag right-to-left to pick Entities that are fully inside the box.
 * * On release, the MarqueePicker will fire a "picked" event with IDs of the picked Entities , if any.
 */var MarqueePickerMouseControl=/*#__PURE__*/function(_Component2){_inherits(MarqueePickerMouseControl,_Component2);var _super3=_createSuper(MarqueePickerMouseControl);/**
     * Creates a new MarqueePickerMouseControl.
     *
     * @param {*} cfg Configuration
     * @param {MarqueePicker} cfg.marqueePicker The MarqueePicker to control.
     */function MarqueePickerMouseControl(cfg){var _this11;_classCallCheck(this,MarqueePickerMouseControl);_this11=_super3.call(this,cfg.marqueePicker,cfg);var marqueePicker=cfg.marqueePicker;var scene=marqueePicker.viewer.scene;var canvas=scene.canvas.canvas;var pageStartX;var pageStartY;var pageEndX;var pageEndY;var canvasStartX;var canvasEndX;var isMouseDragging=false;var isMouseDown=false;var mouseWasUpOffCanvas=false;var mouseDownTimer;canvas.addEventListener("mousedown",function(e){if(!_this11.getActive()){return;}if(e.button!==0){// Left button only
return;}mouseDownTimer=setTimeout(function(){var input=marqueePicker.viewer.scene.input;if(!input.keyDown[input.KEY_CTRL]){// Clear selection unless CTRL down
marqueePicker.clear();}pageStartX=e.pageX;pageStartY=e.pageY;canvasStartX=e.offsetX;marqueePicker.setMarqueeCorner1([pageStartX,pageStartY]);isMouseDragging=true;marqueePicker.viewer.cameraControl.pointerEnabled=false;// Disable camera rotation
marqueePicker.setMarqueeVisible(true);canvas.style.cursor="crosshair";},400);isMouseDown=true;});canvas.addEventListener("mouseup",function(e){if(!_this11.getActive()){return;}if(!isMouseDragging&&!mouseWasUpOffCanvas){return;}if(e.button!==0){return;}clearTimeout(mouseDownTimer);pageEndX=e.pageX;pageEndY=e.pageY;var width=Math.abs(pageEndX-pageStartX);var height=Math.abs(pageEndY-pageStartY);isMouseDragging=false;marqueePicker.viewer.cameraControl.pointerEnabled=true;// Enable camera rotation
if(mouseWasUpOffCanvas){mouseWasUpOffCanvas=false;}if(width>3||height>3){// Marquee pick if rectangle big enough
marqueePicker.pick();}});// Bubbling
document.addEventListener("mouseup",function(e){if(!_this11.getActive()){return;}if(e.button!==0){// check if left button was clicked
return;}clearTimeout(mouseDownTimer);if(!isMouseDragging){return;}marqueePicker.setMarqueeVisible(false);isMouseDragging=false;isMouseDown=false;mouseWasUpOffCanvas=true;marqueePicker.viewer.cameraControl.pointerEnabled=true;},true);// Capturing
canvas.addEventListener("mousemove",function(e){if(!_this11.getActive()){return;}if(e.button!==0){// check if left button was clicked
return;}if(!isMouseDown){return;}clearTimeout(mouseDownTimer);if(!isMouseDragging){return;}pageEndX=e.pageX;pageEndY=e.pageY;canvasEndX=e.offsetX;marqueePicker.setMarqueeVisible(true);marqueePicker.setMarqueeCorner2([pageEndX,pageEndY]);marqueePicker.setPickMode(canvasStartX<canvasEndX?MarqueePicker.PICK_MODE_INSIDE:MarqueePicker.PICK_MODE_INTERSECTS);});return _this11;}/**
     * Activates or deactivates this MarqueePickerMouseControl.
     *
     * @param {boolean} active Whether or not to activate.
     */_createClass(MarqueePickerMouseControl,[{key:"setActive",value:function setActive(active){if(this._active===active){return;}this._active=active;this.fire("active",this._active);}/**
     * Gets if this MarqueePickerMouseControl is active.
     *
     * @returns {boolean}
     */},{key:"getActive",value:function getActive(){return this._active;}/**
     *
     */},{key:"destroy",value:function destroy(){}}]);return MarqueePickerMouseControl;}(Component);/**
 @desc Base class for {@link Viewer} plugin classes.
 */var Plugin=/*#__PURE__*/function(){/**
     * Creates this Plugin and installs it into the given {@link Viewer}.
     *
     * @param {string} id ID for this plugin, unique among all plugins in the viewer.
     * @param {Viewer} viewer The viewer.
     * @param {Object} [cfg] Options
     */function Plugin(id,viewer,cfg){_classCallCheck(this,Plugin);/**
         * ID for this Plugin, unique within its {@link Viewer}.
         *
         * @type {string}
         */this.id=cfg&&cfg.id?cfg.id:id;/**
         * The Viewer that contains this Plugin.
         *
         * @type {Viewer}
         */this.viewer=viewer;this._subIdMap=null;// Subscription subId pool
this._subIdEvents=null;// Subscription subIds mapped to event names
this._eventSubs=null;// Event names mapped to subscribers
this._eventSubsNum=null;this._events=null;// Maps names to events
this._eventCallDepth=0;// Helps us catch stack overflows from recursive events
viewer.addPlugin(this);}/**
     * Schedule a task to perform on the next browser interval
     * @param task
     */_createClass(Plugin,[{key:"scheduleTask",value:function scheduleTask(task){core.scheduleTask(task,null);}/**
     * Fires an event on this Plugin.
     *
     * Notifies existing subscribers to the event, optionally retains the event to give to
     * any subsequent notifications on the event as they are made.
     *
     * @param {String} event The event type name
     * @param {Object} value The event parameters
     * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers
     */},{key:"fire",value:function fire(event,value,forget){if(!this._events){this._events={};}if(!this._eventSubs){this._eventSubs={};this._eventSubsNum={};}if(forget!==true){this._events[event]=value||true;// Save notification
}var subs=this._eventSubs[event];var sub;if(subs){// Notify subscriptions
for(var subId in subs){if(subs.hasOwnProperty(subId)){sub=subs[subId];this._eventCallDepth++;if(this._eventCallDepth<300){sub.callback.call(sub.scope,value);}else{this.error("fire: potential stack overflow from recursive event '"+event+"' - dropping this event");}this._eventCallDepth--;}}}}/**
     * Subscribes to an event on this Plugin.
     *
     * The callback is be called with this Plugin as scope.
     *
     * @param {String} event The event
     * @param {Function} callback Called fired on the event
     * @param {Object} [scope=this] Scope for the callback
     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
     */},{key:"on",value:function on(event,callback,scope){if(!this._events){this._events={};}if(!this._subIdMap){this._subIdMap=new Map$1();// Subscription subId pool
}if(!this._subIdEvents){this._subIdEvents={};}if(!this._eventSubs){this._eventSubs={};}if(!this._eventSubsNum){this._eventSubsNum={};}var subs=this._eventSubs[event];if(!subs){subs={};this._eventSubs[event]=subs;this._eventSubsNum[event]=1;}else{this._eventSubsNum[event]++;}var subId=this._subIdMap.addItem();// Create unique subId
subs[subId]={callback:callback,scope:scope||this};this._subIdEvents[subId]=event;var value=this._events[event];if(value!==undefined){// A publication exists, notify callback immediately
callback.call(scope||this,value);}return subId;}/**
     * Cancels an event subscription that was previously made with {@link Plugin#on} or {@link Plugin#once}.
     *
     * @param {String} subId Subscription ID
     */},{key:"off",value:function off(subId){if(subId===undefined||subId===null){return;}if(!this._subIdEvents){return;}var event=this._subIdEvents[subId];if(event){delete this._subIdEvents[subId];var subs=this._eventSubs[event];if(subs){delete subs[subId];this._eventSubsNum[event]--;}this._subIdMap.removeItem(subId);// Release subId
}}/**
     * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is subIdd.
     *
     * This is equivalent to calling {@link Plugin#on}, and then calling {@link Plugin#off} inside the callback function.
     *
     * @param {String} event Data event to listen to
     * @param {Function} callback Called when fresh data is available at the event
     * @param {Object} [scope=this] Scope for the callback
     */},{key:"once",value:function once(event,callback,scope){var self=this;var subId=this.on(event,function(value){self.off(subId);callback.call(scope||this,value);},scope);}/**
     * Returns true if there are any subscribers to the given event on this Plugin.
     *
     * @param {String} event The event
     * @return {Boolean} True if there are any subscribers to the given event on this Plugin.
     */},{key:"hasSubs",value:function hasSubs(event){return this._eventSubsNum&&this._eventSubsNum[event]>0;}/**
     * Logs a message to the JavaScript developer console, prefixed with the ID of this Plugin.
     *
     * @param {String} msg The error message
     */},{key:"log",value:function log(msg){console.log("[xeokit plugin ".concat(this.id,"]: ").concat(msg));}/**
     * Logs a warning message to the JavaScript developer console, prefixed with the ID of this Plugin.
     *
     * @param {String} msg The error message
     */},{key:"warn",value:function warn(msg){console.warn("[xeokit plugin ".concat(this.id,"]: ").concat(msg));}/**
     * Logs an error message to the JavaScript developer console, prefixed with the ID of this Plugin.
     *
     * @param {String} msg The error message
     */},{key:"error",value:function error(msg){console.error("[xeokit plugin ".concat(this.id,"]: ").concat(msg));}/**
     * Sends a message to this Plugin.
     *
     * @private
     */},{key:"send",value:function send(name,value){//...
}/**
     * Destroys this Plugin and removes it from its {@link Viewer}.
     */},{key:"destroy",value:function destroy(){this.viewer.removePlugin(this);}}]);return Plugin;}();var tempVec3a$L=math.vec3();/**
 * Given a view matrix and a relative-to-center (RTC) coordinate origin, returns a view matrix
 * to transform RTC coordinates to View-space.
 *
 * The returned view matrix is
 *
 * @private
 */var createRTCViewMat=function(){var tempMat=new Float64Array(16);var rtcCenterWorld=new Float64Array(4);var rtcCenterView=new Float64Array(4);return function(viewMat,rtcCenter,rtcViewMat){rtcViewMat=rtcViewMat||tempMat;rtcCenterWorld[0]=rtcCenter[0];rtcCenterWorld[1]=rtcCenter[1];rtcCenterWorld[2]=rtcCenter[2];rtcCenterWorld[3]=1;math.transformVec4(viewMat,rtcCenterWorld,rtcCenterView);math.setMat4Translation(viewMat,rtcCenterView,rtcViewMat);return rtcViewMat.slice();};}();/**
 * Converts a World-space 3D position to RTC.
 *
 * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center pos
 * and a single-precision offset fom that center.
 * @private
 * @param {Float64Array} worldPos The World-space position.
 * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.
 * @param {Float32Array} rtcPos Single-precision offset fom that center.
 */function worldToRTCPos(worldPos,rtcCenter,rtcPos){var xHigh=Float32Array.from([worldPos[0]])[0];var xLow=worldPos[0]-xHigh;var yHigh=Float32Array.from([worldPos[1]])[0];var yLow=worldPos[1]-yHigh;var zHigh=Float32Array.from([worldPos[2]])[0];var zLow=worldPos[2]-zHigh;rtcCenter[0]=xHigh;rtcCenter[1]=yHigh;rtcCenter[2]=zHigh;rtcPos[0]=xLow;rtcPos[1]=yLow;rtcPos[2]=zLow;}/**
 * Converts a flat array of double-precision positions to RTC positions, if necessary.
 *
 * Conversion is necessary if the coordinates have values larger than can be expressed at single-precision. When
 * that's the case, then this function will compute the RTC coordinates and RTC center and return true. Otherwise
 * this function does nothing and returns false.
 *
 * When computing the RTC position, this function uses a modulus operation to ensure that, whenever possible,
 * identical RTC centers are reused for different positions arrays.
 *
 * @private
 * @param {Float64Array} worldPositions Flat array of World-space 3D positions.
 * @param {Float64Array} rtcPositions Outputs the computed flat array of 3D RTC positions.
 * @param {Float64Array} rtcCenter Outputs the computed double-precision relative-to-center (RTC) center pos.
 * @param {Number} [cellSize=10000000] The size of each coordinate cell within the RTC coordinate system.
 * @returns {Boolean} ````True```` if the positions actually needed conversion to RTC, else ````false````. When
 * ````false````, we can safely ignore the data returned in ````rtcPositions```` and ````rtcCenter````,
 * since ````rtcCenter```` will equal ````[0,0,0]````, and ````rtcPositions```` will contain identical values to ````positions````.
 */function worldToRTCPositions(worldPositions,rtcPositions,rtcCenter){var cellSize=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1000;var center=math.getPositionsCenter(worldPositions,tempVec3a$L);var rtcCenterX=Math.round(center[0]/cellSize)*cellSize;var rtcCenterY=Math.round(center[1]/cellSize)*cellSize;var rtcCenterZ=Math.round(center[2]/cellSize)*cellSize;rtcCenter[0]=rtcCenterX;rtcCenter[1]=rtcCenterY;rtcCenter[2]=rtcCenterZ;var rtcNeeded=rtcCenter[0]!==0||rtcCenter[1]!==0||rtcCenter[2]!==0;if(rtcNeeded){for(var _i29=0,len=worldPositions.length;_i29<len;_i29+=3){rtcPositions[_i29+0]=worldPositions[_i29+0]-rtcCenterX;rtcPositions[_i29+1]=worldPositions[_i29+1]-rtcCenterY;rtcPositions[_i29+2]=worldPositions[_i29+2]-rtcCenterZ;}}return rtcNeeded;}/**
 * Converts an RTC 3D position to World-space.
 *
 * @private
 * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.
 * @param {Float32Array} rtcPos Single-precision offset fom that center.
 * @param {Float64Array} worldPos The World-space position.
 */function rtcToWorldPos(rtcCenter,rtcPos,worldPos){worldPos[0]=rtcCenter[0]+rtcPos[0];worldPos[1]=rtcCenter[1]+rtcPos[1];worldPos[2]=rtcCenter[2]+rtcPos[2];return worldPos;}/**
 * Given a 3D plane defined by distance from origin and direction, and an RTC center position,
 * return a plane position that is relative to the RTC center.
 *
 * @private
 * @param dist
 * @param dir
 * @param rtcCenter
 * @param rtcPlanePos
 * @returns {*}
 */function getPlaneRTCPos(dist,dir,rtcCenter,rtcPlanePos){var rtcCenterToPlaneDist=math.dotVec3(dir,rtcCenter)+dist;var dirNormalized=math.normalizeVec3(dir,tempVec3a$L);math.mulVec3Scalar(dirNormalized,-rtcCenterToPlaneDist,rtcPlanePos);return rtcPlanePos;}/**
 * @private
 * @type {{PICKABLE: number, CLIPPABLE: number, BACKFACES: number, VISIBLE: number, SELECTED: number, OUTLINED: number, CULLED: number, RECEIVE_SHADOW: number, COLLIDABLE: number, XRAYED: number, CAST_SHADOW: number, EDGES: number, HIGHLIGHTED: number}}
 */var ENTITY_FLAGS={VISIBLE:1,CULLED:1<<2,PICKABLE:1<<3,CLIPPABLE:1<<4,COLLIDABLE:1<<5,CAST_SHADOW:1<<6,RECEIVE_SHADOW:1<<7,XRAYED:1<<8,HIGHLIGHTED:1<<9,SELECTED:1<<10,EDGES:1<<11,BACKFACES:1<<12,TRANSPARENT:1<<13};var tempFloatRGB=new Float32Array([0,0,0]);var tempIntRGB=new Uint16Array([0,0,0]);math.OBB3();/**
 * An entity within a {@link SceneModel}
 *
 * * Created with {@link SceneModel#createEntity}
 * * Stored by ID in {@link SceneModel#entities}
 * * Has one or more {@link SceneModelMesh}es
 *
 * @implements {Entity}
 */var SceneModelEntity=/*#__PURE__*/function(){/**
     * @private
     */function SceneModelEntity(model,isObject,id,meshes,flags,lodCullable){_classCallCheck(this,SceneModelEntity);this._isObject=isObject;/**
         * The {@link Scene} to which this SceneModelEntity belongs.
         */this.scene=model.scene;/**
         * The {@link SceneModel} to which this SceneModelEntity belongs.
         */this.model=model;/**
         * The {@link SceneModelMesh}es belonging to this SceneModelEntity.
         *
         * * These are created with {@link SceneModel#createMesh} and registered in {@ilnk SceneModel#meshes}
         * * Each SceneModelMesh belongs to one SceneModelEntity
         */this.meshes=meshes;this._numPrimitives=0;for(var _i30=0,len=this.meshes.length;_i30<len;_i30++){// TODO: tidier way? Refactor?
var _mesh=this.meshes[_i30];_mesh.parent=this;_mesh.entity=this;this._numPrimitives+=_mesh.numPrimitives;}/**
         * The unique ID of this SceneModelEntity.
         */this.id=id;/**
         * The original system ID of this SceneModelEntity.
         */this.originalSystemId=math.unglobalizeObjectId(model.id,id);this._flags=flags;this._aabb=math.AABB3();this._aabbDirty=true;this._offset=math.vec3();this._colorizeUpdated=false;this._opacityUpdated=false;this._lodCullable=!!lodCullable;this._culled=false;this._culledVFC=false;this._culledLOD=false;if(this._isObject){model.scene._registerObject(this);}}_createClass(SceneModelEntity,[{key:"_transformDirty",value:function _transformDirty(){this._aabbDirty=true;this.model._transformDirty();}},{key:"_sceneModelDirty",value:function _sceneModelDirty(){// Called by SceneModel when SceneModel's matrix is updated
this._aabbDirty=true;for(var _i31=0,len=this.meshes.length;_i31<len;_i31++){this.meshes[_i31]._sceneModelDirty();}}/**
     * World-space 3D axis-aligned bounding box (AABB) of this SceneModelEntity.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin, zmin, xmax, ymax, zmax]````.
     *
     * @type {Float64Array}
     */},{key:"aabb",get:function get(){if(this._aabbDirty){math.collapseAABB3(this._aabb);for(var _i32=0,len=this.meshes.length;_i32<len;_i32++){math.expandAABB3(this._aabb,this.meshes[_i32].aabb);}this._aabbDirty=false;}// if (this._aabbDirty) {
//     math.AABB3ToOBB3(this._aabb, tempOBB3a);
//     math.transformOBB3(this.model.matrix, tempOBB3a);
//     math.OBB3ToAABB3(tempOBB3a, this._worldAABB);
//     this._worldAABB[0] += this._offset[0];
//     this._worldAABB[1] += this._offset[1];
//     this._worldAABB[2] += this._offset[2];
//     this._worldAABB[3] += this._offset[0];
//     this._worldAABB[4] += this._offset[1];
//     this._worldAABB[5] += this._offset[2];
//     this._aabbDirty = false;
// }
return this._aabb;}},{key:"isEntity",get:function get(){return true;}/**
     * Returns false to indicate that this Entity subtype is not a model.
     * @returns {boolean}
     */},{key:"isModel",get:function get(){return false;}/**
     * Returns ````true```` if this SceneModelEntity represents an object.
     *
     * When this is ````true````, the SceneModelEntity will be registered by {@link SceneModelEntity#id}
     * in {@link Scene#objects} and may also have a corresponding {@link MetaObject}.
     *
     * @type {Boolean}
     */},{key:"isObject",get:function get(){return this._isObject;}},{key:"numPrimitives",get:function get(){return this._numPrimitives;}/**
     * The approximate number of triangles in this SceneModelEntity.
     *
     * @type {Number}
     */},{key:"numTriangles",get:function get(){return this._numPrimitives;}/**
     * Gets if this SceneModelEntity is visible.
     *
     * Only rendered when {@link SceneModelEntity#visible} is ````true````
     * and {@link SceneModelEntity#culled} is ````false````.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#visible} are
     * both ````true```` the SceneModelEntity will be registered
     * by {@link SceneModelEntity#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */},{key:"visible",get:function get(){return this._getFlag(ENTITY_FLAGS.VISIBLE);}/**
     * Sets if this SceneModelEntity is visible.
     *
     * Only rendered when {@link SceneModelEntity#visible} is ````true```` and {@link SceneModelEntity#culled} is ````false````.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#visible} are
     * both ````true```` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */,set:function set(visible){if(!!(this._flags&ENTITY_FLAGS.VISIBLE)===visible){return;// Redundant update
}if(visible){this._flags=this._flags|ENTITY_FLAGS.VISIBLE;}else{this._flags=this._flags&~ENTITY_FLAGS.VISIBLE;}for(var _i33=0,len=this.meshes.length;_i33<len;_i33++){this.meshes[_i33]._setVisible(this._flags);}if(this._isObject){this.model.scene._objectVisibilityUpdated(this);}this.model.glRedraw();}/**
     * Gets if this SceneModelEntity is highlighted.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#highlighted} are both ````true```` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */},{key:"highlighted",get:function get(){return this._getFlag(ENTITY_FLAGS.HIGHLIGHTED);}/**
     * Sets if this SceneModelEntity is highlighted.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#highlighted} are both ````true```` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */,set:function set(highlighted){if(!!(this._flags&ENTITY_FLAGS.HIGHLIGHTED)===highlighted){return;// Redundant update
}if(highlighted){this._flags=this._flags|ENTITY_FLAGS.HIGHLIGHTED;}else{this._flags=this._flags&~ENTITY_FLAGS.HIGHLIGHTED;}for(var i=0,len=this.meshes.length;i<len;i++){this.meshes[i]._setHighlighted(this._flags);}if(this._isObject){this.model.scene._objectHighlightedUpdated(this);}this.model.glRedraw();}/**
     * Gets if this SceneModelEntity is xrayed.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#xrayed} are both ````true``` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */},{key:"xrayed",get:function get(){return this._getFlag(ENTITY_FLAGS.XRAYED);}/**
     * Sets if this SceneModelEntity is xrayed.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#xrayed} are both ````true``` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */,set:function set(xrayed){if(!!(this._flags&ENTITY_FLAGS.XRAYED)===xrayed){return;// Redundant update
}if(xrayed){this._flags=this._flags|ENTITY_FLAGS.XRAYED;}else{this._flags=this._flags&~ENTITY_FLAGS.XRAYED;}for(var _i34=0,len=this.meshes.length;_i34<len;_i34++){this.meshes[_i34]._setXRayed(this._flags);}if(this._isObject){this.model.scene._objectXRayedUpdated(this);}this.model.glRedraw();}/**
     * Gets if this SceneModelEntity is selected.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#selected} are both ````true``` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */},{key:"selected",get:function get(){return this._getFlag(ENTITY_FLAGS.SELECTED);}/**
     * Gets if this SceneModelEntity is selected.
     *
     * When {@link SceneModelEntity#isObject} and {@link SceneModelEntity#selected} are both ````true``` the SceneModelEntity will be
     * registered by {@link SceneModelEntity#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */,set:function set(selected){if(!!(this._flags&ENTITY_FLAGS.SELECTED)===selected){return;// Redundant update
}if(selected){this._flags=this._flags|ENTITY_FLAGS.SELECTED;}else{this._flags=this._flags&~ENTITY_FLAGS.SELECTED;}for(var _i35=0,len=this.meshes.length;_i35<len;_i35++){this.meshes[_i35]._setSelected(this._flags);}if(this._isObject){this.model.scene._objectSelectedUpdated(this);}this.model.glRedraw();}/**
     * Gets if this SceneModelEntity's edges are enhanced.
     *
     * @type {Boolean}
     */},{key:"edges",get:function get(){return this._getFlag(ENTITY_FLAGS.EDGES);}/**
     * Sets if this SceneModelEntity's edges are enhanced.
     *
     * @type {Boolean}
     */,set:function set(edges){if(!!(this._flags&ENTITY_FLAGS.EDGES)===edges){return;// Redundant update
}if(edges){this._flags=this._flags|ENTITY_FLAGS.EDGES;}else{this._flags=this._flags&~ENTITY_FLAGS.EDGES;}for(var i=0,len=this.meshes.length;i<len;i++){this.meshes[i]._setEdges(this._flags);}this.model.glRedraw();}},{key:"culledVFC",get:function get(){return!!this._culledVFC;},set:function set(culled){this._culledVFC=culled;this._setCulled();}},{key:"culledLOD",get:function get(){return!!this._culledLOD;},set:function set(culled){this._culledLOD=culled;this._setCulled();}/**
     * Gets if this SceneModelEntity is culled.
     *
     * Only rendered when {@link SceneModelEntity#visible} is ````true```` and {@link SceneModelEntity#culled} is ````false````.
     *
     * @type {Boolean}
     */},{key:"culled",get:function get(){return!!this._culled;// return this._getFlag(ENTITY_FLAGS.CULLED);
}/**
     * Sets if this SceneModelEntity is culled.
     *
     * Only rendered when {@link SceneModelEntity#visible} is ````true```` and {@link SceneModelEntity#culled} is ````false````.
     *
     * @type {Boolean}
     */,set:function set(culled){this._culled=culled;this._setCulled();}},{key:"_setCulled",value:function _setCulled(){var culled=!!this._culled||!!(this._culledLOD&&this._lodCullable)||!!this._culledVFC;if(!!(this._flags&ENTITY_FLAGS.CULLED)===culled){return;// Redundant update
}if(culled){this._flags=this._flags|ENTITY_FLAGS.CULLED;}else{this._flags=this._flags&~ENTITY_FLAGS.CULLED;}for(var i=0,len=this.meshes.length;i<len;i++){this.meshes[i]._setCulled(this._flags);}this.model.glRedraw();}/**
     * Gets if this SceneModelEntity is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */},{key:"clippable",get:function get(){return this._getFlag(ENTITY_FLAGS.CLIPPABLE);}/**
     * Sets if this SceneModelEntity is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */,set:function set(clippable){if(!!(this._flags&ENTITY_FLAGS.CLIPPABLE)===clippable){return;// Redundant update
}if(clippable){this._flags=this._flags|ENTITY_FLAGS.CLIPPABLE;}else{this._flags=this._flags&~ENTITY_FLAGS.CLIPPABLE;}for(var i=0,len=this.meshes.length;i<len;i++){this.meshes[i]._setClippable(this._flags);}this.model.glRedraw();}/**
     * Gets if this SceneModelEntity is included in boundary calculations.
     *
     * @type {Boolean}
     */},{key:"collidable",get:function get(){return this._getFlag(ENTITY_FLAGS.COLLIDABLE);}/**
     * Sets if this SceneModelEntity is included in boundary calculations.
     *
     * @type {Boolean}
     */,set:function set(collidable){if(!!(this._flags&ENTITY_FLAGS.COLLIDABLE)===collidable){return;// Redundant update
}if(collidable){this._flags=this._flags|ENTITY_FLAGS.COLLIDABLE;}else{this._flags=this._flags&~ENTITY_FLAGS.COLLIDABLE;}for(var i=0,len=this.meshes.length;i<len;i++){this.meshes[i]._setCollidable(this._flags);}}/**
     * Gets if this SceneModelEntity is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */},{key:"pickable",get:function get(){return this._getFlag(ENTITY_FLAGS.PICKABLE);}/**
     * Sets if this SceneModelEntity is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */,set:function set(pickable){if(!!(this._flags&ENTITY_FLAGS.PICKABLE)===pickable){return;// Redundant update
}if(pickable){this._flags=this._flags|ENTITY_FLAGS.PICKABLE;}else{this._flags=this._flags&~ENTITY_FLAGS.PICKABLE;}for(var i=0,len=this.meshes.length;i<len;i++){this.meshes[i]._setPickable(this._flags);}}/**
     * Gets the SceneModelEntity's RGB colorize color, multiplies by the SceneModelEntity's rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */},{key:"colorize",get:function get(){// [0..1, 0..1, 0..1]
if(this.meshes.length===0){return null;}var colorize=this.meshes[0]._colorize;tempFloatRGB[0]=colorize[0]/255.0;// Unquantize
tempFloatRGB[1]=colorize[1]/255.0;tempFloatRGB[2]=colorize[2]/255.0;return tempFloatRGB;}/**
     * Sets the SceneModelEntity's RGB colorize color, multiplies by the SceneModelEntity's rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */,set:function set(color){// [0..1, 0..1, 0..1]
if(color){tempIntRGB[0]=Math.floor(color[0]*255.0);// Quantize
tempIntRGB[1]=Math.floor(color[1]*255.0);tempIntRGB[2]=Math.floor(color[2]*255.0);for(var _i36=0,len=this.meshes.length;_i36<len;_i36++){this.meshes[_i36]._setColorize(tempIntRGB);}}else{for(var _i37=0,_len4=this.meshes.length;_i37<_len4;_i37++){this.meshes[_i37]._setColorize(null);}}if(this._isObject){var colorized=!!color;this.scene._objectColorizeUpdated(this,colorized);this._colorizeUpdated=colorized;}this.model.glRedraw();}/**
     * Gets the SceneModelEntity's opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */},{key:"opacity",get:function get(){if(this.meshes.length>0){return this.meshes[0]._colorize[3]/255.0;}else{return 1.0;}}/**
     * Sets the SceneModelEntity's opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(opacity){if(this.meshes.length===0){return;}var opacityUpdated=opacity!==null&&opacity!==undefined;var lastOpacityQuantized=this.meshes[0]._colorize[3];var opacityQuantized=255;if(opacityUpdated){if(opacity<0){opacity=0;}else if(opacity>1){opacity=1;}opacityQuantized=Math.floor(opacity*255.0);// Quantize
if(lastOpacityQuantized===opacityQuantized){return;}}else{opacityQuantized=255.0;if(lastOpacityQuantized===opacityQuantized){return;}}for(var _i38=0,len=this.meshes.length;_i38<len;_i38++){this.meshes[_i38]._setOpacity(opacityQuantized,this._flags);}if(this._isObject){this.scene._objectOpacityUpdated(this,opacityUpdated);this._opacityUpdated=opacityUpdated;}this.model.glRedraw();}/**
     * Gets the SceneModelEntity's 3D World-space offset.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */},{key:"offset",get:function get(){return this._offset;}/**
     * Sets the SceneModelEntity's 3D World-space offset.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(offset){if(offset){this._offset[0]=offset[0];this._offset[1]=offset[1];this._offset[2]=offset[2];}else{this._offset[0]=0;this._offset[1]=0;this._offset[2]=0;}for(var _i39=0,len=this.meshes.length;_i39<len;_i39++){this.meshes[_i39]._setOffset(this._offset);}this._aabbDirty=true;this.model._aabbDirty=true;this.scene._aabbDirty=true;this.scene._objectOffsetUpdated(this,offset);this.model.glRedraw();}},{key:"saoEnabled",get:function get(){return this.model.saoEnabled;}},{key:"getEachVertex",value:function getEachVertex(callback){for(var _i40=0,len=this.meshes.length;_i40<len;_i40++){this.meshes[_i40].getEachVertex(callback);}}},{key:"_getFlag",value:function _getFlag(flag){return!!(this._flags&flag);}},{key:"_finalize",value:function _finalize(){var scene=this.model.scene;if(this._isObject){if(this.visible){scene._objectVisibilityUpdated(this);}if(this.highlighted){scene._objectHighlightedUpdated(this);}if(this.xrayed){scene._objectXRayedUpdated(this);}if(this.selected){scene._objectSelectedUpdated(this);}}for(var _i41=0,len=this.meshes.length;_i41<len;_i41++){this.meshes[_i41]._finalize(this._flags);}}},{key:"_finalize2",value:function _finalize2(){for(var _i42=0,len=this.meshes.length;_i42<len;_i42++){this.meshes[_i42]._finalize2();}}},{key:"_destroy",value:function _destroy(){var scene=this.model.scene;if(this._isObject){scene._deregisterObject(this);if(this.visible){scene._deRegisterVisibleObject(this);}if(this.xrayed){scene._deRegisterXRayedObject(this);}if(this.selected){scene._deRegisterSelectedObject(this);}if(this.highlighted){scene._deRegisterHighlightedObject(this);}if(this._colorizeUpdated){this.scene._deRegisterColorizedObject(this);}if(this._opacityUpdated){this.scene._deRegisterOpacityObject(this);}if(this._offset&&(this._offset[0]!==0||this._offset[1]!==0||this._offset[2]!==0)){this.scene._deRegisterOffsetObject(this);}}for(var _i43=0,len=this.meshes.length;_i43<len;_i43++){this.meshes[_i43]._destroy();}scene._aabbDirty=true;}}]);return SceneModelEntity;}();var tempVec4a$9=math.vec4();var tempVec4b$6=math.vec4();/**
 * @desc Tracks the World, View and Canvas coordinates, and visibility, of a position within a {@link Scene}.
 *
 * ## Position
 *
 * A Marker holds its position in the World, View and Canvas coordinate systems in three properties:
 *
 * * {@link Marker#worldPos} holds the Marker's 3D World-space coordinates. This property can be dynamically updated. The Marker will fire a "worldPos" event whenever this property changes.
 * * {@link Marker#viewPos} holds the Marker's 3D View-space coordinates. This property is read-only, and is automatically updated from {@link Marker#worldPos} and the current {@link Camera} position. The Marker will fire a "viewPos" event whenever this property changes.
 * * {@link Marker#canvasPos} holds the Marker's 2D Canvas-space coordinates. This property is read-only, and is automatically updated from {@link Marker#canvasPos} and the current {@link Camera} position and projection. The Marker will fire a "canvasPos" event whenever this property changes.
 *
 * ## Visibility
 *
 * {@link Marker#visible} indicates if the Marker is currently visible. The Marker will fire a "visible" event whenever {@link Marker#visible} changes.
 *
 * This property will be ````false```` when:
 *
 * * {@link Marker#entity} is set to an {@link Entity}, and {@link Entity#visible} is ````false````,
 * * {@link Marker#occludable} is ````true```` and the Marker is occluded by some {@link Entity} in the 3D view, or
 * * {@link Marker#canvasPos} is outside the boundary of the {@link Canvas}.
 *
 * ## Usage
 *
 * In the example below, we'll create a Marker that's associated with a {@link Mesh} (which a type of {@link Entity}).
 *
 * We'll configure our Marker to
 * become invisible whenever it's occluded by any Entities in the canvas.
 *
 * We'll also demonstrate how to query the Marker's visibility status and position (in the World, View and
 * Canvas coordinate systems), and how to subscribe to change events on those properties.
 *
 * [[Run this example](/examples/#Markers_SimpleExample)]
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin, Marker} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Create the torus Mesh
 * // Recall that a Mesh is an Entity
 * new Mesh(viewer.scene, {
 *     geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *         center: [0,0,0],
 *         radius: 1.0,
 *         tube: 0.5,
 *         radialSegments: 32,
 *         tubeSegments: 24,
 *         arc: Math.PI * 2.0
 *     }),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         }),
 *         backfaces: true
 *     })
 * });
 *
 * // Create the Marker, associated with our Mesh Entity
 * const myMarker = new Marker({
 *      entity: entity,
 *      worldPos: [10,0,0],
 *      occludable: true
 * });
 *
 * // Get the Marker's current World, View and Canvas coordinates
 * const worldPos   = myMarker.worldPos;     // 3D World-space position
 * const viewPos    = myMarker.viewPos;      // 3D View-space position
 * const canvasPos  = myMarker.canvasPos;    // 2D Canvas-space position
 *
 * const visible = myMarker.visible;
 *
 * // Listen for change of the Marker's 3D World-space position
 * myMarker.on("worldPos", function(worldPos) {
 *    //...
 * });
 *
 * // Listen for change of the Marker's 3D View-space position, which happens
 * // when either worldPos was updated or the Camera was moved
 * myMarker.on("viewPos", function(viewPos) {
 *    //...
 * });
 *
 * // Listen for change of the Marker's 2D Canvas-space position, which happens
 * // when worldPos or viewPos was updated, or Camera's projection was updated
 * myMarker.on("canvasPos", function(canvasPos) {
 *    //...
 * });
 *
 * // Listen for change of Marker visibility. The Marker becomes invisible when it falls outside the canvas,
 * // has an Entity that is also invisible, or when an Entity occludes the Marker's position in the 3D view.
 * myMarker.on("visible", function(visible) { // Marker visibility has changed
 *    if (visible) {
 *        this.log("Marker is visible");
 *    } else {
 *        this.log("Marker is invisible");
 *    }
 * });
 *
 * // Listen for destruction of Marker
 * myMarker.on("destroyed", () => {
 *      //...
 * });
 * ````
 */var Marker=/*#__PURE__*/function(_Component3){_inherits(Marker,_Component3);var _super4=_createSuper(Marker);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this Marker as well.
     * @param {*} [cfg]  Marker configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Entity} [cfg.entity] Entity to associate this Marker with. When the Marker has an Entity, then {@link Marker#visible} will always be ````false```` if {@link Entity#visible} is false.
     * @param {Boolean} [cfg.occludable=false] Indicates whether or not this Marker is hidden (ie. {@link Marker#visible} is ````false```` whenever occluded by {@link Entity}s in the {@link Scene}.
     * @param {Number[]} [cfg.worldPos=[0,0,0]] World-space 3D Marker position.
     */function Marker(owner,cfg){var _this12;_classCallCheck(this,Marker);_this12=_super4.call(this,owner,cfg);_this12._entity=null;_this12._visible=null;_this12._worldPos=math.vec3();_this12._origin=math.vec3();_this12._rtcPos=math.vec3();_this12._viewPos=math.vec3();_this12._canvasPos=math.vec2();_this12._occludable=false;_this12._onCameraViewMatrix=_this12.scene.camera.on("matrix",function(){_this12._viewPosDirty=true;_this12._needUpdate();});_this12._onCameraProjMatrix=_this12.scene.camera.on("projMatrix",function(){_this12._canvasPosDirty=true;_this12._needUpdate();});_this12._onEntityDestroyed=null;_this12._onEntityModelDestroyed=null;_this12._renderer.addMarker(_assertThisInitialized(_this12));_this12.entity=cfg.entity;_this12.worldPos=cfg.worldPos;_this12.occludable=cfg.occludable;return _this12;}_createClass(Marker,[{key:"_update",value:function _update(){// this._needUpdate() schedules this for next tick
if(this._viewPosDirty){math.transformPoint3(this.scene.camera.viewMatrix,this._worldPos,this._viewPos);this._viewPosDirty=false;this._canvasPosDirty=true;this.fire("viewPos",this._viewPos);}if(this._canvasPosDirty){tempVec4a$9.set(this._viewPos);tempVec4a$9[3]=1.0;math.transformPoint4(this.scene.camera.projMatrix,tempVec4a$9,tempVec4b$6);var aabb=this.scene.canvas.boundary;this._canvasPos[0]=Math.floor((1+tempVec4b$6[0]/tempVec4b$6[3])*aabb[2]/2);this._canvasPos[1]=Math.floor((1-tempVec4b$6[1]/tempVec4b$6[3])*aabb[3]/2);this._canvasPosDirty=false;this.fire("canvasPos",this._canvasPos);}}},{key:"_setVisible",value:function _setVisible(visible){// Called by VisibilityTester and this._entity.on("destroyed"..)
if(this._visible===visible);this._visible=visible;this.fire("visible",this._visible);}/**
     * Sets the {@link Entity} this Marker is associated with.
     *
     * An Entity is optional. When the Marker has an Entity, then {@link Marker#visible} will always be ````false````
     * if {@link Entity#visible} is false.
     *
     * @type {Entity}
     */},{key:"entity",get:/**
     * Gets the {@link Entity} this Marker is associated with.
     *
     * @type {Entity}
     */function get(){return this._entity;}/**
     * Sets whether occlusion testing is performed for this Marker.
     *
     * When this is ````true````, then {@link Marker#visible} will be ````false```` whenever the Marker is occluded by an {@link Entity} in the 3D view.
     *
     * The {@link Scene} periodically occlusion-tests all Markers on every 20th "tick" (which represents a rendered frame). We
     * can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.
     *
     * @type {Boolean}
     */,set:function set(entity){var _this13=this;if(this._entity){if(this._entity===entity){return;}if(this._onEntityDestroyed!==null){this._entity.off(this._onEntityDestroyed);this._onEntityDestroyed=null;}if(this._onEntityModelDestroyed!==null){this._entity.model.off(this._onEntityModelDestroyed);this._onEntityModelDestroyed=null;}}this._entity=entity;if(this._entity){if(this._entity instanceof SceneModelEntity){this._onEntityModelDestroyed=this._entity.model.on("destroyed",function(){// SceneModelEntity does not fire events, and cannot exist beyond its VBOSceneModel
_this13._entity=null;// Marker now may become visible, if it was synched to invisible Entity
_this13._onEntityModelDestroyed=null;});}else{this._onEntityDestroyed=this._entity.on("destroyed",function(){_this13._entity=null;_this13._onEntityDestroyed=null;});}}this.fire("entity",this._entity,true/* forget */);}},{key:"occludable",get:/**
     * Gets whether occlusion testing is performed for this Marker.
     *
     * When this is ````true````, then {@link Marker#visible} will be ````false```` whenever the Marker is occluded by an {@link Entity} in the 3D view.
     *
     * @type {Boolean}
     */function get(){return this._occludable;}/**
     * Sets the World-space 3D position of this Marker.
     *
     * Fires a "worldPos" event with new World position.
     *
     * @type {Number[]}
     */,set:function set(occludable){occludable=!!occludable;if(occludable===this._occludable){return;}this._occludable=occludable;}},{key:"worldPos",get:/**
     * Gets the World-space 3D position of this Marker.
     *
     * @type {Number[]}
     */function get(){return this._worldPos;}/**
     * Gets the RTC center of this Marker.
     *
     * This is automatically calculated from {@link Marker#worldPos}.
     *
     * @type {Number[]}
     */,set:function set(worldPos){this._worldPos.set(worldPos||[0,0,0]);worldToRTCPos(this._worldPos,this._origin,this._rtcPos);if(this._occludable){this._renderer.markerWorldPosUpdated(this);}this._viewPosDirty=true;this.fire("worldPos",this._worldPos);this._needUpdate();}},{key:"origin",get:function get(){return this._origin;}/**
     * Gets the RTC position of this Marker.
     *
     * This is automatically calculated from {@link Marker#worldPos}.
     *
     * @type {Number[]}
     */},{key:"rtcPos",get:function get(){return this._rtcPos;}/**
     * View-space 3D coordinates of this Marker.
     *
     * This property is read-only and is automatically calculated from {@link Marker#worldPos} and the current {@link Camera} position.
     *
     * The Marker fires a "viewPos" event whenever this property changes.
     *
     * @type {Number[]}
     * @final
     */},{key:"viewPos",get:function get(){this._update();return this._viewPos;}/**
     * Canvas-space 2D coordinates of this Marker.
     *
     * This property is read-only and is automatically calculated from {@link Marker#worldPos} and the current {@link Camera} position and projection.
     *
     * The Marker fires a "canvasPos" event whenever this property changes.
     *
     * @type {Number[]}
     * @final
     */},{key:"canvasPos",get:function get(){this._update();return this._canvasPos;}/**
     * Indicates if this Marker is currently visible.
     *
     * This is read-only and is automatically calculated.
     *
     * The Marker is **invisible** whenever:
     *
     * * {@link Marker#canvasPos} is currently outside the canvas,
     * * {@link Marker#entity} is set to an {@link Entity} that has {@link Entity#visible} ````false````, or
     * * or {@link Marker#occludable} is ````true```` and the Marker is currently occluded by an Entity in the 3D view.
     *
     * The Marker fires a "visible" event whenever this property changes.
     *
     * @type {Boolean}
     * @final
     */},{key:"visible",get:function get(){return!!this._visible;}/**
     * Destroys this Marker.
     */},{key:"destroy",value:function destroy(){this.fire("destroyed",true);this.scene.camera.off(this._onCameraViewMatrix);this.scene.camera.off(this._onCameraProjMatrix);if(this._entity){if(this._onEntityDestroyed!==null){this._entity.off(this._onEntityDestroyed);}if(this._onEntityModelDestroyed!==null){this._entity.model.off(this._onEntityModelDestroyed);}}this._renderer.removeMarker(this);_get(_getPrototypeOf(Marker.prototype),"destroy",this).call(this);}}]);return Marker;}(Component);/** @private */var Wire=/*#__PURE__*/function(){function Wire(parentElement){var _this14=this;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Wire);this._color=cfg.color||"black";this._highlightClass="viewer-ruler-wire-highlighted";this._wire=document.createElement('div');this._wire.className+=this._wire.className?' viewer-ruler-wire':'viewer-ruler-wire';this._wireClickable=document.createElement('div');this._wireClickable.className+=this._wireClickable.className?' viewer-ruler-wire-clickable':'viewer-ruler-wire-clickable';this._thickness=cfg.thickness||1.0;this._thicknessClickable=cfg.thicknessClickable||6.0;this._visible=true;this._culled=false;var wire=this._wire;var wireStyle=wire.style;wireStyle.border="solid "+this._thickness+"px "+this._color;wireStyle.position="absolute";wireStyle["z-index"]=cfg.zIndex===undefined?"2000001":cfg.zIndex;wireStyle.width=0+"px";wireStyle.height=0+"px";wireStyle.visibility="visible";wireStyle.top=0+"px";wireStyle.left=0+"px";wireStyle['-webkit-transform-origin']="0 0";wireStyle['-moz-transform-origin']="0 0";wireStyle['-ms-transform-origin']="0 0";wireStyle['-o-transform-origin']="0 0";wireStyle['transform-origin']="0 0";wireStyle['-webkit-transform']='rotate(0deg)';wireStyle['-moz-transform']='rotate(0deg)';wireStyle['-ms-transform']='rotate(0deg)';wireStyle['-o-transform']='rotate(0deg)';wireStyle['transform']='rotate(0deg)';wireStyle["opacity"]=1.0;wireStyle["pointer-events"]="none";if(cfg.onContextMenu);parentElement.appendChild(wire);var wireClickable=this._wireClickable;var wireClickableStyle=wireClickable.style;wireClickableStyle.border="solid "+this._thicknessClickable+"px "+this._color;wireClickableStyle.position="absolute";wireClickableStyle["z-index"]=cfg.zIndex===undefined?"2000002":cfg.zIndex+1;wireClickableStyle.width=0+"px";wireClickableStyle.height=0+"px";wireClickableStyle.visibility="visible";wireClickableStyle.top=0+"px";wireClickableStyle.left=0+"px";// wireClickableStyle["pointer-events"] = "none";
wireClickableStyle['-webkit-transform-origin']="0 0";wireClickableStyle['-moz-transform-origin']="0 0";wireClickableStyle['-ms-transform-origin']="0 0";wireClickableStyle['-o-transform-origin']="0 0";wireClickableStyle['transform-origin']="0 0";wireClickableStyle['-webkit-transform']='rotate(0deg)';wireClickableStyle['-moz-transform']='rotate(0deg)';wireClickableStyle['-ms-transform']='rotate(0deg)';wireClickableStyle['-o-transform']='rotate(0deg)';wireClickableStyle['transform']='rotate(0deg)';wireClickableStyle["opacity"]=0.0;wireClickableStyle["pointer-events"]="none";if(cfg.onContextMenu);parentElement.appendChild(wireClickable);if(cfg.onMouseOver){wireClickable.addEventListener('mouseover',function(event){cfg.onMouseOver(event,_this14);});}if(cfg.onMouseLeave){wireClickable.addEventListener('mouseleave',function(event){cfg.onMouseLeave(event,_this14);});}if(cfg.onMouseWheel){wireClickable.addEventListener('wheel',function(event){cfg.onMouseWheel(event,_this14);});}if(cfg.onMouseDown){wireClickable.addEventListener('mousedown',function(event){cfg.onMouseDown(event,_this14);});}if(cfg.onMouseUp){wireClickable.addEventListener('mouseup',function(event){cfg.onMouseUp(event,_this14);});}if(cfg.onMouseMove){wireClickable.addEventListener('mousemove',function(event){cfg.onMouseMove(event,_this14);});}if(cfg.onContextMenu){wireClickable.addEventListener('contextmenu',function(event){cfg.onContextMenu(event,_this14);event.preventDefault();});}this._x1=0;this._y1=0;this._x2=0;this._y2=0;this._update();}_createClass(Wire,[{key:"visible",get:function get(){return this._wire.style.visibility==="visible";}},{key:"_update",value:function _update(){var length=Math.abs(Math.sqrt((this._x1-this._x2)*(this._x1-this._x2)+(this._y1-this._y2)*(this._y1-this._y2)));var angle=Math.atan2(this._y2-this._y1,this._x2-this._x1)*180.0/Math.PI;var wireStyle=this._wire.style;wireStyle["width"]=Math.round(length)+'px';wireStyle["left"]=Math.round(this._x1)+'px';wireStyle["top"]=Math.round(this._y1)+'px';wireStyle['-webkit-transform']='rotate('+angle+'deg)';wireStyle['-moz-transform']='rotate('+angle+'deg)';wireStyle['-ms-transform']='rotate('+angle+'deg)';wireStyle['-o-transform']='rotate('+angle+'deg)';wireStyle['transform']='rotate('+angle+'deg)';var wireClickableStyle=this._wireClickable.style;wireClickableStyle["width"]=Math.round(length)+'px';wireClickableStyle["left"]=Math.round(this._x1)+'px';wireClickableStyle["top"]=Math.round(this._y1)+'px';wireClickableStyle['-webkit-transform']='rotate('+angle+'deg)';wireClickableStyle['-moz-transform']='rotate('+angle+'deg)';wireClickableStyle['-ms-transform']='rotate('+angle+'deg)';wireClickableStyle['-o-transform']='rotate('+angle+'deg)';wireClickableStyle['transform']='rotate('+angle+'deg)';}},{key:"setStartAndEnd",value:function setStartAndEnd(x1,y1,x2,y2){this._x1=x1;this._y1=y1;this._x2=x2;this._y2=y2;this._update();}},{key:"setColor",value:function setColor(color){this._color=color||"black";this._wire.style.border="solid "+this._thickness+"px "+this._color;}},{key:"setOpacity",value:function setOpacity(opacity){this._wire.style.opacity=opacity;}},{key:"setVisible",value:function setVisible(visible){if(this._visible===visible){return;}this._visible=!!visible;this._wire.style.visibility=this._visible&&!this._culled?"visible":"hidden";}},{key:"setCulled",value:function setCulled(culled){if(this._culled===culled){return;}this._culled=!!culled;this._wire.style.visibility=this._visible&&!this._culled?"visible":"hidden";}},{key:"setClickable",value:function setClickable(clickable){this._wireClickable.style["pointer-events"]=!!clickable?"all":"none";}},{key:"setHighlighted",value:function setHighlighted(highlighted){if(this._highlighted===highlighted){return;}this._highlighted=!!highlighted;if(this._highlighted){this._wire.classList.add(this._highlightClass);}else{this._wire.classList.remove(this._highlightClass);}}},{key:"destroy",value:function destroy(visible){if(this._wire.parentElement){this._wire.parentElement.removeChild(this._wire);}if(this._wireClickable.parentElement){this._wireClickable.parentElement.removeChild(this._wireClickable);}}}]);return Wire;}();/** @private */var Dot=/*#__PURE__*/function(){function Dot(parentElement){var _this15=this;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Dot);this._highlightClass="viewer-ruler-dot-highlighted";this._x=0;this._y=0;this._dot=document.createElement('div');this._dot.className+=this._dot.className?' viewer-ruler-dot':'viewer-ruler-dot';this._dotClickable=document.createElement('div');this._dotClickable.className+=this._dotClickable.className?' viewer-ruler-dot-clickable':'viewer-ruler-dot-clickable';this._visible=!!cfg.visible;this._culled=false;var dot=this._dot;var dotStyle=dot.style;dotStyle["border-radius"]=25+"px";dotStyle.border="solid 2px white";dotStyle.background="lightgreen";dotStyle.position="absolute";dotStyle["z-index"]=cfg.zIndex===undefined?"40000005":cfg.zIndex;dotStyle.width=8+"px";dotStyle.height=8+"px";dotStyle.visibility=cfg.visible!==false?"visible":"hidden";dotStyle.top=0+"px";dotStyle.left=0+"px";dotStyle["box-shadow"]="0 2px 5px 0 #182A3D;";dotStyle["opacity"]=1.0;dotStyle["pointer-events"]="none";if(cfg.onContextMenu);parentElement.appendChild(dot);var dotClickable=this._dotClickable;var dotClickableStyle=dotClickable.style;dotClickableStyle["border-radius"]=35+"px";dotClickableStyle.border="solid 10px white";dotClickableStyle.position="absolute";dotClickableStyle["z-index"]=cfg.zIndex===undefined?"40000007":cfg.zIndex+1;dotClickableStyle.width=8+"px";dotClickableStyle.height=8+"px";dotClickableStyle.visibility="visible";dotClickableStyle.top=0+"px";dotClickableStyle.left=0+"px";dotClickableStyle["opacity"]=0.0;dotClickableStyle["pointer-events"]="none";if(cfg.onContextMenu);parentElement.appendChild(dotClickable);dotClickable.addEventListener('click',function(event){parentElement.dispatchEvent(new MouseEvent('mouseover',event));});if(cfg.onMouseOver){dotClickable.addEventListener('mouseover',function(event){cfg.onMouseOver(event,_this15);parentElement.dispatchEvent(new MouseEvent('mouseover',event));});}if(cfg.onMouseLeave){dotClickable.addEventListener('mouseleave',function(event){cfg.onMouseLeave(event,_this15);});}if(cfg.onMouseWheel){dotClickable.addEventListener('wheel',function(event){cfg.onMouseWheel(event,_this15);});}if(cfg.onMouseDown){dotClickable.addEventListener('mousedown',function(event){cfg.onMouseDown(event,_this15);});}if(cfg.onMouseUp){dotClickable.addEventListener('mouseup',function(event){cfg.onMouseUp(event,_this15);});}if(cfg.onMouseMove){dotClickable.addEventListener('mousemove',function(event){cfg.onMouseMove(event,_this15);});}if(cfg.onContextMenu){dotClickable.addEventListener('contextmenu',function(event){cfg.onContextMenu(event,_this15);event.preventDefault();});}this.setPos(cfg.x||0,cfg.y||0);this.setFillColor(cfg.fillColor);this.setBorderColor(cfg.borderColor);}_createClass(Dot,[{key:"setPos",value:function setPos(x,y){this._x=x;this._y=y;var dotStyle=this._dot.style;dotStyle["left"]=Math.round(x)-4+'px';dotStyle["top"]=Math.round(y)-4+'px';var dotClickableStyle=this._dotClickable.style;dotClickableStyle["left"]=Math.round(x)-9+'px';dotClickableStyle["top"]=Math.round(y)-9+'px';}},{key:"setFillColor",value:function setFillColor(color){this._dot.style.background=color||"lightgreen";}},{key:"setBorderColor",value:function setBorderColor(color){this._dot.style.border="solid 2px"+(color||"black");}},{key:"setOpacity",value:function setOpacity(opacity){this._dot.style.opacity=opacity;}},{key:"setVisible",value:function setVisible(visible){if(this._visible===visible){return;}this._visible=!!visible;this._dot.style.visibility=this._visible&&!this._culled?"visible":"hidden";}},{key:"setCulled",value:function setCulled(culled){if(this._culled===culled){return;}this._culled=!!culled;this._dot.style.visibility=this._visible&&!this._culled?"visible":"hidden";}},{key:"setClickable",value:function setClickable(clickable){this._dotClickable.style["pointer-events"]=!!clickable?"all":"none";}},{key:"setHighlighted",value:function setHighlighted(highlighted){if(this._highlighted===highlighted){return;}this._highlighted=!!highlighted;if(this._highlighted){this._dot.classList.add(this._highlightClass);}else{this._dot.classList.remove(this._highlightClass);}}},{key:"destroy",value:function destroy(){this.setVisible(false);if(this._dot.parentElement){this._dot.parentElement.removeChild(this._dot);}if(this._dotClickable.parentElement){this._dotClickable.parentElement.removeChild(this._dotClickable);}}}]);return Dot;}();/** @private */var Label=/*#__PURE__*/function(){function Label(parentElement){var _this16=this;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Label);this._highlightClass="viewer-ruler-label-highlighted";this._prefix=cfg.prefix||"";this._x=0;this._y=0;this._visible=true;this._culled=false;this._label=document.createElement('div');this._label.className+=this._label.className?' viewer-ruler-label':'viewer-ruler-label';var label=this._label;var style=label.style;style["border-radius"]=5+"px";style.color="white";style.padding="4px";style.border="solid 1px";style.background="lightgreen";style.position="absolute";style["z-index"]=cfg.zIndex===undefined?"5000005":cfg.zIndex;style.width="auto";style.height="auto";style.visibility="visible";style.top=0+"px";style.left=0+"px";style["pointer-events"]="all";style["opacity"]=1.0;if(cfg.onContextMenu);label.innerText="";parentElement.appendChild(label);this.setPos(cfg.x||0,cfg.y||0);this.setFillColor(cfg.fillColor);this.setBorderColor(cfg.fillColor);this.setText(cfg.text);if(cfg.onMouseOver){label.addEventListener('mouseover',function(event){cfg.onMouseOver(event,_this16);event.preventDefault();});}if(cfg.onMouseLeave){label.addEventListener('mouseleave',function(event){cfg.onMouseLeave(event,_this16);event.preventDefault();});}if(cfg.onMouseWheel){label.addEventListener('wheel',function(event){cfg.onMouseWheel(event,_this16);});}if(cfg.onMouseDown){label.addEventListener('mousedown',function(event){cfg.onMouseDown(event,_this16);});}if(cfg.onMouseUp){label.addEventListener('mouseup',function(event){cfg.onMouseUp(event,_this16);});}if(cfg.onMouseMove){label.addEventListener('mousemove',function(event){cfg.onMouseMove(event,_this16);});}if(cfg.onContextMenu){label.addEventListener('contextmenu',function(event){cfg.onContextMenu(event,_this16);event.preventDefault();});}}_createClass(Label,[{key:"setPos",value:function setPos(x,y){this._x=x;this._y=y;var style=this._label.style;style["left"]=Math.round(x)-20+'px';style["top"]=Math.round(y)-12+'px';}},{key:"setPosOnWire",value:function setPosOnWire(x1,y1,x2,y2){var x=x1+(x2-x1)*0.5;var y=y1+(y2-y1)*0.5;var style=this._label.style;style["left"]=Math.round(x)-20+'px';style["top"]=Math.round(y)-12+'px';}},{key:"setPosBetweenWires",value:function setPosBetweenWires(x1,y1,x2,y2,x3,y3){var x=(x1+x2+x3)/3;var y=(y1+y2+y3)/3;var style=this._label.style;style["left"]=Math.round(x)-20+'px';style["top"]=Math.round(y)-12+'px';}},{key:"setText",value:function setText(text){this._label.innerHTML=this._prefix+(text||"");}},{key:"setFillColor",value:function setFillColor(color){this._fillColor=color||"lightgreen";this._label.style.background=this._fillColor;}},{key:"setBorderColor",value:function setBorderColor(color){this._borderColor=color||"black";this._label.style.border="solid 1px "+this._borderColor;}},{key:"setOpacity",value:function setOpacity(opacity){this._label.style.opacity=opacity;}},{key:"setVisible",value:function setVisible(visible){if(this._visible===visible){return;}this._visible=!!visible;this._label.style.visibility=this._visible&&!this._culled?"visible":"hidden";}},{key:"setCulled",value:function setCulled(culled){if(this._culled===culled){return;}this._culled=!!culled;this._label.style.visibility=this._visible&&!this._culled?"visible":"hidden";}},{key:"setHighlighted",value:function setHighlighted(highlighted){if(this._highlighted===highlighted){return;}this._highlighted=!!highlighted;if(this._highlighted){this._label.classList.add(this._highlightClass);}else{this._label.classList.remove(this._highlightClass);}}},{key:"setClickable",value:function setClickable(clickable){this._label.style["pointer-events"]=!!clickable?"all":"none";}},{key:"destroy",value:function destroy(){if(this._label.parentElement){this._label.parentElement.removeChild(this._label);}}}]);return Label;}();var originVec=math.vec3();var targetVec=math.vec3();/**
 * @desc Measures the angle indicated by three 3D points.
 *
 * See {@link AngleMeasurementsPlugin} for more info.
 */var AngleMeasurement=/*#__PURE__*/function(_Component4){_inherits(AngleMeasurement,_Component4);var _super5=_createSuper(AngleMeasurement);/**
     * @private
     */function AngleMeasurement(plugin){var _this17;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,AngleMeasurement);_this17=_super5.call(this,plugin.viewer.scene,cfg);/**
         * The {@link AngleMeasurementsPlugin} that owns this AngleMeasurement.
         * @type {AngleMeasurementsPlugin}
         */_this17.plugin=plugin;_this17._container=cfg.container;if(!_this17._container){throw"config missing: container";}_this17._color=cfg.color||plugin.defaultColor;var scene=_this17.plugin.viewer.scene;_this17._originMarker=new Marker(scene,cfg.origin);_this17._cornerMarker=new Marker(scene,cfg.corner);_this17._targetMarker=new Marker(scene,cfg.target);_this17._originWorld=math.vec3();_this17._cornerWorld=math.vec3();_this17._targetWorld=math.vec3();_this17._wp=new Float64Array(12);_this17._vp=new Float64Array(12);_this17._pp=new Float64Array(12);_this17._cp=new Int16Array(6);var onMouseOver=cfg.onMouseOver?function(event){cfg.onMouseOver(event,_assertThisInitialized(_this17));_this17.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mouseover',event));}:null;var onMouseLeave=cfg.onMouseLeave?function(event){cfg.onMouseLeave(event,_assertThisInitialized(_this17));_this17.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mouseleave',event));}:null;var onContextMenu=cfg.onContextMenu?function(event){cfg.onContextMenu(event,_assertThisInitialized(_this17));}:null;var onMouseWheel=function onMouseWheel(event){_this17.plugin.viewer.scene.canvas.canvas.dispatchEvent(new WheelEvent('wheel',event));};var onMouseDown=function onMouseDown(event){_this17.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mousedown',event));};var onMouseUp=function onMouseUp(event){_this17.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mouseup',event));};var onMouseMove=function onMouseMove(event){_this17.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mousemove',event));};_this17._originDot=new Dot(_this17._container,{fillColor:_this17._color,zIndex:plugin.zIndex!==undefined?plugin.zIndex+2:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this17._cornerDot=new Dot(_this17._container,{fillColor:_this17._color,zIndex:plugin.zIndex!==undefined?plugin.zIndex+2:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this17._targetDot=new Dot(_this17._container,{fillColor:_this17._color,zIndex:plugin.zIndex!==undefined?plugin.zIndex+2:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this17._originWire=new Wire(_this17._container,{color:_this17._color||"blue",thickness:1,zIndex:plugin.zIndex,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this17._targetWire=new Wire(_this17._container,{color:_this17._color||"red",thickness:1,zIndex:plugin.zIndex!==undefined?plugin.zIndex+1:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this17._angleLabel=new Label(_this17._container,{fillColor:_this17._color||"#00BBFF",prefix:"",text:"",zIndex:plugin.zIndex+2,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this17._wpDirty=false;_this17._vpDirty=false;_this17._cpDirty=false;_this17._visible=false;_this17._originVisible=false;_this17._cornerVisible=false;_this17._targetVisible=false;_this17._originWireVisible=false;_this17._targetWireVisible=false;_this17._angleVisible=false;_this17._labelsVisible=false;_this17._clickable=false;_this17._originMarker.on("worldPos",function(value){_this17._originWorld.set(value||[0,0,0]);_this17._wpDirty=true;_this17._needUpdate(0);// No lag
});_this17._cornerMarker.on("worldPos",function(value){_this17._cornerWorld.set(value||[0,0,0]);_this17._wpDirty=true;_this17._needUpdate(0);// No lag
});_this17._targetMarker.on("worldPos",function(value){_this17._targetWorld.set(value||[0,0,0]);_this17._wpDirty=true;_this17._needUpdate(0);// No lag
});_this17._onViewMatrix=scene.camera.on("viewMatrix",function(){_this17._vpDirty=true;_this17._needUpdate(0);// No lag
});_this17._onProjMatrix=scene.camera.on("projMatrix",function(){_this17._cpDirty=true;_this17._needUpdate();});_this17._onCanvasBoundary=scene.canvas.on("boundary",function(){_this17._cpDirty=true;_this17._needUpdate(0);// No lag
});_this17._onSectionPlaneUpdated=scene.on("sectionPlaneUpdated",function(){_this17._sectionPlanesDirty=true;_this17._needUpdate();});_this17.approximate=cfg.approximate;_this17.visible=cfg.visible;_this17.originVisible=cfg.originVisible;_this17.cornerVisible=cfg.cornerVisible;_this17.targetVisible=cfg.targetVisible;_this17.originWireVisible=cfg.originWireVisible;_this17.targetWireVisible=cfg.targetWireVisible;_this17.angleVisible=cfg.angleVisible;_this17.labelsVisible=cfg.labelsVisible;return _this17;}_createClass(AngleMeasurement,[{key:"_update",value:function _update(){if(!this._visible){return;}var scene=this.plugin.viewer.scene;if(this._wpDirty){this._wp[0]=this._originWorld[0];this._wp[1]=this._originWorld[1];this._wp[2]=this._originWorld[2];this._wp[3]=1.0;this._wp[4]=this._cornerWorld[0];this._wp[5]=this._cornerWorld[1];this._wp[6]=this._cornerWorld[2];this._wp[7]=1.0;this._wp[8]=this._targetWorld[0];this._wp[9]=this._targetWorld[1];this._wp[10]=this._targetWorld[2];this._wp[11]=1.0;this._wpDirty=false;this._vpDirty=true;}if(this._vpDirty){math.transformPositions4(scene.camera.viewMatrix,this._wp,this._vp);this._vp[3]=1.0;this._vp[7]=1.0;this._vp[11]=1.0;this._vpDirty=false;this._cpDirty=true;}if(this._sectionPlanesDirty){if(this._isSliced(this._wp)){this._angleLabel.setCulled(true);this._originWire.setCulled(true);this._targetWire.setCulled(true);this._originDot.setCulled(true);this._cornerDot.setCulled(true);this._targetDot.setCulled(true);return;}else{this._angleLabel.setCulled(false);this._originWire.setCulled(false);this._targetWire.setCulled(false);this._originDot.setCulled(false);this._cornerDot.setCulled(false);this._targetDot.setCulled(false);}this._sectionPlanesDirty=true;}if(this._cpDirty){var near=-0.3;var zOrigin=this._originMarker.viewPos[2];var zCorner=this._cornerMarker.viewPos[2];var zTarget=this._targetMarker.viewPos[2];if(zOrigin>near||zCorner>near||zTarget>near){this._originDot.setVisible(false);this._cornerDot.setVisible(false);this._targetDot.setVisible(false);this._originWire.setVisible(false);this._targetWire.setVisible(false);this._angleLabel.setCulled(true);return;}math.transformPositions4(scene.camera.project.matrix,this._vp,this._pp);var pp=this._pp;var cp=this._cp;var canvas=scene.canvas.canvas;var offsets=canvas.getBoundingClientRect();var containerOffsets=this._container.getBoundingClientRect();var top=offsets.top-containerOffsets.top;var left=offsets.left-containerOffsets.left;var aabb=scene.canvas.boundary;var canvasWidth=aabb[2];var canvasHeight=aabb[3];var j=0;for(var i=0,len=pp.length;i<len;i+=4){cp[j]=left+Math.floor((1+pp[i+0]/pp[i+3])*canvasWidth/2);cp[j+1]=top+Math.floor((1-pp[i+1]/pp[i+3])*canvasHeight/2);j+=2;}this._originDot.setPos(cp[0],cp[1]);this._cornerDot.setPos(cp[2],cp[3]);this._targetDot.setPos(cp[4],cp[5]);this._originWire.setStartAndEnd(cp[0],cp[1],cp[2],cp[3]);this._targetWire.setStartAndEnd(cp[2],cp[3],cp[4],cp[5]);this._angleLabel.setPosBetweenWires(cp[0],cp[1],cp[2],cp[3],cp[4],cp[5]);math.subVec3(this._originWorld,this._cornerWorld,originVec);math.subVec3(this._targetWorld,this._cornerWorld,targetVec);var validVecs=(originVec[0]!==0||originVec[1]!==0||originVec[2]!==0)&&(targetVec[0]!==0||targetVec[1]!==0||targetVec[2]!==0);if(validVecs){var tilde=this._approximate?" ~ ":" = ";math.normalizeVec3(originVec);math.normalizeVec3(targetVec);var _angle2=Math.abs(math.angleVec3(originVec,targetVec));this._angle=_angle2/math.DEGTORAD;this._angleLabel.setText(tilde+this._angle.toFixed(2)+"");}else{this._angleLabel.setText("");}// this._angleLabel.setText((Math.abs(math.lenVec3(math.subVec3(this._targetWorld, this._originWorld, distVec3)) * scale).toFixed(2)) + unitAbbrev);
this._originDot.setVisible(this._visible&&this._originVisible);this._cornerDot.setVisible(this._visible&&this._cornerVisible);this._targetDot.setVisible(this._visible&&this._targetVisible);this._originWire.setVisible(this._visible&&this._originWireVisible);this._targetWire.setVisible(this._visible&&this._targetWireVisible);this._angleLabel.setCulled(!(this._visible&&this._angleVisible&&this.labelsVisible));this._cpDirty=false;}}},{key:"_isSliced",value:function _isSliced(positions){var sectionPlanes=this.scene._sectionPlanesState.sectionPlanes;for(var _i44=0,len=sectionPlanes.length;_i44<len;_i44++){var sectionPlane=sectionPlanes[_i44];if(math.planeClipsPositions3(sectionPlane.pos,sectionPlane.dir,positions,4)){return true;}}return false;}/**
     * Sets whether this AngleMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */},{key:"approximate",get:/**
     * Gets whether this AngleMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */function get(){return this._approximate;}/**
     * Gets the origin {@link Marker}.
     *
     * @type {Marker}
     */,set:function set(approximate){approximate=approximate!==false;if(this._approximate===approximate){return;}this._approximate=approximate;this._cpDirty=true;this._needUpdate(0);}},{key:"origin",get:function get(){return this._originMarker;}/**
     * Gets the corner {@link Marker}.
     *
     * @type {Marker}
     */},{key:"corner",get:function get(){return this._cornerMarker;}/**
     * Gets the target {@link Marker}.
     *
     * @type {Marker}
     */},{key:"target",get:function get(){return this._targetMarker;}/**
     * Gets the angle between two connected 3D line segments, given
     * as three positions on the surface(s) of one or more {@link Entity}s.
     *
     * @type {Number}
     */},{key:"angle",get:function get(){this._update();return this._angle;}/**
     * Gets the color of the angle measurement.
     *
     * The color is an HTML string representation, eg. "#00BBFF" and "blue".
     *
     * @type {String}
     */},{key:"color",get:function get(){return this._color;}/** Sets the color of the angle measurement.
     *
     * The color is given as an HTML string representation, eg. "#00BBFF" and "blue".
     *
     * @type {String}
     */,set:function set(value){this._originDot.setFillColor(value);this._cornerDot.setFillColor(value);this._targetDot.setFillColor(value);this._originWire.setColor(value||"blue");this._targetWire.setColor(value||"red");this._angleLabel.setFillColor(value||"#00BBFF");this._color=value;}/**
     * Sets whether this AngleMeasurement is visible or not.
     *
     * @type {Boolean}
     */},{key:"visible",get:/**
     * Gets whether this AngleMeasurement is visible or not.
     *
     * @type {Boolean}
     */function get(){return this._visible;}/**
     * Sets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._visible=value;this._originDot.setVisible(this._visible&&this._originVisible);this._cornerDot.setVisible(this._visible&&this._cornerVisible);this._targetDot.setVisible(this._visible&&this._targetVisible);this._originWire.setVisible(this._visible&&this._originWireVisible);this._targetWire.setVisible(this._visible&&this._targetWireVisible);this._angleLabel.setVisible(this._visible&&this._angleVisible);this._cpDirty=true;this._needUpdate();}},{key:"originVisible",get:/**
     * Gets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */function get(){return this._originVisible;}/**
     * Sets if the corner {@link Marker} is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._originVisible=value;this._originDot.setVisible(this._visible&&this._originVisible);this._cpDirty=true;this._needUpdate();}},{key:"cornerVisible",get:/**
     * Gets if the corner {@link Marker} is visible.
     *
     * @type {Boolean}
     */function get(){return this._cornerVisible;}/**
     * Sets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._cornerVisible=value;this._cornerDot.setVisible(this._visible&&this._cornerVisible);this._cpDirty=true;this._needUpdate();}},{key:"targetVisible",get:/**
     * Gets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */function get(){return this._targetVisible;}/**
     * Sets if the wire between the origin and the corner is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._targetVisible=value;this._targetDot.setVisible(this._visible&&this._targetVisible);this._cpDirty=true;this._needUpdate();}},{key:"originWireVisible",get:/**
     * Gets if the wire between the origin and the corner is visible.
     *
     * @type {Boolean}
     */function get(){return this._originWireVisible;}/**
     * Sets if the wire between the target and the corner is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._originWireVisible=value;this._originWire.setVisible(this._visible&&this._originWireVisible);this._cpDirty=true;this._needUpdate();}},{key:"targetWireVisible",get:/**
     * Gets if the wire between the target and the corner is visible.
     *
     * @type {Boolean}
     */function get(){return this._targetWireVisible;}/**
     * Sets if the angle label is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._targetWireVisible=value;this._targetWire.setVisible(this._visible&&this._targetWireVisible);this._cpDirty=true;this._needUpdate();}},{key:"angleVisible",get:/**
     * Gets if the angle label is visible.
     *
     * @type {Boolean}
     */function get(){return this._angleVisible;}/**
     * Sets if the labels are visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;this._angleVisible=value;this._angleLabel.setVisible(this._visible&&this._angleVisible);this._cpDirty=true;this._needUpdate();}},{key:"labelsVisible",get:/**
     * Gets if the labels are visible.
     *
     * @type {Boolean}
     */function get(){return this._labelsVisible;}/**
     * Sets if this DistanceMeasurement appears highlighted.
     * @param highlighted
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultLabelsVisible;this._labelsVisible=value;var labelsVisible=this._visible&&this._labelsVisible;this._angleLabel.setVisible(labelsVisible);this._cpDirty=true;this._needUpdate();}},{key:"setHighlighted",value:function setHighlighted(highlighted){this._originDot.setHighlighted(highlighted);this._cornerDot.setHighlighted(highlighted);this._targetDot.setHighlighted(highlighted);this._originWire.setHighlighted(highlighted);this._targetWire.setHighlighted(highlighted);this._angleLabel.setHighlighted(highlighted);}/**
     * Sets if the wires, dots ad labels will fire "mouseOver" "mouseLeave" and "contextMenu" events.
     *
     * @type {Boolean}
     */},{key:"clickable",get:/**
     * Gets if the wires, dots ad labels will fire "mouseOver" "mouseLeave" and "contextMenu" events.
     *
     * @type {Boolean}
     */function get(){return this._clickable;}/**
     * @private
     */,set:function set(value){value=!!value;this._clickable=value;this._originDot.setClickable(this._clickable);this._cornerDot.setClickable(this._clickable);this._targetDot.setClickable(this._clickable);this._originWire.setClickable(this._clickable);this._targetWire.setClickable(this._clickable);this._angleLabel.setClickable(this._clickable);}},{key:"destroy",value:function destroy(){var scene=this.plugin.viewer.scene;if(this._onViewMatrix){scene.camera.off(this._onViewMatrix);}if(this._onProjMatrix){scene.camera.off(this._onProjMatrix);}if(this._onCanvasBoundary){scene.canvas.off(this._onCanvasBoundary);}if(this._onSectionPlaneUpdated){scene.off(this._onSectionPlaneUpdated);}this._originDot.destroy();this._cornerDot.destroy();this._targetDot.destroy();this._originWire.destroy();this._targetWire.destroy();this._angleLabel.destroy();_get(_getPrototypeOf(AngleMeasurement.prototype),"destroy",this).call(this);}}]);return AngleMeasurement;}(Component);/**
 * Creates {@link AngleMeasurement}s in an {@link AngleMeasurementsPlugin} from user input.
 *
 * @interface
 * @abstract
 */var AngleMeasurementsControl=/*#__PURE__*/function(_Component5){_inherits(AngleMeasurementsControl,_Component5);var _super6=_createSuper(AngleMeasurementsControl);function AngleMeasurementsControl(){_classCallCheck(this,AngleMeasurementsControl);return _super6.apply(this,arguments);}_createClass(AngleMeasurementsControl,[{key:"active",get:/**
     * Gets if this AngleMeasurementsControl is currently active, where it is responding to input.
     *
     * @returns {boolean} True if this AngleMeassurementsControl is active.
     * @abstract
     */function get(){}/**
     * Sets whether snap-to-vertex and snap-to-edge are enabled for this AngleMeasurementsControl.
     *
     * This is `true` by default.
     *
     * Internally, this deactivates then activates the AngleMeasurementsControl when changed, which means that
     * it will destroy any AngleMeasurements currently under construction, and incurs some overhead, since it unbinds
     * and rebinds various input handlers.
     *
     * @param {boolean} snapping Whether to enable snap-to-vertex and snap-edge for this AngleMeasurementsControl.
     */},{key:"snapping",get:/**
     * Gets whether snap-to-vertex and snap-to-edge are enabled for this AngleMeasurementsControl.
     *
     * This is `true` by default.
     *
     * @returns {boolean} Whether snap-to-vertex and snap-to-edge are enabled for this AngleMeasurementsControl.
     */function get(){return true;}/**
     * Activates this AngleMeasurementsMouseControl, ready to respond to input.
     *
     * @abstract
     */,set:function set(snapping){}},{key:"activate",value:function activate(){}/**
     * Deactivates this AngleMeasurementsControl, making it unresponsive to input.
     *
     * Destroys any {@link AngleMeasurement} under construction by this AngleMeasurementsControl.
     *
     * @abstract
     */},{key:"deactivate",value:function deactivate(){}/**
     * Resets this AngleMeasurementsControl.
     *
     * Destroys any {@link AngleMeasurement} under construction by this AngleMeasurementsControl.
     *
     * Does nothing if the AngleMeasurementsControl is not active.
     *
     * @abstract
     */},{key:"reset",value:function reset(){}/**
     * Destroys this AngleMeasurementsMouseControl.
     *
     * Destroys any {@link AngleMeasurement} under construction by this AngleMeasurementsControl.
     *
     * @abstract
     */},{key:"destroy",value:function destroy(){}}]);return AngleMeasurementsControl;}(Component);var MOUSE_FINDING_ORIGIN=0;var MOUSE_FINDING_CORNER=1;var MOUSE_FINDING_TARGET=2;/**
 * Creates {@link AngleMeasurement}s in an {@link AngleMeasurementsPlugin} from mouse input.
 *
 * ## Usage
 *
 * [[Run example](/examples/measurement/#angle_createWithMouse_snapping)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin, AngleMeasurementsMouseControl, PointerLens} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 * });
 *
 * viewer.camera.eye = [-3.93, 2.85, 27.01];
 * viewer.camera.look = [4.40, 3.72, 8.89];
 * viewer.camera.up = [-0.01, 0.99, 0.039];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const sceneModel = xktLoader.load({
 *     id: "myModel",
 *     src: "Duplex.xkt"
 * });
 *
 * const angleMeasurements = new AngleMeasurementsPlugin(viewer);
 *
 * const angleMeasurementsMouseControl  = new AngleMeasurementsMouseControl(angleMeasurements, {
 *     pointerLens : new PointerLens(viewer)
 * })
 *
 * angleMeasurementsMouseControl.snapping = true;
 *
 * angleMeasurementsMouseControl.activate();
 * ````
 */var AngleMeasurementsMouseControl=/*#__PURE__*/function(_AngleMeasurementsCon){_inherits(AngleMeasurementsMouseControl,_AngleMeasurementsCon);var _super7=_createSuper(AngleMeasurementsMouseControl);/**
     * Creates a AngleMeasurementsMouseControl bound to the given AngleMeasurementsPlugin.
     *
     * @param {AngleMeasurementsPlugin} angleMeasurementsPlugin The AngleMeasurementsPlugin to control.
     * @param {*} [cfg] Configuration
     * @param {PointerLens} [cfg.pointerLens] A PointerLens to use to provide a magnified view of the cursor when snapping is enabled.
     * @param {boolean} [cfg.snapping=true] Whether to initially enable snap-to-vertex and snap-to-edge for this AngleMeasurementsMouseControl.
     */function AngleMeasurementsMouseControl(angleMeasurementsPlugin){var _this18;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,AngleMeasurementsMouseControl);_this18=_super7.call(this,angleMeasurementsPlugin.viewer.scene);_this18.pointerLens=cfg.pointerLens;_this18._active=false;_this18._mouseState=MOUSE_FINDING_ORIGIN;_this18._currentAngleMeasurement=null;// init markerDiv element (think about making its style configurable)
_this18._initMarkerDiv();_this18._onMouseHoverSurface=null;_this18._onHoverNothing=null;_this18._onPickedNothing=null;_this18._onPickedSurface=null;_this18._onInputMouseDown=null;_this18._onInputMouseUp=null;_this18._snapping=cfg.snapping!==false;_this18._attachPlugin(angleMeasurementsPlugin,cfg);return _this18;}_createClass(AngleMeasurementsMouseControl,[{key:"_initMarkerDiv",value:function _initMarkerDiv(){var markerDiv=document.createElement('div');markerDiv.setAttribute('id','myMarkerDiv');var canvas=this.scene.canvas.canvas;canvas.parentNode.insertBefore(markerDiv,canvas);markerDiv.style.background="black";markerDiv.style.border="2px solid blue";markerDiv.style.borderRadius="10px";markerDiv.style.width="5px";markerDiv.style.height="5px";markerDiv.style.top="-200px";markerDiv.style.left="-200px";markerDiv.style.margin="0 0";markerDiv.style.zIndex="100";markerDiv.style.position="absolute";markerDiv.style.pointerEvents="none";this.markerDiv=markerDiv;}},{key:"_destroyMarkerDiv",value:function _destroyMarkerDiv(){if(this._markerDiv){var element=document.getElementById('myMarkerDiv');element.parentNode.removeChild(element);this._markerDiv=null;}}},{key:"_attachPlugin",value:function _attachPlugin(angleMeasurementsPlugin){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};/**
         * The {@link AngleMeasurementsPlugin} that owns this AngleMeasurementsMouseControl.
         *
         * @type {AngleMeasurementsPlugin}
         */this.angleMeasurementsPlugin=angleMeasurementsPlugin;/**
         * The {@link AngleMeasurementsPlugin} that owns this AngleMeasurementsMouseControl.
         *
         * @type {AngleMeasurementsPlugin}
         */this.plugin=angleMeasurementsPlugin;}/**
     * Gets if this AngleMeasurementsMouseControl is currently active, where it is responding to input.
     *
     * @returns {boolean}
     */},{key:"active",get:function get(){return this._active;}/**
     * Sets whether snap-to-vertex and snap-to-edge are enabled for this AngleMeasurementsMouseControl.
     *
     * This is `true` by default.
     *
     * Internally, this deactivates then activates the AngleMeasurementsMouseControl when changed, which means that
     * it will destroy any AngleMeasurements currently under construction, and incurs some overhead, since it unbinds
     * and rebinds various input handlers.
     *
     * @param {boolean} snapping Whether to enable snap-to-vertex and snap-edge for this AngleMeasurementsMouseControl.
     */},{key:"snapping",get:/**
     * Gets whether snap-to-vertex and snap-to-edge are enabled for this AngleMeasurementsMouseControl.
     *
     * This is `true` by default.
     *
     * @returns {boolean} Whether snap-to-vertex and snap-to-edge are enabled for this AngleMeasurementsMouseControl.
     */function get(){return this._snapping;}/**
     * Activates this AngleMeasurementsMouseControl, ready to respond to input.
     */,set:function set(snapping){if(snapping!==this._snapping){this._snapping=snapping;this.deactivate();this.activate();}else{this._snapping=snapping;}}},{key:"activate",value:function activate(){var _this19=this;if(this._active){return;}if(!this.markerDiv){this._initMarkerDiv();// if the marker is destroyed after deactivation, we recreate it
}this.angleMeasurementsPlugin;var scene=this.scene;scene.input;var canvas=scene.canvas.canvas;var clickTolerance=20;var cameraControl=this.angleMeasurementsPlugin.viewer.cameraControl;var pointerLens=this.pointerLens;var mouseHovering=false;var hoveredEntity=null;var lastMouseCanvasX=0;var lastMouseCanvasY=0;var mouseWorldPos=math.vec3();var mouseHoverCanvasPos=math.vec2();this._currentAngleMeasurement=null;var getTop=function getTop(el){return el.offsetTop+(el.offsetParent&&getTop(el.offsetParent));};var getLeft=function getLeft(el){return el.offsetLeft+(el.offsetParent&&getLeft(el.offsetParent));};this._onMouseHoverSurface=cameraControl.on(this._snapping?"hoverSnapOrSurface":"hoverSurface",function(event){if(event.snappedToVertex||event.snappedToEdge){if(pointerLens){pointerLens.visible=true;pointerLens.canvasPos=event.canvasPos;pointerLens.snappedCanvasPos=event.snappedCanvasPos||event.canvasPos;pointerLens.snapped=true;}_this19.markerDiv.style.background="greenyellow";_this19.markerDiv.style.border="2px solid green";}else{if(pointerLens){pointerLens.visible=true;pointerLens.canvasPos=event.canvasPos;pointerLens.snappedCanvasPos=event.canvasPos;pointerLens.snapped=false;}_this19.markerDiv.style.background="pink";_this19.markerDiv.style.border="2px solid red";}var canvasPos=event.snappedCanvasPos||event.canvasPos;mouseHovering=true;hoveredEntity=event.entity;mouseWorldPos.set(event.worldPos);mouseHoverCanvasPos.set(canvasPos);switch(_this19._mouseState){case MOUSE_FINDING_ORIGIN:_this19.markerDiv.style.left="".concat(getLeft(canvas)+canvasPos[0]-5,"px");_this19.markerDiv.style.top="".concat(getTop(canvas)+canvasPos[1]-5,"px");break;case MOUSE_FINDING_CORNER:if(_this19._currentAngleMeasurement){_this19._currentAngleMeasurement.originWireVisible=true;_this19._currentAngleMeasurement.targetWireVisible=false;_this19._currentAngleMeasurement.cornerVisible=true;_this19._currentAngleMeasurement.angleVisible=false;_this19._currentAngleMeasurement.corner.worldPos=event.worldPos;_this19._currentAngleMeasurement.corner.entity=event.entity;}_this19.markerDiv.style.left="-10000px";_this19.markerDiv.style.top="-10000px";canvas.style.cursor="pointer";break;case MOUSE_FINDING_TARGET:if(_this19._currentAngleMeasurement){_this19._currentAngleMeasurement.targetWireVisible=true;_this19._currentAngleMeasurement.targetVisible=true;_this19._currentAngleMeasurement.angleVisible=true;_this19._currentAngleMeasurement.target.worldPos=event.worldPos;_this19._currentAngleMeasurement.target.entity=event.entity;}_this19.markerDiv.style.left="-10000px";_this19.markerDiv.style.top="-10000px";canvas.style.cursor="pointer";break;}});canvas.addEventListener('mousedown',this._onMouseDown=function(e){if(e.which!==1){return;}lastMouseCanvasX=e.clientX;lastMouseCanvasY=e.clientY;});canvas.addEventListener("mouseup",this._onMouseUp=function(e){if(e.which!==1){return;}if(e.clientX>lastMouseCanvasX+clickTolerance||e.clientX<lastMouseCanvasX-clickTolerance||e.clientY>lastMouseCanvasY+clickTolerance||e.clientY<lastMouseCanvasY-clickTolerance){return;}switch(_this19._mouseState){case MOUSE_FINDING_ORIGIN:if(mouseHovering){_this19._currentAngleMeasurement=_this19.angleMeasurementsPlugin.createMeasurement({id:math.createUUID(),origin:{worldPos:mouseWorldPos},corner:{worldPos:mouseWorldPos},target:{worldPos:mouseWorldPos},approximate:true});_this19._currentAngleMeasurement.clickable=false;_this19._currentAngleMeasurement.originVisible=true;_this19._currentAngleMeasurement.originWireVisible=true;_this19._currentAngleMeasurement.cornerVisible=false;_this19._currentAngleMeasurement.targetWireVisible=false;_this19._currentAngleMeasurement.targetVisible=false;_this19._currentAngleMeasurement.angleVisible=false;_this19._currentAngleMeasurement.origin.entity=hoveredEntity;_this19._mouseState=MOUSE_FINDING_CORNER;_this19.angleMeasurementsPlugin.fire("measurementStart",_this19._currentAngleMeasurement);}break;case MOUSE_FINDING_CORNER:if(mouseHovering){_this19._currentAngleMeasurement.targetWireVisible=false;_this19._currentAngleMeasurement.targetVisible=true;_this19._currentAngleMeasurement.angleVisible=true;_this19._currentAngleMeasurement.corner.entity=hoveredEntity;_this19._mouseState=MOUSE_FINDING_TARGET;}else{if(_this19._currentAngleMeasurement){_this19._currentAngleMeasurement.destroy();_this19._currentAngleMeasurement=null;hoveredEntity=null;_this19._mouseState=MOUSE_FINDING_ORIGIN;_this19.angleMeasurementsPlugin.fire("measurementCancel",_this19._currentAngleMeasurement);}}break;case MOUSE_FINDING_TARGET:if(mouseHovering){_this19._currentAngleMeasurement.targetVisible=true;_this19._currentAngleMeasurement.angleVisible=true;_this19._currentAngleMeasurement.target.entity=hoveredEntity;_this19._currentAngleMeasurement.clickable=true;hoveredEntity=null;_this19.angleMeasurementsPlugin.fire("measurementEnd",_this19._currentAngleMeasurement);_this19._currentAngleMeasurement=null;_this19._mouseState=MOUSE_FINDING_ORIGIN;}else{if(_this19._currentAngleMeasurement){_this19._currentAngleMeasurement.destroy();_this19._currentAngleMeasurement=null;hoveredEntity=null;_this19._mouseState=MOUSE_FINDING_ORIGIN;_this19.angleMeasurementsPlugin.fire("measurementCancel",_this19._currentAngleMeasurement);}}break;}});this._onMouseHoverOff=cameraControl.on(this._snapping?"hoverSnapOrSurfaceOff":"hoverOff",function(event){mouseHovering=false;if(pointerLens){pointerLens.visible=true;pointerLens.pointerPos=event.canvasPos;pointerLens.snappedCanvasPos=event.snappedCanvasPos||event.canvasPos;pointerLens.snapped=false;}_this19.markerDiv.style.left="-100px";_this19.markerDiv.style.top="-100px";if(_this19._currentAngleMeasurement){switch(_this19._mouseState){case MOUSE_FINDING_ORIGIN:_this19._currentAngleMeasurement.originVisible=false;break;case MOUSE_FINDING_CORNER:_this19._currentAngleMeasurement.cornerVisible=false;_this19._currentAngleMeasurement.originWireVisible=false;_this19._currentAngleMeasurement.targetVisible=false;_this19._currentAngleMeasurement.targetWireVisible=false;_this19._currentAngleMeasurement.angleVisible=false;break;case MOUSE_FINDING_TARGET:_this19._currentAngleMeasurement.targetVisible=false;_this19._currentAngleMeasurement.targetWireVisible=false;_this19._currentAngleMeasurement.angleVisible=false;break;}canvas.style.cursor="default";}});this._active=true;}/**
     * Deactivates this AngleMeasurementsMouseControl, making it unresponsive to input.
     *
     * Destroys any {@link AngleMeasurement} under construction by this AngleMeasurementsMouseControl.
     */},{key:"deactivate",value:function deactivate(){if(!this._active){return;}if(this.pointerLens){this.pointerLens.visible=false;}if(this.markerDiv){this._destroyMarkerDiv();}this.reset();var canvas=this.scene.canvas.canvas;canvas.removeEventListener("mousedown",this._onMouseDown);canvas.removeEventListener("mouseup",this._onMouseUp);var cameraControl=this.angleMeasurementsPlugin.viewer.cameraControl;cameraControl.off(this._onMouseHoverSurface);cameraControl.off(this._onPickedSurface);cameraControl.off(this._onHoverNothing);cameraControl.off(this._onPickedNothing);this._currentAngleMeasurement=null;this._active=false;}/**
     * Resets this AngleMeasurementsMouseControl.
     *
     * Destroys any {@link AngleMeasurement} under construction by this AngleMeasurementsMouseControl.
     *
     * Does nothing if the AngleMeasurementsMouseControl is not active.
     */},{key:"reset",value:function reset(){if(!this._active){return;}this._destroyMarkerDiv();this._initMarkerDiv();if(this._currentAngleMeasurement){this._currentAngleMeasurement.destroy();this._currentAngleMeasurement=null;}this._mouseState=MOUSE_FINDING_ORIGIN;}/**
     * Destroys this AngleMeasurementsMouseControl.
     */},{key:"destroy",value:function destroy(){this.deactivate();_get(_getPrototypeOf(AngleMeasurementsMouseControl.prototype),"destroy",this).call(this);}}]);return AngleMeasurementsMouseControl;}(AngleMeasurementsControl);/**
 * {@link Viewer} plugin for measuring angles.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/63641903-61488180-c6b6-11e9-8e00-895b9d16dc4b.gif">](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_createWithMouse)
 *
 * * [[Example 1: Model with angle measurements](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_modelWithMeasurements)]
 * * [[Example 2: Create angle measurements with mouse](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_createWithMouse)]
 *
 * ## Overview
 *
 * * An {@link AngleMeasurement} shows the angle between two connected 3D line segments, given
 * as three positions on the surface(s) of one or more {@link Entity}s.
 * * As shown on the screen capture above, a AngleMeasurement has two wires that show the line segments, with a label that shows the angle between them.
 * * Create AngleMeasurements programmatically with {@link AngleMeasurementsPlugin#createMeasurement}.
 * * Create AngleMeasurements interactively using a {@link AngleMeasurementsControl}.
 * * Existing AngleMeasurements are registered by ID in {@link AngleMeasurementsPlugin#measurements}.
 * * Destroy AngleMeasurements using {@link AngleMeasurementsPlugin#destroyMeasurement}.
 * * Configure global measurement units and scale via {@link Metrics}, located at {@link Scene#metrics}
 *
 * ## Example 1: Creating AngleMeasurements Programmatically
 *
 * In our first example, we'll use an {@link XKTLoaderPlugin} to load a model, and then use a AngleMeasurementsPlugin to programmatically create two {@link AngleMeasurement}s.
 *
 * Note how each AngleMeasurement has ````origin````, ````corner```` and  ````target````, which each indicate a 3D World-space
 * position on the surface of an {@link Entity}. These can be aon the same Entity, or on different Entitys.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_modelWithMeasurements)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const angleMeasurements = new AngleMeasurementsPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const myMeasurement1 = angleMeasurements.createMeasurement({
 *          id: "myAngleMeasurement1",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          corner: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [4.738, 3.172, 17.768]
 *          },
 *          visible: true
 *      });
 *
 *      const myMeasurement2 = angleMeasurements.createMeasurement({
 *          id: "myAngleMeasurement2",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          corner: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *              worldPos: [0.436, 0.001, 22.135]
 *          },
 *          visible: true
 *      });
 * });
 * ````
 *
 * ## Example 2: Creating AngleMeasurements with Mouse Input
 *
 * In our second example, we'll use an {@link XKTLoaderPlugin} to load a model, then we'll use the AngleMeasurementsPlugin's {@link AngleMeasurementsTouchControl} to interactively create {@link AngleMeasurement}s with mouse or touch input.
 *
 * After we've activated the AngleMeasurementsControl, the first click on any {@link Entity} begins constructing a AngleMeasurement, fixing its
 * origin to that Entity. The next click on any Entity will fix the AngleMeasurement's corner, and the next click after
 * that will fix its target and complete the AngleMeasurement.
 *
 * The AngleMeasurementControl will then wait for the next click on any Entity, to begin constructing
 * another AngleMeasurement, and so on, until deactivated again.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_createWithMouse)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin, AngleMeasurementsMouseControl, PointerLens} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * cconst angleMeasurementsMouseControl  = new AngleMeasurementsMouseControl(angleMeasurements, {
 *     pointerLens : new PointerLens(viewer)
 * })
 *
 * angleMeasurementsMouseControl.snapToVertex = true;
 * angleMeasurementsMouseControl.snapToEdge = true;
 *
 * angleMeasurementsMouseControl.activate();
 * ````
 *
 * ## Example 4: Attaching Mouse Handlers
 *
 * In our fourth example, we'll attach even handlers to our plugin, to catch when the user
 * hovers or right-clicks over our measurements.
 *
 * [[Run example](/examples/measurement/#angle_modelWithMeasurements)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const angleMeasurements = new AngleMeasurementsPlugin(viewer);
 *
 * angleMeasurements.on("mouseOver", (e) => {
 *     e.measurement.setHighlighted(true);
 * });
 *
 * angleMeasurements.on("mouseLeave", (e) => {
 *     e.measurement.setHighlighted(false);
 * });
 *
 * angleMeasurements.on("contextMenu", (e) => {
 *     // Show context menu
 *     e.event.preventDefault();
 * });
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *       angleMeasurementsPlugin.createMeasurement({
 *             id: "angleMeasurement1",
 *             origin: {
 *                 entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *                 worldPos: [0.4158603637281142, 2.5193106917110457, 17.79972838299403]
 *             },
 *             corner: {
 *                 entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *                 worldPos: [0.41857741956197625,0.0987169929481646,17.799763071093395]
 *             },
 *             target: {
 *                 entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *                 worldPos: [5.235526066859247, 0.11580773869801986, 17.824891550941565]
 *             },
 *             visible: true
 *         });
 *
 *         angleMeasurementsPlugin.createMeasurement({
 *             id: "angleMeasurement2",
 *             origin: {
 *                 entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *                 worldPos: [-0.00003814187850181838, 5.9996748076205115,17.79996871551525]
 *             },
 *             corner: {
 *                 entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNqI"],
 *                 worldPos: [-0.0005214119318139865, 3.1010044228517595, 17.787656604483363]
 *
 *             },
 *             target: {
 *                 entity: viewer.scene.objects["1s1jVhK8z0pgKYcr9jt7AB"],
 *                 worldPos: [ 8.380657312957396, 3.1055697628459553, 17.799220108187185]
 *             },
 *             visible: true
 *         });
 * });
 * ````
 */var AngleMeasurementsPlugin=/*#__PURE__*/function(_Plugin){_inherits(AngleMeasurementsPlugin,_Plugin);var _super8=_createSuper(AngleMeasurementsPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} [cfg]  Plugin configuration.
     * @param {String} [cfg.id="AngleMeasurements"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {HTMLElement} [cfg.container] Container DOM element for markers and labels. Defaults to ````document.body````.
     * @param {string} [cfg.defaultColor=null] The default color of the dots, wire and label.
     * @param {boolean} [cfg.defaultLabelsVisible=true] The default value of {@link AngleMeasurement.labelsVisible}.
     * @param {number} [cfg.zIndex] If set, the wires, dots and labels will have this zIndex (+1 for dots and +2 for labels).
     * @param {PointerCircle} [cfg.pointerLens] A PointerLens to help the user position the pointer. This can be shared with other plugins.
     */function AngleMeasurementsPlugin(viewer){var _this20;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,AngleMeasurementsPlugin);_this20=_super8.call(this,"AngleMeasurements",viewer);_this20._container=cfg.container||document.body;_this20._defaultControl=null;_this20._measurements={};_this20.defaultColor=cfg.defaultColor!==undefined?cfg.defaultColor:"#00BBFF";_this20.defaultLabelsVisible=cfg.defaultLabelsVisible!==false;_this20.zIndex=cfg.zIndex||10000;_this20._onMouseOver=function(event,measurement){_this20.fire("mouseOver",{plugin:_assertThisInitialized(_this20),angleMeasurement:measurement,measurement:measurement,event:event});};_this20._onMouseLeave=function(event,measurement){_this20.fire("mouseLeave",{plugin:_assertThisInitialized(_this20),angleMeasurement:measurement,measurement:measurement,event:event});};_this20._onContextMenu=function(event,measurement){_this20.fire("contextMenu",{plugin:_assertThisInitialized(_this20),angleMeasurement:measurement,measurement:measurement,event:event});};return _this20;}/**
     * Gets the plugin's HTML container element, if any.
     * @returns {*|HTMLElement|HTMLElement}
     */_createClass(AngleMeasurementsPlugin,[{key:"getContainerElement",value:function getContainerElement(){return this._container;}/**
     * @private
     */},{key:"send",value:function send(name,value){}/**
     * Gets the default {@link AngleMeasurementsMouseControl}.
     *
     * @type {AngleMeasurementsMouseControl}
     * @deprecated
     */},{key:"control",get:function get(){if(!this._defaultControl){this._defaultControl=new AngleMeasurementsMouseControl(this,{});}return this._defaultControl;}/**
     * Gets the existing {@link AngleMeasurement}s, each mapped to its {@link AngleMeasurement#id}.
     *
     * @type {{String:AngleMeasurement}}
     */},{key:"measurements",get:function get(){return this._measurements;}/**
     * Creates an {@link AngleMeasurement}.
     *
     * The AngleMeasurement is then registered by {@link AngleMeasurement#id} in {@link AngleMeasurementsPlugin#measurements}.
     *
     * @param {Object} params {@link AngleMeasurement} configuration.
     * @param {String} params.id Unique ID to assign to {@link AngleMeasurement#id}. The AngleMeasurement will be registered by this in {@link AngleMeasurementsPlugin#measurements} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.
     * @param {Number[]} params.origin.worldPos Origin World-space 3D position.
     * @param {Entity} params.origin.entity Origin Entity.
     * @param {Number[]} params.corner.worldPos Corner World-space 3D position.
     * @param {Entity} params.corner.entity Corner Entity.
     * @param {Number[]} params.target.worldPos Target World-space 3D position.
     * @param {Entity} params.target.entity Target Entity.
     * @param {Boolean} [params.visible=true] Whether to initially show the {@link AngleMeasurement}.
     * @returns {AngleMeasurement} The new {@link AngleMeasurement}.
     */},{key:"createMeasurement",value:function createMeasurement(){var _this21=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(this.viewer.scene.components[params.id]){this.error("Viewer scene component with this ID already exists: "+params.id);delete params.id;}var origin=params.origin;var corner=params.corner;var target=params.target;var measurement=new AngleMeasurement(this,{id:params.id,plugin:this,container:this._container,origin:{entity:origin.entity,worldPos:origin.worldPos},corner:{entity:corner.entity,worldPos:corner.worldPos},target:{entity:target.entity,worldPos:target.worldPos},visible:params.visible,originVisible:true,originWireVisible:true,cornerVisible:true,targetWireVisible:true,targetVisible:true,onMouseOver:this._onMouseOver,onMouseLeave:this._onMouseLeave,onContextMenu:this._onContextMenu});this._measurements[measurement.id]=measurement;measurement.on("destroyed",function(){delete _this21._measurements[measurement.id];});measurement.clickable=true;this.fire("measurementCreated",measurement);return measurement;}/**
     * Destroys a {@link AngleMeasurement}.
     *
     * @param {String} id ID of AngleMeasurement to destroy.
     */},{key:"destroyMeasurement",value:function destroyMeasurement(id){var measurement=this._measurements[id];if(!measurement){this.log("AngleMeasurement not found: "+id);return;}measurement.destroy();this.fire("measurementDestroyed",measurement);}/**
     * Shows all or hides the angle label of each {@link AngleMeasurement}.
     *
     * @param {Boolean} labelsShown Whether or not to show the labels.
     */},{key:"setLabelsShown",value:function setLabelsShown(labelsShown){for(var _i45=0,_Object$entries=Object.entries(this.measurements);_i45<_Object$entries.length;_i45++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i45],2),key=_Object$entries$_i[0],measurement=_Object$entries$_i[1];measurement.labelShown=labelsShown;}}/**
     * Destroys all {@link AngleMeasurement}s.
     */},{key:"clear",value:function clear(){var ids=Object.keys(this._measurements);for(var i=0,len=ids.length;i<len;i++){this.destroyMeasurement(ids[i]);}}/**
     * Destroys this AngleMeasurementsPlugin.
     *
     * Destroys all {@link AngleMeasurement}s first.
     */},{key:"destroy",value:function destroy(){this.clear();_get(_getPrototypeOf(AngleMeasurementsPlugin.prototype),"destroy",this).call(this);}}]);return AngleMeasurementsPlugin;}(Plugin);/**
 * A {@link Marker} with an HTML label attached to it, managed by an {@link AnnotationsPlugin}.
 *
 * See {@link AnnotationsPlugin} for more info.
 */var Annotation=/*#__PURE__*/function(_Marker){_inherits(Annotation,_Marker);var _super9=_createSuper(Annotation);/**
     * @private
     */function Annotation(owner,cfg){var _this22;_classCallCheck(this,Annotation);_this22=_super9.call(this,owner,cfg);/**
         * The {@link AnnotationsPlugin} this Annotation was created by.
         * @type {AnnotationsPlugin}
         */_this22.plugin=cfg.plugin;_this22._container=cfg.container;if(!_this22._container){throw"config missing: container";}if(!cfg.markerElement&&!cfg.markerHTML){throw"config missing: need either markerElement or markerHTML";}if(!cfg.labelElement&&!cfg.labelHTML){throw"config missing: need either labelElement or labelHTML";}_this22._htmlDirty=false;if(cfg.markerElement){_this22._marker=cfg.markerElement;_this22._marker.addEventListener("click",_this22._onMouseClickedExternalMarker=function(){_this22.plugin.fire("markerClicked",_assertThisInitialized(_this22));});_this22._marker.addEventListener("mouseenter",_this22._onMouseEnterExternalMarker=function(){_this22.plugin.fire("markerMouseEnter",_assertThisInitialized(_this22));});_this22._marker.addEventListener("mouseleave",_this22._onMouseLeaveExternalMarker=function(){_this22.plugin.fire("markerMouseLeave",_assertThisInitialized(_this22));});_this22._markerExternal=true;// Don't destroy marker when destroying Annotation
}else{_this22._markerHTML=cfg.markerHTML;_this22._htmlDirty=true;_this22._markerExternal=false;}if(cfg.labelElement){_this22._label=cfg.labelElement;_this22._labelExternal=true;// Don't destroy marker when destroying Annotation
}else{_this22._labelHTML=cfg.labelHTML;_this22._htmlDirty=true;_this22._labelExternal=false;}_this22._markerShown=!!cfg.markerShown;_this22._labelShown=!!cfg.labelShown;_this22._values=cfg.values||{};_this22._layoutDirty=true;_this22._visibilityDirty=true;_this22._buildHTML();_this22._onTick=_this22.scene.on("tick",function(){if(_this22._htmlDirty){_this22._buildHTML();_this22._htmlDirty=false;_this22._layoutDirty=true;_this22._visibilityDirty=true;}if(_this22._layoutDirty||_this22._visibilityDirty){if(_this22._markerShown||_this22._labelShown){_this22._updatePosition();_this22._layoutDirty=false;}}if(_this22._visibilityDirty){_this22._marker.style.visibility=_this22.visible&&_this22._markerShown?"visible":"hidden";_this22._label.style.visibility=_this22.visible&&_this22._markerShown&&_this22._labelShown?"visible":"hidden";_this22._visibilityDirty=false;}});_this22.on("canvasPos",function(){_this22._layoutDirty=true;});_this22.on("visible",function(){_this22._visibilityDirty=true;});_this22.setMarkerShown(cfg.markerShown!==false);_this22.setLabelShown(cfg.labelShown);/**
         * Optional World-space position for {@link Camera#eye}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {Number[]} Eye position.
         */_this22.eye=cfg.eye?cfg.eye.slice():null;/**
         * Optional World-space position for {@link Camera#look}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {Number[]} The "look" vector.
         */_this22.look=cfg.look?cfg.look.slice():null;/**
         * Optional World-space position for {@link Camera#up}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {Number[]} The "up" vector.
         */_this22.up=cfg.up?cfg.up.slice():null;/**
         * Optional projection type for {@link Camera#projection}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {String} The projection type - "perspective" or "ortho"..
         */_this22.projection=cfg.projection;return _this22;}/**
     * @private
     */_createClass(Annotation,[{key:"_buildHTML",value:function _buildHTML(){var _this23=this;if(!this._markerExternal){if(this._marker){this._container.removeChild(this._marker);this._marker=null;}var markerHTML=this._markerHTML||"<p></p>";// Make marker
if(utils.isArray(markerHTML)){markerHTML=markerHTML.join("");}markerHTML=this._renderTemplate(markerHTML.trim());var markerFragment=document.createRange().createContextualFragment(markerHTML);this._marker=markerFragment.firstChild;this._container.appendChild(this._marker);this._marker.style.visibility=this._markerShown?"visible":"hidden";this._marker.addEventListener("click",function(){_this23.plugin.fire("markerClicked",_this23);});this._marker.addEventListener("mouseenter",function(){_this23.plugin.fire("markerMouseEnter",_this23);});this._marker.addEventListener("mouseleave",function(){_this23.plugin.fire("markerMouseLeave",_this23);});this._marker.addEventListener('wheel',function(event){_this23.plugin.viewer.scene.canvas.canvas.dispatchEvent(new WheelEvent('wheel',event));});}if(!this._labelExternal){if(this._label){this._container.removeChild(this._label);this._label=null;}var labelHTML=this._labelHTML||"<p></p>";// Make label
if(utils.isArray(labelHTML)){labelHTML=labelHTML.join("");}labelHTML=this._renderTemplate(labelHTML.trim());var labelFragment=document.createRange().createContextualFragment(labelHTML);this._label=labelFragment.firstChild;this._container.appendChild(this._label);this._label.style.visibility=this._markerShown&&this._labelShown?"visible":"hidden";this._label.addEventListener('wheel',function(event){_this23.plugin.viewer.scene.canvas.canvas.dispatchEvent(new WheelEvent('wheel',event));});}}/**
     * @private
     */},{key:"_updatePosition",value:function _updatePosition(){var boundary=this.scene.canvas.boundary;var left=boundary[0];var top=boundary[1];var canvasPos=this.canvasPos;this._marker.style.left=Math.floor(left+canvasPos[0])-12+"px";this._marker.style.top=Math.floor(top+canvasPos[1])-12+"px";this._marker.style["z-index"]=90005+Math.floor(this._viewPos[2])+1;var offsetX=20;var offsetY=-17;this._label.style.left=20+Math.floor(left+canvasPos[0]+offsetX)+"px";this._label.style.top=Math.floor(top+canvasPos[1]+offsetY)+"px";this._label.style["z-index"]=90005+Math.floor(this._viewPos[2])+1;}/**
     * @private
     */},{key:"_renderTemplate",value:function _renderTemplate(template){for(var key in this._values){if(this._values.hasOwnProperty(key)){var value=this._values[key];template=template.replace(new RegExp('{{'+key+'}}','g'),value);}}return template;}/**
     * Sets whether or not to show this Annotation's marker.
     *
     * The marker shows the Annotation's position.
     *
     * The marker is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {Boolean} shown Whether to show the marker.
     */},{key:"setMarkerShown",value:function setMarkerShown(shown){shown=!!shown;if(this._markerShown===shown){return;}this._markerShown=shown;this._visibilityDirty=true;}/**
     * Gets whether or not to show this Annotation's marker.
     *
     * The marker shows the Annotation's position.
     *
     * The marker is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @returns {Boolean} Whether to show the marker.
     */},{key:"getMarkerShown",value:function getMarkerShown(){return this._markerShown;}/**
     * Sets whether or not to show this Annotation's label.
     *
     * The label is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {Boolean} shown Whether to show the label.
     */},{key:"setLabelShown",value:function setLabelShown(shown){shown=!!shown;if(this._labelShown===shown){return;}this._labelShown=shown;this._visibilityDirty=true;}/**
     * Gets whether or not to show this Annotation's label.
     *
     * The label is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @returns {Boolean} Whether to show the label.
     */},{key:"getLabelShown",value:function getLabelShown(){return this._labelShown;}/**
     * Sets the value of a field within the HTML templates for either the Annotation's marker or label.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {String} key Identifies the field.
     * @param {String} value The field's value.
     */},{key:"setField",value:function setField(key,value){this._values[key]=value||"";this._htmlDirty=true;}/**
     * Gets the value of a field within the HTML templates for either the Annotation's marker or label.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {String} key Identifies the field.
     * @returns {String} The field's value.
     */},{key:"getField",value:function getField(key){return this._values[key];}/**
     * Sets values for multiple placeholders within the Annotation's HTML templates for marker and label.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {{String:(String|Number)}} values Map of field values.
     */},{key:"setValues",value:function setValues(values){for(var key in values){if(values.hasOwnProperty(key)){var value=values[key];this.setField(key,value);}}}/**
     * Gets the values that were set for the placeholders within this Annotation's HTML marker and label templates.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @RETURNS {{String:(String|Number)}} Map of field values.
     */},{key:"getValues",value:function getValues(){return this._values;}/**
     * Destroys this Annotation.
     *
     * You can also call {@link AnnotationsPlugin#destroyAnnotation}.
     */},{key:"destroy",value:function destroy(){if(this._marker){if(!this._markerExternal){this._marker.parentNode.removeChild(this._marker);}else{this._marker.removeEventListener("click",this._onMouseClickedExternalMarker);this._marker.removeEventListener("mouseenter",this._onMouseEnterExternalMarker);this._marker.removeEventListener("mouseleave",this._onMouseLeaveExternalMarker);this._marker=null;}}if(this._label){if(!this._labelExternal){this._label.parentNode.removeChild(this._label);}this._label=null;}this.scene.off(this._onTick);_get(_getPrototypeOf(Annotation.prototype),"destroy",this).call(this);}}]);return Annotation;}(Marker);var tempVec3a$K=math.vec3();var tempVec3b$z=math.vec3();var tempVec3c$v=math.vec3();/**
 * {@link Viewer} plugin that creates {@link Annotation}s.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/58403089-26589280-8062-11e9-8652-aed61a4e8c64.gif">](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickFlyToPosition)
 *
 * * [[Example 1: Create annotations with mouse](https://xeokit.github.io/xeokit-sdk/examples/#annotations_createWithMouse)]
 * * [[Example 2: Click annotations to toggle labels](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickShowLabels)]
 * * [[Example 3: Hover annotations to show labels](https://xeokit.github.io/xeokit-sdk/examples/#annotations_hoverShowLabels)]
 * * [[Example 4: Click annotations to fly to viewpoint](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickFlyToPosition)]
 * * [[Example 5: Create Annotations with externally-created elements](https://xeokit.github.io/xeokit-sdk/examples/#annotations_externalElements)]
 *
 * ## Overview
 *
 * * An {@link Annotation} is a 3D position with a label attached.
 * * Annotations render themselves with HTML elements that float over the canvas; customize the appearance of
 * individual Annotations using HTML template; configure default appearance by setting templates on the AnnotationsPlugin.
 * * Dynamically insert data values into each Annotation's HTML templates; configure default values on the AnnotationsPlugin.
 * * Optionally configure Annotation with externally-created DOM elements for markers and labels; these override templates and data values.
 * * Optionally configure Annotations to hide themselves whenever occluded by {@link Entity}s.
 * * Optionally configure each Annotation with a position we can jump or fly the {@link Camera} to.
 *
 * ## Example 1: Loading a model and creating an annotation
 *
 * In the example below, we'll use an {@link XKTLoaderPlugin} to load a model, and an AnnotationsPlugin
 * to create an {@link Annotation} on it.
 *
 * We'll configure the AnnotationsPlugin with default HTML templates for each Annotation's position (its "marker") and
 * label, along with some default data values to insert into them.
 *
 * When we create our Annotation, we'll give it some specific data values to insert into the templates, overriding some of
 * the defaults we configured on the plugin. Note the correspondence between the placeholders in the templates
 * and the keys in the values map.
 *
 * We'll also configure the Annotation to hide itself whenever it's position is occluded by any {@link Entity}s (this is default behavior). The
 * {@link Scene} periodically occlusion-tests all Annotations on every 20th "tick" (which represents a rendered frame). We
 * can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.
 *
 * Finally, we'll query the Annotation's position occlusion/visibility status, and subscribe to change events on those properties.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickShowLabels)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin,AnnotationsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const annotations = new AnnotationsPlugin(viewer, {
 *
 *      // Default HTML template for marker position
 *      markerHTML: "<div class='annotation-marker' style='background-color: {{markerBGColor}};'>{{glyph}}</div>",
 *
 *      // Default HTML template for label
 *      labelHTML: "<div class='annotation-label' style='background-color: {{labelBGColor}};'>" +
 *      "<div class='annotation-title'>{{title}}</div><div class='annotation-desc'>{{description}}</div></div>",
 *
 *      // Default values to insert into the marker and label templates
 *      values: {
 *          markerBGColor: "red",
 *          labelBGColor: "red",
 *          glyph: "X",
 *          title: "Untitled",
 *          description: "No description"
 *      }
 * });
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/geometry.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const entity = viewer.scene.meshes[""];
 *
 *      // Create an annotation
 *      const myAnnotation1 = annotations.createAnnotation({
 *
 *          id: "myAnnotation",
 *
 *          entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"], // Optional, associate with an Entity
 *
 *          worldPos: [0, 0, 0],        // 3D World-space position
 *
 *          occludable: true,           // Optional, default, makes Annotation invisible when occluded by Entities
 *          markerShown: true,          // Optional, default is true, makes position visible (when not occluded)
 *          labelShown: true            // Optional, default is false, makes label visible (when not occluded)
 *
 *          values: {                   // Optional, overrides AnnotationPlugin's defaults
 *              glyph: "A",
 *              title: "My Annotation",
 *              description: "This is my annotation."
 *          }
 *      });
 *
 *      // Listen for change of the Annotation's 3D World-space position
 *
 *      myAnnotation1.on("worldPos", function(worldPos) {
 *          //...
 *      });
 *
 *      // Listen for change of the Annotation's 3D View-space position, which happens
 *      // when either worldPos was updated or the Camera was moved
 *
 *      myAnnotation1.on("viewPos", function(viewPos) {
 *          //...
 *      });
 *
 *      // Listen for change of the Annotation's 2D Canvas-space position, which happens
 *      // when worldPos or viewPos was updated, or Camera's projection was updated
 *
 *      myAnnotation1.on("canvasPos", function(canvasPos) {
 *          //...
 *      });
 *
 *      // Listen for change of Annotation visibility. The Annotation becomes invisible when it falls outside the canvas,
 *      // or its position is occluded by some Entity. Note that, when not occluded, the position is only
 *      // shown when Annotation#markerShown is true, and the label is only shown when Annotation#labelShown is true.
 *
 *      myAnnotation1.on("visible", function(visible) { // Marker visibility has changed
 *          if (visible) {
 *              this.log("Annotation is visible");
 *          } else {
 *              this.log("Annotation is invisible");
 *          }
 *      });
 *
 *      // Listen for destruction of the Annotation
 *
 *      myAnnotation1.on("destroyed", () => {
 *          //...
 *      });
 * });
 * ````
 *
 * Let's query our {@link Annotation}'s current position in the World, View and Canvas coordinate systems:
 *
 * ````javascript
 * const worldPos  = myAnnotation.worldPos;  // [x,y,z]
 * const viewPos   = myAnnotation.viewPos;   // [x,y,z]
 * const canvasPos = myAnnotation.canvasPos; // [x,y]
 * ````
 *
 * We can query it's current visibility, which is ````false```` when its position is occluded by some {@link Entity}:
 *
 * ````
 * const visible = myAnnotation1.visible;
 * ````
 *
 * To listen for change events on our Annotation's position and visibility:
 *
 * ````javascript
 * // World-space position changes when we assign a new value to Annotation#worldPos
 * myAnnotation1.on("worldPos", (worldPos) => {
 *     //...
 * });
 *
 * // View-space position changes when either worldPos was updated or the Camera was moved
 * myAnnotation1.on("viewPos", (viewPos) => {
 *     //...
 * });
 *
 * // Canvas-space position changes when worldPos or viewPos was updated, or Camera's projection was updated
 * myAnnotation1.on("canvasPos", (canvasPos) => {
 *     //...
 * });
 *
 * // Annotation is invisible when its position falls off the canvas or is occluded by some Entity
 * myAnnotation1.on("visible", (visible) => {
 *     //...
 * });
 * ````
 *
 * Finally, let's dynamically update the values for a couple of placeholders in our Annotation's label:
 *
 * ```` javascript
 * myAnnotation1.setValues({
 *      title: "Here's a new title",
 *      description: "Here's a new description"
 * });
 * ````
 *
 *
 * ## Example 2: Creating an Annotation with a unique appearance
 *
 * Now let's create a second {@link Annotation}, this time with its own custom HTML label template, which includes
 * an image. In the Annotation's values, we'll also provide a new title and description, custom colors for the marker
 * and label, plus a URL for the image in the label template. To render its marker, the Annotation will fall back
 * on the AnnotationPlugin's default marker template.
 *
 * ````javascript
 * const myAnnotation2 = annotations.createAnnotation({
 *
 *      id: "myAnnotation2",
 *
 *      worldPos: [-0.163, 1.810, 7.977],
 *
 *      occludable: true,
 *      markerShown: true,
 *      labelShown: true,
 *
 *      // Custom label template is the same as the Annotation's, with the addition of an image element
 *      labelHTML: "<div class='annotation-label' style='background-color: {{labelBGColor}};'>\
 *          <div class='annotation-title'>{{title}}</div>\
 *          <div class='annotation-desc'>{{description}}</div>\
 *          <br><img alt='myImage' width='150px' height='100px' src='{{imageSrc}}'>\
 *          </div>",
 *
 *      // Custom template values override all the AnnotationPlugin's defaults, and includes an additional value
 *      // for the image element's URL
 *      values: {
 *          glyph: "A3",
 *          title: "The West wall",
 *          description: "Annotations can contain<br>custom HTML like this<br>image:",
 *          markerBGColor: "green",
 *          labelBGColor: "green",
 *          imageSrc: "https://xeokit.io/img/docs/BIMServerLoaderPlugin/schependomlaan.png"
 *      }
 * });
 * ````
 *
 * ## Example 3: Creating an Annotation with a camera position
 *
 * We can optionally configure each {@link Annotation} with a position to fly or jump the {@link Camera} to.
 *
 * Let's create another Annotation, this time providing it with ````eye````, ````look```` and ````up```` properties
 * indicating a viewpoint on whatever it's annotating:
 *
 * ````javascript
 * const myAnnotation3 = annotations.createAnnotation({
 *
 *      id: "myAnnotation3",
 *
 *      worldPos: [-0.163, 3.810, 7.977],
 *
 *      eye: [0,0,-10],
 *      look: [-0.163, 3.810, 7.977],
 *      up: [0,1,0];
 *
 *      occludable: true,
 *      markerShown: true,
 *      labelShown: true,
 *
 *      labelHTML: "<div class='annotation-label' style='background-color: {{labelBGColor}};'>\
 *          <div class='annotation-title'>{{title}}</div>\
 *          <div class='annotation-desc'>{{description}}</div>\
 *          <br><img alt='myImage' width='150px' height='100px' src='{{imageSrc}}'>\
 *          </div>",
 *
 *      values: {
 *          glyph: "A3",
 *          title: "The West wall",
 *          description: "Annotations can contain<br>custom HTML like this<br>image:",
 *          markerBGColor: "green",
 *          labelBGColor: "green",
 *          imageSrc: "https://xeokit.io/img/docs/BIMServerLoaderPlugin/schependomlaan.png"
 *      }
 * });
 * ````
 *
 * Now we can fly the {@link Camera} to the Annotation's viewpoint, like this:
 *
 * ````javascript
 * viewer.cameraFlight.flyTo(myAnnotation3);
 * ````
 *
 * Or jump the Camera, like this:
 *
 * ````javascript
 * viewer.cameraFlight.jumpTo(myAnnotation3);
 * ````
 *
 * ## Example 4: Creating an Annotation using externally-created DOM elements
 *
 * Now let's create another {@link Annotation}, this time providing it with pre-existing DOM elements for its marker
 * and label. Note that AnnotationsPlugin will ignore any ````markerHTML````, ````labelHTML````
 * or ````values```` properties when provide  ````markerElementId```` or ````labelElementId````.
 *
 * ````javascript
 * const myAnnotation2 = annotations.createAnnotation({
 *
 *      id: "myAnnotation2",
 *
 *      worldPos: [-0.163, 1.810, 7.977],
 *
 *      occludable: true,
 *      markerShown: true,
 *      labelShown: true,
 *
 *      markerElementId: "myMarkerElement",
 *      labelElementId: "myLabelElement"
 * });
 * ````
 *
 * ## Example 5: Creating annotations by clicking on objects
 *
 * AnnotationsPlugin makes it easy to create {@link Annotation}s on the surfaces of {@link Entity}s as we click on them.
 *
 * The {@link AnnotationsPlugin#createAnnotation} method can accept a {@link PickResult} returned
 * by {@link Scene#pick}, from which it initializes the {@link Annotation}'s {@link Annotation#worldPos} and
 * {@link Annotation#entity}. Note that this only works when {@link Scene#pick} was configured to perform a 3D
 * surface-intersection pick (see {@link Scene#pick} for more info).
 *
 * Let's now extend our example to create an Annotation wherever we click on the surface of of our model:
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#annotations_createWithMouse)]
 *
 * ````javascript
 * var i = 1; // Used to create unique Annotation IDs
 *
 * viewer.scene.input.on("mouseclicked", (coords) => {
 *
 *     var pickRecord = viewer.scene.pick({
 *         canvasPos: coords,
 *         pickSurface: true  // <<------ This causes picking to find the intersection point on the entity
 *     });
 *
 *     if (pickRecord) {
 *
 *         const annotation = annotations.createAnnotation({
 *              id: "myAnnotationOnClick" + i,
 *              pickRecord: pickRecord,
 *              occludable: true,           // Optional, default is true
 *              markerShown: true,          // Optional, default is true
 *              labelShown: true,           // Optional, default is true
 *              values: {                   // HTML template values
 *                  glyph: "A" + i,
 *                  title: "My annotation " + i,
 *                  description: "My description " + i
 *              },
           });
 *
 *         i++;
 *      }
 * });
 * ````
 *
 * Note that when the Annotation is occludable, there is potential for the {@link Annotation#worldPos} to become
 * visually embedded within the surface of its Entity when viewed from a distance. This happens as a result of limited
 * GPU accuracy GPU accuracy, especially when the near and far view-space clipping planes, specified by {@link Perspective#near}
 * and {@link Perspective#far}, or {@link Ortho#near} and {@link Perspective#far}, are far away from each other.
 *
 * To prevent this, we can offset Annotations from their Entity surfaces by an amount that we set
 * on {@link AnnotationsPlugin#surfaceOffset}:
 *
 * ````javascript
 * annotations.surfaceOffset = 0.3; // Default value
 * ````
 *
 * Annotations subsequently created with {@link AnnotationsPlugin#createAnnotation} using a {@link PickResult} will then
 * be offset by that amount.
 *
 * Another thing we can do to prevent this unwanted occlusion is keep the distance between the view-space clipping
 * planes to a minimum, which improves the accuracy of the Annotation occlusion test. In general, a good default
 * value for ````Perspective#far```` and ````Ortho#far```` is around ````2.000````.
 */var AnnotationsPlugin=/*#__PURE__*/function(_Plugin2){_inherits(AnnotationsPlugin,_Plugin2);var _super10=_createSuper(AnnotationsPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="Annotations"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} [cfg.markerHTML] HTML text template for Annotation markers. Defaults to ````<div></div>````. Ignored on {@link Annotation}s configured with a ````markerElementId````.
     * @param {String} [cfg.labelHTML] HTML text template for Annotation labels. Defaults to ````<div></div>````.  Ignored on {@link Annotation}s configured with a ````labelElementId````.
     * @param {HTMLElement} [cfg.container] Container DOM element for markers and labels. Defaults to ````document.body````.
     * @param {{String:(String|Number)}} [cfg.values={}] Map of default values to insert into the HTML templates for the marker and label.
     * @param {Number}  [cfg.surfaceOffset=0.3] The amount by which each {@link Annotation} is offset from the surface of
     * its {@link Entity} when we create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.
     */function AnnotationsPlugin(viewer,cfg){var _this24;_classCallCheck(this,AnnotationsPlugin);_this24=_super10.call(this,"Annotations",viewer);_this24._labelHTML=cfg.labelHTML||"<div></div>";_this24._markerHTML=cfg.markerHTML||"<div></div>";_this24._container=cfg.container||document.body;_this24._values=cfg.values||{};/**
         * The {@link Annotation}s created by {@link AnnotationsPlugin#createAnnotation}, each mapped to its {@link Annotation#id}.
         * @type {{String:Annotation}}
         */_this24.annotations={};_this24.surfaceOffset=cfg.surfaceOffset;return _this24;}/**
     * Gets the plugin's HTML container element, if any.
     * @returns {*|HTMLElement|HTMLElement}
     */_createClass(AnnotationsPlugin,[{key:"getContainerElement",value:function getContainerElement(){return this._container;}/**
     * @private
     */},{key:"send",value:function send(name,value){switch(name){case"clearAnnotations":this.clear();break;}}/**
     * Sets the amount by which each {@link Annotation} is offset from the surface of its {@link Entity}, when we
     * create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.
     *
     * See the class comments for more info.
     *
     * This is ````0.3```` by default.
     *
     * @param {Number} surfaceOffset The surface offset.
     */},{key:"surfaceOffset",get:/**
     * Gets the amount by which an {@link Annotation} is offset from the surface of its {@link Entity} when
     * created by {@link AnnotationsPlugin#createAnnotation}, when we
     * create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.
     *
     * This is ````0.3```` by default.
     *
     * @returns {Number} The surface offset.
     */function get(){return this._surfaceOffset;}/**
     * Creates an {@link Annotation}.
     *
     * The Annotation is then registered by {@link Annotation#id} in {@link AnnotationsPlugin#annotations}.
     *
     * @param {Object} params Annotation configuration.
     * @param {String} params.id Unique ID to assign to {@link Annotation#id}. The Annotation will be registered by this in {@link AnnotationsPlugin#annotations} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.
     * @param {String} [params.markerElementId] ID of pre-existing DOM element to render the marker. This overrides ````markerHTML```` and does not support ````values```` (data is baked into the label DOM element).
     * @param {String} [params.labelElementId] ID of pre-existing DOM element to render the label. This overrides ````labelHTML```` and does not support ````values```` (data is baked into the label DOM element).
     * @param {String} [params.markerHTML] HTML text template for the Annotation marker. Defaults to the marker HTML given to the AnnotationsPlugin constructor. Ignored if you provide ````markerElementId````.
     * @param {String} [params.labelHTML] HTML text template for the Annotation label. Defaults to the label HTML given to the AnnotationsPlugin constructor. Ignored if you provide ````labelElementId````.
     * @param {Number[]} [params.worldPos=[0,0,0]] World-space position of the Annotation marker, assigned to {@link Annotation#worldPos}.
     * @param {Entity} [params.entity] Optional {@link Entity} to associate the Annotation with. Causes {@link Annotation#visible} to be ````false```` whenever {@link Entity#visible} is also ````false````.
     * @param {PickResult} [params.pickResult] Sets the Annotation's World-space position and direction vector from the given {@link PickResult}'s {@link PickResult#worldPos} and {@link PickResult#worldNormal}, and the Annotation's Entity from {@link PickResult#entity}. Causes ````worldPos```` and ````entity```` parameters to be ignored, if they are also given.
     * @param {Boolean} [params.occludable=false] Indicates whether or not the {@link Annotation} marker and label are hidden whenever the marker occluded by {@link Entity}s in the {@link Scene}. The
     * {@link Scene} periodically occlusion-tests all Annotations on every 20th "tick" (which represents a rendered frame). We can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.
     * @param  {{String:(String|Number)}} [params.values={}] Map of values to insert into the HTML templates for the marker and label. These will be inserted in addition to any values given to the AnnotationsPlugin constructor.
     * @param {Boolean} [params.markerShown=true] Whether to initially show the {@link Annotation} marker.
     * @param {Boolean} [params.labelShown=false] Whether to initially show the {@link Annotation} label.
     * @param {Number[]} [params.eye] Optional World-space position for {@link Camera#eye}, used when this Annotation is associated with a {@link Camera} position.
     * @param {Number[]} [params.look] Optional World-space position for {@link Camera#look}, used when this Annotation is associated with a {@link Camera} position.
     * @param {Number[]} [params.up] Optional World-space position for {@link Camera#up}, used when this Annotation is associated with a {@link Camera} position.
     * @param {String} [params.projection] Optional projection type for {@link Camera#projection}, used when this Annotation is associated with a {@link Camera} position.
     * @returns {Annotation} The new {@link Annotation}.
     */,set:function set(surfaceOffset){if(surfaceOffset===undefined||surfaceOffset===null){surfaceOffset=0.3;}this._surfaceOffset=surfaceOffset;}},{key:"createAnnotation",value:function createAnnotation(params){var _this25=this;if(this.viewer.scene.components[params.id]){this.error("Viewer component with this ID already exists: "+params.id);delete params.id;}var worldPos;var entity;params.pickResult=params.pickResult||params.pickRecord;if(params.pickResult){var pickResult=params.pickResult;if(!pickResult.worldPos||!pickResult.worldNormal){this.error("Param 'pickResult' does not have both worldPos and worldNormal");}else{var normalizedWorldNormal=math.normalizeVec3(pickResult.worldNormal,tempVec3a$K);var offsetVec=math.mulVec3Scalar(normalizedWorldNormal,this._surfaceOffset,tempVec3b$z);var offsetWorldPos=math.addVec3(pickResult.worldPos,offsetVec,tempVec3c$v);worldPos=offsetWorldPos;entity=pickResult.entity;}}else{worldPos=params.worldPos;entity=params.entity;}var markerElement=null;if(params.markerElementId){markerElement=document.getElementById(params.markerElementId);if(!markerElement){this.error("Can't find DOM element for 'markerElementId' value '"+params.markerElementId+"' - defaulting to internally-generated empty DIV");}}var labelElement=null;if(params.labelElementId){labelElement=document.getElementById(params.labelElementId);if(!labelElement){this.error("Can't find DOM element for 'labelElementId' value '"+params.labelElementId+"' - defaulting to internally-generated empty DIV");}}var annotation=new Annotation(this.viewer.scene,{id:params.id,plugin:this,entity:entity,worldPos:worldPos,container:this._container,markerElement:markerElement,labelElement:labelElement,markerHTML:params.markerHTML||this._markerHTML,labelHTML:params.labelHTML||this._labelHTML,occludable:params.occludable,values:utils.apply(params.values,utils.apply(this._values,{})),markerShown:params.markerShown,labelShown:params.labelShown,eye:params.eye,look:params.look,up:params.up,projection:params.projection,visible:params.visible!==false});this.annotations[annotation.id]=annotation;annotation.on("destroyed",function(){delete _this25.annotations[annotation.id];_this25.fire("annotationDestroyed",annotation.id);});this.fire("annotationCreated",annotation.id);return annotation;}/**
     * Destroys an {@link Annotation}.
     *
     * @param {String} id ID of Annotation to destroy.
     */},{key:"destroyAnnotation",value:function destroyAnnotation(id){var annotation=this.annotations[id];if(!annotation){this.log("Annotation not found: "+id);return;}annotation.destroy();}/**
     * Destroys all {@link Annotation}s.
     */},{key:"clear",value:function clear(){var ids=Object.keys(this.annotations);for(var i=0,len=ids.length;i<len;i++){this.destroyAnnotation(ids[i]);}}/**
     * Destroys this AnnotationsPlugin.
     *
     * Destroys all {@link Annotation}s first.
     */},{key:"destroy",value:function destroy(){this.clear();_get(_getPrototypeOf(AnnotationsPlugin.prototype),"destroy",this).call(this);}}]);return AnnotationsPlugin;}(Plugin);var defaultCSS=".sk-fading-circle {\
        background: transparent;\
        margin: 20px auto;\
        width: 50px;\
        height:50px;\
        position: relative;\
        }\
        .sk-fading-circle .sk-circle {\
        width: 120%;\
        height: 120%;\
        position: absolute;\
        left: 0;\
        top: 0;\
        }\
        .sk-fading-circle .sk-circle:before {\
        content: '';\
        display: block;\
        margin: 0 auto;\
        width: 15%;\
        height: 15%;\
        background-color: #ff8800;\
        border-radius: 100%;\
        -webkit-animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        }\
        .sk-fading-circle .sk-circle2 {\
        -webkit-transform: rotate(30deg);\
        -ms-transform: rotate(30deg);\
        transform: rotate(30deg);\
    }\
    .sk-fading-circle .sk-circle3 {\
        -webkit-transform: rotate(60deg);\
        -ms-transform: rotate(60deg);\
        transform: rotate(60deg);\
    }\
    .sk-fading-circle .sk-circle4 {\
        -webkit-transform: rotate(90deg);\
        -ms-transform: rotate(90deg);\
        transform: rotate(90deg);\
    }\
    .sk-fading-circle .sk-circle5 {\
        -webkit-transform: rotate(120deg);\
        -ms-transform: rotate(120deg);\
        transform: rotate(120deg);\
    }\
    .sk-fading-circle .sk-circle6 {\
        -webkit-transform: rotate(150deg);\
        -ms-transform: rotate(150deg);\
        transform: rotate(150deg);\
    }\
    .sk-fading-circle .sk-circle7 {\
        -webkit-transform: rotate(180deg);\
        -ms-transform: rotate(180deg);\
        transform: rotate(180deg);\
    }\
    .sk-fading-circle .sk-circle8 {\
        -webkit-transform: rotate(210deg);\
        -ms-transform: rotate(210deg);\
        transform: rotate(210deg);\
    }\
    .sk-fading-circle .sk-circle9 {\
        -webkit-transform: rotate(240deg);\
        -ms-transform: rotate(240deg);\
        transform: rotate(240deg);\
    }\
    .sk-fading-circle .sk-circle10 {\
        -webkit-transform: rotate(270deg);\
        -ms-transform: rotate(270deg);\
        transform: rotate(270deg);\
    }\
    .sk-fading-circle .sk-circle11 {\
        -webkit-transform: rotate(300deg);\
        -ms-transform: rotate(300deg);\
        transform: rotate(300deg);\
    }\
    .sk-fading-circle .sk-circle12 {\
        -webkit-transform: rotate(330deg);\
        -ms-transform: rotate(330deg);\
        transform: rotate(330deg);\
    }\
    .sk-fading-circle .sk-circle2:before {\
        -webkit-animation-delay: -1.1s;\
        animation-delay: -1.1s;\
    }\
    .sk-fading-circle .sk-circle3:before {\
        -webkit-animation-delay: -1s;\
        animation-delay: -1s;\
    }\
    .sk-fading-circle .sk-circle4:before {\
        -webkit-animation-delay: -0.9s;\
        animation-delay: -0.9s;\
    }\
    .sk-fading-circle .sk-circle5:before {\
        -webkit-animation-delay: -0.8s;\
        animation-delay: -0.8s;\
    }\
    .sk-fading-circle .sk-circle6:before {\
        -webkit-animation-delay: -0.7s;\
        animation-delay: -0.7s;\
    }\
    .sk-fading-circle .sk-circle7:before {\
        -webkit-animation-delay: -0.6s;\
        animation-delay: -0.6s;\
    }\
    .sk-fading-circle .sk-circle8:before {\
        -webkit-animation-delay: -0.5s;\
        animation-delay: -0.5s;\
    }\
    .sk-fading-circle .sk-circle9:before {\
        -webkit-animation-delay: -0.4s;\
        animation-delay: -0.4s;\
    }\
    .sk-fading-circle .sk-circle10:before {\
        -webkit-animation-delay: -0.3s;\
        animation-delay: -0.3s;\
    }\
    .sk-fading-circle .sk-circle11:before {\
        -webkit-animation-delay: -0.2s;\
        animation-delay: -0.2s;\
    }\
    .sk-fading-circle .sk-circle12:before {\
        -webkit-animation-delay: -0.1s;\
        animation-delay: -0.1s;\
    }\
    @-webkit-keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }\
    @keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }";/**
 * @desc Displays a progress animation at the center of its {@link Canvas} while things are loading or otherwise busy.
 *
 *
 * * Located at {@link Canvas#spinner}.
 * * Automatically shown while things are loading, however may also be shown by application code wanting to indicate busyness.
 * * {@link Spinner#processes} holds the count of active processes. As a process starts, it increments {@link Spinner#processes}, then decrements it on completion or failure.
 * * A Spinner is only visible while {@link Spinner#processes} is greater than zero.
 *
 * ````javascript
 * var spinner = viewer.scene.canvas.spinner;
 *
 * // Increment count of busy processes represented by the spinner;
 * // assuming the count was zero, this now shows the spinner
 * spinner.processes++;
 *
 * // Increment the count again, by some other process; spinner already visible, now requires two decrements
 * // before it becomes invisible again
 * spinner.processes++;
 *
 * // Decrement the count; count still greater than zero, so spinner remains visible
 * spinner.process--;
 *
 * // Decrement the count; count now zero, so spinner becomes invisible
 * spinner.process--;
 * ````
 */var Spinner=/*#__PURE__*/function(_Component6){_inherits(Spinner,_Component6);var _super11=_createSuper(Spinner);/**
     @private
     */function Spinner(owner){var _this26;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Spinner);_this26=_super11.call(this,owner,cfg);_this26._canvas=cfg.canvas;_this26._element=null;_this26._isCustom=false;// True when the element is custom HTML
if(cfg.elementId){// Custom spinner element supplied
_this26._element=document.getElementById(cfg.elementId);if(!_this26._element){_this26.error("Can't find given Spinner HTML element: '"+cfg.elementId+"' - will automatically create default element");}else{_this26._adjustPosition();}}if(!_this26._element){_this26._createDefaultSpinner();}_this26.processes=0;return _this26;}/** @private */_createClass(Spinner,[{key:"type",get:/**
     @private
     */function get(){return"Spinner";}},{key:"_createDefaultSpinner",value:function _createDefaultSpinner(){this._injectDefaultCSS();var element=document.createElement('div');var style=element.style;style["z-index"]="9000";style.position="absolute";element.innerHTML='<div class="sk-fading-circle">\
                <div class="sk-circle1 sk-circle"></div>\
                <div class="sk-circle2 sk-circle"></div>\
                <div class="sk-circle3 sk-circle"></div>\
                <div class="sk-circle4 sk-circle"></div>\
                <div class="sk-circle5 sk-circle"></div>\
                <div class="sk-circle6 sk-circle"></div>\
                <div class="sk-circle7 sk-circle"></div>\
                <div class="sk-circle8 sk-circle"></div>\
                <div class="sk-circle9 sk-circle"></div>\
                <div class="sk-circle10 sk-circle"></div>\
                <div class="sk-circle11 sk-circle"></div>\
                <div class="sk-circle12 sk-circle"></div>\
                </div>';this._canvas.parentElement.appendChild(element);this._element=element;this._isCustom=false;this._adjustPosition();}/**
     * @private
     */},{key:"_injectDefaultCSS",value:function _injectDefaultCSS(){var elementId="xeokit-spinner-css";if(document.getElementById(elementId)){return;}var defaultCSSNode=document.createElement('style');defaultCSSNode.innerHTML=defaultCSS;defaultCSSNode.id=elementId;document.body.appendChild(defaultCSSNode);}/**
     * @private
     */},{key:"_adjustPosition",value:function _adjustPosition(){// (Re)positions spinner DIV over the center of the canvas - called by Canvas
if(this._isCustom){return;}var canvas=this._canvas;var element=this._element;var style=element.style;style["left"]=canvas.offsetLeft+canvas.clientWidth*0.5-element.clientWidth*0.5+"px";style["top"]=canvas.offsetTop+canvas.clientHeight*0.5-element.clientHeight*0.5+"px";}/**
     * Sets the number of processes this Spinner represents.
     *
     * The Spinner is visible while this property is greater than zero.
     *
     * Increment this property whenever you commence some process during which you want the Spinner to be visible, then decrement it again when the process is complete.
     *
     * Clamps to zero if you attempt to set to to a negative value.
     *
     * Fires a {@link Spinner#processes:event} event on change.

     * Default value is ````0````.
     *
     * @param {Number} value New processes count.
     */},{key:"processes",get:/**
     * Gets the number of processes this Spinner represents.
     *
     * The Spinner is visible while this property is greater than zero.
     *
     * @returns {Number} Current processes count.
     */function get(){return this._processes;},set:function set(value){value=value||0;if(this._processes===value){return;}if(value<0){return;}var prevValue=this._processes;this._processes=value;var element=this._element;if(element){element.style["visibility"]=this._processes>0?"visible":"hidden";}/**
         Fired whenever this Spinner's {@link Spinner#visible} property changes.

         @event processes
         @param value The property's new value
         */this.fire("processes",this._processes);if(this._processes===0&&this._processes!==prevValue){/**
             Fired whenever this Spinner's {@link Spinner#visible} property becomes zero.

             @event zeroProcesses
             */this.fire("zeroProcesses",this._processes);}}},{key:"_destroy",value:function _destroy(){if(this._element&&!this._isCustom){this._element.parentNode.removeChild(this._element);this._element=null;}var styleElement=document.getElementById("xeokit-spinner-css");if(styleElement){styleElement.parentNode.removeChild(styleElement);}}}]);return Spinner;}(Component);var WEBGL_CONTEXT_NAMES=["webgl2","experimental-webgl","webkit-3d","moz-webgl","moz-glweb20"];/**
 * @desc Manages its {@link Scene}'s HTML canvas.
 *
 * * Provides the HTML canvas element in {@link Canvas#canvas}.
 * * Has a {@link Spinner}, provided at {@link Canvas#spinner}, which manages the loading progress indicator.
 */var Canvas=/*#__PURE__*/function(_Component7){_inherits(Canvas,_Component7);var _super12=_createSuper(Canvas);/**
     * @constructor
     * @private
     */function Canvas(owner){var _this27;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Canvas);_this27=_super12.call(this,owner,cfg);_this27._backgroundColor=math.vec3([cfg.backgroundColor?cfg.backgroundColor[0]:1,cfg.backgroundColor?cfg.backgroundColor[1]:1,cfg.backgroundColor?cfg.backgroundColor[2]:1]);_this27._backgroundColorFromAmbientLight=!!cfg.backgroundColorFromAmbientLight;/**
         * The HTML canvas.
         *
         * @property canvas
         * @type {HTMLCanvasElement}
         * @final
         */_this27.canvas=cfg.canvas;/**
         * The WebGL rendering context.
         *
         * @property gl
         * @type {WebGLRenderingContext}
         * @final
         */_this27.gl=null;/**
         * True when WebGL 2 support is enabled.
         *
         * @property webgl2
         * @type {Boolean}
         * @final
         */_this27.webgl2=false;// Will set true in _initWebGL if WebGL is requested and we succeed in getting it.
/**
         * Indicates if this Canvas is transparent.
         *
         * @property transparent
         * @type {Boolean}
         * @default {false}
         * @final
         */_this27.transparent=!!cfg.transparent;/**
         * Attributes for the WebGL context
         *
         * @type {{}|*}
         */_this27.contextAttr=cfg.contextAttr||{};_this27.contextAttr.alpha=_this27.transparent;_this27.contextAttr.preserveDrawingBuffer=!!_this27.contextAttr.preserveDrawingBuffer;_this27.contextAttr.stencil=false;_this27.contextAttr.premultipliedAlpha=!!_this27.contextAttr.premultipliedAlpha;// False by default: https://github.com/xeokit/xeokit-sdk/issues/251
_this27.contextAttr.antialias=_this27.contextAttr.antialias!==false;// If the canvas uses css styles to specify the sizes make sure the basic
// width and height attributes match or the WebGL context will use 300 x 150
_this27.resolutionScale=cfg.resolutionScale;_this27.canvas.width=Math.round(_this27.canvas.clientWidth*_this27._resolutionScale);_this27.canvas.height=Math.round(_this27.canvas.clientHeight*_this27._resolutionScale);/**
         * Boundary of the Canvas in absolute browser window coordinates.
         *
         * ### Usage:
         *
         * ````javascript
         * var boundary = myScene.canvas.boundary;
         *
         * var xmin = boundary[0];
         * var ymin = boundary[1];
         * var width = boundary[2];
         * var height = boundary[3];
         * ````
         *
         * @property boundary
         * @type {Number[]}
         * @final
         */_this27.boundary=[_this27.canvas.offsetLeft,_this27.canvas.offsetTop,_this27.canvas.clientWidth,_this27.canvas.clientHeight];// Get WebGL context
_this27._initWebGL(cfg);// Bind context loss and recovery handlers
var self=_assertThisInitialized(_this27);_this27.canvas.addEventListener("webglcontextlost",_this27._webglcontextlostListener=function(event){console.time("webglcontextrestored");self.scene._webglContextLost();/**
                 * Fired whenever the WebGL context has been lost
                 * @event webglcontextlost
                 */self.fire("webglcontextlost");event.preventDefault();},false);_this27.canvas.addEventListener("webglcontextrestored",_this27._webglcontextrestoredListener=function(event){self._initWebGL();if(self.gl){self.scene._webglContextRestored(self.gl);/**
                     * Fired whenever the WebGL context has been restored again after having previously being lost
                     * @event webglContextRestored
                     * @param value The WebGL context object
                     */self.fire("webglcontextrestored",self.gl);event.preventDefault();}console.timeEnd("webglcontextrestored");},false);// Attach to resize events on the canvas
var dirtyBoundary=true;// make sure we publish the 1st boundary event
var resizeObserver=new ResizeObserver(function(entries){var _iterator3=_createForOfIteratorHelper(entries),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var entry=_step3.value;if(entry.contentBoxSize){dirtyBoundary=true;}}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}});resizeObserver.observe(_this27.canvas);// Publish canvas size and position changes on each scene tick
_this27._tick=_this27.scene.on("tick",function(){// Only publish if the canvas bounds changed
if(!dirtyBoundary){return;}dirtyBoundary=false;// Set the real size of the canvas (the drawable w*h)
self.canvas.width=Math.round(self.canvas.clientWidth*self._resolutionScale);self.canvas.height=Math.round(self.canvas.clientHeight*self._resolutionScale);// Publish the boundary change
self.boundary[0]=self.canvas.offsetLeft;self.boundary[1]=self.canvas.offsetTop;self.boundary[2]=self.canvas.clientWidth;self.boundary[3]=self.canvas.clientHeight;self.fire("boundary",self.boundary);});_this27._spinner=new Spinner(_this27.scene,{canvas:_this27.canvas,elementId:cfg.spinnerElementId});return _this27;}/**
     @private
     */_createClass(Canvas,[{key:"type",get:function get(){return"Canvas";}/**
     * Gets whether the canvas clear color will be derived from {@link AmbientLight} or {@link Canvas#backgroundColor}
     * when {@link Canvas#transparent} is ```true```.
     *
     * When {@link Canvas#transparent} is ```true``` and this is ````true````, then the canvas clear color will
     * be taken from the {@link Scene}'s ambient light color.
     *
     * When {@link Canvas#transparent} is ```true``` and this is ````false````, then the canvas clear color will
     * be taken from {@link Canvas#backgroundColor}.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */},{key:"backgroundColorFromAmbientLight",get:function get(){return this._backgroundColorFromAmbientLight;}/**
     * Sets if the canvas background color is derived from an {@link AmbientLight}.
     *
     * This only has effect when the canvas is not transparent. When not enabled, the background color
     * will be the canvas element's HTML/CSS background color.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */,set:function set(backgroundColorFromAmbientLight){this._backgroundColorFromAmbientLight=backgroundColorFromAmbientLight!==false;this.glRedraw();}/**
     * Gets the canvas clear color.
     *
     * Default value is ````[1, 1, 1]````.
     *
     * @type {Number[]}
     */},{key:"backgroundColor",get:function get(){return this._backgroundColor;}/**
     * Sets the canvas clear color.
     *
     * Default value is ````[1, 1, 1]````.
     *
     * @type {Number[]}
     */,set:function set(value){if(value){this._backgroundColor[0]=value[0];this._backgroundColor[1]=value[1];this._backgroundColor[2]=value[2];}else{this._backgroundColor[0]=1.0;this._backgroundColor[1]=1.0;this._backgroundColor[2]=1.0;}this.glRedraw();}/**
     * Gets the scale of the canvas back buffer relative to the CSS-defined size of the canvas.
     *
     * This is a common way to trade off rendering quality for speed. If the canvas size is defined in CSS, then
     * setting this to a value between ````[0..1]```` (eg ````0.5````) will render into a smaller back buffer, giving
     * a performance boost.
     *
     * @returns {*|number} The resolution scale.
     */},{key:"resolutionScale",get:function get(){return this._resolutionScale;}/**
     * Sets the scale of the canvas back buffer relative to the CSS-defined size of the canvas.
     *
     * This is a common way to trade off rendering quality for speed. If the canvas size is defined in CSS, then
     * setting this to a value between ````[0..1]```` (eg ````0.5````) will render into a smaller back buffer, giving
     * a performance boost.
     *
     * @param {*|number} resolutionScale The resolution scale.
     */,set:function set(resolutionScale){resolutionScale=resolutionScale||1.0;if(resolutionScale===this._resolutionScale){return;}this._resolutionScale=resolutionScale;var canvas=this.canvas;canvas.width=Math.round(canvas.clientWidth*this._resolutionScale);canvas.height=Math.round(canvas.clientHeight*this._resolutionScale);this.glRedraw();}/**
     * The busy {@link Spinner} for this Canvas.
     *
     * @property spinner
     * @type Spinner
     * @final
     */},{key:"spinner",get:function get(){return this._spinner;}/**
     * Creates a default canvas in the DOM.
     * @private
     */},{key:"_createCanvas",value:function _createCanvas(){var canvasId="xeokit-canvas-"+math.createUUID();var body=document.getElementsByTagName("body")[0];var div=document.createElement('div');var style=div.style;style.height="100%";style.width="100%";style.padding="0";style.margin="0";style.background="rgba(0,0,0,0);";style["float"]="left";style.left="0";style.top="0";style.position="absolute";style.opacity="1.0";style["z-index"]="-10000";div.innerHTML+='<canvas id="'+canvasId+'" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0;"></canvas>';body.appendChild(div);this.canvas=document.getElementById(canvasId);}},{key:"_getElementXY",value:function _getElementXY(e){var x=0,y=0;while(e){x+=e.offsetLeft-e.scrollLeft;y+=e.offsetTop-e.scrollTop;e=e.offsetParent;}return{x:x,y:y};}/**
     * Initialises the WebGL context
     * @private
     */},{key:"_initWebGL",value:function _initWebGL(){// Default context attribute values
if(!this.gl){for(var _i46=0;!this.gl&&_i46<WEBGL_CONTEXT_NAMES.length;_i46++){try{this.gl=this.canvas.getContext(WEBGL_CONTEXT_NAMES[_i46],this.contextAttr);}catch(e){// Try with next context name
}}}if(!this.gl){this.error('Failed to get a WebGL context');/**
             * Fired whenever the canvas failed to get a WebGL context, which probably means that WebGL
             * is either unsupported or has been disabled.
             * @event webglContextFailed
             */this.fire("webglContextFailed",true,true);}// data-textures: avoid to re-bind same texture
{var gl=this.gl;var lastTextureUnit="__";var originalActiveTexture=gl.activeTexture;gl.activeTexture=function(arg1){if(lastTextureUnit===arg1){return;}lastTextureUnit=arg1;originalActiveTexture.call(this,arg1);};var lastBindTexture={};var originalBindTexture=gl.bindTexture;gl.bindTexture=function(arg1,arg2){if(lastBindTexture[lastTextureUnit]===arg2){return;}lastBindTexture[lastTextureUnit]=arg2;originalBindTexture.call(this,arg1,arg2);};// setInterval (
//     () => {
//         console.log (`${avoidedRebinds} avoided texture binds/sec`);
//         avoidedRebinds = 0;
//     },
//     1000
// );
}if(this.gl){// Setup extension (if necessary) and hints for fragment shader derivative functions
if(this.webgl2){this.gl.hint(this.gl.FRAGMENT_SHADER_DERIVATIVE_HINT,this.gl.FASTEST);// data-textures: not using standard-derivatives
if(!(this.gl instanceof WebGL2RenderingContext));}}}/**
     * @private
     * @deprecated
     */},{key:"getSnapshot",value:function getSnapshot(params){throw"Canvas#getSnapshot() has been replaced by Viewer#getSnapshot() - use that method instead.";}/**
     * Reads colors of pixels from the last rendered frame.
     *
     * Call this method like this:
     *
     * ````JavaScript
     *
     * // Ignore transparent pixels (default is false)
     * var opaqueOnly = true;
     *
     * var colors = new Float32Array(8);
     *
     * viewer.scene.canvas.readPixels([ 100, 22, 12, 33 ], colors, 2, opaqueOnly);
     * ````
     *
     * Then the r,g,b components of the colors will be set to the colors at those pixels.
     *
     * @param {Number[]} pixels
     * @param {Number[]} colors
     * @param {Number} size
     * @param {Boolean} opaqueOnly
     */},{key:"readPixels",value:function readPixels(pixels,colors,size,opaqueOnly){return this.scene._renderer.readPixels(pixels,colors,size,opaqueOnly);}/**
     * Simulates lost WebGL context.
     */},{key:"loseWebGLContext",value:function loseWebGLContext(){if(this.canvas.loseContext){this.canvas.loseContext();}}},{key:"destroy",value:function destroy(){this.scene.off(this._tick);this._spinner._destroy();// Memory leak avoidance
this.canvas.removeEventListener("webglcontextlost",this._webglcontextlostListener);this.canvas.removeEventListener("webglcontextrestored",this._webglcontextrestoredListener);this.gl=null;_get(_getPrototypeOf(Canvas.prototype),"destroy",this).call(this);}}]);return Canvas;}(Component);/**
 * @desc Provides rendering context to {@link Drawable"}s as xeokit renders them for a frame.
 *
 * Also creates RTC viewing and picking matrices, caching and reusing matrices within each frame.
 *
 * @private
 */var FrameContext=/*#__PURE__*/function(){function FrameContext(scene){_classCallCheck(this,FrameContext);this._scene=scene;this._matPool=[];this._matPoolNextFreeIndex=0;this._rtcViewMats={};this._rtcPickViewMats={};this.reset();}/**
     * Called by the renderer before each frame.
     * @private
     */_createClass(FrameContext,[{key:"reset",value:function reset(){this._matPoolNextFreeIndex=0;this._rtcViewMats={};this._rtcPickViewMats={};/**
         * The WebGL rendering context.
         * @type {WebGLRenderingContext}
         */this.gl=this._scene.canvas.gl;/**
         * ID of the last {@link WebGLProgram} that was bound during the current frame.
         * @property lastProgramId
         * @type {Number}
         */this.lastProgramId=null;/**
         * Whether to render a physically-based representation for triangle surfaces.
         *
         * When ````false````, we'll render them with a fast vertex-shaded Gouraud-shaded representation, which
         * is great for zillions of objects.
         *
         * When ````true````, we'll render them at a better visual quality, using smooth, per-fragment shading
         * and a more realistic lighting model.
         *
         * @property quality
         * @default false
         * @type {Boolean}
         */this.pbrEnabled=false;/**
         * Whether to render color textures for triangle surfaces.
         *
         * @property quality
         * @default false
         * @type {Boolean}
         */this.colorTextureEnabled=false;/**
         * Whether SAO is currently enabled during the current frame.
         * @property withSAO
         * @default false
         * @type {Boolean}
         */this.withSAO=false;/**
         * Whether backfaces are currently enabled during the current frame.
         * @property backfaces
         * @default false
         * @type {Boolean}
         */this.backfaces=false;/**
         * The vertex winding order for what we currently consider to be a backface during current
         * frame: true == "cw", false == "ccw".
         * @property frontFace
         * @default true
         * @type {Boolean}
         */this.frontface=true;/**
         * The next available texture unit to bind a {@link Texture} to.
         * @defauilt 0
         * @property textureUnit
         * @type {number}
         */this.textureUnit=0;/**
         * Performance statistic that counts how many times the renderer has called ````gl.drawElements()```` has been
         * called so far within the current frame.
         * @default 0
         * @property drawElements
         * @type {number}
         */this.drawElements=0;/**
         * Performance statistic that counts how many times ````gl.drawArrays()```` has been called so far within
         * the current frame.
         * @default 0
         * @property drawArrays
         * @type {number}
         */this.drawArrays=0;/**
         * Performance statistic that counts how many times ````gl.useProgram()```` has been called so far within
         * the current frame.
         * @default 0
         * @property useProgram
         * @type {number}
         */this.useProgram=0;/**
         * Statistic that counts how many times ````gl.bindTexture()```` has been called so far within the current frame.
         * @default 0
         * @property bindTexture
         * @type {number}
         */this.bindTexture=0;/**
         * Counts how many times the renderer has called ````gl.bindArray()```` so far within the current frame.
         * @defaulr 0
         * @property bindArray
         * @type {number}
         */this.bindArray=0;/**
         * Indicates which pass the renderer is currently rendering.
         *
         * See {@link Scene/passes:property"}}Scene#passes{{/crossLink}}, which configures how many passes we render
         * per frame, which typically set to ````2```` when rendering a stereo view.
         *
         * @property pass
         * @type {number}
         */this.pass=0;/**
         * The 4x4 viewing transform matrix the renderer is currently using when rendering castsShadows.
         *
         * This sets the viewpoint to look from the point of view of each {@link DirLight}
         * or {@link PointLight} that casts a shadow.
         *
         * @property shadowViewMatrix
         * @type {Number[]}
         */this.shadowViewMatrix=null;/**
         * The 4x4 viewing projection matrix the renderer is currently using when rendering shadows.
         *
         * @property shadowProjMatrix
         * @type {Number[]}
         */this.shadowProjMatrix=null;/**
         * The 4x4 viewing transform matrix the renderer is currently using when rendering a ray-pick.
         *
         * This sets the viewpoint to look along the ray given to {@link Scene/pick:method"}}Scene#pick(){{/crossLink}}
         * when picking with a ray.
         *
         * @property pickViewMatrix
         * @type {Number[]}
         */this.pickViewMatrix=null;/**
         * The 4x4 orthographic projection transform matrix the renderer is currently using when rendering a ray-pick.
         *
         * @property pickProjMatrix
         * @type {Number[]}
         */this.pickProjMatrix=null;/**
         * Distance to the near clipping plane when rendering depth fragments for GPU-accelerated 3D picking.
         *
         * @property pickZNear
         * @type {Number|*}
         */this.pickZNear=0.01;/**
         * Distance to the far clipping plane when rendering depth fragments for GPU-accelerated 3D picking.
         *
         * @property pickZFar
         * @type {Number|*}
         */this.pickZFar=5000;/**
         * Whether or not the renderer is currently picking invisible objects.
         *
         * @property pickInvisible
         * @type {Number}
         */this.pickInvisible=false;/**
         * Used to draw only requested elements / indices.
         *
         * @property pickElementsCount
         * @type {Number}
         */this.pickElementsCount=null;/**
         * Used to draw only requested elements / indices.
         *
         * @property pickElementsOffset
         * @type {Number}
         */this.pickElementsOffset=null;/** The current line width.
         *
         * @property lineWidth
         * @type Number
         */this.lineWidth=1;/**
         * Collects info from SceneModel.drawSnapInit and SceneModel.drawSnap,
         * which is then used in Renderer to determine snap-picking results.
         *
         * @type {{}}
         */this.snapPickLayerParams={};/**
         * Collects info from SceneModel.drawSnapInit and SceneModel.drawSnap,
         * which is then used in Renderer to determine snap-picking results.
         * @type {number}
         */this.snapPickLayerNumber=0;/**
         * Collects info from SceneModel.drawSnapInit and SceneModel.drawSnap,
         * which is then used in Renderer to determine snap-picking results.
         * @type {Number[]}
         */this.snapPickCoordinateScale=math.vec3();/**
         * Collects info from SceneModel.drawSnapInit and SceneModel.drawSnap,
         * which is then used in Renderer to determine snap-picking results.
         * @type {Number[]}
         */this.snapPickOrigin=math.vec3();}/**
     * Get View matrix for the given RTC center.
     */},{key:"getRTCViewMatrix",value:function getRTCViewMatrix(originHash,origin){var rtcViewMat=this._rtcViewMats[originHash];if(!rtcViewMat){rtcViewMat=this._getNewMat();createRTCViewMat(this._scene.camera.viewMatrix,origin,rtcViewMat);this._rtcViewMats[originHash]=rtcViewMat;}return rtcViewMat;}/**
     * Get picking View RTC matrix for the given RTC center.
     */},{key:"getRTCPickViewMatrix",value:function getRTCPickViewMatrix(originHash,origin){var rtcPickViewMat=this._rtcPickViewMats[originHash];if(!rtcPickViewMat){rtcPickViewMat=this._getNewMat();var pickViewMat=this.pickViewMatrix||this._scene.camera.viewMatrix;createRTCViewMat(pickViewMat,origin,rtcPickViewMat);this._rtcPickViewMats[originHash]=rtcPickViewMat;}return rtcPickViewMat;}},{key:"_getNewMat",value:function _getNewMat(){var mat=this._matPool[this._matPoolNextFreeIndex];if(!mat){mat=math.mat4();this._matPool[this._matPoolNextFreeIndex]=mat;}this._matPoolNextFreeIndex++;return mat;}}]);return FrameContext;}();/**
 * @private
 * @type {{WEBGL: boolean, SUPPORTED_EXTENSIONS: {}}}
 */var WEBGL_INFO={WEBGL:false,SUPPORTED_EXTENSIONS:{}};var canvas=document.createElement("canvas");if(canvas){var gl=canvas.getContext("webgl",{antialias:true})||canvas.getContext("experimental-webgl",{antialias:true});WEBGL_INFO.WEBGL=!!gl;if(WEBGL_INFO.WEBGL){WEBGL_INFO.ANTIALIAS=gl.getContextAttributes().antialias;if(gl.getShaderPrecisionFormat){if(gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){WEBGL_INFO.FS_MAX_FLOAT_PRECISION="highp";}else if(gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){WEBGL_INFO.FS_MAX_FLOAT_PRECISION="mediump";}else{WEBGL_INFO.FS_MAX_FLOAT_PRECISION="lowp";}}else{WEBGL_INFO.FS_MAX_FLOAT_PRECISION="mediump";}WEBGL_INFO.DEPTH_BUFFER_BITS=gl.getParameter(gl.DEPTH_BITS);WEBGL_INFO.MAX_TEXTURE_SIZE=gl.getParameter(gl.MAX_TEXTURE_SIZE);WEBGL_INFO.MAX_CUBE_MAP_SIZE=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);WEBGL_INFO.MAX_RENDERBUFFER_SIZE=gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);WEBGL_INFO.MAX_TEXTURE_UNITS=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);WEBGL_INFO.MAX_VERTEX_ATTRIBS=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);WEBGL_INFO.MAX_VERTEX_UNIFORM_VECTORS=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);WEBGL_INFO.MAX_FRAGMENT_UNIFORM_VECTORS=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);WEBGL_INFO.MAX_VARYING_VECTORS=gl.getParameter(gl.MAX_VARYING_VECTORS);gl.getSupportedExtensions().forEach(function(ext){WEBGL_INFO.SUPPORTED_EXTENSIONS[ext]=true;});}}/**
 * @desc Pick result returned by {@link Scene#pick}.
 *
 */var PickResult=/*#__PURE__*/function(){/**
     * @private
     */function PickResult(){_classCallCheck(this,PickResult);/**
         * Picked entity.
         * Null when no entity was picked.
         * @property entity
         * @type {Entity|*}
         */this.entity=null;/**
         * Type of primitive that was picked - usually "triangle".
         * Null when no primitive was picked.
         * @property primitive
         * @type {String}
         */this.primitive=null;/**
         * Index of primitive that was picked.
         * -1 when no entity was picked.
         * @property primIndex
         * @type {number}
         */this.primIndex=-1;/**
         * True when the picked surface position is full precision.
         * When false, the picked surface position should be regarded as approximate.
         * Full-precision surface picking is performed with the {@link Scene#pick} method's ````pickSurfacePrecision```` option.
         * @property pickSurfacePrecision
         * @type {Boolean}
         */this.pickSurfacePrecision=false;/**
         * True when picked from touch input, else false when from mouse input.
         * @type {boolean}
         */this.touchInput=false;/**
         * True when snapped to nearest edge.
         * @type {boolean}
         */this.snappedToEdge=false;/**
         * True when snapped to nearest vertex.
         * @type {boolean}
         */this.snappedToVertex=false;this._origin=new Float64Array([0,0,0]);this._direction=new Float64Array([0,0,0]);this._indices=new Int32Array(3);this._localPos=new Float64Array([0,0,0]);this._worldPos=new Float64Array([0,0,0]);this._viewPos=new Float64Array([0,0,0]);this._canvasPos=new Int16Array([0,0]);this._snappedCanvasPos=new Int16Array([0,0]);this._bary=new Float64Array([0,0,0]);this._worldNormal=new Float64Array([0,0,0]);this._uv=new Float64Array([0,0]);this.reset();}/**
     * Canvas pick coordinates.
     * @property canvasPos
     * @type {Number[]}
     */_createClass(PickResult,[{key:"canvasPos",get:function get(){return this._gotCanvasPos?this._canvasPos:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._canvasPos[0]=value[0];this._canvasPos[1]=value[1];this._gotCanvasPos=true;}else{this._gotCanvasPos=false;}}/**
     * World-space 3D ray origin when raypicked.
     * @property origin
     * @type {Number[]}
     */},{key:"origin",get:function get(){return this._gotOrigin?this._origin:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._origin[0]=value[0];this._origin[1]=value[1];this._origin[2]=value[2];this._gotOrigin=true;}else{this._gotOrigin=false;}}/**
     * World-space 3D ray direction when raypicked.
     * @property direction
     * @type {Number[]}
     */},{key:"direction",get:function get(){return this._gotDirection?this._direction:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._direction[0]=value[0];this._direction[1]=value[1];this._direction[2]=value[2];this._gotDirection=true;}else{this._gotDirection=false;}}/**
     * Picked triangle's vertex indices.
     * @property indices
     * @type {Int32Array}
     */},{key:"indices",get:function get(){return this.entity&&this._gotIndices?this._indices:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._indices[0]=value[0];this._indices[1]=value[1];this._indices[2]=value[2];this._gotIndices=true;}else{this._gotIndices=false;}}/**
     * Picked Local-space point.
     * @property localPos
     * @type {Number[]}
     */},{key:"localPos",get:function get(){return this.entity&&this._gotLocalPos?this._localPos:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._localPos[0]=value[0];this._localPos[1]=value[1];this._localPos[2]=value[2];this._gotLocalPos=true;}else{this._gotLocalPos=false;}}/**
     * Canvas cursor coordinates, snapped when snap picking, otherwise same as {@link PickResult#pointerPos}.
     * @property snappedCanvasPos
     * @type {Number[]}
     */},{key:"snappedCanvasPos",get:function get(){return this._gotSnappedCanvasPos?this._snappedCanvasPos:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._snappedCanvasPos[0]=value[0];this._snappedCanvasPos[1]=value[1];this._gotSnappedCanvasPos=true;}else{this._gotSnappedCanvasPos=false;}}/**
     * Picked World-space point.
     * @property worldPos
     * @type {Number[]}
     */},{key:"worldPos",get:function get(){return this._gotWorldPos?this._worldPos:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._worldPos[0]=value[0];this._worldPos[1]=value[1];this._worldPos[2]=value[2];this._gotWorldPos=true;}else{this._gotWorldPos=false;}}/**
     * Picked View-space point.
     * @property viewPos
     * @type {Number[]}
     */},{key:"viewPos",get:function get(){return this.entity&&this._gotViewPos?this._viewPos:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._viewPos[0]=value[0];this._viewPos[1]=value[1];this._viewPos[2]=value[2];this._gotViewPos=true;}else{this._gotViewPos=false;}}/**
     * Barycentric coordinate within picked triangle.
     * @property bary
     * @type {Number[]}
     */},{key:"bary",get:function get(){return this.entity&&this._gotBary?this._bary:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._bary[0]=value[0];this._bary[1]=value[1];this._bary[2]=value[2];this._gotBary=true;}else{this._gotBary=false;}}/**
     * Normal vector at picked position on surface.
     * @property worldNormal
     * @type {Number[]}
     */},{key:"worldNormal",get:function get(){return this.entity&&this._gotWorldNormal?this._worldNormal:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._worldNormal[0]=value[0];this._worldNormal[1]=value[1];this._worldNormal[2]=value[2];this._gotWorldNormal=true;}else{this._gotWorldNormal=false;}}/**
     * UV coordinates at picked position on surface.
     * @property uv
     * @type {Number[]}
     */},{key:"uv",get:function get(){return this.entity&&this._gotUV?this._uv:null;}/**
     * @private
     * @param value
     */,set:function set(value){if(value){this._uv[0]=value[0];this._uv[1]=value[1];this._gotUV=true;}else{this._gotUV=false;}}/**
     * @private
     */},{key:"reset",value:function reset(){this.entity=null;this.primIndex=-1;this.primitive=null;this.pickSurfacePrecision=false;this._gotCanvasPos=false;this._gotSnappedCanvasPos=false;this._gotOrigin=false;this._gotDirection=false;this._gotIndices=false;this._gotLocalPos=false;this._gotWorldPos=false;this._gotViewPos=false;this._gotBary=false;this._gotWorldNormal=false;this._gotUV=false;this.touchInput=false;this.snappedToEdge=false;this.snappedToVertex=false;}}]);return PickResult;}();/**
 * @desc Represents a vertex or fragment stage within a {@link Program}.
 * @private
 */var Shader=/*#__PURE__*/function(){function Shader(gl,type,source){_classCallCheck(this,Shader);this.allocated=false;this.compiled=false;this.handle=gl.createShader(type);if(!this.handle){this.errors=["Failed to allocate"];return;}this.allocated=true;gl.shaderSource(this.handle,source);gl.compileShader(this.handle);this.compiled=gl.getShaderParameter(this.handle,gl.COMPILE_STATUS);if(!this.compiled){if(!gl.isContextLost()){// Handled explicitly elsewhere, so won't re-handle here
var lines=source.split("\n");var numberedLines=[];for(var _i47=0;_i47<lines.length;_i47++){numberedLines.push(_i47+1+": "+lines[_i47]+"\n");}this.errors=[];this.errors.push("");this.errors.push(gl.getShaderInfoLog(this.handle));this.errors=this.errors.concat(numberedLines.join(""));}}}_createClass(Shader,[{key:"destroy",value:function destroy(){}}]);return Shader;}();/**
 * @desc A low-level component that represents a WebGL Sampler.
 * @private
 */var Sampler=/*#__PURE__*/_createClass(function Sampler(gl,location){_classCallCheck(this,Sampler);this.bindTexture=function(texture,unit){if(texture.bind(unit)){gl.uniform1i(location,unit);return true;}return false;};});/**
 * @desc Represents a WebGL vertex attribute buffer (VBO).
 * @private
 * @param gl {WebGLRenderingContext} The WebGL rendering context.
 */var Attribute=/*#__PURE__*/function(){function Attribute(gl,location){_classCallCheck(this,Attribute);this._gl=gl;this.location=location;}_createClass(Attribute,[{key:"bindArrayBuffer",value:function bindArrayBuffer(arrayBuf){if(!arrayBuf){return;}arrayBuf.bind();this._gl.enableVertexAttribArray(this.location);this._gl.vertexAttribPointer(this.location,arrayBuf.itemSize,arrayBuf.itemType,arrayBuf.normalized,arrayBuf.stride,arrayBuf.offset);}}]);return Attribute;}();var ids$4=new Map$1({});function joinSansComments(srcLines){var src=[];var line;var n;for(var _i48=0,len=srcLines.length;_i48<len;_i48++){line=srcLines[_i48];n=line.indexOf("/");if(n>0){if(line.charAt(n+1)==="/"){line=line.substring(0,n);}}src.push(line);}return src.join("\n");}function logErrors(errors){console.error(errors.join("\n"));}/**
 * @desc Represents a WebGL program.
 * @private
 */var Program=/*#__PURE__*/function(){function Program(gl,shaderSource){_classCallCheck(this,Program);this.id=ids$4.addItem({});this.source=shaderSource;this.init(gl);}_createClass(Program,[{key:"init",value:function init(gl){this.gl=gl;this.allocated=false;this.compiled=false;this.linked=false;this.validated=false;this.errors=null;this.uniforms={};this.samplers={};this.attributes={};this._vertexShader=new Shader(gl,gl.VERTEX_SHADER,joinSansComments(this.source.vertex));this._fragmentShader=new Shader(gl,gl.FRAGMENT_SHADER,joinSansComments(this.source.fragment));if(!this._vertexShader.allocated){this.errors=["Vertex shader failed to allocate"].concat(this._vertexShader.errors);logErrors(this.errors);return;}if(!this._fragmentShader.allocated){this.errors=["Fragment shader failed to allocate"].concat(this._fragmentShader.errors);logErrors(this.errors);return;}this.allocated=true;if(!this._vertexShader.compiled){this.errors=["Vertex shader failed to compile"].concat(this._vertexShader.errors);logErrors(this.errors);return;}if(!this._fragmentShader.compiled){this.errors=["Fragment shader failed to compile"].concat(this._fragmentShader.errors);logErrors(this.errors);return;}this.compiled=true;var a;var i;var u;var uName;var location;this.handle=gl.createProgram();if(!this.handle){this.errors=["Failed to allocate program"];return;}gl.attachShader(this.handle,this._vertexShader.handle);gl.attachShader(this.handle,this._fragmentShader.handle);gl.linkProgram(this.handle);this.linked=gl.getProgramParameter(this.handle,gl.LINK_STATUS);// HACK: Disable validation temporarily
// Perhaps we should defer validation until render-time, when the program has values set for all inputs?
this.validated=true;if(!this.linked||!this.validated){this.errors=[];this.errors.push("");this.errors.push(gl.getProgramInfoLog(this.handle));this.errors.push("\nVertex shader:\n");this.errors=this.errors.concat(this.source.vertex);this.errors.push("\nFragment shader:\n");this.errors=this.errors.concat(this.source.fragment);logErrors(this.errors);return;}var numUniforms=gl.getProgramParameter(this.handle,gl.ACTIVE_UNIFORMS);for(i=0;i<numUniforms;++i){u=gl.getActiveUniform(this.handle,i);if(u){uName=u.name;if(uName[uName.length-1]==="\0"){uName=uName.substr(0,uName.length-1);}location=gl.getUniformLocation(this.handle,uName);if(u.type===gl.SAMPLER_2D||u.type===gl.SAMPLER_CUBE||u.type===35682){this.samplers[uName]=new Sampler(gl,location);}else if(gl instanceof WebGL2RenderingContext&&(u.type===gl.UNSIGNED_INT_SAMPLER_2D||u.type===gl.INT_SAMPLER_2D)){this.samplers[uName]=new Sampler(gl,location);}else{this.uniforms[uName]=location;}}}var numAttribs=gl.getProgramParameter(this.handle,gl.ACTIVE_ATTRIBUTES);for(i=0;i<numAttribs;i++){a=gl.getActiveAttrib(this.handle,i);if(a){location=gl.getAttribLocation(this.handle,a.name);this.attributes[a.name]=new Attribute(gl,location);}}this.allocated=true;}},{key:"bind",value:function bind(){if(!this.allocated){return;}this.gl.useProgram(this.handle);}},{key:"getLocation",value:function getLocation(name){if(!this.allocated){return;}return this.uniforms[name];}},{key:"getAttribute",value:function getAttribute(name){if(!this.allocated){return;}return this.attributes[name];}},{key:"bindTexture",value:function bindTexture(name,texture,unit){if(!this.allocated){return false;}var sampler=this.samplers[name];if(sampler){return sampler.bindTexture(texture,unit);}else{return false;}}},{key:"destroy",value:function destroy(){if(!this.allocated){return;}ids$4.removeItem(this.id);this.gl.deleteProgram(this.handle);this.gl.deleteShader(this._vertexShader.handle);this.gl.deleteShader(this._fragmentShader.handle);this.handle=null;this.attributes=null;this.uniforms=null;this.samplers=null;this.allocated=false;}}]);return Program;}();/**
 * @desc Represents a WebGL ArrayBuffer.
 *
 * @private
 */var ArrayBuf=/*#__PURE__*/function(){function ArrayBuf(gl,type,data,numItems,itemSize,usage,normalized,stride,offset){_classCallCheck(this,ArrayBuf);this._gl=gl;this.type=type;this.allocated=false;switch(data.constructor){case Uint8Array:this.itemType=gl.UNSIGNED_BYTE;this.itemByteSize=1;break;case Int8Array:this.itemType=gl.BYTE;this.itemByteSize=1;break;case Uint16Array:this.itemType=gl.UNSIGNED_SHORT;this.itemByteSize=2;break;case Int16Array:this.itemType=gl.SHORT;this.itemByteSize=2;break;case Uint32Array:this.itemType=gl.UNSIGNED_INT;this.itemByteSize=4;break;case Int32Array:this.itemType=gl.INT;this.itemByteSize=4;break;default:this.itemType=gl.FLOAT;this.itemByteSize=4;}this.usage=usage;this.length=0;this.dataLength=numItems;this.numItems=0;this.itemSize=itemSize;this.normalized=!!normalized;this.stride=stride||0;this.offset=offset||0;this._allocate(data);}_createClass(ArrayBuf,[{key:"_allocate",value:function _allocate(data){this.allocated=false;this._handle=this._gl.createBuffer();if(!this._handle){throw"Failed to allocate WebGL ArrayBuffer";}if(this._handle){this._gl.bindBuffer(this.type,this._handle);this._gl.bufferData(this.type,data.length>this.dataLength?data.slice(0,this.dataLength):data,this.usage);this._gl.bindBuffer(this.type,null);this.length=data.length;this.numItems=this.length/this.itemSize;this.allocated=true;}}},{key:"setData",value:function setData(data,offset){if(!this.allocated){return;}if(data.length+(offset||0)>this.length){// Needs reallocation
this.destroy();this._allocate(data);}else{// No reallocation needed
this._gl.bindBuffer(this.type,this._handle);if(offset||offset===0){this._gl.bufferSubData(this.type,offset*this.itemByteSize,data);}else{this._gl.bufferData(this.type,data,this.usage);}this._gl.bindBuffer(this.type,null);}}},{key:"bind",value:function bind(){if(!this.allocated){return;}this._gl.bindBuffer(this.type,this._handle);}},{key:"unbind",value:function unbind(){if(!this.allocated){return;}this._gl.bindBuffer(this.type,null);}},{key:"destroy",value:function destroy(){if(!this.allocated){return;}this._gl.deleteBuffer(this._handle);this._handle=null;this.allocated=false;}}]);return ArrayBuf;}();var OcclusionLayer=/*#__PURE__*/function(){function OcclusionLayer(scene,origin){_classCallCheck(this,OcclusionLayer);this.scene=scene;this.aabb=math.AABB3();this.origin=math.vec3(origin);this.originHash=this.origin.join();this.numMarkers=0;this.markers={};this.markerList=[];// Ordered array of Markers
this.markerIndices={};// ID map of Marker indices in _markerList
this.positions=[];// Packed array of World-space marker positions
this.indices=[];// Indices corresponding to array above
this.positionsBuf=null;this.lenPositionsBuf=0;this.indicesBuf=null;this.sectionPlanesActive=[];this.culledBySectionPlanes=false;this.occlusionTestList=[];// List of
this.lenOcclusionTestList=0;this.pixels=[];this.aabbDirty=false;this.markerListDirty=false;this.positionsDirty=true;this.occlusionTestListDirty=false;}_createClass(OcclusionLayer,[{key:"addMarker",value:function addMarker(marker){this.markers[marker.id]=marker;this.markerListDirty=true;this.numMarkers++;}},{key:"markerWorldPosUpdated",value:function markerWorldPosUpdated(marker){if(!this.markers[marker.id]){// Not added
return;}var i=this.markerIndices[marker.id];this.positions[i*3+0]=marker.worldPos[0];this.positions[i*3+1]=marker.worldPos[1];this.positions[i*3+2]=marker.worldPos[2];this.positionsDirty=true;// TODO: avoid reallocating VBO each time
}},{key:"removeMarker",value:function removeMarker(marker){delete this.markers[marker.id];this.markerListDirty=true;this.numMarkers--;}},{key:"update",value:function update(){if(this.markerListDirty){this._buildMarkerList();this.markerListDirty=false;this.positionsDirty=true;this.occlusionTestListDirty=true;}if(this.positionsDirty){//////////////  TODO: Don't rebuild this when positions change, very wasteful
this._buildPositions();this.positionsDirty=false;this.aabbDirty=true;this.vbosDirty=true;}if(this.aabbDirty){this._buildAABB();this.aabbDirty=false;}if(this.vbosDirty){this._buildVBOs();this.vbosDirty=false;}if(this.occlusionTestListDirty){this._buildOcclusionTestList();}this._updateActiveSectionPlanes();}},{key:"_buildMarkerList",value:function _buildMarkerList(){this.numMarkers=0;for(var id in this.markers){if(this.markers.hasOwnProperty(id)){this.markerList[this.numMarkers]=this.markers[id];this.markerIndices[id]=this.numMarkers;this.numMarkers++;}}this.markerList.length=this.numMarkers;}},{key:"_buildPositions",value:function _buildPositions(){var j=0;for(var _i49=0;_i49<this.numMarkers;_i49++){if(this.markerList[_i49]){var marker=this.markerList[_i49];var worldPos=marker.worldPos;this.positions[j++]=worldPos[0];this.positions[j++]=worldPos[1];this.positions[j++]=worldPos[2];this.indices[_i49]=_i49;}}this.positions.length=this.numMarkers*3;this.indices.length=this.numMarkers;}},{key:"_buildAABB",value:function _buildAABB(){var aabb=this.aabb;math.collapseAABB3(aabb);math.expandAABB3Points3(aabb,this.positions);var origin=this.origin;aabb[0]+=origin[0];aabb[1]+=origin[1];aabb[2]+=origin[2];aabb[3]+=origin[0];aabb[4]+=origin[1];aabb[5]+=origin[2];}},{key:"_buildVBOs",value:function _buildVBOs(){if(this.positionsBuf){if(this.lenPositionsBuf===this.positions.length){// Just updating buffer elements, don't need to reallocate
this.positionsBuf.setData(this.positions);// Indices don't need updating
return;}this.positionsBuf.destroy();this.positionsBuf=null;this.indicesBuf.destroy();this.indicesBuf=null;}var gl=this.scene.canvas.gl;var lenPositions=this.numMarkers*3;var lenIndices=this.numMarkers;this.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this.positions),lenPositions,3,gl.STATIC_DRAW);this.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(this.indices),lenIndices,1,gl.STATIC_DRAW);this.lenPositionsBuf=this.positions.length;}},{key:"_buildOcclusionTestList",value:function _buildOcclusionTestList(){var canvas=this.scene.canvas;var near=this.scene.camera.perspective.near;// Assume near enough to ortho near
var boundary=canvas.boundary;var canvasWidth=boundary[2];var canvasHeight=boundary[3];var lenPixels=0;this.lenOcclusionTestList=0;for(var _i50=0;_i50<this.numMarkers;_i50++){var marker=this.markerList[_i50];var _viewPos=marker.viewPos;if(_viewPos[2]>-near){// Clipped by near plane
marker._setVisible(false);continue;}var _canvasPos=marker.canvasPos;var canvasX=_canvasPos[0];var canvasY=_canvasPos[1];if(canvasX+10<0||canvasY+10<0||canvasX-10>canvasWidth||canvasY-10>canvasHeight){marker._setVisible(false);continue;}if(marker.entity&&!marker.entity.visible){marker._setVisible(false);continue;}if(marker.occludable){this.occlusionTestList[this.lenOcclusionTestList++]=marker;this.pixels[lenPixels++]=canvasX;this.pixels[lenPixels++]=canvasY;continue;}marker._setVisible(true);}}},{key:"_updateActiveSectionPlanes",value:function _updateActiveSectionPlanes(){var sectionPlanes=this.scene._sectionPlanesState.sectionPlanes;var numSectionPlanes=sectionPlanes.length;if(numSectionPlanes>0){for(var _i51=0;_i51<numSectionPlanes;_i51++){var sectionPlane=sectionPlanes[_i51];if(!sectionPlane.active){this.sectionPlanesActive[_i51]=false;}else{var intersect=math.planeAABB3Intersect(sectionPlane.dir,sectionPlane.dist,this.aabb);var outside=intersect===-1;if(outside){this.culledBySectionPlanes=true;return;}var intersecting=intersect===0;this.sectionPlanesActive[_i51]=intersecting;}}}this.culledBySectionPlanes=false;}},{key:"destroy",value:function destroy(){this.markers={};this.markerList.length=0;if(this.positionsBuf){this.positionsBuf.destroy();}if(this.indicesBuf){this.indicesBuf.destroy();}}}]);return OcclusionLayer;}();var MARKER_COLOR=math.vec3([1.0,0.0,0.0]);var POINT_SIZE=20;var MARKER_SPRITE_CLIPZ_OFFSET=-0.001;// Amount that we offset sprite clip Z coords to raise them from surfaces
var tempVec3a$J=math.vec3();/**
 * Manages occlusion testing. Private member of a Renderer.
 */var OcclusionTester=/*#__PURE__*/function(){function OcclusionTester(scene,renderBufferManager){var _this28=this;_classCallCheck(this,OcclusionTester);this._scene=scene;this._renderBufferManager=renderBufferManager;this._occlusionLayers={};this._occlusionLayersList=[];this._occlusionLayersListDirty=false;this._shaderSource=null;this._program=null;this._shaderSourceHash=null;this._shaderSourceDirty=true;// Need to build shader source code ?
this._programDirty=false;// Need to build shader program ?
this._markersToOcclusionLayersMap={};this._onCameraViewMatrix=scene.camera.on("viewMatrix",function(){_this28._occlusionTestListDirty=true;});this._onCameraProjMatrix=scene.camera.on("projMatrix",function(){_this28._occlusionTestListDirty=true;});this._onCanvasBoundary=scene.canvas.on("boundary",function(){_this28._occlusionTestListDirty=true;});}/**
     * Adds a Marker for occlusion testing.
     * @param marker
     */_createClass(OcclusionTester,[{key:"addMarker",value:function addMarker(marker){var originHash=marker.origin.join();var occlusionLayer=this._occlusionLayers[originHash];if(!occlusionLayer){occlusionLayer=new OcclusionLayer(this._scene,marker.origin);this._occlusionLayers[occlusionLayer.originHash]=occlusionLayer;this._occlusionLayersListDirty=true;}occlusionLayer.addMarker(marker);this._markersToOcclusionLayersMap[marker.id]=occlusionLayer;this._occlusionTestListDirty=true;}/**
     * Notifies OcclusionTester that a Marker has updated its World-space position.
     * @param marker
     */},{key:"markerWorldPosUpdated",value:function markerWorldPosUpdated(marker){var occlusionLayer=this._markersToOcclusionLayersMap[marker.id];if(!occlusionLayer){marker.error("Marker has not been added to OcclusionTester");return;}var originHash=marker.origin.join();if(originHash!==occlusionLayer.originHash){if(occlusionLayer.numMarkers===1){occlusionLayer.destroy();delete this._occlusionLayers[occlusionLayer.originHash];this._occlusionLayersListDirty=true;}else{occlusionLayer.removeMarker(marker);}var newOcclusionLayer=this._occlusionLayers[originHash];if(!newOcclusionLayer){newOcclusionLayer=new OcclusionLayer(this._scene,marker.origin);this._occlusionLayers[originHash]=occlusionLayer;this._occlusionLayersListDirty=true;}newOcclusionLayer.addMarker(marker);this._markersToOcclusionLayersMap[marker.id]=newOcclusionLayer;}else{occlusionLayer.markerWorldPosUpdated(marker);}}/**
     * Removes a Marker from occlusion testing.
     * @param marker
     */},{key:"removeMarker",value:function removeMarker(marker){var originHash=marker.origin.join();var occlusionLayer=this._occlusionLayers[originHash];if(!occlusionLayer){return;}if(occlusionLayer.numMarkers===1){occlusionLayer.destroy();delete this._occlusionLayers[occlusionLayer.originHash];this._occlusionLayersListDirty=true;}else{occlusionLayer.removeMarker(marker);}delete this._markersToOcclusionLayersMap[marker.id];}/**
     * Returns true if an occlusion test is needed.
     *
     * @returns {Boolean}
     */},{key:"needOcclusionTest",get:function get(){return this._occlusionTestListDirty;}/**
     * Binds the render buffer. After calling this, the caller then renders object silhouettes to the render buffer,
     * then calls drawMarkers() and doOcclusionTest().
     */},{key:"bindRenderBuf",value:function bindRenderBuf(){var shaderSourceHash=[this._scene.canvas.canvas.id,this._scene._sectionPlanesState.getHash()].join(";");if(shaderSourceHash!==this._shaderSourceHash){this._shaderSourceHash=shaderSourceHash;this._shaderSourceDirty=true;}if(this._shaderSourceDirty){this._buildShaderSource();this._shaderSourceDirty=false;this._programDirty=true;}if(this._programDirty){this._buildProgram();this._programDirty=false;this._occlusionTestListDirty=true;}if(this._occlusionLayersListDirty){this._buildOcclusionLayersList();this._occlusionLayersListDirty=false;}if(this._occlusionTestListDirty){for(var _i52=0,len=this._occlusionLayersList.length;_i52<len;_i52++){var occlusionLayer=this._occlusionLayersList[_i52];occlusionLayer.occlusionTestListDirty=true;}this._occlusionTestListDirty=false;}{this._readPixelBuf=this._renderBufferManager.getRenderBuffer("occlusionReadPix");this._readPixelBuf.bind();this._readPixelBuf.clear();}}},{key:"_buildOcclusionLayersList",value:function _buildOcclusionLayersList(){var numOcclusionLayers=0;for(var originHash in this._occlusionLayers){if(this._occlusionLayers.hasOwnProperty(originHash)){this._occlusionLayersList[numOcclusionLayers++]=this._occlusionLayers[originHash];}}this._occlusionLayersList.length=numOcclusionLayers;}},{key:"_buildShaderSource",value:function _buildShaderSource(){this._shaderSource={vertex:this._buildVertexShaderSource(),fragment:this._buildFragmentShaderSource()};}},{key:"_buildVertexShaderSource",value:function _buildVertexShaderSource(){var scene=this._scene;var clipping=scene._sectionPlanesState.sectionPlanes.length>0;var src=[];src.push("#version 300 es");src.push("// OcclusionTester vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");}src.push("void main(void) {");src.push("vec4 worldPosition = vec4(position, 1.0); ");src.push("   vec4 viewPosition = viewMatrix * worldPosition;");if(clipping){src.push("   vWorldPosition = worldPosition;");}src.push("   vec4 clipPos = projMatrix * viewPosition;");src.push("   gl_PointSize = "+POINT_SIZE+".0;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}else{src.push("clipPos.z += "+MARKER_SPRITE_CLIPZ_OFFSET+";");}src.push("   gl_Position = clipPos;");src.push("}");return src;}},{key:"_buildFragmentShaderSource",value:function _buildFragmentShaderSource(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.sectionPlanes.length>0;var src=[];src.push("#version 300 es");src.push("// OcclusionTester fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");for(var _i53=0;_i53<sectionPlanesState.sectionPlanes.length;_i53++){src.push("uniform bool sectionPlaneActive"+_i53+";");src.push("uniform vec3 sectionPlanePos"+_i53+";");src.push("uniform vec3 sectionPlaneDir"+_i53+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.sectionPlanes.length;i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor = vec4(1.0, 0.0, 0.0, 1.0); ");src.push("}");return src;}},{key:"_buildProgram",value:function _buildProgram(){if(this._program){this._program.destroy();}var scene=this._scene;var gl=scene.canvas.gl;var sectionPlanesState=scene._sectionPlanesState;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];var sectionPlanes=sectionPlanesState.sectionPlanes;for(var _i54=0,len=sectionPlanes.length;_i54<len;_i54++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i54),pos:program.getLocation("sectionPlanePos"+_i54),dir:program.getLocation("sectionPlaneDir"+_i54)});}this._aPosition=program.getAttribute("position");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}}/**
     * Draws {@link Marker}s to the render buffer.
     */},{key:"drawMarkers",value:function drawMarkers(){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var sectionPlanesState=scene._sectionPlanesState;var camera=scene.camera;var project=scene.camera.project;program.bind();gl.uniformMatrix4fv(this._uProjMatrix,false,camera._project._state.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}for(var _i55=0,len=this._occlusionLayersList.length;_i55<len;_i55++){var occlusionLayer=this._occlusionLayersList[_i55];occlusionLayer.update();if(occlusionLayer.culledBySectionPlanes){continue;}var origin=occlusionLayer.origin;gl.uniformMatrix4fv(this._uViewMatrix,false,createRTCViewMat(camera.viewMatrix,origin));var numSectionPlanes=sectionPlanesState.sectionPlanes.length;if(numSectionPlanes>0){var sectionPlanes=sectionPlanesState.sectionPlanes;for(var sectionPlaneIndex=0;sectionPlaneIndex<numSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){var active=occlusionLayer.sectionPlanesActive[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];gl.uniform3fv(sectionPlaneUniforms.pos,getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$J));gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}}}this._aPosition.bindArrayBuffer(occlusionLayer.positionsBuf);var indicesBuf=occlusionLayer.indicesBuf;indicesBuf.bind();gl.drawElements(gl.POINTS,indicesBuf.numItems,indicesBuf.itemType,0);}}/**
     * Sets visibilities of {@link Marker}s according to whether or not they are obscured by anything in the render buffer.
     */},{key:"doOcclusionTest",value:function doOcclusionTest(){{var resolutionScale=this._scene.canvas.resolutionScale;var markerR=MARKER_COLOR[0]*255;var markerG=MARKER_COLOR[1]*255;var markerB=MARKER_COLOR[2]*255;for(var _i56=0,len=this._occlusionLayersList.length;_i56<len;_i56++){var occlusionLayer=this._occlusionLayersList[_i56];for(var _i57=0;_i57<occlusionLayer.lenOcclusionTestList;_i57++){var marker=occlusionLayer.occlusionTestList[_i57];var j=_i57*2;var _color=this._readPixelBuf.read(Math.round(occlusionLayer.pixels[j]*resolutionScale),Math.round(occlusionLayer.pixels[j+1]*resolutionScale));var visible=_color[0]===markerR&&_color[1]===markerG&&_color[2]===markerB;marker._setVisible(visible);}}}}/**
     * Unbinds render buffer.
     */},{key:"unbindRenderBuf",value:function unbindRenderBuf(){{this._readPixelBuf.unbind();}}/**
     * Destroys this OcclusionTester.
     */},{key:"destroy",value:function destroy(){if(this.destroyed){return;}for(var _i58=0,len=this._occlusionLayersList.length;_i58<len;_i58++){var occlusionLayer=this._occlusionLayersList[_i58];occlusionLayer.destroy();}if(this._program){this._program.destroy();}this._scene.camera.off(this._onCameraViewMatrix);this._scene.camera.off(this._onCameraProjMatrix);this._scene.canvas.off(this._onCanvasBoundary);this.destroyed=true;}}]);return OcclusionTester;}();var tempVec2=math.vec2();/**
 * SAO implementation inspired from previous SAO work in THREE.js by ludobaka / ludobaka.github.io and bhouston
 * @private
 */var SAOOcclusionRenderer=/*#__PURE__*/function(){function SAOOcclusionRenderer(scene){_classCallCheck(this,SAOOcclusionRenderer);this._scene=scene;this._numSamples=null;// The program
this._program=null;this._programError=false;// Variable locations
this._aPosition=null;this._aUV=null;this._uDepthTexture="uDepthTexture";this._uCameraNear=null;this._uCameraFar=null;this._uCameraProjectionMatrix=null;this._uCameraInverseProjectionMatrix=null;this._uScale=null;this._uIntensity=null;this._uBias=null;this._uKernelRadius=null;this._uMinResolution=null;this._uRandomSeed=null;// VBOs
this._uvBuf=null;this._positionsBuf=null;this._indicesBuf=null;}_createClass(SAOOcclusionRenderer,[{key:"render",value:function render(depthRenderBuffer){var _this29=this;this._build();if(this._programError){return;}if(!this._getInverseProjectMat){// HACK: scene.camera not defined until render time
this._getInverseProjectMat=function(){var projMatDirty=true;_this29._scene.camera.on("projMatrix",function(){projMatDirty=true;});var inverseProjectMat=math.mat4();return function(){if(projMatDirty){math.inverseMat4(scene.camera.projMatrix,inverseProjectMat);}return inverseProjectMat;};}();}var gl=this._scene.canvas.gl;var program=this._program;var scene=this._scene;var sao=scene.sao;var viewportWidth=gl.drawingBufferWidth;var viewportHeight=gl.drawingBufferHeight;var projectState=scene.camera.project._state;var near=projectState.near;var far=projectState.far;var projectionMatrix=projectState.matrix;var inverseProjectionMatrix=this._getInverseProjectMat();var randomSeed=Math.random();var perspective=scene.camera.projection==="perspective";tempVec2[0]=viewportWidth;tempVec2[1]=viewportHeight;gl.viewport(0,0,viewportWidth,viewportHeight);gl.clearColor(0,0,0,1);gl.disable(gl.DEPTH_TEST);gl.disable(gl.BLEND);gl.frontFace(gl.CCW);gl.clear(gl.COLOR_BUFFER_BIT);program.bind();gl.uniform1f(this._uCameraNear,near);gl.uniform1f(this._uCameraFar,far);gl.uniformMatrix4fv(this._uCameraProjectionMatrix,false,projectionMatrix);gl.uniformMatrix4fv(this._uCameraInverseProjectionMatrix,false,inverseProjectionMatrix);gl.uniform1i(this._uPerspective,perspective);gl.uniform1f(this._uScale,sao.scale*(far/5));gl.uniform1f(this._uIntensity,sao.intensity);gl.uniform1f(this._uBias,sao.bias);gl.uniform1f(this._uKernelRadius,sao.kernelRadius);gl.uniform1f(this._uMinResolution,sao.minResolution);gl.uniform2fv(this._uViewport,tempVec2);gl.uniform1f(this._uRandomSeed,randomSeed);var depthTexture=depthRenderBuffer.getDepthTexture();program.bindTexture(this._uDepthTexture,depthTexture,0);this._aUV.bindArrayBuffer(this._uvBuf);this._aPosition.bindArrayBuffer(this._positionsBuf);this._indicesBuf.bind();gl.drawElements(gl.TRIANGLES,this._indicesBuf.numItems,this._indicesBuf.itemType,0);}},{key:"_build",value:function _build(){var dirty=false;var sao=this._scene.sao;if(sao.numSamples!==this._numSamples){this._numSamples=Math.floor(sao.numSamples);dirty=true;}if(!dirty){return;}var gl=this._scene.canvas.gl;if(this._program){this._program.destroy();this._program=null;}this._program=new Program(gl,{vertex:["#version 300 es\n                    precision highp float;\n                    precision highp int;\n                    \n                    in vec3 aPosition;\n                    in vec2 aUV;            \n                    \n                    out vec2 vUV;\n                    \n                    void main () {\n                        gl_Position = vec4(aPosition, 1.0);\n                        vUV = aUV;\n                    }"],fragment:["#version 300 es      \n                precision highp float;\n                precision highp int;           \n                \n                #define NORMAL_TEXTURE 0\n                #define PI 3.14159265359\n                #define PI2 6.28318530718\n                #define EPSILON 1e-6\n                #define NUM_SAMPLES ".concat(this._numSamples,"\n                #define NUM_RINGS 4              \n            \n                in vec2        vUV;\n            \n                uniform sampler2D   uDepthTexture;\n               \n                uniform float       uCameraNear;\n                uniform float       uCameraFar;\n                uniform mat4        uProjectMatrix;\n                uniform mat4        uInverseProjectMatrix;\n                \n                uniform bool        uPerspective;\n\n                uniform float       uScale;\n                uniform float       uIntensity;\n                uniform float       uBias;\n                uniform float       uKernelRadius;\n                uniform float       uMinResolution;\n                uniform vec2        uViewport;\n                uniform float       uRandomSeed;\n\n                float pow2( const in float x ) { return x*x; }\n                \n                highp float rand( const in vec2 uv ) {\n                    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n                    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n                    return fract(sin(sn) * c);\n                }\n\n                vec3 packNormalToRGB( const in vec3 normal ) {\n                    return normalize( normal ) * 0.5 + 0.5;\n                }\n\n                vec3 unpackRGBToNormal( const in vec3 rgb ) {\n                    return 2.0 * rgb.xyz - 1.0;\n                }\n\n                const float packUpscale = 256. / 255.;\n                const float unpackDownScale = 255. / 256.; \n\n                const vec3 packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n                const vec4 unPackFactors = unpackDownScale / vec4( packFactors, 1. );   \n\n                const float shiftRights = 1. / 256.;\n\n                vec4 packFloatToRGBA( const in float v ) {\n                    vec4 r = vec4( fract( v * packFactors ), v );\n                    r.yzw -= r.xyz * shiftRights; \n                    return r * packUpscale;\n                }\n\n                float unpackRGBAToFloat( const in vec4 v ) {                   \n                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unPackFactors );\n                }\n                \n                float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n                    return ( near * far ) / ( ( far - near ) * invClipZ - far );\n                }\n\n                float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n                    return linearClipZ * ( near - far ) - near;\n                }\n                \n                float getDepth( const in vec2 screenPosition ) {\n                    return vec4(texture(uDepthTexture, screenPosition)).r;\n                }\n\n                float getViewZ( const in float depth ) {\n                     if (uPerspective) {\n                         return perspectiveDepthToViewZ( depth, uCameraNear, uCameraFar );\n                     } else {\n                        return orthographicDepthToViewZ( depth, uCameraNear, uCameraFar );\n                     }\n                }\n\n                vec3 getViewPos( const in vec2 screenPos, const in float depth, const in float viewZ ) {\n                \tfloat clipW = uProjectMatrix[2][3] * viewZ + uProjectMatrix[3][3];\n                \tvec4 clipPosition = vec4( ( vec3( screenPos, depth ) - 0.5 ) * 2.0, 1.0 );\n                \tclipPosition *= clipW; \n                \treturn ( uInverseProjectMatrix * clipPosition ).xyz;\n                }\n\n                vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPos ) {               \n                    return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n                }\n\n                float scaleDividedByCameraFar;\n                float minResolutionMultipliedByCameraFar;\n\n                float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n                \tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n                \tfloat viewDistance = length( viewDelta );\n                \tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n                \treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - uBias) / (1.0 + pow2( scaledScreenDistance ) );\n                }\n\n                const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n                const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n                float getAmbientOcclusion( const in vec3 centerViewPosition ) {\n            \n                \tscaleDividedByCameraFar = uScale / uCameraFar;\n                \tminResolutionMultipliedByCameraFar = uMinResolution * uCameraFar;\n                \tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUV );\n\n                \tfloat angle = rand( vUV + uRandomSeed ) * PI2;\n                \tvec2 radius = vec2( uKernelRadius * INV_NUM_SAMPLES ) / uViewport;\n                \tvec2 radiusStep = radius;\n\n                \tfloat occlusionSum = 0.0;\n                \tfloat weightSum = 0.0;\n\n                \tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n                \t\tvec2 sampleUv = vUV + vec2( cos( angle ), sin( angle ) ) * radius;\n                \t\tradius += radiusStep;\n                \t\tangle += ANGLE_STEP;\n\n                \t\tfloat sampleDepth = getDepth( sampleUv );\n                \t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n                \t\t\tcontinue;\n                \t\t}\n\n                \t\tfloat sampleViewZ = getViewZ( sampleDepth );\n                \t\tvec3 sampleViewPosition = getViewPos( sampleUv, sampleDepth, sampleViewZ );\n                \t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n                \t\tweightSum += 1.0;\n                \t}\n\n                \tif( weightSum == 0.0 ) discard;\n\n                \treturn occlusionSum * ( uIntensity / weightSum );\n                }\n\n                out vec4 outColor;\n   \n                void main() {\n                \n                \tfloat centerDepth = getDepth( vUV );\n                \t\n                \tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n                \t\tdiscard;\n                \t}\n\n                \tfloat centerViewZ = getViewZ( centerDepth );\n                \tvec3 viewPosition = getViewPos( vUV, centerDepth, centerViewZ );\n\n                \tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n                \n                \toutColor = packFloatToRGBA(  1.0- ambientOcclusion );\n                }")]});if(this._program.errors){console.error(this._program.errors.join("\n"));this._programError=true;return;}var uv=new Float32Array([1,1,0,1,0,0,1,0]);var positions=new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]);// Mitigation: if Uint8Array is used, the geometry is corrupted on OSX when using Chrome with data-textures
var indices=new Uint32Array([0,1,2,0,2,3]);this._positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,positions,positions.length,3,gl.STATIC_DRAW);this._uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,uv,uv.length,2,gl.STATIC_DRAW);this._indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,indices,indices.length,1,gl.STATIC_DRAW);this._program.bind();this._uCameraNear=this._program.getLocation("uCameraNear");this._uCameraFar=this._program.getLocation("uCameraFar");this._uCameraProjectionMatrix=this._program.getLocation("uProjectMatrix");this._uCameraInverseProjectionMatrix=this._program.getLocation("uInverseProjectMatrix");this._uPerspective=this._program.getLocation("uPerspective");this._uScale=this._program.getLocation("uScale");this._uIntensity=this._program.getLocation("uIntensity");this._uBias=this._program.getLocation("uBias");this._uKernelRadius=this._program.getLocation("uKernelRadius");this._uMinResolution=this._program.getLocation("uMinResolution");this._uViewport=this._program.getLocation("uViewport");this._uRandomSeed=this._program.getLocation("uRandomSeed");this._aPosition=this._program.getAttribute("aPosition");this._aUV=this._program.getAttribute("aUV");this._dirty=false;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();this._program=null;}}}]);return SAOOcclusionRenderer;}();var blurStdDev=4;var blurDepthCutoff=0.01;var KERNEL_RADIUS=16;var sampleOffsetsVert=new Float32Array(createSampleOffsets(KERNEL_RADIUS+1,[0,1]));var sampleOffsetsHor=new Float32Array(createSampleOffsets(KERNEL_RADIUS+1,[1,0]));var sampleWeights=new Float32Array(createSampleWeights(KERNEL_RADIUS+1,blurStdDev));var tempVec2a$1=new Float32Array(2);/**
 * SAO implementation inspired from previous SAO work in THREE.js by ludobaka / ludobaka.github.io and bhouston
 * @private
 */var SAODepthLimitedBlurRenderer=/*#__PURE__*/function(){function SAODepthLimitedBlurRenderer(scene){_classCallCheck(this,SAODepthLimitedBlurRenderer);this._scene=scene;// The program
this._program=null;this._programError=false;// Variable locations
this._aPosition=null;this._aUV=null;this._uDepthTexture="uDepthTexture";this._uOcclusionTexture="uOcclusionTexture";this._uViewport=null;this._uCameraNear=null;this._uCameraFar=null;this._uCameraProjectionMatrix=null;this._uCameraInverseProjectionMatrix=null;// VBOs
this._uvBuf=null;this._positionsBuf=null;this._indicesBuf=null;this.init();}_createClass(SAODepthLimitedBlurRenderer,[{key:"init",value:function init(){// Create program & VBOs, locate attributes and uniforms
var gl=this._scene.canvas.gl;this._program=new Program(gl,{vertex:["#version 300 es\n                precision highp float;\n                precision highp int;\n                    \n                in vec3 aPosition;\n                in vec2 aUV;\n                uniform vec2 uViewport;\n                out vec2 vUV;\n                out vec2 vInvSize;\n                void main () {\n                    vUV = aUV;\n                    vInvSize = 1.0 / uViewport;\n                    gl_Position = vec4(aPosition, 1.0);\n                }"],fragment:["#version 300 es\n                precision highp float;\n                precision highp int;\n                    \n                #define PI 3.14159265359\n                #define PI2 6.28318530718\n                #define EPSILON 1e-6\n\n                #define KERNEL_RADIUS ".concat(KERNEL_RADIUS,"\n\n                in vec2        vUV;\n                in vec2        vInvSize;\n            \n                uniform sampler2D   uDepthTexture;\n                uniform sampler2D   uOcclusionTexture;              \n               \n                uniform float       uCameraNear;\n                uniform float       uCameraFar;               \n                uniform float       uDepthCutoff;\n\n                uniform vec2        uSampleOffsets[ KERNEL_RADIUS + 1 ];\n                uniform float       uSampleWeights[ KERNEL_RADIUS + 1 ];\n\n                const float         unpackDownscale = 255. / 256.; \n\n                const vec3          packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n                const vec4          unpackFactors = unpackDownscale / vec4( packFactors, 1. );   \n\n                const float packUpscale = 256. / 255.;\n       \n                const float shiftRights = 1. / 256.;\n                \n                float unpackRGBAToFloat( const in vec4 v ) {\n                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unpackFactors );\n                }               \n\n                vec4 packFloatToRGBA( const in float v ) {\n                    vec4 r = vec4( fract( v * packFactors ), v );\n                    r.yzw -= r.xyz * shiftRights; \n                    return r * packUpscale;\n                }\n\n                float viewZToOrthographicDepth( const in float viewZ) {\n                    return ( viewZ + uCameraNear ) / ( uCameraNear - uCameraFar );\n                }\n              \n                float orthographicDepthToViewZ( const in float linearClipZ) {\n                    return linearClipZ * ( uCameraNear - uCameraFar ) - uCameraNear;\n                }\n\n                float viewZToPerspectiveDepth( const in float viewZ) {\n                    return (( uCameraNear + viewZ ) * uCameraFar ) / (( uCameraFar - uCameraNear ) * viewZ );\n                }\n                \n                float perspectiveDepthToViewZ( const in float invClipZ) {\n                    return ( uCameraNear * uCameraFar ) / ( ( uCameraFar - uCameraNear ) * invClipZ - uCameraFar );\n                }\n\n                float getDepth( const in vec2 screenPosition ) {\n                    return vec4(texture(uDepthTexture, screenPosition)).r;\n                }\n\n                float getViewZ( const in float depth ) {\n                     return perspectiveDepthToViewZ( depth );\n                }\n\n                out vec4 outColor;\n        \n                void main() {\n                \n                    float depth = getDepth( vUV );\n                    if( depth >= ( 1.0 - EPSILON ) ) {\n                        discard;\n                    }\n\n                    float centerViewZ = -getViewZ( depth );\n                    bool rBreak = false;\n                    bool lBreak = false;\n\n                    float weightSum = uSampleWeights[0];\n                    float occlusionSum = unpackRGBAToFloat(texture( uOcclusionTexture, vUV )) * weightSum;\n\n                    for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n                        float sampleWeight = uSampleWeights[i];\n                        vec2 sampleUVOffset = uSampleOffsets[i] * vInvSize;\n\n                        vec2 sampleUV = vUV + sampleUVOffset;\n                        float viewZ = -getViewZ( getDepth( sampleUV ) );\n\n                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {\n                            rBreak = true;\n                        }\n\n                        if( ! rBreak ) {\n                            occlusionSum += unpackRGBAToFloat(texture( uOcclusionTexture, sampleUV )) * sampleWeight;\n                            weightSum += sampleWeight;\n                        }\n\n                        sampleUV = vUV - sampleUVOffset;\n                        viewZ = -getViewZ( getDepth( sampleUV ) );\n\n                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {\n                            lBreak = true;\n                        }\n\n                        if( ! lBreak ) {\n                            occlusionSum += unpackRGBAToFloat(texture( uOcclusionTexture, sampleUV )) * sampleWeight;\n                            weightSum += sampleWeight;\n                        }\n                    }\n\n                    outColor = packFloatToRGBA(occlusionSum / weightSum);\n                }")]});if(this._program.errors){console.error(this._program.errors.join("\n"));this._programError=true;return;}var uv=new Float32Array([1,1,0,1,0,0,1,0]);var positions=new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]);// Mitigation: if Uint8Array is used, the geometry is corrupted on OSX when using Chrome with data-textures
var indices=new Uint32Array([0,1,2,0,2,3]);this._positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,positions,positions.length,3,gl.STATIC_DRAW);this._uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,uv,uv.length,2,gl.STATIC_DRAW);this._indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,indices,indices.length,1,gl.STATIC_DRAW);this._program.bind();this._uViewport=this._program.getLocation("uViewport");this._uCameraNear=this._program.getLocation("uCameraNear");this._uCameraFar=this._program.getLocation("uCameraFar");this._uDepthCutoff=this._program.getLocation("uDepthCutoff");this._uSampleOffsets=gl.getUniformLocation(this._program.handle,"uSampleOffsets");this._uSampleWeights=gl.getUniformLocation(this._program.handle,"uSampleWeights");this._aPosition=this._program.getAttribute("aPosition");this._aUV=this._program.getAttribute("aUV");}},{key:"render",value:function render(depthRenderBuffer,occlusionRenderBuffer,direction){var _this30=this;if(this._programError){return;}if(!this._getInverseProjectMat){// HACK: scene.camera not defined until render time
this._getInverseProjectMat=function(){var projMatDirty=true;_this30._scene.camera.on("projMatrix",function(){projMatDirty=true;});var inverseProjectMat=math.mat4();return function(){if(projMatDirty){math.inverseMat4(scene.camera.projMatrix,inverseProjectMat);}return inverseProjectMat;};}();}var gl=this._scene.canvas.gl;var program=this._program;var scene=this._scene;var viewportWidth=gl.drawingBufferWidth;var viewportHeight=gl.drawingBufferHeight;var projectState=scene.camera.project._state;var near=projectState.near;var far=projectState.far;gl.viewport(0,0,viewportWidth,viewportHeight);gl.clearColor(0,0,0,1);gl.enable(gl.DEPTH_TEST);gl.disable(gl.BLEND);gl.frontFace(gl.CCW);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);program.bind();tempVec2a$1[0]=viewportWidth;tempVec2a$1[1]=viewportHeight;gl.uniform2fv(this._uViewport,tempVec2a$1);gl.uniform1f(this._uCameraNear,near);gl.uniform1f(this._uCameraFar,far);gl.uniform1f(this._uDepthCutoff,blurDepthCutoff);if(direction===0){// Horizontal
gl.uniform2fv(this._uSampleOffsets,sampleOffsetsHor);}else{// Vertical
gl.uniform2fv(this._uSampleOffsets,sampleOffsetsVert);}gl.uniform1fv(this._uSampleWeights,sampleWeights);var depthTexture=depthRenderBuffer.getDepthTexture();var occlusionTexture=occlusionRenderBuffer.getTexture();program.bindTexture(this._uDepthTexture,depthTexture,0);// TODO: use FrameCtx.textureUnit
program.bindTexture(this._uOcclusionTexture,occlusionTexture,1);this._aUV.bindArrayBuffer(this._uvBuf);this._aPosition.bindArrayBuffer(this._positionsBuf);this._indicesBuf.bind();gl.drawElements(gl.TRIANGLES,this._indicesBuf.numItems,this._indicesBuf.itemType,0);}},{key:"destroy",value:function destroy(){this._program.destroy();}}]);return SAODepthLimitedBlurRenderer;}();function createSampleWeights(kernelRadius,stdDev){var weights=[];for(var _i59=0;_i59<=kernelRadius;_i59++){weights.push(gaussian(_i59,stdDev));}return weights;// TODO: Optimize
}function gaussian(x,stdDev){return Math.exp(-(x*x)/(2.0*(stdDev*stdDev)))/(Math.sqrt(2.0*Math.PI)*stdDev);}function createSampleOffsets(kernelRadius,uvIncrement){var offsets=[];for(var _i60=0;_i60<=kernelRadius;_i60++){offsets.push(uvIncrement[0]*_i60);offsets.push(uvIncrement[1]*_i60);}return offsets;}/**
 * @desc Represents a WebGL render buffer.
 * @private
 */var RenderBuffer=/*#__PURE__*/function(){function RenderBuffer(canvas,gl,options){_classCallCheck(this,RenderBuffer);options=options||{};/** @type {WebGL2RenderingContext} */this.gl=gl;this.allocated=false;this.canvas=canvas;this.buffer=null;this.bound=false;this.size=options.size;this._hasDepthTexture=!!options.depthTexture;}_createClass(RenderBuffer,[{key:"setSize",value:function setSize(size){this.size=size;}},{key:"webglContextRestored",value:function webglContextRestored(gl){this.gl=gl;this.buffer=null;this.allocated=false;this.bound=false;}},{key:"bind",value:function bind(){this._touch.apply(this,arguments);if(this.bound){return;}var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,this.buffer.framebuf);this.bound=true;}/**
     * Create and specify a WebGL texture image.
     *
     * @param { number } width 
     * @param { number } height 
     * @param { GLenum } [internalformat=null] 
     *
     * @returns { WebGLTexture }
     */},{key:"createTexture",value:function createTexture(width,height){var internalformat=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var gl=this.gl;var colorTexture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,colorTexture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);if(internalformat){gl.texStorage2D(gl.TEXTURE_2D,1,internalformat,width,height);}else{gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);}return colorTexture;}/**
     *
     * @param {number[]} [internalformats=[]]
     * @returns
     */},{key:"_touch",value:function _touch(){var _this31=this;var width;var height;var gl=this.gl;if(this.size){width=this.size[0];height=this.size[1];}else{width=gl.drawingBufferWidth;height=gl.drawingBufferHeight;}if(this.buffer){if(this.buffer.width===width&&this.buffer.height===height){return;}else{this.buffer.textures.forEach(function(texture){return gl.deleteTexture(texture);});gl.deleteFramebuffer(this.buffer.framebuf);gl.deleteRenderbuffer(this.buffer.renderbuf);}}var colorTextures=[];for(var _len5=arguments.length,internalformats=new Array(_len5),_key3=0;_key3<_len5;_key3++){internalformats[_key3]=arguments[_key3];}if(internalformats.length>0){colorTextures.push.apply(colorTextures,_toConsumableArray(internalformats.map(function(internalformat){return _this31.createTexture(width,height,internalformat);})));}else{colorTextures.push(this.createTexture(width,height));}var depthTexture;if(this._hasDepthTexture){depthTexture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,depthTexture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texImage2D(gl.TEXTURE_2D,0,gl.DEPTH_COMPONENT32F,width,height,0,gl.DEPTH_COMPONENT,gl.FLOAT,null);}var renderbuf=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuf);gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT32F,width,height);var framebuf=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,framebuf);for(var _i61=0;_i61<colorTextures.length;_i61++){gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+_i61,gl.TEXTURE_2D,colorTextures[_i61],0);}if(internalformats.length>0){gl.drawBuffers(colorTextures.map(function(_,i){return gl.COLOR_ATTACHMENT0+i;}));}if(this._hasDepthTexture){gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.TEXTURE_2D,depthTexture,0);}else{gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,renderbuf);}gl.bindTexture(gl.TEXTURE_2D,null);gl.bindRenderbuffer(gl.RENDERBUFFER,null);gl.bindFramebuffer(gl.FRAMEBUFFER,null);// Verify framebuffer is OK
gl.bindFramebuffer(gl.FRAMEBUFFER,framebuf);if(!gl.isFramebuffer(framebuf)){throw"Invalid framebuffer";}gl.bindFramebuffer(gl.FRAMEBUFFER,null);var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);switch(status){case gl.FRAMEBUFFER_COMPLETE:break;case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case gl.FRAMEBUFFER_UNSUPPORTED:throw"Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";default:throw"Incomplete framebuffer: "+status;}this.buffer={framebuf:framebuf,renderbuf:renderbuf,texture:colorTextures[0],textures:colorTextures,depthTexture:depthTexture,width:width,height:height};this.bound=false;}},{key:"clear",value:function clear(){if(!this.bound){throw"Render buffer not bound";}var gl=this.gl;gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);}},{key:"read",value:function read(pickX,pickY){var glFormat=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var glType=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;var arrayType=arguments.length>4&&arguments[4]!==undefined?arguments[4]:Uint8Array;var arrayMultiplier=arguments.length>5&&arguments[5]!==undefined?arguments[5]:4;var colorBufferIndex=arguments.length>6&&arguments[6]!==undefined?arguments[6]:0;var x=pickX;var y=this.buffer.height?this.buffer.height-pickY-1:this.gl.drawingBufferHeight-pickY;var pix=new arrayType(arrayMultiplier);var gl=this.gl;gl.readBuffer(gl.COLOR_ATTACHMENT0+colorBufferIndex);gl.readPixels(x,y,1,1,glFormat||gl.RGBA,glType||gl.UNSIGNED_BYTE,pix,0);return pix;}},{key:"readArray",value:function readArray(){var glFormat=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var glType=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var arrayType=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Uint8Array;var arrayMultiplier=arguments.length>3&&arguments[3]!==undefined?arguments[3]:4;var colorBufferIndex=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var pix=new arrayType(this.buffer.width*this.buffer.height*arrayMultiplier);var gl=this.gl;gl.readBuffer(gl.COLOR_ATTACHMENT0+colorBufferIndex);gl.readPixels(0,0,this.buffer.width,this.buffer.height,glFormat||gl.RGBA,glType||gl.UNSIGNED_BYTE,pix,0);return pix;}/**
     * Returns an HTMLCanvas containing the contents of the RenderBuffer as an image.
     *
     * - The HTMLCanvas has a CanvasRenderingContext2D.
     * - Expects the caller to draw more things on the HTMLCanvas (annotations etc).
     *
     * @returns {HTMLCanvasElement}
     */},{key:"readImageAsCanvas",value:function readImageAsCanvas(){var gl=this.gl;var imageDataCache=this._getImageDataCache();var pixelData=imageDataCache.pixelData;var canvas=imageDataCache.canvas;var imageData=imageDataCache.imageData;var context=imageDataCache.context;gl.readPixels(0,0,this.buffer.width,this.buffer.height,gl.RGBA,gl.UNSIGNED_BYTE,pixelData);var width=this.buffer.width;var height=this.buffer.height;var halfHeight=height/2|0;// the | 0 keeps the result an int
var bytesPerRow=width*4;var temp=new Uint8Array(width*4);for(var y=0;y<halfHeight;++y){var topOffset=y*bytesPerRow;var bottomOffset=(height-y-1)*bytesPerRow;temp.set(pixelData.subarray(topOffset,topOffset+bytesPerRow));pixelData.copyWithin(topOffset,bottomOffset,bottomOffset+bytesPerRow);pixelData.set(temp,bottomOffset);}imageData.data.set(pixelData);context.putImageData(imageData,0,0);return canvas;}},{key:"readImage",value:function readImage(params){var gl=this.gl;var imageDataCache=this._getImageDataCache();var pixelData=imageDataCache.pixelData;var canvas=imageDataCache.canvas;var imageData=imageDataCache.imageData;var context=imageDataCache.context;var _this$buffer=this.buffer,width=_this$buffer.width,height=_this$buffer.height;gl.readPixels(0,0,width,height,gl.RGBA,gl.UNSIGNED_BYTE,pixelData);imageData.data.set(pixelData);context.putImageData(imageData,0,0);// flip Y
context.save();context.globalCompositeOperation='copy';context.scale(1,-1);context.drawImage(canvas,0,-height,width,height);context.restore();var format=params.format||"png";if(format!=="jpeg"&&format!=="png"&&format!=="bmp"){console.error("Unsupported image format: '"+format+"' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'png'");format="png";}return canvas.toDataURL("image/".concat(format));}},{key:"_getImageDataCache",value:function _getImageDataCache(){var type=arguments.length>0&&arguments[0]!==undefined?arguments[0]:Uint8Array;var multiplier=arguments.length>1&&arguments[1]!==undefined?arguments[1]:4;var bufferWidth=this.buffer.width;var bufferHeight=this.buffer.height;var imageDataCache=this._imageDataCache;if(imageDataCache){if(imageDataCache.width!==bufferWidth||imageDataCache.height!==bufferHeight){this._imageDataCache=null;imageDataCache=null;}}if(!imageDataCache){var _canvas=document.createElement('canvas');var context=_canvas.getContext('2d');_canvas.width=bufferWidth;_canvas.height=bufferHeight;imageDataCache={pixelData:new type(bufferWidth*bufferHeight*multiplier),canvas:_canvas,context:context,imageData:context.createImageData(bufferWidth,bufferHeight),width:bufferWidth,height:bufferHeight};this._imageDataCache=imageDataCache;}imageDataCache.context.resetTransform();// Prevents strange scale-accumulation effect with html2canvas
return imageDataCache;}},{key:"unbind",value:function unbind(){var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,null);this.bound=false;}},{key:"getTexture",value:function getTexture(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var self=this;return this._texture||(this._texture={renderBuffer:this,bind:function bind(unit){if(self.buffer&&self.buffer.textures[index]){self.gl.activeTexture(self.gl["TEXTURE"+unit]);self.gl.bindTexture(self.gl.TEXTURE_2D,self.buffer.textures[index]);return true;}return false;},unbind:function unbind(unit){if(self.buffer&&self.buffer.textures[index]){self.gl.activeTexture(self.gl["TEXTURE"+unit]);self.gl.bindTexture(self.gl.TEXTURE_2D,null);}}});}},{key:"hasDepthTexture",value:function hasDepthTexture(){return this._hasDepthTexture;}},{key:"getDepthTexture",value:function getDepthTexture(){if(!this._hasDepthTexture){return null;}var self=this;return this._depthTexture||(this._dethTexture={renderBuffer:this,bind:function bind(unit){if(self.buffer&&self.buffer.depthTexture){self.gl.activeTexture(self.gl["TEXTURE"+unit]);self.gl.bindTexture(self.gl.TEXTURE_2D,self.buffer.depthTexture);return true;}return false;},unbind:function unbind(unit){if(self.buffer&&self.buffer.depthTexture){self.gl.activeTexture(self.gl["TEXTURE"+unit]);self.gl.bindTexture(self.gl.TEXTURE_2D,null);}}});}},{key:"destroy",value:function destroy(){if(this.allocated){var _gl=this.gl;this.buffer.textures.forEach(function(texture){return _gl.deleteTexture(texture);});_gl.deleteTexture(this.buffer.depthTexture);_gl.deleteFramebuffer(this.buffer.framebuf);_gl.deleteRenderbuffer(this.buffer.renderbuf);this.allocated=false;this.buffer=null;this.bound=false;}this._imageDataCache=null;this._texture=null;this._depthTexture=null;}}]);return RenderBuffer;}();/**
 * @private
 */var RenderBufferManager=/*#__PURE__*/function(){function RenderBufferManager(scene){_classCallCheck(this,RenderBufferManager);this.scene=scene;this._renderBuffersBasic={};this._renderBuffersScaled={};}_createClass(RenderBufferManager,[{key:"getRenderBuffer",value:function getRenderBuffer(id,options){var renderBuffers=this.scene.canvas.resolutionScale===1.0?this._renderBuffersBasic:this._renderBuffersScaled;var renderBuffer=renderBuffers[id];if(!renderBuffer){renderBuffer=new RenderBuffer(this.scene.canvas.canvas,this.scene.canvas.gl,options);renderBuffers[id]=renderBuffer;}return renderBuffer;}},{key:"destroy",value:function destroy(){for(var id in this._renderBuffersBasic){this._renderBuffersBasic[id].destroy();}for(var _id in this._renderBuffersScaled){this._renderBuffersScaled[_id].destroy();}}}]);return RenderBufferManager;}();/**
 * @private
 */function getExtension(gl,name){if(gl._cachedExtensions===undefined){gl._cachedExtensions={};}if(gl._cachedExtensions[name]!==undefined){return gl._cachedExtensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}gl._cachedExtensions[name]=extension;return extension;}/**
 * @private
 */var Renderer$1=function Renderer$1(scene,options){options=options||{};var frameCtx=new FrameContext(scene);var canvas=scene.canvas.canvas;/**
     * @type {WebGL2RenderingContext}
     */var gl=scene.canvas.gl;var canvasTransparent=!!options.transparent;var alphaDepthMask=options.alphaDepthMask;var pickIDs=new Map$1({});var drawableTypeInfo={};var drawables={};var drawableListDirty=true;var stateSortDirty=true;var imageDirty=true;var transparentEnabled=true;var edgesEnabled=true;var saoEnabled=true;var pbrEnabled=true;var colorTextureEnabled=true;var renderBufferManager=new RenderBufferManager(scene);var snapshotBound=false;var saoOcclusionRenderer=new SAOOcclusionRenderer(scene);var saoDepthLimitedBlurRenderer=new SAODepthLimitedBlurRenderer(scene);this.scene=scene;this._occlusionTester=null;// Lazy-created in #addMarker()
this.capabilities={astcSupported:!!getExtension(gl,'WEBGL_compressed_texture_astc'),etc1Supported:true,// WebGL2
etc2Supported:!!getExtension(gl,'WEBGL_compressed_texture_etc'),dxtSupported:!!getExtension(gl,'WEBGL_compressed_texture_s3tc'),bptcSupported:!!getExtension(gl,'EXT_texture_compression_bptc'),pvrtcSupported:!!(getExtension(gl,'WEBGL_compressed_texture_pvrtc')||getExtension(gl,'WEBKIT_WEBGL_compressed_texture_pvrtc'))};this.setTransparentEnabled=function(enabled){transparentEnabled=enabled;imageDirty=true;};this.setEdgesEnabled=function(enabled){edgesEnabled=enabled;imageDirty=true;};this.setSAOEnabled=function(enabled){saoEnabled=enabled;imageDirty=true;};this.setPBREnabled=function(enabled){pbrEnabled=enabled;imageDirty=true;};this.setColorTextureEnabled=function(enabled){colorTextureEnabled=enabled;imageDirty=true;};this.needStateSort=function(){stateSortDirty=true;};this.shadowsDirty=function(){};this.imageDirty=function(){imageDirty=true;};this.webglContextLost=function(){};this.webglContextRestored=function(gl){// renderBufferManager.webglContextRestored(gl);
saoOcclusionRenderer.init();saoDepthLimitedBlurRenderer.init();imageDirty=true;};/**
     * Inserts a drawable into this renderer.
     *  @private
     */this.addDrawable=function(id,drawable){var type=drawable.type;if(!type){console.error("Renderer#addDrawable() : drawable with ID "+id+" has no 'type' - ignoring");return;}var drawableInfo=drawableTypeInfo[type];if(!drawableInfo){drawableInfo={type:drawable.type,count:0,isStateSortable:drawable.isStateSortable,stateSortCompare:drawable.stateSortCompare,drawableMap:{},drawableListPreCull:[],drawableList:[]};drawableTypeInfo[type]=drawableInfo;}drawableInfo.count++;drawableInfo.drawableMap[id]=drawable;drawables[id]=drawable;drawableListDirty=true;};/**
     * Removes a drawable from this renderer.
     *  @private
     */this.removeDrawable=function(id){var drawable=drawables[id];if(!drawable){console.error("Renderer#removeDrawable() : drawable not found with ID "+id+" - ignoring");return;}var type=drawable.type;var drawableInfo=drawableTypeInfo[type];if(--drawableInfo.count<=0){delete drawableTypeInfo[type];}else{delete drawableInfo.drawableMap[id];}delete drawables[id];drawableListDirty=true;};/**
     * Gets a unique pick ID for the given Pickable. A Pickable can be a {@link Mesh} or a {@link PerformanceMesh}.
     * @returns {Number} New pick ID.
     */this.getPickID=function(entity){return pickIDs.addItem(entity);};/**
     * Released a pick ID for reuse.
     * @param {Number} pickID Pick ID to release.
     */this.putPickID=function(pickID){pickIDs.removeItem(pickID);};/**
     * Clears the canvas.
     *  @private
     */this.clear=function(params){gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);if(canvasTransparent){gl.clearColor(1,1,1,1);}else{var _backgroundColor=scene.canvas.backgroundColorFromAmbientLight?this.lights.getAmbientColorAndIntensity():scene.canvas.backgroundColor;gl.clearColor(_backgroundColor[0],_backgroundColor[1],_backgroundColor[2],1.0);}gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);};/**
     * Returns true if the next call to render() will draw something
     * @returns {Boolean}
     */this.needsRender=function(){var needsRender=imageDirty||drawableListDirty||stateSortDirty;return needsRender;};/**
     * Renders inserted drawables.
     *  @private
     */this.render=function(params){params=params||{};if(params.force){imageDirty=true;}updateDrawlist();if(imageDirty){draw(params);stats.frame.frameCount++;imageDirty=false;}};function updateDrawlist(){// Prepares state-sorted array of drawables from maps of inserted drawables
if(drawableListDirty){buildDrawableList();drawableListDirty=false;stateSortDirty=true;}if(stateSortDirty){sortDrawableList();stateSortDirty=false;imageDirty=true;}if(imageDirty){// Image is usually dirty because the camera moved
cullDrawableList();}}function buildDrawableList(){for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableMap=drawableInfo.drawableMap;var drawableListPreCull=drawableInfo.drawableListPreCull;var lenDrawableList=0;for(var id in drawableMap){if(drawableMap.hasOwnProperty(id)){drawableListPreCull[lenDrawableList++]=drawableMap[id];}}drawableListPreCull.length=lenDrawableList;}}}function sortDrawableList(){for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];if(drawableInfo.isStateSortable){drawableInfo.drawableListPreCull.sort(drawableInfo.stateSortCompare);}}}}function cullDrawableList(){for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableListPreCull=drawableInfo.drawableListPreCull;var drawableList=drawableInfo.drawableList;var lenDrawableList=0;for(var _i62=0,len=drawableListPreCull.length;_i62<len;_i62++){var drawable=drawableListPreCull[_i62];drawable.rebuildRenderFlags();if(!drawable.renderFlags.culled){drawableList[lenDrawableList++]=drawable;}}drawableList.length=lenDrawableList;}}}function draw(params){var sao=scene.sao;if(saoEnabled&&sao.possible){drawSAOBuffers(params);}drawShadowMaps();drawColor(params);}function drawSAOBuffers(params){var sao=scene.sao;// Render depth buffer
var saoDepthRenderBuffer=renderBufferManager.getRenderBuffer("saoDepth",{depthTexture:true});saoDepthRenderBuffer.bind();saoDepthRenderBuffer.clear();drawDepth(params);saoDepthRenderBuffer.unbind();// Render occlusion buffer
var occlusionRenderBuffer1=renderBufferManager.getRenderBuffer("saoOcclusion");occlusionRenderBuffer1.bind();occlusionRenderBuffer1.clear();saoOcclusionRenderer.render(saoDepthRenderBuffer);occlusionRenderBuffer1.unbind();if(sao.blur){// Horizontally blur occlusion buffer 1 into occlusion buffer 2
var occlusionRenderBuffer2=renderBufferManager.getRenderBuffer("saoOcclusion2");occlusionRenderBuffer2.bind();occlusionRenderBuffer2.clear();saoDepthLimitedBlurRenderer.render(saoDepthRenderBuffer,occlusionRenderBuffer1,0);occlusionRenderBuffer2.unbind();// Vertically blur occlusion buffer 2 back into occlusion buffer 1
occlusionRenderBuffer1.bind();occlusionRenderBuffer1.clear();saoDepthLimitedBlurRenderer.render(saoDepthRenderBuffer,occlusionRenderBuffer2,1);occlusionRenderBuffer1.unbind();}}function drawDepth(params){frameCtx.reset();frameCtx.pass=params.pass;gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);gl.clearColor(0,0,0,0);gl.enable(gl.DEPTH_TEST);gl.frontFace(gl.CCW);gl.enable(gl.CULL_FACE);gl.depthMask(true);if(params.clear!==false){gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);}for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(var _i63=0,len=drawableList.length;_i63<len;_i63++){var drawable=drawableList[_i63];if(drawable.culled===true||drawable.visible===false||!drawable.drawDepth||!drawable.saoEnabled){continue;}if(drawable.renderFlags.colorOpaque){drawable.drawDepth(frameCtx);}}}}// const numVertexAttribs = WEBGL_INFO.MAX_VERTEX_ATTRIBS; // Fixes https://github.com/xeokit/xeokit-sdk/issues/174
// for (let ii = 0; ii < numVertexAttribs; ii++) {
//     gl.disableVertexAttribArray(ii);
// }
}function drawShadowMaps(){var lights=scene._lightsState.lights;for(var _i64=0,len=lights.length;_i64<len;_i64++){var light=lights[_i64];if(!light.castsShadow){continue;}drawShadowMap(light);}}function drawShadowMap(light){var castsShadow=light.castsShadow;if(!castsShadow){return;}var shadowRenderBuf=light.getShadowRenderBuf();if(!shadowRenderBuf){return;}shadowRenderBuf.bind();frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;frameCtx.shadowViewMatrix=light.getShadowViewMatrix();frameCtx.shadowProjMatrix=light.getShadowProjMatrix();gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);gl.clearColor(0,0,0,1);gl.enable(gl.DEPTH_TEST);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(var _i65=0,len=drawableList.length;_i65<len;_i65++){var drawable=drawableList[_i65];if(drawable.visible===false||!drawable.castsShadow||!drawable.drawShadow){continue;}if(drawable.renderFlags.colorOpaque){// Transparent objects don't cast shadows (yet)
drawable.drawShadow(frameCtx);}}}}shadowRenderBuf.unbind();}function drawColor(params){var normalDrawSAOBin=[];var normalEdgesOpaqueBin=[];var normalFillTransparentBin=[];var normalEdgesTransparentBin=[];var xrayedFillOpaqueBin=[];var xrayEdgesOpaqueBin=[];var xrayedFillTransparentBin=[];var xrayEdgesTransparentBin=[];var highlightedFillOpaqueBin=[];var highlightedEdgesOpaqueBin=[];var highlightedFillTransparentBin=[];var highlightedEdgesTransparentBin=[];var selectedFillOpaqueBin=[];var selectedEdgesOpaqueBin=[];var selectedFillTransparentBin=[];var selectedEdgesTransparentBin=[];var ambientColorAndIntensity=scene._lightsState.getAmbientColorAndIntensity();frameCtx.reset();frameCtx.pass=params.pass;frameCtx.withSAO=false;frameCtx.pbrEnabled=pbrEnabled&&!!scene.pbrEnabled;frameCtx.colorTextureEnabled=colorTextureEnabled&&!!scene.colorTextureEnabled;gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);if(canvasTransparent){gl.clearColor(0,0,0,0);}else{var _backgroundColor2=scene.canvas.backgroundColorFromAmbientLight?ambientColorAndIntensity:scene.canvas.backgroundColor;gl.clearColor(_backgroundColor2[0],_backgroundColor2[1],_backgroundColor2[2],1.0);}gl.enable(gl.DEPTH_TEST);gl.frontFace(gl.CCW);gl.enable(gl.CULL_FACE);gl.depthMask(true);gl.lineWidth(1);frameCtx.lineWidth=1;var saoPossible=scene.sao.possible;if(saoEnabled&&saoPossible){var occlusionRenderBuffer1=renderBufferManager.getRenderBuffer("saoOcclusion");frameCtx.occlusionTexture=occlusionRenderBuffer1?occlusionRenderBuffer1.getTexture():null;}else{frameCtx.occlusionTexture=null;}var i;var len;var drawable;var startTime=Date.now();if(params.clear!==false){gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);}var normalDrawSAOBinLen=0;var normalEdgesOpaqueBinLen=0;var normalFillTransparentBinLen=0;var normalEdgesTransparentBinLen=0;var xrayedFillOpaqueBinLen=0;var xrayEdgesOpaqueBinLen=0;var xrayedFillTransparentBinLen=0;var xrayEdgesTransparentBinLen=0;var highlightedFillOpaqueBinLen=0;var highlightedEdgesOpaqueBinLen=0;var highlightedFillTransparentBinLen=0;var highlightedEdgesTransparentBinLen=0;var selectedFillOpaqueBinLen=0;var selectedEdgesOpaqueBinLen=0;var selectedFillTransparentBinLen=0;var selectedEdgesTransparentBinLen=0;//------------------------------------------------------------------------------------------------------
// Render normal opaque solids, defer others to bins to render after
//------------------------------------------------------------------------------------------------------
for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(i=0,len=drawableList.length;i<len;i++){drawable=drawableList[i];if(drawable.culled===true||drawable.visible===false){continue;}var renderFlags=drawable.renderFlags;if(renderFlags.colorOpaque){if(saoEnabled&&saoPossible&&drawable.saoEnabled){normalDrawSAOBin[normalDrawSAOBinLen++]=drawable;}else{drawable.drawColorOpaque(frameCtx);}}if(transparentEnabled){if(renderFlags.colorTransparent){normalFillTransparentBin[normalFillTransparentBinLen++]=drawable;}}if(renderFlags.xrayedSilhouetteTransparent){xrayedFillTransparentBin[xrayedFillTransparentBinLen++]=drawable;}if(renderFlags.xrayedSilhouetteOpaque){xrayedFillOpaqueBin[xrayedFillOpaqueBinLen++]=drawable;}if(renderFlags.highlightedSilhouetteTransparent){highlightedFillTransparentBin[highlightedFillTransparentBinLen++]=drawable;}if(renderFlags.highlightedSilhouetteOpaque){highlightedFillOpaqueBin[highlightedFillOpaqueBinLen++]=drawable;}if(renderFlags.selectedSilhouetteTransparent){selectedFillTransparentBin[selectedFillTransparentBinLen++]=drawable;}if(renderFlags.selectedSilhouetteOpaque){selectedFillOpaqueBin[selectedFillOpaqueBinLen++]=drawable;}if(drawable.edges&&edgesEnabled){if(renderFlags.edgesOpaque){normalEdgesOpaqueBin[normalEdgesOpaqueBinLen++]=drawable;}if(renderFlags.edgesTransparent){normalEdgesTransparentBin[normalEdgesTransparentBinLen++]=drawable;}if(renderFlags.selectedEdgesTransparent){selectedEdgesTransparentBin[selectedEdgesTransparentBinLen++]=drawable;}if(renderFlags.selectedEdgesOpaque){selectedEdgesOpaqueBin[selectedEdgesOpaqueBinLen++]=drawable;}if(renderFlags.xrayedEdgesTransparent){xrayEdgesTransparentBin[xrayEdgesTransparentBinLen++]=drawable;}if(renderFlags.xrayedEdgesOpaque){xrayEdgesOpaqueBin[xrayEdgesOpaqueBinLen++]=drawable;}if(renderFlags.highlightedEdgesTransparent){highlightedEdgesTransparentBin[highlightedEdgesTransparentBinLen++]=drawable;}if(renderFlags.highlightedEdgesOpaque){highlightedEdgesOpaqueBin[highlightedEdgesOpaqueBinLen++]=drawable;}}}}}//------------------------------------------------------------------------------------------------------
// Render deferred bins
//------------------------------------------------------------------------------------------------------
// Opaque color with SAO
if(normalDrawSAOBinLen>0){frameCtx.withSAO=true;for(i=0;i<normalDrawSAOBinLen;i++){normalDrawSAOBin[i].drawColorOpaque(frameCtx);}}// Opaque edges
if(normalEdgesOpaqueBinLen>0){for(i=0;i<normalEdgesOpaqueBinLen;i++){normalEdgesOpaqueBin[i].drawEdgesColorOpaque(frameCtx);}}// Opaque X-ray fill
if(xrayedFillOpaqueBinLen>0){for(i=0;i<xrayedFillOpaqueBinLen;i++){xrayedFillOpaqueBin[i].drawSilhouetteXRayed(frameCtx);}}// Opaque X-ray edges
if(xrayEdgesOpaqueBinLen>0){for(i=0;i<xrayEdgesOpaqueBinLen;i++){xrayEdgesOpaqueBin[i].drawEdgesXRayed(frameCtx);}}// Transparent
if(xrayedFillTransparentBinLen>0||xrayEdgesTransparentBinLen>0||normalFillTransparentBinLen>0||normalEdgesTransparentBinLen>0){gl.enable(gl.CULL_FACE);gl.enable(gl.BLEND);if(canvasTransparent){gl.blendEquation(gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);}frameCtx.backfaces=false;if(!alphaDepthMask){gl.depthMask(false);}// Transparent color edges
if(normalFillTransparentBinLen>0||normalEdgesTransparentBinLen>0){gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);}if(normalEdgesTransparentBinLen>0){for(i=0;i<normalEdgesTransparentBinLen;i++){drawable=normalEdgesTransparentBin[i];drawable.drawEdgesColorTransparent(frameCtx);}}// Transparent color fill
if(normalFillTransparentBinLen>0){for(i=0;i<normalFillTransparentBinLen;i++){drawable=normalFillTransparentBin[i];drawable.drawColorTransparent(frameCtx);}}// Transparent X-ray edges
if(xrayEdgesTransparentBinLen>0){for(i=0;i<xrayEdgesTransparentBinLen;i++){xrayEdgesTransparentBin[i].drawEdgesXRayed(frameCtx);}}// Transparent X-ray fill
if(xrayedFillTransparentBinLen>0){for(i=0;i<xrayedFillTransparentBinLen;i++){xrayedFillTransparentBin[i].drawSilhouetteXRayed(frameCtx);}}gl.disable(gl.BLEND);if(!alphaDepthMask){gl.depthMask(true);}}// Opaque highlight
if(highlightedFillOpaqueBinLen>0||highlightedEdgesOpaqueBinLen>0){frameCtx.lastProgramId=null;if(scene.highlightMaterial.glowThrough){gl.clear(gl.DEPTH_BUFFER_BIT);}// Opaque highlighted edges
if(highlightedEdgesOpaqueBinLen>0){for(i=0;i<highlightedEdgesOpaqueBinLen;i++){highlightedEdgesOpaqueBin[i].drawEdgesHighlighted(frameCtx);}}// Opaque highlighted fill
if(highlightedFillOpaqueBinLen>0){for(i=0;i<highlightedFillOpaqueBinLen;i++){highlightedFillOpaqueBin[i].drawSilhouetteHighlighted(frameCtx);}}}// Highlighted transparent
if(highlightedFillTransparentBinLen>0||highlightedEdgesTransparentBinLen>0||highlightedFillOpaqueBinLen>0){frameCtx.lastProgramId=null;if(scene.selectedMaterial.glowThrough){gl.clear(gl.DEPTH_BUFFER_BIT);}gl.enable(gl.BLEND);if(canvasTransparent){gl.blendEquation(gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);}gl.enable(gl.CULL_FACE);// Highlighted transparent edges
if(highlightedEdgesTransparentBinLen>0){for(i=0;i<highlightedEdgesTransparentBinLen;i++){highlightedEdgesTransparentBin[i].drawEdgesHighlighted(frameCtx);}}// Highlighted transparent fill
if(highlightedFillTransparentBinLen>0){for(i=0;i<highlightedFillTransparentBinLen;i++){highlightedFillTransparentBin[i].drawSilhouetteHighlighted(frameCtx);}}gl.disable(gl.BLEND);}// Selected opaque
if(selectedFillOpaqueBinLen>0||selectedEdgesOpaqueBinLen>0){frameCtx.lastProgramId=null;if(scene.selectedMaterial.glowThrough){gl.clear(gl.DEPTH_BUFFER_BIT);}// Selected opaque fill
if(selectedEdgesOpaqueBinLen>0){for(i=0;i<selectedEdgesOpaqueBinLen;i++){selectedEdgesOpaqueBin[i].drawEdgesSelected(frameCtx);}}// Selected opaque edges
if(selectedFillOpaqueBinLen>0){for(i=0;i<selectedFillOpaqueBinLen;i++){selectedFillOpaqueBin[i].drawSilhouetteSelected(frameCtx);}}}// Selected transparent
if(selectedFillTransparentBinLen>0||selectedEdgesTransparentBinLen>0){frameCtx.lastProgramId=null;if(scene.selectedMaterial.glowThrough){gl.clear(gl.DEPTH_BUFFER_BIT);}gl.enable(gl.CULL_FACE);gl.enable(gl.BLEND);if(canvasTransparent){gl.blendEquation(gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);}// Selected transparent edges
if(selectedEdgesTransparentBinLen>0){for(i=0;i<selectedEdgesTransparentBinLen;i++){selectedEdgesTransparentBin[i].drawEdgesSelected(frameCtx);}}// Selected transparent fill
if(selectedFillTransparentBinLen>0){for(i=0;i<selectedFillTransparentBinLen;i++){selectedFillTransparentBin[i].drawSilhouetteSelected(frameCtx);}}gl.disable(gl.BLEND);}var endTime=Date.now();var frameStats=stats.frame;frameStats.renderTime=(endTime-startTime)/1000.0;frameStats.drawElements=frameCtx.drawElements;frameStats.drawArrays=frameCtx.drawArrays;frameStats.useProgram=frameCtx.useProgram;frameStats.bindTexture=frameCtx.bindTexture;frameStats.bindArray=frameCtx.bindArray;var numTextureUnits=WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS;for(var ii=0;ii<numTextureUnits;ii++){gl.activeTexture(gl.TEXTURE0+ii);}gl.bindTexture(gl.TEXTURE_CUBE_MAP,null);gl.bindTexture(gl.TEXTURE_2D,null);var numVertexAttribs=WEBGL_INFO.MAX_VERTEX_ATTRIBS;// Fixes https://github.com/xeokit/xeokit-sdk/issues/174
for(var _ii=0;_ii<numVertexAttribs;_ii++){gl.disableVertexAttribArray(_ii);}}/**
     * Picks an Entity.
     * @private
     */this.pick=function(){var tempVec3a=math.vec3();math.mat4();var tempMat4b=math.mat4();var randomVec3=math.vec3();var up=math.vec3([0,1,0]);var _pickResult=new PickResult();var nearAndFar=math.vec2();var canvasPos=math.vec3();var worldRayOrigin=math.vec3();var worldRayDir=math.vec3();math.vec3();math.vec3();return function(params){var pickResult=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_pickResult;pickResult.reset();updateDrawlist();var look;var pickViewMatrix=null;var pickProjMatrix=null;pickResult.pickSurface=params.pickSurface;if(params.canvasPos){canvasPos[0]=params.canvasPos[0];canvasPos[1]=params.canvasPos[1];pickViewMatrix=scene.camera.viewMatrix;pickProjMatrix=scene.camera.projMatrix;pickResult.canvasPos=params.canvasPos;}else{// Picking with arbitrary World-space ray
// Align camera along ray and fire ray through center of canvas
if(params.matrix){pickViewMatrix=params.matrix;pickProjMatrix=scene.camera.projMatrix;}else{worldRayOrigin.set(params.origin||[0,0,0]);worldRayDir.set(params.direction||[0,0,1]);look=math.addVec3(worldRayOrigin,worldRayDir,tempVec3a);randomVec3[0]=Math.random();randomVec3[1]=Math.random();randomVec3[2]=Math.random();math.normalizeVec3(randomVec3);math.cross3Vec3(worldRayDir,randomVec3,up);pickViewMatrix=math.lookAtMat4v(worldRayOrigin,look,up,tempMat4b);//    pickProjMatrix = scene.camera.projMatrix;
pickProjMatrix=scene.camera.ortho.matrix;pickResult.origin=worldRayOrigin;pickResult.direction=worldRayDir;}canvasPos[0]=canvas.clientWidth*0.5;canvasPos[1]=canvas.clientHeight*0.5;}for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableList=drawableTypeInfo[type].drawableList;for(var _i66=0,len=drawableList.length;_i66<len;_i66++){var drawable=drawableList[_i66];if(drawable.setPickMatrices){// Eg. SceneModel, which needs pre-loading into texture
drawable.setPickMatrices(pickViewMatrix,pickProjMatrix);}}}}var pickBuffer=renderBufferManager.getRenderBuffer("pick",{size:[1,1]});pickBuffer.bind();var pickable=gpuPickPickable(pickBuffer,canvasPos,pickViewMatrix,pickProjMatrix,params,pickResult);if(!pickable){pickBuffer.unbind();return null;}var pickedEntity=pickable.delegatePickedEntity?pickable.delegatePickedEntity():pickable;if(!pickedEntity){pickBuffer.unbind();return null;}if(params.pickSurface){// GPU-based ray-picking
if(pickable.canPickTriangle&&pickable.canPickTriangle()){gpuPickTriangle(pickBuffer,pickable,canvasPos,pickViewMatrix,pickProjMatrix,pickResult);pickable.pickTriangleSurface(pickViewMatrix,pickProjMatrix,pickResult);pickResult.pickSurfacePrecision=false;}else{if(pickable.canPickWorldPos&&pickable.canPickWorldPos()){nearAndFar[0]=scene.camera.project.near;nearAndFar[1]=scene.camera.project.far;gpuPickWorldPos(pickBuffer,pickable,canvasPos,pickViewMatrix,pickProjMatrix,nearAndFar,pickResult);if(params.pickSurfaceNormal!==false){gpuPickWorldNormal(pickBuffer,pickable,canvasPos,pickViewMatrix,pickProjMatrix,pickResult);}pickResult.pickSurfacePrecision=false;}}}pickBuffer.unbind();pickResult.entity=pickedEntity;return pickResult;};}();function gpuPickPickable(pickBuffer,canvasPos,pickViewMatrix,pickProjMatrix,params,pickResult){var resolutionScale=scene.canvas.resolutionScale;frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;// "ccw"
frameCtx.pickOrigin=pickResult.origin;frameCtx.pickViewMatrix=pickViewMatrix;frameCtx.pickProjMatrix=pickProjMatrix;frameCtx.pickInvisible=!!params.pickInvisible;frameCtx.pickClipPos=[getClipPosX(canvasPos[0]*resolutionScale,gl.drawingBufferWidth),getClipPosY(canvasPos[1]*resolutionScale,gl.drawingBufferHeight)];gl.viewport(0,0,1,1);gl.depthMask(true);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);var includeEntityIds=params.includeEntityIds;var excludeEntityIds=params.excludeEntityIds;for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(var _i67=0,len=drawableList.length;_i67<len;_i67++){var drawable=drawableList[_i67];if(!drawable.drawPickMesh||params.pickInvisible!==true&&drawable.visible===false||drawable.pickable===false){continue;}if(includeEntityIds&&!includeEntityIds[drawable.id]){// TODO: push this logic into drawable
continue;}if(excludeEntityIds&&excludeEntityIds[drawable.id]){continue;}drawable.drawPickMesh(frameCtx);}}}var pix=pickBuffer.read(0,0);var pickID=pix[0]+(pix[1]<<8)+(pix[2]<<16)+(pix[3]<<24);if(pickID<0){return;}var pickable=pickIDs.items[pickID];return pickable;}function gpuPickTriangle(pickBuffer,pickable,canvasPos,pickViewMatrix,pickProjMatrix,pickResult){if(!pickable.drawPickTriangles){return;}var resolutionScale=scene.canvas.resolutionScale;frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;// "ccw"
frameCtx.pickOrigin=pickResult.origin;frameCtx.pickViewMatrix=pickViewMatrix;// Can be null
frameCtx.pickProjMatrix=pickProjMatrix;// Can be null
// frameCtx.pickInvisible = !!params.pickInvisible;
frameCtx.pickClipPos=[getClipPosX(canvasPos[0]*resolutionScale,gl.drawingBufferWidth),getClipPosY(canvasPos[1]*resolutionScale,gl.drawingBufferHeight)];gl.viewport(0,0,1,1);gl.clearColor(0,0,0,0);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);pickable.drawPickTriangles(frameCtx);var pix=pickBuffer.read(0,0);var primIndex=pix[0]+pix[1]*256+pix[2]*256*256+pix[3]*256*256*256;primIndex*=3;// Convert from triangle number to first vertex in indices
pickResult.primIndex=primIndex;}var gpuPickWorldPos=function(){var tempVec4a=math.vec4();var tempVec4b=math.vec4();var tempVec4c=math.vec4();var tempVec4d=math.vec4();var tempVec4e=math.vec4();var tempMat4a=math.mat4();var tempMat4b=math.mat4();var tempMat4c=math.mat4();return function(pickBuffer,pickable,canvasPos,pickViewMatrix,pickProjMatrix,nearAndFar,pickResult){var resolutionScale=scene.canvas.resolutionScale;frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;// "ccw"
frameCtx.pickOrigin=pickResult.origin;frameCtx.pickViewMatrix=pickViewMatrix;frameCtx.pickProjMatrix=pickProjMatrix;frameCtx.pickZNear=nearAndFar[0];frameCtx.pickZFar=nearAndFar[1];frameCtx.pickElementsCount=pickable.pickElementsCount;frameCtx.pickElementsOffset=pickable.pickElementsOffset;frameCtx.pickClipPos=[getClipPosX(canvasPos[0]*resolutionScale,gl.drawingBufferWidth),getClipPosY(canvasPos[1]*resolutionScale,gl.drawingBufferHeight)];gl.viewport(0,0,1,1);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);pickable.drawPickDepths(frameCtx);// Draw color-encoded fragment screen-space depths
var pix=pickBuffer.read(0,0);var screenZ=unpackDepth(pix);// Get screen-space Z at the given canvas coords
// Calculate clip space coordinates, which will be in range of x=[-1..1] and y=[-1..1], with y=(+1) at top
var x=(canvasPos[0]-canvas.clientWidth/2)/(canvas.clientWidth/2);var y=-(canvasPos[1]-canvas.clientHeight/2)/(canvas.clientHeight/2);var origin=pickable.origin;var pvMat;if(origin){var rtcPickViewMat=createRTCViewMat(pickViewMatrix,origin,tempMat4a);pvMat=math.mulMat4(pickProjMatrix,rtcPickViewMat,tempMat4b);}else{pvMat=math.mulMat4(pickProjMatrix,pickViewMatrix,tempMat4b);}var pvMatInverse=math.inverseMat4(pvMat,tempMat4c);tempVec4a[0]=x;tempVec4a[1]=y;tempVec4a[2]=-1;tempVec4a[3]=1;var world1=math.transformVec4(pvMatInverse,tempVec4a);world1=math.mulVec4Scalar(world1,1/world1[3]);tempVec4b[0]=x;tempVec4b[1]=y;tempVec4b[2]=1;tempVec4b[3]=1;var world2=math.transformVec4(pvMatInverse,tempVec4b);world2=math.mulVec4Scalar(world2,1/world2[3]);var dir=math.subVec3(world2,world1,tempVec4c);var worldPos=math.addVec3(world1,math.mulVec4Scalar(dir,screenZ,tempVec4d),tempVec4e);if(origin){math.addVec3(worldPos,origin);}pickResult.worldPos=worldPos;};}();function drawSnapInit(frameCtx){frameCtx.snapPickLayerParams=[];frameCtx.snapPickLayerNumber=0;for(var type in drawableTypeInfo){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(var _i68=0,len=drawableList.length;_i68<len;_i68++){var drawable=drawableList[_i68];if(drawable.drawSnapInit){if(!drawable.culled&&drawable.visible&&drawable.pickable){drawable.drawSnapInit(frameCtx);}}}}return frameCtx.snapPickLayerParams;}function drawSnap(frameCtx){frameCtx.snapPickLayerParams=frameCtx.snapPickLayerParams||[];frameCtx.snapPickLayerNumber=frameCtx.snapPickLayerParams.length;for(var type in drawableTypeInfo){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(var _i69=0,len=drawableList.length;_i69<len;_i69++){var drawable=drawableList[_i69];if(drawable.drawSnap){if(!drawable.culled&&drawable.visible&&drawable.pickable){drawable.drawSnap(frameCtx);}}}}return frameCtx.snapPickLayerParams;}function getClipPosX(pos,size){return 2*(pos/size)-1;}function getClipPosY(pos,size){return 1-2*(pos/size);}/**
     * @param {[number, number]} canvasPos
     * @param {number} [snapRadiusInPixels=30]
     * @param {boolean} [snapToVertex=true]
     * @param {boolean} [snapToEdge=true]
     * @param pickResult
     * @returns {PickResult}
     */this.snapPick=function(){var _pickResult=new PickResult();return function(canvasPos,snapRadiusInPixels,snapToVertex,snapToEdge){var pickResult=arguments.length>4&&arguments[4]!==undefined?arguments[4]:_pickResult;if(!snapToVertex&&!snapToEdge){return this.pick({canvasPos:canvasPos,pickSurface:true});}var resolutionScale=scene.canvas.resolutionScale;frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;// "ccw"
frameCtx.pickZNear=scene.camera.project.near;frameCtx.pickZFar=scene.camera.project.far;snapRadiusInPixels=snapRadiusInPixels||30;var vertexPickBuffer=renderBufferManager.getRenderBuffer("uniquePickColors-aabs",{depthTexture:true,size:[2*snapRadiusInPixels+1,2*snapRadiusInPixels+1]});frameCtx.snapVectorA=[getClipPosX(canvasPos[0]*resolutionScale,gl.drawingBufferWidth),getClipPosY(canvasPos[1]*resolutionScale,gl.drawingBufferHeight)];frameCtx.snapInvVectorAB=[gl.drawingBufferWidth/(2*snapRadiusInPixels),gl.drawingBufferHeight/(2*snapRadiusInPixels)];// Bind and clear the snap render target
vertexPickBuffer.bind(gl.RGBA32I,gl.RGBA32I,gl.RGBA8UI);gl.viewport(0,0,vertexPickBuffer.size[0],vertexPickBuffer.size[1]);gl.enable(gl.DEPTH_TEST);gl.frontFace(gl.CCW);gl.disable(gl.CULL_FACE);gl.depthMask(true);gl.disable(gl.BLEND);gl.depthFunc(gl.LEQUAL);gl.clear(gl.DEPTH_BUFFER_BIT);gl.clearBufferiv(gl.COLOR,0,new Int32Array([0,0,0,0]));gl.clearBufferiv(gl.COLOR,1,new Int32Array([0,0,0,0]));gl.clearBufferuiv(gl.COLOR,2,new Uint32Array([0,0,0,0]));//////////////////////////////////
// Set view and proj mats for VBO renderers
///////////////////////////////////////
var pickViewMatrix=scene.camera.viewMatrix;var pickProjMatrix=scene.camera.projMatrix;for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableList=drawableTypeInfo[type].drawableList;for(var _i70=0,len=drawableList.length;_i70<len;_i70++){var drawable=drawableList[_i70];if(drawable.setPickMatrices){// Eg. SceneModel, which needs pre-loading into texture
drawable.setPickMatrices(pickViewMatrix,pickProjMatrix);}}}}// a) init z-buffer
gl.drawBuffers([gl.COLOR_ATTACHMENT0,gl.COLOR_ATTACHMENT1,gl.COLOR_ATTACHMENT2]);var layerParamsSurface=drawSnapInit(frameCtx);// b) snap-pick
var layerParamsSnap=[];frameCtx.snapPickLayerParams=layerParamsSnap;gl.depthMask(false);gl.drawBuffers([gl.COLOR_ATTACHMENT0]);if(snapToVertex&&snapToEdge){frameCtx.snapMode="edge";drawSnap(frameCtx);frameCtx.snapMode="vertex";frameCtx.snapPickLayerNumber++;drawSnap(frameCtx);}else{frameCtx.snapMode=snapToVertex?"vertex":"edge";drawSnap(frameCtx);}gl.depthMask(true);// Read and decode the snapped coordinates
var snapPickResultArray=vertexPickBuffer.readArray(gl.RGBA_INTEGER,gl.INT,Int32Array,4);var snapPickNormalResultArray=vertexPickBuffer.readArray(gl.RGBA_INTEGER,gl.INT,Int32Array,4,1);var snapPickIdResultArray=vertexPickBuffer.readArray(gl.RGBA_INTEGER,gl.UNSIGNED_INT,Uint32Array,4,2);vertexPickBuffer.unbind();// result 1) regular hi-precision world position
var worldPos=null;var middleX=snapRadiusInPixels;var middleY=snapRadiusInPixels;var middleIndex=middleX*4+middleY*vertexPickBuffer.size[0]*4;var pickResultMiddleXY=snapPickResultArray.slice(middleIndex,middleIndex+4);var pickNormalResultMiddleXY=snapPickNormalResultArray.slice(middleIndex,middleIndex+4);var pickPickableResultMiddleXY=snapPickIdResultArray.slice(middleIndex,middleIndex+4);if(pickResultMiddleXY[3]!==0){var pickedLayerParmasSurface=layerParamsSurface[Math.abs(pickResultMiddleXY[3])%layerParamsSurface.length];var origin=pickedLayerParmasSurface.origin;var _scale=pickedLayerParmasSurface.coordinateScale;worldPos=[pickResultMiddleXY[0]*_scale[0]+origin[0],pickResultMiddleXY[1]*_scale[1]+origin[1],pickResultMiddleXY[2]*_scale[2]+origin[2]];math.normalizeVec3([pickNormalResultMiddleXY[0]/math.MAX_INT,pickNormalResultMiddleXY[1]/math.MAX_INT,pickNormalResultMiddleXY[2]/math.MAX_INT]);var pickID=pickPickableResultMiddleXY[0]+(pickPickableResultMiddleXY[1]<<8)+(pickPickableResultMiddleXY[2]<<16)+(pickPickableResultMiddleXY[3]<<24);pickIDs.items[pickID];}// result 2) hi-precision snapped (to vertex/edge) world position
var snapPickResult=[];for(var _i71=0;_i71<snapPickResultArray.length;_i71+=4){if(snapPickResultArray[_i71+3]>0){var pixelNumber=Math.floor(_i71/4);var w=vertexPickBuffer.size[0];var x=pixelNumber%w-Math.floor(w/2);var y=Math.floor(pixelNumber/w)-Math.floor(w/2);var dist=Math.sqrt(Math.pow(x,2)+Math.pow(y,2));snapPickResult.push({x:x,y:y,dist:dist,isVertex:snapToVertex&&snapToEdge?snapPickResultArray[_i71+3]>layerParamsSnap.length/2:snapToVertex,result:[snapPickResultArray[_i71+0],snapPickResultArray[_i71+1],snapPickResultArray[_i71+2],snapPickResultArray[_i71+3]],normal:[snapPickNormalResultArray[_i71+0],snapPickNormalResultArray[_i71+1],snapPickNormalResultArray[_i71+2],snapPickNormalResultArray[_i71+3]],id:[snapPickIdResultArray[_i71+0],snapPickIdResultArray[_i71+1],snapPickIdResultArray[_i71+2],snapPickIdResultArray[_i71+3]]});}}var snappedWorldPos=null;var snappedWorldNormal=null;var snappedPickable=null;var snapType=null;if(snapPickResult.length>0){// vertex snap first, then edge snap
snapPickResult.sort(function(a,b){if(a.isVertex!==b.isVertex){return a.isVertex?-1:1;}else{return a.dist-b.dist;}});snapType=snapPickResult[0].isVertex?"vertex":"edge";var snapPick=snapPickResult[0].result;var snapPickNormal=snapPickResult[0].normal;var snapPickId=snapPickResult[0].id;var pickedLayerParmas=layerParamsSnap[snapPick[3]];var _origin=pickedLayerParmas.origin;var _scale2=pickedLayerParmas.coordinateScale;snappedWorldNormal=math.normalizeVec3([snapPickNormal[0]/math.MAX_INT,snapPickNormal[1]/math.MAX_INT,snapPickNormal[2]/math.MAX_INT]);snappedWorldPos=[snapPick[0]*_scale2[0]+_origin[0],snapPick[1]*_scale2[1]+_origin[1],snapPick[2]*_scale2[2]+_origin[2]];snappedPickable=pickIDs.items[snapPickId[0]+(snapPickId[1]<<8)+(snapPickId[2]<<16)+(snapPickId[3]<<24)];}if(null===worldPos&&null==snappedWorldPos){// If neither regular pick or snap pick, return null
return null;}var snappedCanvasPos=null;if(null!==snappedWorldPos){snappedCanvasPos=scene.camera.projectWorldPos(snappedWorldPos);}var snappedEntity=snappedPickable&&snappedPickable.delegatePickedEntity?snappedPickable.delegatePickedEntity():snappedPickable;pickResult.reset();pickResult.snappedToEdge=snapType==="edge";pickResult.snappedToVertex=snapType==="vertex";pickResult.worldPos=snappedWorldPos;pickResult.worldNormal=snappedWorldNormal;pickResult.entity=snappedEntity;pickResult.canvasPos=canvasPos;pickResult.snappedCanvasPos=snappedCanvasPos||canvasPos;return pickResult;};}();function unpackDepth(depthZ){var vec=[depthZ[0]/256.0,depthZ[1]/256.0,depthZ[2]/256.0,depthZ[3]/256.0];var bitShift=[1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0];return math.dotVec4(vec,bitShift);}function gpuPickWorldNormal(pickBuffer,pickable,canvasPos,pickViewMatrix,pickProjMatrix,pickResult){var resolutionScale=scene.canvas.resolutionScale;frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;// "ccw"
frameCtx.pickOrigin=pickResult.origin;frameCtx.pickViewMatrix=pickViewMatrix;frameCtx.pickProjMatrix=pickProjMatrix;frameCtx.pickClipPos=[getClipPosX(canvasPos[0]*resolutionScale,gl.drawingBufferWidth),getClipPosY(canvasPos[1]*resolutionScale,gl.drawingBufferHeight)];var pickNormalBuffer=renderBufferManager.getRenderBuffer("pick-normal",{size:[3,3]});pickNormalBuffer.bind(gl.RGBA32I);gl.viewport(0,0,pickNormalBuffer.size[0],pickNormalBuffer.size[1]);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.DEPTH_BUFFER_BIT);gl.clearBufferiv(gl.COLOR,0,new Int32Array([0,0,0,0]));pickable.drawPickNormals(frameCtx);// Draw color-encoded fragment World-space normals
var pix=pickNormalBuffer.read(1,1,gl.RGBA_INTEGER,gl.INT,Int32Array,4);pickNormalBuffer.unbind();var worldNormal=[pix[0]/math.MAX_INT,pix[1]/math.MAX_INT,pix[2]/math.MAX_INT];math.normalizeVec3(worldNormal);pickResult.worldNormal=worldNormal;}/**
     * Adds a {@link Marker} for occlusion testing.
     * @param marker
     */this.addMarker=function(marker){this._occlusionTester=this._occlusionTester||new OcclusionTester(scene,renderBufferManager);this._occlusionTester.addMarker(marker);scene.occlusionTestCountdown=0;};/**
     * Notifies that a {@link Marker#worldPos} has updated.
     * @param marker
     */this.markerWorldPosUpdated=function(marker){this._occlusionTester.markerWorldPosUpdated(marker);};/**
     * Removes a {@link Marker} from occlusion testing.
     * @param marker
     */this.removeMarker=function(marker){this._occlusionTester.removeMarker(marker);};/**
     * Performs an occlusion test for all added {@link Marker}s, updating
     * their {@link Marker#visible} properties accordingly.
     */this.doOcclusionTest=function(){if(this._occlusionTester&&this._occlusionTester.needOcclusionTest){updateDrawlist();this._occlusionTester.bindRenderBuf();frameCtx.reset();frameCtx.backfaces=true;frameCtx.frontface=true;// "ccw"
gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);gl.clearColor(0,0,0,0);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);for(var type in drawableTypeInfo){if(drawableTypeInfo.hasOwnProperty(type)){var drawableInfo=drawableTypeInfo[type];var drawableList=drawableInfo.drawableList;for(var _i72=0,len=drawableList.length;_i72<len;_i72++){var drawable=drawableList[_i72];if(!drawable.drawOcclusion||drawable.culled===true||drawable.visible===false||drawable.pickable===false){// TODO: Option to exclude transparent?
continue;}drawable.drawOcclusion(frameCtx);}}}this._occlusionTester.drawMarkers(frameCtx);this._occlusionTester.doOcclusionTest();// Updates Marker "visible" properties
this._occlusionTester.unbindRenderBuf();}};/**
     * Read pixels from the renderer's current output. Performs a force-render first.
     * @param pixels
     * @param colors
     * @param len
     * @param opaqueOnly
     * @private
     */this.readPixels=function(pixels,colors,len,opaqueOnly){var snapshotBuffer=renderBufferManager.getRenderBuffer("snapshot");snapshotBuffer.bind();snapshotBuffer.clear();this.render({force:true,opaqueOnly:opaqueOnly});var color;var i;var j;var k;for(i=0;i<len;i++){j=i*2;k=i*4;color=snapshotBuffer.read(pixels[j],pixels[j+1]);colors[k]=color[0];colors[k+1]=color[1];colors[k+2]=color[2];colors[k+3]=color[3];}snapshotBuffer.unbind();imageDirty=true;};/**
     * Enter snapshot mode.
     *
     * Switches rendering to a hidden snapshot canvas.
     *
     * Exit snapshot mode using endSnapshot().
     */this.beginSnapshot=function(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var snapshotBuffer=renderBufferManager.getRenderBuffer("snapshot");if(params.width&&params.height){snapshotBuffer.setSize([params.width,params.height]);}snapshotBuffer.bind();snapshotBuffer.clear();snapshotBound=true;};/**
     * When in snapshot mode, renders a frame of the current Scene state to the snapshot canvas.
     */this.renderSnapshot=function(){if(!snapshotBound){return;}var snapshotBuffer=renderBufferManager.getRenderBuffer("snapshot");snapshotBuffer.clear();this.render({force:true,opaqueOnly:false});imageDirty=true;};/**
     * When in snapshot mode, gets an image of the snapshot canvas.
     *
     * @private
     * @returns {String} The image data URI.
     */this.readSnapshot=function(params){var snapshotBuffer=renderBufferManager.getRenderBuffer("snapshot");return snapshotBuffer.readImage(params);};/**
     * Returns an HTMLCanvas containing an image of the snapshot canvas.
     *
     * - The HTMLCanvas has a CanvasRenderingContext2D.
     * - Expects the caller to draw more things on the HTMLCanvas (annotations etc).
     *
     * @returns {HTMLCanvasElement}
     */this.readSnapshotAsCanvas=function(){var snapshotBuffer=renderBufferManager.getRenderBuffer("snapshot");return snapshotBuffer.readImageAsCanvas();};/**
     * Exists snapshot mode.
     *
     * Switches rendering back to the main canvas.
     */this.endSnapshot=function(){if(!snapshotBound){return;}var snapshotBuffer=renderBufferManager.getRenderBuffer("snapshot");snapshotBuffer.unbind();snapshotBound=false;};/**
     * Destroys this renderer.
     * @private
     */this.destroy=function(){drawableTypeInfo={};drawables={};renderBufferManager.destroy();saoOcclusionRenderer.destroy();saoDepthLimitedBlurRenderer.destroy();if(this._occlusionTester){this._occlusionTester.destroy();}};};/**
 * @desc Meditates mouse, touch and keyboard events for various interaction controls.
 *
 * Ordinarily, you would only use this component as a utility to help manage input events and state for your
 * own custom input handlers.
 *
 * * Located at {@link Scene#input}
 * * Used by (at least) {@link CameraControl}
 *
 * ## Usage
 *
 * Subscribing to mouse events on the canvas:
 *
 * ````javascript
 * import {Viewer} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * const input = viewer.scene.input;
 *
 * const onMouseDown = input.on("mousedown", (canvasCoords) => {
 *       console.log("Mouse down at: x=" + canvasCoords[0] + ", y=" + coords[1]);
 * });
 *
 * const onMouseUp = input.on("mouseup", (canvasCoords) => {
 *       console.log("Mouse up at: x=" + canvasCoords[0] + ", y=" + canvasCoords[1]);
 * });
 *
 * const onMouseClicked = input.on("mouseclicked", (canvasCoords) => {
 *      console.log("Mouse clicked at: x=" + canvasCoords[0] + ", y=" + canvasCoords[1]);
 * });
 *
 * const onDblClick = input.on("dblclick", (canvasCoords) => {
 *       console.log("Double-click at: x=" + canvasCoords[0] + ", y=" + canvasCoords[1]);
 * });
 * ````
 *
 * Subscribing to keyboard events on the canvas:
 *
 * ````javascript
 * const onKeyDown = input.on("keydown", (keyCode) => {
 *      switch (keyCode) {
 *          case this.KEY_A:
 *              console.log("The 'A' key is down");
 *              break;
 *
 *          case this.KEY_B:
 *              console.log("The 'B' key is down");
 *              break;
 *
 *          case this.KEY_C:
 *              console.log("The 'C' key is down");
 *              break;
 *
 *          default:
 *              console.log("Some other key is down");
 *      }
 * });
 *
 * const onKeyUp = input.on("keyup", (keyCode) => {
 *      switch (keyCode) {
 *          case this.KEY_A:
 *              console.log("The 'A' key is up");
 *              break;
 *
 *          case this.KEY_B:
 *              console.log("The 'B' key is up");
 *              break;
 *
 *          case this.KEY_C:
 *              console.log("The 'C' key is up");
 *              break;
 *
 *          default:
 *              console.log("Some other key is up");
 *      }
 *  });
 * ````
 *
 * Checking if keys are down:
 *
 * ````javascript
 * const isCtrlDown = input.ctrlDown;
 * const isAltDown = input.altDown;
 * const shiftDown = input.shiftDown;
 * //...
 *
 * const isAKeyDown = input.keyDown[input.KEY_A];
 * const isBKeyDown = input.keyDown[input.KEY_B];
 * const isShiftKeyDown = input.keyDown[input.KEY_SHIFT];
 * //...
 *
 * ````
 * Unsubscribing from events:
 *
 * ````javascript
 * input.off(onMouseDown);
 * input.off(onMouseUp);
 * //...
 * ````
 *
 * ## Disabling all events
 *
 * Event handling is enabled by default.
 *
 * To disable all events:
 *
 * ````javascript
 * myViewer.scene.input.setEnabled(false);
 * ````
 * To enable all events again:
 *
 * ````javascript
 * myViewer.scene.input.setEnabled(true);
 * ````
 *
 * ## Disabling keyboard input
 *
 * When the mouse is over the canvas, the canvas will consume keyboard events. Therefore, sometimes we need
 * to disable keyboard control, so that other UI elements can get those events.
 *
 * To disable keyboard events:
 *
 * ````javascript
 * myViewer.scene.input.setKeyboardEnabled(false);
 * ````
 *
 * To enable keyboard events again:
 *
 * ````javascript
 * myViewer.scene.input.setKeyboardEnabled(true)
 * ````
 */var Input=/*#__PURE__*/function(_Component8){_inherits(Input,_Component8);var _super13=_createSuper(Input);/**
     * @private
     */function Input(owner){var _this32;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Input);_this32=_super13.call(this,owner,cfg);/**
         * Code for the BACKSPACE key.
         * @property KEY_BACKSPACE
         * @final
         * @type {Number}
         */_this32.KEY_BACKSPACE=8;/**
         * Code for the TAB key.
         * @property KEY_TAB
         * @final
         * @type {Number}
         */_this32.KEY_TAB=9;/**
         * Code for the ENTER key.
         * @property KEY_ENTER
         * @final
         * @type {Number}
         */_this32.KEY_ENTER=13;/**
         * Code for the SHIFT key.
         * @property KEY_SHIFT
         * @final
         * @type {Number}
         */_this32.KEY_SHIFT=16;/**
         * Code for the CTRL key.
         * @property KEY_CTRL
         * @final
         * @type {Number}
         */_this32.KEY_CTRL=17;/**
         * Code for the ALT key.
         * @property KEY_ALT
         * @final
         * @type {Number}
         */_this32.KEY_ALT=18;/**
         * Code for the PAUSE_BREAK key.
         * @property KEY_PAUSE_BREAK
         * @final
         * @type {Number}
         */_this32.KEY_PAUSE_BREAK=19;/**
         * Code for the CAPS_LOCK key.
         * @property KEY_CAPS_LOCK
         * @final
         * @type {Number}
         */_this32.KEY_CAPS_LOCK=20;/**
         * Code for the ESCAPE key.
         * @property KEY_ESCAPE
         * @final
         * @type {Number}
         */_this32.KEY_ESCAPE=27;/**
         * Code for the PAGE_UP key.
         * @property KEY_PAGE_UP
         * @final
         * @type {Number}
         */_this32.KEY_PAGE_UP=33;/**
         * Code for the PAGE_DOWN key.
         * @property KEY_PAGE_DOWN
         * @final
         * @type {Number}
         */_this32.KEY_PAGE_DOWN=34;/**
         * Code for the END key.
         * @property KEY_END
         * @final
         * @type {Number}
         */_this32.KEY_END=35;/**
         * Code for the HOME key.
         * @property KEY_HOME
         * @final
         * @type {Number}
         */_this32.KEY_HOME=36;/**
         * Code for the LEFT_ARROW key.
         * @property KEY_LEFT_ARROW
         * @final
         * @type {Number}
         */_this32.KEY_LEFT_ARROW=37;/**
         * Code for the UP_ARROW key.
         * @property KEY_UP_ARROW
         * @final
         * @type {Number}
         */_this32.KEY_UP_ARROW=38;/**
         * Code for the RIGHT_ARROW key.
         * @property KEY_RIGHT_ARROW
         * @final
         * @type {Number}
         */_this32.KEY_RIGHT_ARROW=39;/**
         * Code for the DOWN_ARROW key.
         * @property KEY_DOWN_ARROW
         * @final
         * @type {Number}
         */_this32.KEY_DOWN_ARROW=40;/**
         * Code for the INSERT key.
         * @property KEY_INSERT
         * @final
         * @type {Number}
         */_this32.KEY_INSERT=45;/**
         * Code for the DELETE key.
         * @property KEY_DELETE
         * @final
         * @type {Number}
         */_this32.KEY_DELETE=46;/**
         * Code for the 0 key.
         * @property KEY_NUM_0
         * @final
         * @type {Number}
         */_this32.KEY_NUM_0=48;/**
         * Code for the 1 key.
         * @property KEY_NUM_1
         * @final
         * @type {Number}
         */_this32.KEY_NUM_1=49;/**
         * Code for the 2 key.
         * @property KEY_NUM_2
         * @final
         * @type {Number}
         */_this32.KEY_NUM_2=50;/**
         * Code for the 3 key.
         * @property KEY_NUM_3
         * @final
         * @type {Number}
         */_this32.KEY_NUM_3=51;/**
         * Code for the 4 key.
         * @property KEY_NUM_4
         * @final
         * @type {Number}
         */_this32.KEY_NUM_4=52;/**
         * Code for the 5 key.
         * @property KEY_NUM_5
         * @final
         * @type {Number}
         */_this32.KEY_NUM_5=53;/**
         * Code for the 6 key.
         * @property KEY_NUM_6
         * @final
         * @type {Number}
         */_this32.KEY_NUM_6=54;/**
         * Code for the 7 key.
         * @property KEY_NUM_7
         * @final
         * @type {Number}
         */_this32.KEY_NUM_7=55;/**
         * Code for the 8 key.
         * @property KEY_NUM_8
         * @final
         * @type {Number}
         */_this32.KEY_NUM_8=56;/**
         * Code for the 9 key.
         * @property KEY_NUM_9
         * @final
         * @type {Number}
         */_this32.KEY_NUM_9=57;/**
         * Code for the A key.
         * @property KEY_A
         * @final
         * @type {Number}
         */_this32.KEY_A=65;/**
         * Code for the B key.
         * @property KEY_B
         * @final
         * @type {Number}
         */_this32.KEY_B=66;/**
         * Code for the C key.
         * @property KEY_C
         * @final
         * @type {Number}
         */_this32.KEY_C=67;/**
         * Code for the D key.
         * @property KEY_D
         * @final
         * @type {Number}
         */_this32.KEY_D=68;/**
         * Code for the E key.
         * @property KEY_E
         * @final
         * @type {Number}
         */_this32.KEY_E=69;/**
         * Code for the F key.
         * @property KEY_F
         * @final
         * @type {Number}
         */_this32.KEY_F=70;/**
         * Code for the G key.
         * @property KEY_G
         * @final
         * @type {Number}
         */_this32.KEY_G=71;/**
         * Code for the H key.
         * @property KEY_H
         * @final
         * @type {Number}
         */_this32.KEY_H=72;/**
         * Code for the I key.
         * @property KEY_I
         * @final
         * @type {Number}
         */_this32.KEY_I=73;/**
         * Code for the J key.
         * @property KEY_J
         * @final
         * @type {Number}
         */_this32.KEY_J=74;/**
         * Code for the K key.
         * @property KEY_K
         * @final
         * @type {Number}
         */_this32.KEY_K=75;/**
         * Code for the L key.
         * @property KEY_L
         * @final
         * @type {Number}
         */_this32.KEY_L=76;/**
         * Code for the M key.
         * @property KEY_M
         * @final
         * @type {Number}
         */_this32.KEY_M=77;/**
         * Code for the N key.
         * @property KEY_N
         * @final
         * @type {Number}
         */_this32.KEY_N=78;/**
         * Code for the O key.
         * @property KEY_O
         * @final
         * @type {Number}
         */_this32.KEY_O=79;/**
         * Code for the P key.
         * @property KEY_P
         * @final
         * @type {Number}
         */_this32.KEY_P=80;/**
         * Code for the Q key.
         * @property KEY_Q
         * @final
         * @type {Number}
         */_this32.KEY_Q=81;/**
         * Code for the R key.
         * @property KEY_R
         * @final
         * @type {Number}
         */_this32.KEY_R=82;/**
         * Code for the S key.
         * @property KEY_S
         * @final
         * @type {Number}
         */_this32.KEY_S=83;/**
         * Code for the T key.
         * @property KEY_T
         * @final
         * @type {Number}
         */_this32.KEY_T=84;/**
         * Code for the U key.
         * @property KEY_U
         * @final
         * @type {Number}
         */_this32.KEY_U=85;/**
         * Code for the V key.
         * @property KEY_V
         * @final
         * @type {Number}
         */_this32.KEY_V=86;/**
         * Code for the W key.
         * @property KEY_W
         * @final
         * @type {Number}
         */_this32.KEY_W=87;/**
         * Code for the X key.
         * @property KEY_X
         * @final
         * @type {Number}
         */_this32.KEY_X=88;/**
         * Code for the Y key.
         * @property KEY_Y
         * @final
         * @type {Number}
         */_this32.KEY_Y=89;/**
         * Code for the Z key.
         * @property KEY_Z
         * @final
         * @type {Number}
         */_this32.KEY_Z=90;/**
         * Code for the LEFT_WINDOW key.
         * @property KEY_LEFT_WINDOW
         * @final
         * @type {Number}
         */_this32.KEY_LEFT_WINDOW=91;/**
         * Code for the RIGHT_WINDOW key.
         * @property KEY_RIGHT_WINDOW
         * @final
         * @type {Number}
         */_this32.KEY_RIGHT_WINDOW=92;/**
         * Code for the SELECT key.
         * @property KEY_SELECT
         * @final
         * @type {Number}
         */_this32.KEY_SELECT_KEY=93;/**
         * Code for the number pad 0 key.
         * @property KEY_NUMPAD_0
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_0=96;/**
         * Code for the number pad 1 key.
         * @property KEY_NUMPAD_1
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_1=97;/**
         * Code for the number pad 2 key.
         * @property KEY_NUMPAD 2
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_2=98;/**
         * Code for the number pad 3 key.
         * @property KEY_NUMPAD_3
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_3=99;/**
         * Code for the number pad 4 key.
         * @property KEY_NUMPAD_4
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_4=100;/**
         * Code for the number pad 5 key.
         * @property KEY_NUMPAD_5
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_5=101;/**
         * Code for the number pad 6 key.
         * @property KEY_NUMPAD_6
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_6=102;/**
         * Code for the number pad 7 key.
         * @property KEY_NUMPAD_7
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_7=103;/**
         * Code for the number pad 8 key.
         * @property KEY_NUMPAD_8
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_8=104;/**
         * Code for the number pad 9 key.
         * @property KEY_NUMPAD_9
         * @final
         * @type {Number}
         */_this32.KEY_NUMPAD_9=105;/**
         * Code for the MULTIPLY key.
         * @property KEY_MULTIPLY
         * @final
         * @type {Number}
         */_this32.KEY_MULTIPLY=106;/**
         * Code for the ADD key.
         * @property KEY_ADD
         * @final
         * @type {Number}
         */_this32.KEY_ADD=107;/**
         * Code for the SUBTRACT key.
         * @property KEY_SUBTRACT
         * @final
         * @type {Number}
         */_this32.KEY_SUBTRACT=109;/**
         * Code for the DECIMAL POINT key.
         * @property KEY_DECIMAL_POINT
         * @final
         * @type {Number}
         */_this32.KEY_DECIMAL_POINT=110;/**
         * Code for the DIVIDE key.
         * @property KEY_DIVIDE
         * @final
         * @type {Number}
         */_this32.KEY_DIVIDE=111;/**
         * Code for the F1 key.
         * @property KEY_F1
         * @final
         * @type {Number}
         */_this32.KEY_F1=112;/**
         * Code for the F2 key.
         * @property KEY_F2
         * @final
         * @type {Number}
         */_this32.KEY_F2=113;/**
         * Code for the F3 key.
         * @property KEY_F3
         * @final
         * @type {Number}
         */_this32.KEY_F3=114;/**
         * Code for the F4 key.
         * @property KEY_F4
         * @final
         * @type {Number}
         */_this32.KEY_F4=115;/**
         * Code for the F5 key.
         * @property KEY_F5
         * @final
         * @type {Number}
         */_this32.KEY_F5=116;/**
         * Code for the F6 key.
         * @property KEY_F6
         * @final
         * @type {Number}
         */_this32.KEY_F6=117;/**
         * Code for the F7 key.
         * @property KEY_F7
         * @final
         * @type {Number}
         */_this32.KEY_F7=118;/**
         * Code for the F8 key.
         * @property KEY_F8
         * @final
         * @type {Number}
         */_this32.KEY_F8=119;/**
         * Code for the F9 key.
         * @property KEY_F9
         * @final
         * @type {Number}
         */_this32.KEY_F9=120;/**
         * Code for the F10 key.
         * @property KEY_F10
         * @final
         * @type {Number}
         */_this32.KEY_F10=121;/**
         * Code for the F11 key.
         * @property KEY_F11
         * @final
         * @type {Number}
         */_this32.KEY_F11=122;/**
         * Code for the F12 key.
         * @property KEY_F12
         * @final
         * @type {Number}
         */_this32.KEY_F12=123;/**
         * Code for the NUM_LOCK key.
         * @property KEY_NUM_LOCK
         * @final
         * @type {Number}
         */_this32.KEY_NUM_LOCK=144;/**
         * Code for the SCROLL_LOCK key.
         * @property KEY_SCROLL_LOCK
         * @final
         * @type {Number}
         */_this32.KEY_SCROLL_LOCK=145;/**
         * Code for the SEMI_COLON key.
         * @property KEY_SEMI_COLON
         * @final
         * @type {Number}
         */_this32.KEY_SEMI_COLON=186;/**
         * Code for the EQUAL_SIGN key.
         * @property KEY_EQUAL_SIGN
         * @final
         * @type {Number}
         */_this32.KEY_EQUAL_SIGN=187;/**
         * Code for the COMMA key.
         * @property KEY_COMMA
         * @final
         * @type {Number}
         */_this32.KEY_COMMA=188;/**
         * Code for the DASH key.
         * @property KEY_DASH
         * @final
         * @type {Number}
         */_this32.KEY_DASH=189;/**
         * Code for the PERIOD key.
         * @property KEY_PERIOD
         * @final
         * @type {Number}
         */_this32.KEY_PERIOD=190;/**
         * Code for the FORWARD_SLASH key.
         * @property KEY_FORWARD_SLASH
         * @final
         * @type {Number}
         */_this32.KEY_FORWARD_SLASH=191;/**
         * Code for the GRAVE_ACCENT key.
         * @property KEY_GRAVE_ACCENT
         * @final
         * @type {Number}
         */_this32.KEY_GRAVE_ACCENT=192;/**
         * Code for the OPEN_BRACKET key.
         * @property KEY_OPEN_BRACKET
         * @final
         * @type {Number}
         */_this32.KEY_OPEN_BRACKET=219;/**
         * Code for the BACK_SLASH key.
         * @property KEY_BACK_SLASH
         * @final
         * @type {Number}
         */_this32.KEY_BACK_SLASH=220;/**
         * Code for the CLOSE_BRACKET key.
         * @property KEY_CLOSE_BRACKET
         * @final
         * @type {Number}
         */_this32.KEY_CLOSE_BRACKET=221;/**
         * Code for the SINGLE_QUOTE key.
         * @property KEY_SINGLE_QUOTE
         * @final
         * @type {Number}
         */_this32.KEY_SINGLE_QUOTE=222;/**
         * Code for the SPACE key.
         * @property KEY_SPACE
         * @final
         * @type {Number}
         */_this32.KEY_SPACE=32;/**
         * The canvas element that mouse and keyboards are bound to.
         *
         * @final
         * @type {HTMLCanvasElement}
         */_this32.element=cfg.element;/** True whenever ALT key is down.
         *
         * @type {boolean}
         */_this32.altDown=false;/** True whenever CTRL key is down.
         *
         * @type {boolean}
         */_this32.ctrlDown=false;/** True whenever left mouse button is down.
         *
         * @type {boolean}
         */_this32.mouseDownLeft=false;/**
         * True whenever middle mouse button is down.
         *
         * @type {boolean}
         */_this32.mouseDownMiddle=false;/**
         * True whenever the right mouse button is down.
         *
         * @type {boolean}
         */_this32.mouseDownRight=false;/**
         * Flag for each key that's down.
         *
         * @type {boolean[]}
         */_this32.keyDown=[];/** True while input enabled
         *
         * @type {boolean}
         */_this32.enabled=true;/** True while keyboard input is enabled.
         *
         * Default value is ````true````.
         *
         * {@link CameraControl} will not respond to keyboard events while this is ````false````.
         *
         * @type {boolean}
         */_this32.keyboardEnabled=true;/** True while the mouse is over the canvas.
         *
         * @type {boolean}
         */_this32.mouseover=false;/**
         * Current mouse position within the canvas.
         * @type {Number[]}
         */_this32.mouseCanvasPos=math.vec2();_this32._keyboardEventsElement=cfg.keyboardEventsElement||document;_this32._bindEvents();return _this32;}_createClass(Input,[{key:"_bindEvents",value:function _bindEvents(){var _this33=this;if(this._eventsBound){return;}this._keyboardEventsElement.addEventListener("keydown",this._keyDownListener=function(e){if(!_this33.enabled||!_this33.keyboardEnabled){return;}if(e.target.tagName!=="INPUT"&&e.target.tagName!=="TEXTAREA"){if(e.keyCode===_this33.KEY_CTRL){_this33.ctrlDown=true;}else if(e.keyCode===_this33.KEY_ALT){_this33.altDown=true;}else if(e.keyCode===_this33.KEY_SHIFT){_this33.shiftDown=true;}_this33.keyDown[e.keyCode]=true;_this33.fire("keydown",e.keyCode,true);}},false);this._keyboardEventsElement.addEventListener("keyup",this._keyUpListener=function(e){if(!_this33.enabled||!_this33.keyboardEnabled){return;}if(e.target.tagName!=="INPUT"&&e.target.tagName!=="TEXTAREA"){if(e.keyCode===_this33.KEY_CTRL){_this33.ctrlDown=false;}else if(e.keyCode===_this33.KEY_ALT){_this33.altDown=false;}else if(e.keyCode===_this33.KEY_SHIFT){_this33.shiftDown=false;}_this33.keyDown[e.keyCode]=false;_this33.fire("keyup",e.keyCode,true);}});this.element.addEventListener("mouseenter",this._mouseEnterListener=function(e){if(!_this33.enabled){return;}_this33.mouseover=true;_this33._getMouseCanvasPos(e);_this33.fire("mouseenter",_this33.mouseCanvasPos,true);});this.element.addEventListener("mouseleave",this._mouseLeaveListener=function(e){if(!_this33.enabled){return;}_this33.mouseover=false;_this33._getMouseCanvasPos(e);_this33.fire("mouseleave",_this33.mouseCanvasPos,true);});this.element.addEventListener("mousedown",this._mouseDownListener=function(e){if(!_this33.enabled){return;}switch(e.which){case 1:// Left button
_this33.mouseDownLeft=true;break;case 2:// Middle/both buttons
_this33.mouseDownMiddle=true;break;case 3:// Right button
_this33.mouseDownRight=true;break;}_this33._getMouseCanvasPos(e);_this33.element.focus();_this33.fire("mousedown",_this33.mouseCanvasPos,true);if(_this33.mouseover){e.preventDefault();}});document.addEventListener("mouseup",this._mouseUpListener=function(e){if(!_this33.enabled){return;}switch(e.which){case 1:// Left button
_this33.mouseDownLeft=false;break;case 2:// Middle/both buttons
_this33.mouseDownMiddle=false;break;case 3:// Right button
_this33.mouseDownRight=false;break;}_this33.fire("mouseup",_this33.mouseCanvasPos,true);// if (this.mouseover) {
//     e.preventDefault();
// }
},true);document.addEventListener("click",this._clickListener=function(e){if(!_this33.enabled){return;}switch(e.which){case 1:// Left button
_this33.mouseDownLeft=false;_this33.mouseDownRight=false;break;case 2:// Middle/both buttons
_this33.mouseDownMiddle=false;break;case 3:// Right button
_this33.mouseDownLeft=false;_this33.mouseDownRight=false;break;}_this33._getMouseCanvasPos(e);_this33.fire("click",_this33.mouseCanvasPos,true);if(_this33.mouseover){e.preventDefault();}});document.addEventListener("dblclick",this._dblClickListener=function(e){if(!_this33.enabled){return;}switch(e.which){case 1:// Left button
_this33.mouseDownLeft=false;_this33.mouseDownRight=false;break;case 2:// Middle/both buttons
_this33.mouseDownMiddle=false;break;case 3:// Right button
_this33.mouseDownLeft=false;_this33.mouseDownRight=false;break;}_this33._getMouseCanvasPos(e);_this33.fire("dblclick",_this33.mouseCanvasPos,true);if(_this33.mouseover){e.preventDefault();}});var tickifedMouseMoveFn=this.scene.tickify(function(){return _this33.fire("mousemove",_this33.mouseCanvasPos,true);});this.element.addEventListener("mousemove",this._mouseMoveListener=function(e){if(!_this33.enabled){return;}_this33._getMouseCanvasPos(e);tickifedMouseMoveFn();if(_this33.mouseover){e.preventDefault();}});var tickifiedMouseWheelFn=this.scene.tickify(function(delta){_this33.fire("mousewheel",delta,true);});this.element.addEventListener("wheel",this._mouseWheelListener=function(e,d){if(!_this33.enabled){return;}var delta=Math.max(-1,Math.min(1,-e.deltaY*40));tickifiedMouseWheelFn(delta);},{passive:true});// mouseclicked
{var downX;var downY;// Tolerance between down and up positions for a mouse click
var tolerance=2;this.on("mousedown",function(params){downX=params[0];downY=params[1];});this.on("mouseup",function(params){if(downX>=params[0]-tolerance&&downX<=params[0]+tolerance&&downY>=params[1]-tolerance&&downY<=params[1]+tolerance){_this33.fire("mouseclicked",params,true);}});}this._eventsBound=true;}},{key:"_unbindEvents",value:function _unbindEvents(){if(!this._eventsBound){return;}this._keyboardEventsElement.removeEventListener("keydown",this._keyDownListener);this._keyboardEventsElement.removeEventListener("keyup",this._keyUpListener);this.element.removeEventListener("mouseenter",this._mouseEnterListener);this.element.removeEventListener("mouseleave",this._mouseLeaveListener);this.element.removeEventListener("mousedown",this._mouseDownListener);document.removeEventListener("mouseup",this._mouseDownListener);document.removeEventListener("click",this._clickListener);document.removeEventListener("dblclick",this._dblClickListener);this.element.removeEventListener("mousemove",this._mouseMoveListener);this.element.removeEventListener("wheel",this._mouseWheelListener);if(window.OrientationChangeEvent){window.removeEventListener('orientationchange',this._orientationchangedListener);}if(window.DeviceMotionEvent){window.removeEventListener('devicemotion',this._deviceMotionListener);}if(window.DeviceOrientationEvent){window.removeEventListener("deviceorientation",this._deviceOrientListener);}this._eventsBound=false;}},{key:"_getMouseCanvasPos",value:function _getMouseCanvasPos(event){if(!event){event=window.event;this.mouseCanvasPos[0]=event.x;this.mouseCanvasPos[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent;}this.mouseCanvasPos[0]=event.pageX-totalOffsetLeft;this.mouseCanvasPos[1]=event.pageY-totalOffsetTop;}}/**
     * Sets whether input handlers are enabled.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} enable Indicates if input handlers are enabled.
     */},{key:"setEnabled",value:function setEnabled(enable){if(this.enabled!==enable){this.fire("enabled",this.enabled=enable);}}/**
     * Gets whether input handlers are enabled.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Indicates if input handlers are enabled.
     */},{key:"getEnabled",value:function getEnabled(){return this.enabled;}/**
     * Sets whether or not keyboard input is enabled.
     *
     * Default value is ````true````.
     *
     * {@link CameraControl} will not respond to keyboard events while this is set ````false````.
     *
     * @param {Boolean} value Indicates whether keyboard input is enabled.
     */},{key:"setKeyboardEnabled",value:function setKeyboardEnabled(value){this.keyboardEnabled=value;}/**
     * Gets whether keyboard input is enabled.
     *
     * Default value is ````true````.
     *
     * {@link CameraControl} will not respond to keyboard events while this is set ````false````.
     *
     * @returns {Boolean} Returns whether keyboard input is enabled.
     */},{key:"getKeyboardEnabled",value:function getKeyboardEnabled(){return this.keyboardEnabled;}/**
     * @private
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Input.prototype),"destroy",this).call(this);this._unbindEvents();}}]);return Input;}(Component);var ids$3=new Map$1({});/**
 * @desc Represents a chunk of state changes applied by the {@link Scene}'s renderer while it renders a frame.
 *
 * * Contains properties that represent the state changes.
 * * Has a unique automatically-generated numeric ID, which the renderer can use to sort these, in order to avoid applying redundant state changes for each frame.
 * * Initialize your own properties on a RenderState via its constructor.
 *
 * @private
 */var RenderState=/*#__PURE__*/function(){function RenderState(cfg){_classCallCheck(this,RenderState);/**
         The RenderState's ID, unique within the renderer.
         @property id
         @type {Number}
         @final
         */this.id=ids$3.addItem({});for(var key in cfg){if(cfg.hasOwnProperty(key)){this[key]=cfg[key];}}}/**
     Destroys this RenderState.
     */_createClass(RenderState,[{key:"destroy",value:function destroy(){ids$3.removeItem(this.id);}}]);return RenderState;}();/**
 * @desc controls the canvas viewport for a {@link Scene}.
 *
 * * One Viewport per scene.
 * * You can configure a Scene to render multiple times per frame, while setting the Viewport to different extents on each render.
 * * Make a Viewport automatically size to its {@link Scene} {@link Canvas} by setting its {@link Viewport#autoBoundary} ````true````.
 *
 *
 * Configuring the Scene to render twice on each frame, each time to a separate viewport:
 *
 * ````Javascript
 * // Load glTF model
 * var model = new xeokit.GLTFModel({
    src: "models/gltf/GearboxAssy/glTF-MaterialsCommon/GearboxAssy.gltf"
 });

 var scene = model.scene;
 var viewport = scene.viewport;

 // Configure Scene to render twice for each frame
 scene.passes = 2; // Default is 1
 scene.clearEachPass = false; // Default is false

 // Render to a separate viewport on each render

 var viewport = scene.viewport;
 viewport.autoBoundary = false;

 scene.on("rendering", function (e) {
     switch (e.pass) {
         case 0:
             viewport.boundary = [0, 0, 200, 200]; // xmin, ymin, width, height
             break;

         case 1:
             viewport.boundary = [200, 0, 200, 200];
             break;
     }
 });
 ````

 @class Viewport
 @module xeokit
 @submodule rendering
 @constructor
 @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
 @param {*} [cfg] Viewport configuration
 @param {String} [cfg.id] Optional ID, unique among all components in the parent
 {@link Scene}, generated automatically when omitted.
 @param {String:Object} [cfg.meta] Optional map of user-defined metadata to attach to this Viewport.
 @param [cfg.boundary] {Number[]} Canvas-space Viewport boundary, given as
 (min, max, width, height). Defaults to the size of the parent
 {@link Scene} {@link Canvas}.
 @param [cfg.autoBoundary=false] {Boolean} Indicates if this Viewport's {@link Viewport#boundary}
 automatically synchronizes with the size of the parent {@link Scene} {@link Canvas}.

 @extends Component
 */var Viewport=/*#__PURE__*/function(_Component9){_inherits(Viewport,_Component9);var _super14=_createSuper(Viewport);/**
     @private
     */function Viewport(owner){var _this34;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Viewport);_this34=_super14.call(this,owner,cfg);_this34._state=new RenderState({boundary:[0,0,100,100]});_this34.boundary=cfg.boundary;_this34.autoBoundary=cfg.autoBoundary;return _this34;}/**
     * Sets the canvas-space boundary of this Viewport, indicated as ````[min, max, width, height]````.
     *
     * When {@link Viewport#autoBoundary} is ````true````, ignores calls to this method and automatically synchronizes with {@link Canvas#boundary}.
     *
     * Fires a "boundary"" event on change.
     *
     * Defaults to the {@link Canvas} extents.
     *
     * @param {Number[]} value New Viewport extents.
     */_createClass(Viewport,[{key:"type",get:/**
     @private
     */function get(){return"Viewport";}},{key:"boundary",get:/**
     * Gets the canvas-space boundary of this Viewport, indicated as ````[min, max, width, height]````.
     *
     * @returns {Number[]} The Viewport extents.
     */function get(){return this._state.boundary;}/**
     * Sets if {@link Viewport#boundary} automatically synchronizes with {@link Canvas#boundary}.
     *
     * Default is ````false````.
     *
     * @param {Boolean} value Set true to automatically sycnhronize.
     */,set:function set(value){if(this._autoBoundary){return;}if(!value){var canvasBoundary=this.scene.canvas.boundary;var width=canvasBoundary[2];var height=canvasBoundary[3];value=[0,0,width,height];}this._state.boundary=value;this.glRedraw();/**
         Fired whenever this Viewport's {@link Viewport#boundary} property changes.

         @event boundary
         @param value {Boolean} The property's new value
         */this.fire("boundary",this._state.boundary);}},{key:"autoBoundary",get:/**
     * Gets if {@link Viewport#boundary} automatically synchronizes with {@link Canvas#boundary}.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when automatically sycnhronizing.
     */function get(){return this._autoBoundary;},set:function set(value){value=!!value;if(value===this._autoBoundary){return;}this._autoBoundary=value;if(this._autoBoundary){this._onCanvasSize=this.scene.canvas.on("boundary",function(boundary){var width=boundary[2];var height=boundary[3];this._state.boundary=[0,0,width,height];this.glRedraw();/**
                     Fired whenever this Viewport's {@link Viewport#boundary} property changes.

                     @event boundary
                     @param value {Boolean} The property's new value
                     */this.fire("boundary",this._state.boundary);},this);}else if(this._onCanvasSize){this.scene.canvas.off(this._onCanvasSize);this._onCanvasSize=null;}/**
         Fired whenever this Viewport's {@link autoBoundary/autoBoundary} property changes.

         @event autoBoundary
         @param value The property's new value
         */this.fire("autoBoundary",this._autoBoundary);}},{key:"_getState",value:function _getState(){return this._state;}/**
     * @private
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Viewport.prototype),"destroy",this).call(this);this._state.destroy();}}]);return Viewport;}(Component);/**
 * @desc Defines its {@link Camera}'s perspective projection using a field-of-view angle.
 *
 * * Located at {@link Camera#perspective}.
 * * Implicitly sets the left, right, top, bottom frustum planes using {@link Perspective#fov}.
 * * {@link Perspective#near} and {@link Perspective#far} specify the distances to the WebGL clipping planes.
 */var Perspective=/*#__PURE__*/function(_Component10){_inherits(Perspective,_Component10);var _super15=_createSuper(Perspective);/**
     * @constructor
     * @private
     */function Perspective(camera){var _this35;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Perspective);_this35=_super15.call(this,camera,cfg);/**
         * The Camera this Perspective belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */_this35.camera=camera;_this35._state=new RenderState({matrix:math.mat4(),inverseMatrix:math.mat4(),transposedMatrix:math.mat4(),near:0.1,far:10000.0});_this35._inverseMatrixDirty=true;_this35._transposedMatrixDirty=true;_this35._fov=60.0;// Recompute aspect from change in canvas size
_this35._canvasResized=_this35.scene.canvas.on("boundary",_this35._needUpdate,_assertThisInitialized(_this35));_this35.fov=cfg.fov;_this35.fovAxis=cfg.fovAxis;_this35.near=cfg.near;_this35.far=cfg.far;return _this35;}_createClass(Perspective,[{key:"type",get:/**
     @private
     */function get(){return"Perspective";}},{key:"_update",value:function _update(){var WIDTH_INDEX=2;var HEIGHT_INDEX=3;var boundary=this.scene.canvas.boundary;var aspect=boundary[WIDTH_INDEX]/boundary[HEIGHT_INDEX];var fovAxis=this._fovAxis;var fov=this._fov;if(fovAxis==="x"||fovAxis==="min"&&aspect<1||fovAxis==="max"&&aspect>1){fov=fov/aspect;}fov=Math.min(fov,120);math.perspectiveMat4(fov*(Math.PI/180.0),aspect,this._state.near,this._state.far,this._state.matrix);this._inverseMatrixDirty=true;this._transposedMatrixDirty=true;this.glRedraw();this.camera._updateScheduled=true;this.fire("matrix",this._state.matrix);}/**
     * Sets the Perspective's field-of-view angle (FOV).
     *
     * Fires an "fov" event on change.

     * Default value is ````60.0````.
     *
     * @param {Number} value New field-of-view.
     */},{key:"fov",get:/**
     * Gets the Perspective's field-of-view angle (FOV).
     *
     * Default value is ````60.0````.
     *
     * @returns {Number} Current field-of-view.
     */function get(){return this._fov;}/**
     * Sets the Perspective's FOV axis.
     *
     * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
     *
     * Fires an "fovAxis" event on change.

     * Default value ````"min"````.
     *
     * @param {String} value New FOV axis value.
     */,set:function set(value){value=value!==undefined&&value!==null?value:60.0;if(value===this._fov){return;}this._fov=value;this._needUpdate(0);// Ensure matrix built on next "tick"
this.fire("fov",this._fov);}},{key:"fovAxis",get:/**
     * Gets the Perspective's FOV axis.
     *
     * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
     *
     * Fires an "fovAxis" event on change.

     * Default value is ````"min"````.
     *
     * @returns {String} The current FOV axis value.
     */function get(){return this._fovAxis;}/**
     * Sets the position of the Perspective's near plane on the positive View-space Z-axis.
     *
     * Fires a "near" event on change.
     *
     * Default value is ````0.1````.
     *
     * @param {Number} value New Perspective near plane position.
     */,set:function set(value){value=value||"min";if(this._fovAxis===value){return;}if(value!=="x"&&value!=="y"&&value!=="min"){this.error("Unsupported value for 'fovAxis': "+value+" - defaulting to 'min'");value="min";}this._fovAxis=value;this._needUpdate(0);// Ensure matrix built on next "tick"
this.fire("fovAxis",this._fovAxis);}},{key:"near",get:/**
     * Gets the position of the Perspective's near plane on the positive View-space Z-axis.
     *
     * Fires an "emits" emits on change.
     *
     * Default value is ````0.1````.
     *
     * @returns The Perspective's near plane position.
     */function get(){return this._state.near;}/**
     * Sets the position of this Perspective's far plane on the positive View-space Z-axis.
     *
     * Fires a "far" event on change.
     *
     * Default value is ````10000.0````.
     *
     * @param {Number} value New Perspective far plane position.
     */,set:function set(value){var near=value!==undefined&&value!==null?value:0.1;if(this._state.near===near){return;}this._state.near=near;this._needUpdate(0);// Ensure matrix built on next "tick"
this.fire("near",this._state.near);}},{key:"far",get:/**
     * Gets the position of this Perspective's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @return {Number} The Perspective's far plane position.
     */function get(){return this._state.far;}/**
     * Gets the Perspective's projection transform matrix.
     *
     * Fires a "matrix" event on change.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns {Number[]} The Perspective's projection matrix.
     */,set:function set(value){var far=value!==undefined&&value!==null?value:10000.0;if(this._state.far===far){return;}this._state.far=far;this._needUpdate(0);// Ensure matrix built on next "tick"
this.fire("far",this._state.far);}},{key:"matrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.matrix;}/**
     * Gets the inverse of {@link Perspective#matrix}.
     *
     * @returns {Number[]} The inverse of {@link Perspective#matrix}.
     */},{key:"inverseMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._inverseMatrixDirty){math.inverseMat4(this._state.matrix,this._state.inverseMatrix);this._inverseMatrixDirty=false;}return this._state.inverseMatrix;}/**
     * Gets the transpose of {@link Perspective#matrix}.
     *
     * @returns {Number[]} The transpose of {@link Perspective#matrix}.
     */},{key:"transposedMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._transposedMatrixDirty){math.transposeMat4(this._state.matrix,this._state.transposedMatrix);this._transposedMatrixDirty=false;}return this._state.transposedMatrix;}/**
     * Un-projects the given Canvas-space coordinates and Screen-space depth, using this Perspective projection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */},{key:"unproject",value:function unproject(canvasPos,screenZ,screenPos,viewPos,worldPos){var canvas=this.scene.canvas.canvas;var halfCanvasWidth=canvas.offsetWidth/2.0;var halfCanvasHeight=canvas.offsetHeight/2.0;screenPos[0]=(canvasPos[0]-halfCanvasWidth)/halfCanvasWidth;screenPos[1]=(canvasPos[1]-halfCanvasHeight)/halfCanvasHeight;screenPos[2]=screenZ;screenPos[3]=1.0;math.mulMat4v4(this.inverseMatrix,screenPos,viewPos);math.mulVec3Scalar(viewPos,1.0/viewPos[3]);viewPos[3]=1.0;viewPos[1]*=-1;math.mulMat4v4(this.camera.inverseViewMatrix,viewPos,worldPos);return worldPos;}/** @private
     *
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Perspective.prototype),"destroy",this).call(this);this._state.destroy();this.scene.canvas.off(this._canvasResized);}}]);return Perspective;}(Component);/**
 * @desc Defines its {@link Camera}'s orthographic projection as a box-shaped view volume.
 *
 * * Located at {@link Camera#ortho}.
 * * Works like Blender's orthographic projection, where the positions of the left, right, top and bottom planes are implicitly
 * indicated with a single {@link Ortho#scale} property, which causes the frustum to be symmetrical on X and Y axis, large enough to
 * contain the number of units given by {@link Ortho#scale}.
 * * {@link Ortho#near} and {@link Ortho#far} indicated the distances to the WebGL clipping planes.
 */var Ortho=/*#__PURE__*/function(_Component11){_inherits(Ortho,_Component11);var _super16=_createSuper(Ortho);/**
     * @constructor
     * @private
     */function Ortho(camera){var _this36;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Ortho);_this36=_super16.call(this,camera,cfg);/**
         * The Camera this Ortho belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */_this36.camera=camera;_this36._state=new RenderState({matrix:math.mat4(),inverseMatrix:math.mat4(),transposedMatrix:math.mat4(),near:0.1,far:10000.0});_this36._inverseMatrixDirty=true;_this36._transposedMatrixDirty=true;_this36.scale=cfg.scale;_this36.near=cfg.near;_this36.far=cfg.far;_this36._onCanvasBoundary=_this36.scene.canvas.on("boundary",_this36._needUpdate,_assertThisInitialized(_this36));return _this36;}_createClass(Ortho,[{key:"type",get:/**
     @private
     */function get(){return"Ortho";}},{key:"_update",value:function _update(){var WIDTH_INDEX=2;var HEIGHT_INDEX=3;var scene=this.scene;var scale=this._scale;var halfSize=0.5*scale;var boundary=scene.canvas.boundary;var boundaryWidth=boundary[WIDTH_INDEX];var boundaryHeight=boundary[HEIGHT_INDEX];var aspect=boundaryWidth/boundaryHeight;var left;var right;var top;var bottom;if(boundaryWidth>boundaryHeight){left=-halfSize;right=halfSize;top=halfSize/aspect;bottom=-halfSize/aspect;}else{left=-halfSize*aspect;right=halfSize*aspect;top=halfSize;bottom=-halfSize;}math.orthoMat4c(left,right,bottom,top,this._state.near,this._state.far,this._state.matrix);this._inverseMatrixDirty=true;this._transposedMatrixDirty=true;this.glRedraw();this.fire("matrix",this._state.matrix);}/**
     * Sets scale factor for this Ortho's extents on X and Y axis.
     *
     * Clamps to minimum value of ````0.01```.
     *
     * Fires a "scale" event on change.
     *
     * Default value is ````1.0````
     * @param {Number} value New scale value.
     */},{key:"scale",get:/**
     * Gets scale factor for this Ortho's extents on X and Y axis.
     *
     * Clamps to minimum value of ````0.01```.
     *
     * Default value is ````1.0````
     *
     * @returns {Number} New Ortho scale value.
     */function get(){return this._scale;}/**
     * Sets the position of the Ortho's near plane on the positive View-space Z-axis.
     *
     * Fires a "near" emits on change.
     *
     * Default value is ````0.1````.
     *
     * @param {Number} value New Ortho near plane position.
     */,set:function set(value){if(value===undefined||value===null){value=1.0;}if(value<=0){value=0.01;}this._scale=value;this._needUpdate(0);this.fire("scale",this._scale);}},{key:"near",get:/**
     * Gets the position of the Ortho's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @returns {Number} New Ortho near plane position.
     */function get(){return this._state.near;}/**
     * Sets the position of the Ortho's far plane on the positive View-space Z-axis.
     *
     * Fires a "far" event on change.
     *
     * Default value is ````10000.0````.
     *
     * @param {Number} value New far ortho plane position.
     */,set:function set(value){var near=value!==undefined&&value!==null?value:0.1;if(this._state.near===near){return;}this._state.near=near;this._needUpdate(0);this.fire("near",this._state.near);}},{key:"far",get:/**
     * Gets the position of the Ortho's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @returns {Number} New far ortho plane position.
     */function get(){return this._state.far;}/**
     * Gets the Ortho's projection transform matrix.
     *
     * Fires a "matrix" event on change.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns {Number[]} The Ortho's projection matrix.
     */,set:function set(value){var far=value!==undefined&&value!==null?value:10000.0;if(this._state.far===far){return;}this._state.far=far;this._needUpdate(0);this.fire("far",this._state.far);}},{key:"matrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.matrix;}/**
     * Gets the inverse of {@link Ortho#matrix}.
     *
     * @returns {Number[]} The inverse of {@link Ortho#matrix}.
     */},{key:"inverseMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._inverseMatrixDirty){math.inverseMat4(this._state.matrix,this._state.inverseMatrix);this._inverseMatrixDirty=false;}return this._state.inverseMatrix;}/**
     * Gets the transpose of {@link Ortho#matrix}.
     *
     * @returns {Number[]} The transpose of {@link Ortho#matrix}.
     */},{key:"transposedMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._transposedMatrixDirty){math.transposeMat4(this._state.matrix,this._state.transposedMatrix);this._transposedMatrixDirty=false;}return this._state.transposedMatrix;}/**
     * Un-projects the given Canvas-space coordinates, using this Ortho projection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */},{key:"unproject",value:function unproject(canvasPos,screenZ,screenPos,viewPos,worldPos){var canvas=this.scene.canvas.canvas;var halfCanvasWidth=canvas.offsetWidth/2.0;var halfCanvasHeight=canvas.offsetHeight/2.0;screenPos[0]=(canvasPos[0]-halfCanvasWidth)/halfCanvasWidth;screenPos[1]=(canvasPos[1]-halfCanvasHeight)/halfCanvasHeight;screenPos[2]=screenZ;screenPos[3]=1.0;math.mulMat4v4(this.inverseMatrix,screenPos,viewPos);math.mulVec3Scalar(viewPos,1.0/viewPos[3]);viewPos[3]=1.0;viewPos[1]*=-1;math.mulMat4v4(this.camera.inverseViewMatrix,viewPos,worldPos);return worldPos;}/** @private
     *
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Ortho.prototype),"destroy",this).call(this);this._state.destroy();this.scene.canvas.off(this._onCanvasBoundary);}}]);return Ortho;}(Component);/**
 * @desc Defines its {@link Camera}'s perspective projection as a frustum-shaped view volume.
 *
 * * Located at {@link Camera#frustum}.
 * * Allows to explicitly set the positions of the left, right, top, bottom, near and far planes, which is useful for asymmetrical view volumes, such as for stereo viewing.
 * * {@link Frustum#near} and {@link Frustum#far} specify the distances to the WebGL clipping planes.
 */var Frustum=/*#__PURE__*/function(_Component12){_inherits(Frustum,_Component12);var _super17=_createSuper(Frustum);/**
     * @constructor
     * @private
     */function Frustum(camera){var _this37;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Frustum);_this37=_super17.call(this,camera,cfg);/**
         * The Camera this Frustum belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */_this37.camera=camera;_this37._state=new RenderState({matrix:math.mat4(),inverseMatrix:math.mat4(),transposedMatrix:math.mat4(),near:0.1,far:10000.0});_this37._left=-1.0;_this37._right=1.0;_this37._bottom=-1.0;_this37._top=1.0;_this37._inverseMatrixDirty=true;_this37._transposedMatrixDirty=true;// Set component properties
_this37.left=cfg.left;_this37.right=cfg.right;_this37.bottom=cfg.bottom;_this37.top=cfg.top;_this37.near=cfg.near;_this37.far=cfg.far;return _this37;}_createClass(Frustum,[{key:"type",get:/**
     @private
     */function get(){return"Frustum";}},{key:"_update",value:function _update(){math.frustumMat4(this._left,this._right,this._bottom,this._top,this._state.near,this._state.far,this._state.matrix);this._inverseMatrixDirty=true;this._transposedMatrixDirty=true;this.glRedraw();this.fire("matrix",this._state.matrix);}/**
     * Sets the position of the Frustum's left plane on the View-space X-axis.
     *
     * Fires a {@link Frustum#left:emits} emits on change.
     *
     * @param {Number} value New left frustum plane position.
     */},{key:"left",get:/**
     * Gets the position of the Frustum's left plane on the View-space X-axis.
     *
     * @return {Number} Left frustum plane position.
     */function get(){return this._left;}/**
     * Sets the position of the Frustum's right plane on the View-space X-axis.
     *
     * Fires a {@link Frustum#right:emits} emits on change.
     *
     * @param {Number} value New right frustum plane position.
     */,set:function set(value){this._left=value!==undefined&&value!==null?value:-1.0;this._needUpdate(0);this.fire("left",this._left);}},{key:"right",get:/**
     * Gets the position of the Frustum's right plane on the View-space X-axis.
     *
     * Fires a {@link Frustum#right:emits} emits on change.
     *
     * @return {Number} Right frustum plane position.
     */function get(){return this._right;}/**
     * Sets the position of the Frustum's top plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#top:emits} emits on change.
     *
     * @param {Number} value New top frustum plane position.
     */,set:function set(value){this._right=value!==undefined&&value!==null?value:1.0;this._needUpdate(0);this.fire("right",this._right);}},{key:"top",get:/**
     * Gets the position of the Frustum's top plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#top:emits} emits on change.
     *
     * @return {Number} Top frustum plane position.
     */function get(){return this._top;}/**
     * Sets the position of the Frustum's bottom plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#bottom:emits} emits on change.
     *
     * @emits {"bottom"} event with the value of this property whenever it changes.
     *
     * @param {Number} value New bottom frustum plane position.
     */,set:function set(value){this._top=value!==undefined&&value!==null?value:1.0;this._needUpdate(0);this.fire("top",this._top);}},{key:"bottom",get:/**
     * Gets the position of the Frustum's bottom plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#bottom:emits} emits on change.
     *
     * @return {Number} Bottom frustum plane position.
     */function get(){return this._bottom;}/**
     * Sets the position of the Frustum's near plane on the positive View-space Z-axis.
     *
     * Fires a {@link Frustum#near:emits} emits on change.
     *
     * Default value is ````0.1````.
     *
     * @param {Number} value New Frustum near plane position.
     */,set:function set(value){this._bottom=value!==undefined&&value!==null?value:-1.0;this._needUpdate(0);this.fire("bottom",this._bottom);}},{key:"near",get:/**
     * Gets the position of the Frustum's near plane on the positive View-space Z-axis.
     *
     * Fires a {@link Frustum#near:emits} emits on change.
     *
     * Default value is ````0.1````.
     *
     * @return {Number} Near frustum plane position.
     */function get(){return this._state.near;}/**
     * Sets the position of the Frustum's far plane on the positive View-space Z-axis.
     *
     * Fires a {@link Frustum#far:emits} emits on change.
     *
     * Default value is ````10000.0````.
     *
     * @param {Number} value New far frustum plane position.
     */,set:function set(value){this._state.near=value!==undefined&&value!==null?value:0.1;this._needUpdate(0);this.fire("near",this._state.near);}},{key:"far",get:/**
     * Gets the position of the Frustum's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @return {Number} Far frustum plane position.
     */function get(){return this._state.far;}/**
     * Gets the Frustum's projection transform matrix.
     *
     * Fires a {@link Frustum#matrix:emits} emits on change.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns {Number[]} The Frustum's projection matrix matrix.
     */,set:function set(value){this._state.far=value!==undefined&&value!==null?value:10000.0;this._needUpdate(0);this.fire("far",this._state.far);}},{key:"matrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.matrix;}/**
     * Gets the inverse of {@link Frustum#matrix}.
     *
     * @returns {Number[]} The inverse orthographic projection matrix.
     */},{key:"inverseMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._inverseMatrixDirty){math.inverseMat4(this._state.matrix,this._state.inverseMatrix);this._inverseMatrixDirty=false;}return this._state.inverseMatrix;}/**
     * Gets the transpose of {@link Frustum#matrix}.
     *
     * @returns {Number[]} The transpose of {@link Frustum#matrix}.
     */},{key:"transposedMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._transposedMatrixDirty){math.transposeMat4(this._state.matrix,this._state.transposedMatrix);this._transposedMatrixDirty=false;}return this._state.transposedMatrix;}/**
     * Un-projects the given Canvas-space coordinates, using this Frustum projection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */},{key:"unproject",value:function unproject(canvasPos,screenZ,screenPos,viewPos,worldPos){var canvas=this.scene.canvas.canvas;var halfCanvasWidth=canvas.offsetWidth/2.0;var halfCanvasHeight=canvas.offsetHeight/2.0;screenPos[0]=(canvasPos[0]-halfCanvasWidth)/halfCanvasWidth;screenPos[1]=(canvasPos[1]-halfCanvasHeight)/halfCanvasHeight;screenPos[2]=screenZ;screenPos[3]=1.0;math.mulMat4v4(this.inverseMatrix,screenPos,viewPos);math.mulVec3Scalar(viewPos,1.0/viewPos[3]);viewPos[3]=1.0;viewPos[1]*=-1;math.mulMat4v4(this.camera.inverseViewMatrix,viewPos,worldPos);return worldPos;}/** @private
     *
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Frustum.prototype),"destroy",this).call(this);this._state.destroy();_get(_getPrototypeOf(Frustum.prototype),"destroy",this).call(this);}}]);return Frustum;}(Component);/**
 * @desc Defines a custom projection for a {@link Camera} as a custom 4x4 matrix..
 *
 * Located at {@link Camera#customProjection}.
 */var CustomProjection=/*#__PURE__*/function(_Component13){_inherits(CustomProjection,_Component13);var _super18=_createSuper(CustomProjection);/**
     * @constructor
     * @private
     */function CustomProjection(camera){var _this38;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CustomProjection);_this38=_super18.call(this,camera,cfg);/**
         * The Camera this CustomProjection belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */_this38.camera=camera;_this38._state=new RenderState({matrix:math.mat4(),inverseMatrix:math.mat4(),transposedMatrix:math.mat4()});_this38._inverseMatrixDirty=true;_this38._transposedMatrixDirty=false;_this38.matrix=cfg.matrix;return _this38;}/**
     * Sets the CustomProjection's projection transform matrix.
     *
     * Fires a "matrix" event on change.

     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @param {Number[]} matrix New value for the CustomProjection's matrix.
     */_createClass(CustomProjection,[{key:"type",get:/**
     * @private
     */function get(){return"CustomProjection";}},{key:"matrix",get:/**
     * Gets the CustomProjection's projection transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @return {Number[]} New value for the CustomProjection's matrix.
     */function get(){return this._state.matrix;}/**
     * Gets the inverse of {@link CustomProjection#matrix}.
     *
     * @returns {Number[]} The inverse of {@link CustomProjection#matrix}.
     */,set:function set(matrix){this._state.matrix.set(matrix||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this._inverseMatrixDirty=true;this._transposedMatrixDirty=true;this.glRedraw();this.fire("matrix",this._state.matrix);}},{key:"inverseMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._inverseMatrixDirty){math.inverseMat4(this._state.matrix,this._state.inverseMatrix);this._inverseMatrixDirty=false;}return this._state.inverseMatrix;}/**
     * Gets the transpose of {@link CustomProjection#matrix}.
     *
     * @returns {Number[]} The transpose of {@link CustomProjection#matrix}.
     */},{key:"transposedMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}if(this._transposedMatrixDirty){math.transposeMat4(this._state.matrix,this._state.transposedMatrix);this._transposedMatrixDirty=false;}return this._state.transposedMatrix;}/**
     * Un-projects the given Canvas-space coordinates, using this CustomProjection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */},{key:"unproject",value:function unproject(canvasPos,screenZ,screenPos,viewPos,worldPos){var canvas=this.scene.canvas.canvas;var halfCanvasWidth=canvas.offsetWidth/2.0;var halfCanvasHeight=canvas.offsetHeight/2.0;screenPos[0]=(canvasPos[0]-halfCanvasWidth)/halfCanvasWidth;screenPos[1]=(canvasPos[1]-halfCanvasHeight)/halfCanvasHeight;screenPos[2]=screenZ;screenPos[3]=1.0;math.mulMat4v4(this.inverseMatrix,screenPos,viewPos);math.mulVec3Scalar(viewPos,1.0/viewPos[3]);viewPos[3]=1.0;viewPos[1]*=-1;math.mulMat4v4(this.camera.inverseViewMatrix,viewPos,worldPos);return worldPos;}/** @private
     *
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(CustomProjection.prototype),"destroy",this).call(this);this._state.destroy();}}]);return CustomProjection;}(Component);var tempVec3$6=math.vec3();var tempVec3b$y=math.vec3();var tempVec3c$u=math.vec3();var tempVec3d$d=math.vec3();var tempVec3e$2=math.vec3();var tempVec3f$2=math.vec3();var tempVec4a$8=math.vec4();var tempVec4b$5=math.vec4();var tempVec4c$2=math.vec4();var tempMat=math.mat4();var tempMatb=math.mat4();var eyeLookVec=math.vec3();var eyeLookVecNorm=math.vec3();var eyeLookOffset=math.vec3();var offsetEye=math.vec3();/**
 * @desc Manages viewing and projection transforms for its {@link Scene}.
 *
 * * One Camera per {@link Scene}
 * * Scene is located at {@link Viewer#scene} and Camera is located at {@link Scene#camera}
 * * Controls viewing and projection transforms
 * * Has methods to pan, zoom and orbit (or first-person rotation)
 * * Dynamically configurable World-space axis
 * * Has {@link Perspective}, {@link Ortho} and {@link Frustum} and {@link CustomProjection}, which you can dynamically switch it between
 * * Switchable gimbal lock
 * * Can be "flown" to look at targets using a {@link CameraFlightAnimation}
 * * Can be animated along a path using a {@link CameraPathAnimation}
 *
 * ## Getting the Camera
 *
 * There is exactly one Camera per {@link Scene}:
 *
 * ````javascript
 * import {Viewer} from "xeokit-sdk.es.js";
 *
 * var camera = viewer.scene.camera;
 *
 * ````
 *
 * ## Setting the Camera Position
 *
 * Get and set the Camera's absolute position via {@link Camera#eye}, {@link Camera#look} and {@link Camera#up}:
 *
 * ````javascript
 * camera.eye = [-10,0,0];
 * camera.look = [-10,0,0];
 * camera.up = [0,1,0];
 * ````
 *
 * ## Camera View and Projection Matrices
 *
 * The Camera's view matrix transforms coordinates from World-space to View-space.
 *
 * Getting the view matrix:
 *
 * ````javascript
 * var viewMatrix = camera.viewMatrix;
 * var viewNormalMatrix = camera.normalMatrix;
 * ````
 *
 * The Camera's view normal matrix transforms normal vectors from World-space to View-space.
 *
 * Getting the view normal matrix:
 *
 * ````javascript
 * var viewNormalMatrix = camera.normalMatrix;
 * ````
 *
 * The Camera fires a ````"viewMatrix"```` event whenever the {@link Camera#viewMatrix} and {@link Camera#viewNormalMatrix} updates.
 *
 * Listen for view matrix updates:
 *
 * ````javascript
 * camera.on("viewMatrix", function(matrix) { ... });
 * ````
 *
 * ## Rotating the Camera
 *
 * Orbiting the {@link Camera#look} position:
 *
 * ````javascript
 * camera.orbitYaw(20.0);
 * camera.orbitPitch(10.0);
 * ````
 *
 * First-person rotation, rotates {@link Camera#look} and {@link Camera#up} about {@link Camera#eye}:
 *
 * ````javascript
 * camera.yaw(5.0);
 * camera.pitch(-10.0);
 * ````
 *
 * ## Panning the Camera
 *
 * Panning along the Camera's local axis (ie. left/right, up/down, forward/backward):
 *
 * ````javascript
 * camera.pan([-20, 0, 10]);
 * ````
 *
 * ## Zooming the Camera
 *
 * Zoom to vary distance between {@link Camera#eye} and {@link Camera#look}:
 *
 * ````javascript
 * camera.zoom(-5); // Move five units closer
 * ````
 *
 * Get the current distance between {@link Camera#eye} and {@link Camera#look}:
 *
 * ````javascript
 * var distance = camera.eyeLookDist;
 * ````
 *
 * ## Projection
 *
 * The Camera has a Component to manage each projection type, which are: {@link Perspective}, {@link Ortho}
 * and {@link Frustum} and {@link CustomProjection}.
 *
 * You can configure those components at any time, regardless of which is currently active:
 *
 * The Camera has a {@link Perspective} to manage perspective
 * ````javascript
 *
 * // Set some properties on Perspective
 * camera.perspective.near = 0.4;
 * camera.perspective.fov = 45;
 *
 * // Set some properties on Ortho
 * camera.ortho.near = 0.8;
 * camera.ortho.far = 1000;
 *
 * // Set some properties on Frustum
 * camera.frustum.left = -1.0;
 * camera.frustum.right = 1.0;
 * camera.frustum.far = 1000.0;
 *
 * // Set the matrix property on CustomProjection
 * camera.customProjection.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
 *
 * // Switch between the projection types
 * camera.projection = "perspective"; // Switch to perspective
 * camera.projection = "frustum"; // Switch to frustum
 * camera.projection = "ortho"; // Switch to ortho
 * camera.projection = "customProjection"; // Switch to custom
 * ````
 *
 * Camera provides the projection matrix for the currently active projection in {@link Camera#projMatrix}.
 *
 * Get the projection matrix:
 *
 * ````javascript
 * var projMatrix = camera.projMatrix;
 * ````
 *
 * Listen for projection matrix updates:
 *
 * ````javascript
 * camera.on("projMatrix", function(matrix) { ... });
 * ````
 *
 * ## Configuring World up direction
 *
 * We can dynamically configure the directions of the World-space coordinate system.
 *
 * Setting the +Y axis as World "up", +X as right and -Z as forwards (convention in some modeling software):
 *
 * ````javascript
 * camera.worldAxis = [
 *     1, 0, 0,    // Right
 *     0, 1, 0,    // Up
 *     0, 0,-1     // Forward
 * ];
 * ````
 *
 * Setting the +Z axis as World "up", +X as right and -Y as "up" (convention in most CAD and BIM viewers):
 *
 * ````javascript
 * camera.worldAxis = [
 *     1, 0, 0, // Right
 *     0, 0, 1, // Up
 *     0,-1, 0  // Forward
 * ];
 * ````
 *
 * The Camera has read-only convenience properties that provide each axis individually:
 *
 * ````javascript
 * var worldRight = camera.worldRight;
 * var worldForward = camera.worldForward;
 * var worldUp = camera.worldUp;
 * ````
 *
 * ### Gimbal locking
 *
 * By default, the Camera locks yaw rotation to pivot about the World-space "up" axis. We can dynamically lock and unlock that at any time:
 *
 * ````javascript
 * camera.gimbalLock = false; // Yaw rotation now happens about Camera's local Y-axis
 * camera.gimbalLock = true; // Yaw rotation now happens about World's "up" axis
 * ````
 *
 * See: <a href="https://en.wikipedia.org/wiki/Gimbal_lock">https://en.wikipedia.org/wiki/Gimbal_lock</a>
 */var Camera=/*#__PURE__*/function(_Component14){_inherits(Camera,_Component14);var _super19=_createSuper(Camera);/**
     * @constructor
     * @private
     */function Camera(owner){var _this39;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Camera);_this39=_super19.call(this,owner,cfg);_this39._state=new RenderState({deviceMatrix:math.mat4(),hasDeviceMatrix:false,// True when deviceMatrix set to other than identity
matrix:math.mat4(),normalMatrix:math.mat4(),inverseMatrix:math.mat4()});_this39._perspective=new Perspective(_assertThisInitialized(_this39));_this39._ortho=new Ortho(_assertThisInitialized(_this39));_this39._frustum=new Frustum(_assertThisInitialized(_this39));_this39._customProjection=new CustomProjection(_assertThisInitialized(_this39));_this39._project=_this39._perspective;_this39._eye=math.vec3([0,0,10.0]);_this39._look=math.vec3([0,0,0]);_this39._up=math.vec3([0,1,0]);_this39._worldUp=math.vec3([0,1,0]);_this39._worldRight=math.vec3([1,0,0]);_this39._worldForward=math.vec3([0,0,-1]);_this39.deviceMatrix=cfg.deviceMatrix;_this39.eye=cfg.eye;_this39.look=cfg.look;_this39.up=cfg.up;_this39.worldAxis=cfg.worldAxis;_this39.gimbalLock=cfg.gimbalLock;_this39.constrainPitch=cfg.constrainPitch;_this39.projection=cfg.projection;_this39._perspective.on("matrix",function(){if(_this39._projectionType==="perspective"){_this39.fire("projMatrix",_this39._perspective.matrix);}});_this39._ortho.on("matrix",function(){if(_this39._projectionType==="ortho"){_this39.fire("projMatrix",_this39._ortho.matrix);}});_this39._frustum.on("matrix",function(){if(_this39._projectionType==="frustum"){_this39.fire("projMatrix",_this39._frustum.matrix);}});_this39._customProjection.on("matrix",function(){if(_this39._projectionType==="customProjection"){_this39.fire("projMatrix",_this39._customProjection.matrix);}});return _this39;}_createClass(Camera,[{key:"type",get:/**
     @private
     */function get(){return"Camera";}},{key:"_update",value:function _update(){var state=this._state;// In ortho mode, build the view matrix with an eye position that's translated
// well back from look, so that the front sectionPlane plane doesn't unexpectedly cut
// the front off the view (not a problem with perspective, since objects close enough
// to be clipped by the front plane are usually too big to see anything of their cross-sections).
var eye;if(this.projection==="ortho"){math.subVec3(this._eye,this._look,eyeLookVec);math.normalizeVec3(eyeLookVec,eyeLookVecNorm);math.mulVec3Scalar(eyeLookVecNorm,1000.0,eyeLookOffset);math.addVec3(this._look,eyeLookOffset,offsetEye);eye=offsetEye;}else{eye=this._eye;}if(state.hasDeviceMatrix){math.lookAtMat4v(eye,this._look,this._up,tempMatb);math.mulMat4(state.deviceMatrix,tempMatb,state.matrix);//state.matrix.set(state.deviceMatrix);
}else{math.lookAtMat4v(eye,this._look,this._up,state.matrix);}math.inverseMat4(this._state.matrix,this._state.inverseMatrix);math.transposeMat4(this._state.inverseMatrix,this._state.normalMatrix);this.glRedraw();this.fire("matrix",this._state.matrix);this.fire("viewMatrix",this._state.matrix);}/**
     * Rotates {@link Camera#eye} about {@link Camera#look}, around the {@link Camera#up} vector
     *
     * @param {Number} angleInc Angle of rotation in degrees
     */},{key:"orbitYaw",value:function orbitYaw(angleInc){var lookEyeVec=math.subVec3(this._eye,this._look,tempVec3$6);math.rotationMat4v(angleInc*0.0174532925,this._gimbalLock?this._worldUp:this._up,tempMat);lookEyeVec=math.transformPoint3(tempMat,lookEyeVec,tempVec3b$y);this.eye=math.addVec3(this._look,lookEyeVec,tempVec3c$u);// Set eye position as 'look' plus 'eye' vector
this.up=math.transformPoint3(tempMat,this._up,tempVec3d$d);// Rotate 'up' vector
}/**
     * Rotates {@link Camera#eye} about {@link Camera#look} around the right axis (orthogonal to {@link Camera#up} and "look").
     *
     * @param {Number} angleInc Angle of rotation in degrees
     */},{key:"orbitPitch",value:function orbitPitch(angleInc){if(this._constrainPitch){angleInc=math.dotVec3(this._up,this._worldUp)/math.DEGTORAD;if(angleInc<1){return;}}var eye2=math.subVec3(this._eye,this._look,tempVec3$6);var left=math.cross3Vec3(math.normalizeVec3(eye2,tempVec3b$y),math.normalizeVec3(this._up,tempVec3c$u));math.rotationMat4v(angleInc*0.0174532925,left,tempMat);eye2=math.transformPoint3(tempMat,eye2,tempVec3d$d);this.up=math.transformPoint3(tempMat,this._up,tempVec3e$2);this.eye=math.addVec3(eye2,this._look,tempVec3f$2);}/**
     * Rotates {@link Camera#look} about {@link Camera#eye}, around the {@link Camera#up} vector.
     *
     * @param {Number} angleInc Angle of rotation in degrees
     */},{key:"yaw",value:function yaw(angleInc){var look2=math.subVec3(this._look,this._eye,tempVec3$6);math.rotationMat4v(angleInc*0.0174532925,this._gimbalLock?this._worldUp:this._up,tempMat);look2=math.transformPoint3(tempMat,look2,tempVec3b$y);this.look=math.addVec3(look2,this._eye,tempVec3c$u);if(this._gimbalLock){this.up=math.transformPoint3(tempMat,this._up,tempVec3d$d);}}/**
     * Rotates {@link Camera#look} about {@link Camera#eye}, around the right axis (orthogonal to {@link Camera#up} and "look").

     * @param {Number} angleInc Angle of rotation in degrees
     */},{key:"pitch",value:function pitch(angleInc){if(this._constrainPitch){angleInc=math.dotVec3(this._up,this._worldUp)/math.DEGTORAD;if(angleInc<1){return;}}var look2=math.subVec3(this._look,this._eye,tempVec3$6);var left=math.cross3Vec3(math.normalizeVec3(look2,tempVec3b$y),math.normalizeVec3(this._up,tempVec3c$u));math.rotationMat4v(angleInc*0.0174532925,left,tempMat);this.up=math.transformPoint3(tempMat,this._up,tempVec3f$2);look2=math.transformPoint3(tempMat,look2,tempVec3d$d);this.look=math.addVec3(look2,this._eye,tempVec3e$2);}/**
     * Pans the Camera along its local X, Y and Z axis.
     *
     * @param pan The pan vector
     */},{key:"pan",value:function pan(_pan){var eye2=math.subVec3(this._eye,this._look,tempVec3$6);var vec=[0,0,0];var v;if(_pan[0]!==0){var left=math.cross3Vec3(math.normalizeVec3(eye2,[]),math.normalizeVec3(this._up,tempVec3b$y));v=math.mulVec3Scalar(left,_pan[0]);vec[0]+=v[0];vec[1]+=v[1];vec[2]+=v[2];}if(_pan[1]!==0){v=math.mulVec3Scalar(math.normalizeVec3(this._up,tempVec3c$u),_pan[1]);vec[0]+=v[0];vec[1]+=v[1];vec[2]+=v[2];}if(_pan[2]!==0){v=math.mulVec3Scalar(math.normalizeVec3(eye2,tempVec3d$d),_pan[2]);vec[0]+=v[0];vec[1]+=v[1];vec[2]+=v[2];}this.eye=math.addVec3(this._eye,vec,tempVec3e$2);this.look=math.addVec3(this._look,vec,tempVec3f$2);}/**
     * Increments/decrements the Camera's zoom factor, which is the distance between {@link Camera#eye} and {@link Camera#look}.
     *
     * @param {Number} delta Zoom factor increment.
     */},{key:"zoom",value:function zoom(delta){var vec=math.subVec3(this._eye,this._look,tempVec3$6);var lenLook=Math.abs(math.lenVec3(vec,tempVec3b$y));var newLenLook=Math.abs(lenLook+delta);if(newLenLook<0.5){return;}var dir=math.normalizeVec3(vec,tempVec3c$u);this.eye=math.addVec3(this._look,math.mulVec3Scalar(dir,newLenLook),tempVec3d$d);}/**
     * Sets the position of the Camera's eye.
     *
     * Default value is ````[0,0,10]````.
     *
     * @emits "eye" event on change, with the value of this property.
     * @type {Number[]} New eye position.
     */},{key:"eye",get:/**
     * Gets the position of the Camera's eye.
     *
     * Default vale is ````[0,0,10]````.
     *
     * @type {Number[]} New eye position.
     */function get(){return this._eye;}/**
     * Sets the position of this Camera's point-of-interest.
     *
     * Default value is ````[0,0,0]````.
     *
     * @emits "look" event on change, with the value of this property.
     *
     * @param {Number[]} look Camera look position.
     */,set:function set(eye){this._eye.set(eye||[0,0,10]);this._needUpdate(0);// Ensure matrix built on next "tick"
this.fire("eye",this._eye);}},{key:"look",get:/**
     * Gets the position of this Camera's point-of-interest.
     *
     * Default value is ````[0,0,0]````.
     *
     * @returns {Number[]} Camera look position.
     */function get(){return this._look;}/**
     * Sets the direction of this Camera's {@link Camera#up} vector.
     *
     * @emits "up" event on change, with the value of this property.
     *
     * @param {Number[]} up Direction of "up".
     */,set:function set(look){this._look.set(look||[0,0,0]);this._needUpdate(0);// Ensure matrix built on next "tick"
this.fire("look",this._look);}},{key:"up",get:/**
     * Gets the direction of this Camera's {@link Camera#up} vector.
     *
     * @returns {Number[]} Direction of "up".
     */function get(){return this._up;}/**
     * Sets an optional matrix to premultiply into {@link Camera#matrix} matrix.
     *
     * This is intended to be used for stereo rendering with WebVR etc.
     *
     * @param {Number[]} matrix The matrix.
     */,set:function set(up){this._up.set(up||[0,1,0]);this._needUpdate(0);this.fire("up",this._up);}},{key:"deviceMatrix",get:/**
     * Gets an optional matrix to premultiply into {@link Camera#matrix} matrix.
     *
     * @returns {Number[]} The matrix.
     */function get(){return this._state.deviceMatrix;}/**
     * Sets the up, right and forward axis of the World coordinate system.
     *
     * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
     *
     * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
     *
     * @param {Number[]} axis The new Wworld coordinate axis.
     */,set:function set(matrix){this._state.deviceMatrix.set(matrix||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this._state.hasDeviceMatrix=!!matrix;this._needUpdate(0);this.fire("deviceMatrix",this._state.deviceMatrix);}},{key:"worldAxis",get:/**
     * Gets the up, right and forward axis of the World coordinate system.
     *
     * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
     *
     * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
     *
     * @returns {Number[]} The current World coordinate axis.
     */function get(){return this._worldAxis;}/**
     * Gets the direction of World-space "up".
     *
     * This is set by {@link Camera#worldAxis}.
     *
     * Default value is ````[0,1,0]````.
     *
     * @returns {Number[]} The "up" vector.
     */,set:function set(axis){axis=axis||[1,0,0,0,1,0,0,0,1];if(!this._worldAxis){this._worldAxis=math.vec3(axis);}else{this._worldAxis.set(axis);}this._worldRight[0]=this._worldAxis[0];this._worldRight[1]=this._worldAxis[1];this._worldRight[2]=this._worldAxis[2];this._worldUp[0]=this._worldAxis[3];this._worldUp[1]=this._worldAxis[4];this._worldUp[2]=this._worldAxis[5];this._worldForward[0]=this._worldAxis[6];this._worldForward[1]=this._worldAxis[7];this._worldForward[2]=this._worldAxis[8];this.fire("worldAxis",this._worldAxis);}},{key:"worldUp",get:function get(){return this._worldUp;}/**
     * Gets if the World-space X-axis is "up".
     * @returns {Boolean}
     */},{key:"xUp",get:function get(){return this._worldUp[0]>this._worldUp[1]&&this._worldUp[0]>this._worldUp[2];}/**
     * Gets if the World-space Y-axis is "up".
     * @returns {Boolean}
     */},{key:"yUp",get:function get(){return this._worldUp[1]>this._worldUp[0]&&this._worldUp[1]>this._worldUp[2];}/**
     * Gets if the World-space Z-axis is "up".
     * @returns {Boolean}
     */},{key:"zUp",get:function get(){return this._worldUp[2]>this._worldUp[0]&&this._worldUp[2]>this._worldUp[1];}/**
     * Gets the direction of World-space "right".
     *
     * This is set by {@link Camera#worldAxis}.
     *
     * Default value is ````[1,0,0]````.
     *
     * @returns {Number[]} The "up" vector.
     */},{key:"worldRight",get:function get(){return this._worldRight;}/**
     * Gets the direction of World-space "forwards".
     *
     * This is set by {@link Camera#worldAxis}.
     *
     * Default value is ````[0,0,1]````.
     *
     * @returns {Number[]} The "up" vector.
     */},{key:"worldForward",get:function get(){return this._worldForward;}/**
     * Sets whether to lock yaw rotation to pivot about the World-space "up" axis.
     *
     * Fires a {@link Camera#gimbalLock:event} event on change.
     *
     * @params {Boolean} gimbalLock Set true to lock gimbal.
     */},{key:"gimbalLock",get:/**
     * Gets whether to lock yaw rotation to pivot about the World-space "up" axis.
     *
     * @returns {Boolean} Returns ````true```` if gimbal is locked.
     */function get(){return this._gimbalLock;}/**
     * Sets whether to prevent camera from being pitched upside down.
     *
     * The camera is upside down when the angle between {@link Camera#up} and {@link Camera#worldUp} is less than one degree.
     *
     * Fires a {@link Camera#constrainPitch:event} event on change.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} value Set ````true```` to contrain pitch rotation.
     */,set:function set(value){this._gimbalLock=value!==false;this.fire("gimbalLock",this._gimbalLock);}},{key:"constrainPitch",set:function set(value){this._constrainPitch=!!value;this.fire("constrainPitch",this._constrainPitch);}/**
     * Gets whether to prevent camera from being pitched upside down.
     *
     * The camera is upside down when the angle between {@link Camera#up} and {@link Camera#worldUp} is less than one degree.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if pitch rotation is currently constrained.
     get constrainPitch() {
        return this._constrainPitch;
    }

     /**
     * Gets distance from {@link Camera#look} to {@link Camera#eye}.
     *
     * @returns {Number} The distance.
     */},{key:"eyeLookDist",get:function get(){return math.lenVec3(math.subVec3(this._look,this._eye,tempVec3$6));}/**
     * Gets the Camera's viewing transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing transform matrix.
     */},{key:"matrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.matrix;}/**
     * Gets the Camera's viewing transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing transform matrix.
     */},{key:"viewMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.matrix;}/**
     * The Camera's viewing normal transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing normal transform matrix.
     */},{key:"normalMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.normalMatrix;}/**
     * The Camera's viewing normal transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing normal transform matrix.
     */},{key:"viewNormalMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.normalMatrix;}/**
     * Gets the inverse of the Camera's viewing transform matrix.
     *
     * This has the same value as {@link Camera#normalMatrix}.
     *
     * @returns {Number[]} The inverse viewing transform matrix.
     */},{key:"inverseViewMatrix",get:function get(){if(this._updateScheduled){this._doUpdate();}return this._state.inverseMatrix;}/**
     * Gets the Camera's projection transformation projMatrix.
     *
     * Fires a {@link Camera#projMatrix:event} event on change.
     *
     * @returns {Number[]} The projection matrix.
     */},{key:"projMatrix",get:function get(){return this[this.projection].matrix;}/**
     * Gets the Camera's perspective projection.
     *
     * The Camera uses this while {@link Camera#projection} equals ````perspective````.
     *
     * @returns {Perspective} The Perspective component.
     */},{key:"perspective",get:function get(){return this._perspective;}/**
     * Gets the Camera's orthographic projection.
     *
     * The Camera uses this while {@link Camera#projection} equals ````ortho````.
     *
     * @returns {Ortho} The Ortho component.
     */},{key:"ortho",get:function get(){return this._ortho;}/**
     * Gets the Camera's frustum projection.
     *
     * The Camera uses this while {@link Camera#projection} equals ````frustum````.
     *
     * @returns {Frustum} The Ortho component.
     */},{key:"frustum",get:function get(){return this._frustum;}/**
     * Gets the Camera's custom projection.
     *
     * This is used while {@link Camera#projection} equals "customProjection".
     *
     * @returns {CustomProjection} The custom projection.
     */},{key:"customProjection",get:function get(){return this._customProjection;}/**
     * Sets the active projection type.
     *
     * Accepted values are ````"perspective"````, ````"ortho"````, ````"frustum"```` and ````"customProjection"````.
     *
     * Default value is ````"perspective"````.
     *
     * @param {String} value Identifies the active projection type.
     */},{key:"projection",get:/**
     * Gets the active projection type.
     *
     * Possible values are ````"perspective"````, ````"ortho"````, ````"frustum"```` and ````"customProjection"````.
     *
     * Default value is ````"perspective"````.
     *
     * @returns {String} Identifies the active projection type.
     */function get(){return this._projectionType;}/**
     * Gets the currently active projection for this Camera.
     *
     * The currently active project is selected with {@link Camera#projection}.
     *
     * @returns {Perspective|Ortho|Frustum|CustomProjection} The currently active projection is active.
     */,set:function set(value){value=value||"perspective";if(this._projectionType===value){return;}if(value==="perspective"){this._project=this._perspective;}else if(value==="ortho"){this._project=this._ortho;}else if(value==="frustum"){this._project=this._frustum;}else if(value==="customProjection"){this._project=this._customProjection;}else{this.error("Unsupported value for 'projection': "+value+" defaulting to 'perspective'");this._project=this._perspective;value="perspective";}this._project._update();this._projectionType=value;this.glRedraw();this._update();// Need to rebuild lookat matrix with full eye, look & up
this.fire("dirty");this.fire("projection",this._projectionType);this.fire("projMatrix",this._project.matrix);}},{key:"project",get:function get(){return this._project;}/**
     * Get the 2D canvas position of a 3D world position.
     *
     * @param {[number, number, number]} worldPos
     * @returns {[number, number]} the canvas position
     */},{key:"projectWorldPos",value:function projectWorldPos(worldPos){var _worldPos=tempVec4a$8;var viewPos=tempVec4b$5;var screenPos=tempVec4c$2;_worldPos[0]=worldPos[0];_worldPos[1]=worldPos[1];_worldPos[2]=worldPos[2];_worldPos[3]=1;math.mulMat4v4(this.viewMatrix,_worldPos,viewPos);math.mulMat4v4(this.projMatrix,viewPos,screenPos);math.mulVec3Scalar(screenPos,1.0/screenPos[3]);screenPos[3]=1.0;screenPos[1]*=-1;var canvas=this.scene.canvas.canvas;var halfCanvasWidth=canvas.offsetWidth/2.0;var halfCanvasHeight=canvas.offsetHeight/2.0;var canvasPos=[screenPos[0]*halfCanvasWidth+halfCanvasWidth,screenPos[1]*halfCanvasHeight+halfCanvasHeight];return canvasPos;}/**
     * Destroys this Camera.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Camera.prototype),"destroy",this).call(this);this._state.destroy();}}]);return Camera;}(Component);/**
 * @desc A dynamic light source within a {@link Scene}.
 *
 * These are registered by {@link Light#id} in {@link Scene#lights}.
 */var Light=/*#__PURE__*/function(_Component15){_inherits(Light,_Component15);var _super20=_createSuper(Light);function Light(owner){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Light);return _super20.call(this,owner,cfg);}_createClass(Light,[{key:"type",get:/**
     @private
     */function get(){return"Light";}/**
     * @private
     */},{key:"isLight",get:function get(){return true;}}]);return Light;}(Component);/**
 * @desc A directional light source that illuminates all {@link Mesh}es equally from a given direction.
 *
 * * Has an emission direction vector in {@link DirLight#dir}, but no position.
 * * Defined in either *World* or *View* coordinate space. When in World-space, {@link DirLight#dir} is relative to the
 * World coordinate system, and will appear to move as the {@link Camera} moves. When in View-space, {@link DirLight#dir} is
 * relative to the View coordinate system, and will behave as if fixed to the viewer's head.
 * * {@link AmbientLight}s, {@link DirLight}s and {@link PointLight}s are registered by their {@link Component#id} on {@link Scene#lights}.
 *
 * ## Usage
 *
 * In the example below we'll replace the {@link Scene}'s default light sources with three View-space DirLights.
 *
 * [[Run this example](/examples/#lights_DirLight_view)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      buildPlaneGeometry, ReadableGeometry,
 *      PhongMaterial, Texture, DirLight} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * // Replace the Scene's default lights with three custom view-space DirLights
 *
 * viewer.scene.clearLights();
 *
 * new DirLight(viewer.scene, {
 *      id: "keyLight",
 *      dir: [0.8, -0.6, -0.8],
 *      color: [1.0, 0.3, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "fillLight",
 *      dir: [-0.8, -0.4, -0.4],
 *      color: [0.3, 1.0, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "rimLight",
 *      dir: [0.2, -0.8, 0.8],
 *      color: [0.6, 0.6, 0.6],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuse: [0.7, 0.7, 0.7],
 *          specular: [1.0, 1.0, 1.0],
 *          emissive: [0, 0, 0],
 *          alpha: 1.0,
 *          ambient: [1, 1, 0],
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 *  });
 *
 * new Mesh(viewer.scene, {
 *      geometry: buildPlaneGeometry(ReadableGeometry, viewer.scene, {
 *          xSize: 30,
 *          zSize: 30
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          backfaces: true
 *      }),
 *      position: [0, -2.1, 0]
 * });
 * ````
 */var DirLight=/*#__PURE__*/function(_Light){_inherits(DirLight,_Light);var _super21=_createSuper(DirLight);/**
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this DirLight as well.
     * @param {*} [cfg] The DirLight configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.dir=[1.0, 1.0, 1.0]]  A unit vector indicating the direction that the light is shining,  given in either World or View space, depending on the value of the ````space```` parameter.
     * @param {Number[]} [cfg.color=[0.7, 0.7, 0.8 ]] The color of this DirLight.
     * @param {Number} [cfg.intensity=1.0] The intensity of this DirLight, as a factor in range ````[0..1]````.
     * @param {String} [cfg.space="view"] The coordinate system the DirLight is defined in - ````"view"```` or ````"space"````.
     * @param {Boolean} [cfg.castsShadow=false] Flag which indicates if this DirLight casts a castsShadow.
     */function DirLight(owner){var _this40;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,DirLight);_this40=_super21.call(this,owner,cfg);_this40._shadowRenderBuf=null;_this40._shadowViewMatrix=null;_this40._shadowProjMatrix=null;_this40._shadowViewMatrixDirty=true;_this40._shadowProjMatrixDirty=true;var camera=_this40.scene.camera;var canvas=_this40.scene.canvas;_this40._onCameraViewMatrix=camera.on("viewMatrix",function(){_this40._shadowViewMatrixDirty=true;});_this40._onCameraProjMatrix=camera.on("projMatrix",function(){_this40._shadowProjMatrixDirty=true;});_this40._onCanvasBoundary=canvas.on("boundary",function(){_this40._shadowProjMatrixDirty=true;});_this40._state=new RenderState({type:"dir",dir:math.vec3([1.0,1.0,1.0]),color:math.vec3([0.7,0.7,0.8]),intensity:1.0,space:cfg.space||"view",castsShadow:false,getShadowViewMatrix:function getShadowViewMatrix(){if(_this40._shadowViewMatrixDirty){if(!_this40._shadowViewMatrix){_this40._shadowViewMatrix=math.identityMat4();}var _camera=_this40.scene.camera;var dir=_this40._state.dir;var look=_camera.look;var eye=[look[0]-dir[0],look[1]-dir[1],look[2]-dir[2]];var up=[0,1,0];math.lookAtMat4v(eye,look,up,_this40._shadowViewMatrix);_this40._shadowViewMatrixDirty=false;}return _this40._shadowViewMatrix;},getShadowProjMatrix:function getShadowProjMatrix(){if(_this40._shadowProjMatrixDirty){// TODO: Set when canvas resizes
if(!_this40._shadowProjMatrix){_this40._shadowProjMatrix=math.identityMat4();}math.orthoMat4c(-40,40,-40,40,-40.0,80,_this40._shadowProjMatrix);// left, right, bottom, top, near, far, dest
_this40._shadowProjMatrixDirty=false;}return _this40._shadowProjMatrix;},getShadowRenderBuf:function getShadowRenderBuf(){if(!_this40._shadowRenderBuf){_this40._shadowRenderBuf=new RenderBuffer(_this40.scene.canvas.canvas,_this40.scene.canvas.gl,{size:[1024,1024]});// Super old mobile devices have a limit of 1024x1024 textures
}return _this40._shadowRenderBuf;}});_this40.dir=cfg.dir;_this40.color=cfg.color;_this40.intensity=cfg.intensity;_this40.castsShadow=cfg.castsShadow;_this40.scene._lightCreated(_assertThisInitialized(_this40));return _this40;}/**
     * Sets the direction in which the DirLight is shining.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @param {Number[]} value The direction vector.
     */_createClass(DirLight,[{key:"type",get:/**
     @private
     */function get(){return"DirLight";}},{key:"dir",get:/**
     * Gets the direction in which the DirLight is shining.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @returns {Number[]} The direction vector.
     */function get(){return this._state.dir;}/**
     * Sets the RGB color of this DirLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param {Number[]} color The DirLight's RGB color.
     */,set:function set(value){this._state.dir.set(value||[1.0,1.0,1.0]);this._shadowViewMatrixDirty=true;this.glRedraw();}},{key:"color",get:/**
     * Gets the RGB color of this DirLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The DirLight's RGB color.
     */function get(){return this._state.color;}/**
     * Sets the intensity of this DirLight.
     *
     * Default intensity is ````1.0```` for maximum intensity.
     *
     * @param {Number} intensity The DirLight's intensity
     */,set:function set(color){this._state.color.set(color||[0.7,0.7,0.8]);this.glRedraw();}},{key:"intensity",get:/**
     * Gets the intensity of this DirLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The DirLight's intensity.
     */function get(){return this._state.intensity;}/**
     * Sets if this DirLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} castsShadow Set ````true```` to cast shadows.
     */,set:function set(intensity){intensity=intensity!==undefined?intensity:1.0;this._state.intensity=intensity;this.glRedraw();}},{key:"castsShadow",get:/**
     * Gets if this DirLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if this DirLight casts shadows.
     */function get(){return this._state.castsShadow;}/**
     * Destroys this DirLight.
     */,set:function set(castsShadow){castsShadow=!!castsShadow;if(this._state.castsShadow===castsShadow){return;}this._state.castsShadow=castsShadow;this._shadowViewMatrixDirty=true;this.glRedraw();}},{key:"destroy",value:function destroy(){var camera=this.scene.camera;var canvas=this.scene.canvas;camera.off(this._onCameraViewMatrix);camera.off(this._onCameraProjMatrix);canvas.off(this._onCanvasBoundary);_get(_getPrototypeOf(DirLight.prototype),"destroy",this).call(this);this._state.destroy();if(this._shadowRenderBuf){this._shadowRenderBuf.destroy();}this.scene._lightDestroyed(this);this.glRedraw();}}]);return DirLight;}(Light);/**
 * @desc An ambient light source of fixed color and intensity that illuminates all {@link Mesh}es equally.
 *
 * * {@link AmbientLight#color} multiplies by {@link PhongMaterial#ambient} at each position of each {@link ReadableGeometry} surface.
 * * {@link AmbientLight#color} multiplies by {@link LambertMaterial#color} uniformly across each triangle of each {@link ReadableGeometry} (ie. flat shaded).
 * * {@link AmbientLight}s, {@link DirLight}s and {@link PointLight}s are registered by their {@link Component#id} on {@link Scene#lights}.
 *
 * ## Usage
 *
 * In the example below we'll destroy the {@link Scene}'s default light sources then create an AmbientLight and a couple of {@link @DirLight}s:
 *
 * [[Run this example](/examples/#lights_AmbientLight)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 * ReadableGeometry, PhongMaterial, Texture, AmbientLight} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * // Replace the Scene's default lights with a single custom AmbientLight
 *
 * viewer.scene.clearLights();
 *
 * new AmbientLight(viewer.scene, {
 *      color: [0.0, 0.3, 0.7],
 *      intensity: 1.0
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "keyLight",
 *      dir: [0.8, -0.6, -0.8],
 *      color: [1.0, 0.3, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "fillLight",
 *      dir: [-0.8, -0.4, -0.4],
 *      color: [0.3, 1.0, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "rimLight",
 *      dir: [0.2, -0.8, 0.8],
 *      color: [0.6, 0.6, 0.6],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * // Create a mesh with torus shape and PhongMaterial
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          ambient: [1.0, 1.0, 1.0],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 * });
 *
 * // Adjust the color of our AmbientLight
 *
 * var ambientLight = viewer.scene.lights["myAmbientLight"];
 * ambientLight.color = [1.0, 0.8, 0.8];
 *````
 */var AmbientLight=/*#__PURE__*/function(_Light2){_inherits(AmbientLight,_Light2);var _super22=_createSuper(AmbientLight);/**
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this AmbientLight as well.
     * @param {*} [cfg] AmbientLight configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.color=[0.7, 0.7, 0.8]]  The color of this AmbientLight.
     * @param {Number} [cfg.intensity=[1.0]]  The intensity of this AmbientLight, as a factor in range ````[0..1]````.
     */function AmbientLight(owner){var _this41;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,AmbientLight);_this41=_super22.call(this,owner,cfg);_this41._state={type:"ambient",color:math.vec3([0.7,0.7,0.7]),intensity:1.0};_this41.color=cfg.color;_this41.intensity=cfg.intensity;_this41.scene._lightCreated(_assertThisInitialized(_this41));return _this41;}/**
     * Sets the RGB color of this AmbientLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param {Number[]} color The AmbientLight's RGB color.
     */_createClass(AmbientLight,[{key:"type",get:/**
     @private
     */function get(){return"AmbientLight";}},{key:"color",get:/**
     * Gets the RGB color of this AmbientLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The AmbientLight's RGB color.
     */function get(){return this._state.color;}/**
     * Sets the intensity of this AmbientLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @param {Number} intensity The AmbientLight's intensity.
     */,set:function set(color){this._state.color.set(color||[0.7,0.7,0.8]);this.glRedraw();}},{key:"intensity",get:/**
     * Gets the intensity of this AmbientLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The AmbientLight's intensity.
     */function get(){return this._state.intensity;}/**
     * Destroys this AmbientLight.
     */,set:function set(intensity){this._state.intensity=intensity!==undefined?intensity:1.0;this.glRedraw();}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(AmbientLight.prototype),"destroy",this).call(this);this.scene._lightDestroyed(this);}}]);return AmbientLight;}(Light);/**
 * @desc Defines a shape for one or more {@link Mesh}es.
 *
 * * {@link ReadableGeometry} is a subclass that stores its data in both browser and GPU memory. Use ReadableGeometry when you need to keep the geometry arrays in browser memory.
 * * {@link VBOGeometry} is a subclass that stores its data solely in GPU memory. Use VBOGeometry when you need a lower memory footprint and don't need to keep the geometry data in browser memory.
 */var Geometry=/*#__PURE__*/function(_Component16){_inherits(Geometry,_Component16);var _super23=_createSuper(Geometry);function Geometry(owner){var _this42;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Geometry);_this42=_super23.call(this,owner,cfg);stats.memory.meshes++;return _this42;}_createClass(Geometry,[{key:"type",get:/** @private */function get(){return"Geometry";}/** @private */},{key:"isGeometry",get:function get(){return true;}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Geometry.prototype),"destroy",this).call(this);stats.memory.meshes--;}}]);return Geometry;}(Component);/**
 * @private
 */var buildEdgeIndices=function(){var uniquePositions=[];var indicesLookup=[];var indicesReverseLookup=[];var weldedIndices=[];// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions
var faces=[];var numFaces=0;var compa=new Uint16Array(3);var compb=new Uint16Array(3);var compc=new Uint16Array(3);var a=math.vec3();var b=math.vec3();var c=math.vec3();var cb=math.vec3();var ab=math.vec3();var cross=math.vec3();var normal=math.vec3();function weldVertices(positions,indices){var positionsMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var vx;var vy;var vz;var key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i;var len;var lenUniquePositions=0;for(i=0,len=positions.length;i<len;i+=3){vx=positions[i];vy=positions[i+1];vz=positions[i+2];key=Math.round(vx*precision)+'_'+Math.round(vy*precision)+'_'+Math.round(vz*precision);if(positionsMap[key]===undefined){positionsMap[key]=lenUniquePositions/3;uniquePositions[lenUniquePositions++]=vx;uniquePositions[lenUniquePositions++]=vy;uniquePositions[lenUniquePositions++]=vz;}indicesLookup[i/3]=positionsMap[key];}for(i=0,len=indices.length;i<len;i++){weldedIndices[i]=indicesLookup[indices[i]];indicesReverseLookup[weldedIndices[i]]=indices[i];}}function buildFaces(numIndices,positionsDecodeMatrix){numFaces=0;for(var _i73=0,len=numIndices;_i73<len;_i73+=3){var ia=weldedIndices[_i73]*3;var ib=weldedIndices[_i73+1]*3;var ic=weldedIndices[_i73+2]*3;if(positionsDecodeMatrix){compa[0]=uniquePositions[ia];compa[1]=uniquePositions[ia+1];compa[2]=uniquePositions[ia+2];compb[0]=uniquePositions[ib];compb[1]=uniquePositions[ib+1];compb[2]=uniquePositions[ib+2];compc[0]=uniquePositions[ic];compc[1]=uniquePositions[ic+1];compc[2]=uniquePositions[ic+2];// Decode
math.decompressPosition(compa,positionsDecodeMatrix,a);math.decompressPosition(compb,positionsDecodeMatrix,b);math.decompressPosition(compc,positionsDecodeMatrix,c);}else{a[0]=uniquePositions[ia];a[1]=uniquePositions[ia+1];a[2]=uniquePositions[ia+2];b[0]=uniquePositions[ib];b[1]=uniquePositions[ib+1];b[2]=uniquePositions[ib+2];c[0]=uniquePositions[ic];c[1]=uniquePositions[ic+1];c[2]=uniquePositions[ic+2];}math.subVec3(c,b,cb);math.subVec3(a,b,ab);math.cross3Vec3(cb,ab,cross);math.normalizeVec3(cross,normal);var face=faces[numFaces]||(faces[numFaces]={normal:math.vec3()});face.normal[0]=normal[0];face.normal[1]=normal[1];face.normal[2]=normal[2];numFaces++;}}return function(positions,indices,positionsDecodeMatrix,edgeThreshold){weldVertices(positions,indices);buildFaces(indices.length,positionsDecodeMatrix);var edgeIndices=[];var thresholdDot=Math.cos(math.DEGTORAD*edgeThreshold);var edges={};var edge1;var edge2;var index1;var index2;var key;var largeIndex=false;var edge;var normal1;var normal2;var dot;var ia;var ib;for(var _i74=0,len=indices.length;_i74<len;_i74+=3){var faceIndex=_i74/3;for(var j=0;j<3;j++){edge1=weldedIndices[_i74+j];edge2=weldedIndices[_i74+(j+1)%3];index1=Math.min(edge1,edge2);index2=Math.max(edge1,edge2);key=index1+","+index2;if(edges[key]===undefined){edges[key]={index1:index1,index2:index2,face1:faceIndex,face2:undefined};}else{edges[key].face2=faceIndex;}}}for(key in edges){edge=edges[key];// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
if(edge.face2!==undefined){normal1=faces[edge.face1].normal;normal2=faces[edge.face2].normal;dot=math.dotVec3(normal1,normal2);if(dot>thresholdDot){continue;}}ia=indicesReverseLookup[edge.index1];ib=indicesReverseLookup[edge.index2];if(!largeIndex&&ia>65535||ib>65535){largeIndex=true;}edgeIndices.push(ia);edgeIndices.push(ib);}return largeIndex?new Uint32Array(edgeIndices):new Uint16Array(edgeIndices);};}();/**
 * Private geometry compression and decompression utilities.
 */ /**
 * @private
 * @param array
 * @returns {{min: Float32Array, max: Float32Array}}
 */function getPositionsBounds(array){var min=new Float32Array(3);var max=new Float32Array(3);var i,j;for(i=0;i<3;i++){min[i]=Number.MAX_VALUE;max[i]=-Number.MAX_VALUE;}for(i=0;i<array.length;i+=3){for(j=0;j<3;j++){min[j]=Math.min(min[j],array[i+j]);max[j]=Math.max(max[j],array[i+j]);}}return{min:min,max:max};}var createPositionsDecodeMatrix$1=function(){var translate=math.mat4();var scale=math.mat4();return function(aabb,positionsDecodeMatrix){positionsDecodeMatrix=positionsDecodeMatrix||math.mat4();var xmin=aabb[0];var ymin=aabb[1];var zmin=aabb[2];var xwid=aabb[3]-xmin;var ywid=aabb[4]-ymin;var zwid=aabb[5]-zmin;var maxInt=65535;math.identityMat4(translate);math.translationMat4v(aabb,translate);math.identityMat4(scale);math.scalingMat4v([xwid/maxInt,ywid/maxInt,zwid/maxInt],scale);math.mulMat4(translate,scale,positionsDecodeMatrix);return positionsDecodeMatrix;};}();/**
 * @private
 */var compressPositions=function(){// http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf
var translate=math.mat4();var scale=math.mat4();return function(array,min,max){var quantized=new Uint16Array(array.length);var multiplier=new Float32Array([max[0]!==min[0]?65535/(max[0]-min[0]):0,max[1]!==min[1]?65535/(max[1]-min[1]):0,max[2]!==min[2]?65535/(max[2]-min[2]):0]);var i;for(i=0;i<array.length;i+=3){quantized[i+0]=Math.max(0,Math.min(65535,Math.floor((array[i+0]-min[0])*multiplier[0])));quantized[i+1]=Math.max(0,Math.min(65535,Math.floor((array[i+1]-min[1])*multiplier[1])));quantized[i+2]=Math.max(0,Math.min(65535,Math.floor((array[i+2]-min[2])*multiplier[2])));}math.identityMat4(translate);math.translationMat4v(min,translate);math.identityMat4(scale);math.scalingMat4v([(max[0]-min[0])/65535,(max[1]-min[1])/65535,(max[2]-min[2])/65535],scale);var decodeMat=math.mulMat4(translate,scale,math.identityMat4());return{quantized:quantized,decodeMatrix:decodeMat};};}();function compressPosition(p,aabb,q){var multiplier=new Float32Array([aabb[3]!==aabb[0]?65535/(aabb[3]-aabb[0]):0,aabb[4]!==aabb[1]?65535/(aabb[4]-aabb[1]):0,aabb[5]!==aabb[2]?65535/(aabb[5]-aabb[2]):0]);q[0]=Math.max(0,Math.min(65535,Math.floor((p[0]-aabb[0])*multiplier[0])));q[1]=Math.max(0,Math.min(65535,Math.floor((p[1]-aabb[1])*multiplier[1])));q[2]=Math.max(0,Math.min(65535,Math.floor((p[2]-aabb[2])*multiplier[2])));}function decompressPosition(position,decodeMatrix,dest){dest[0]=position[0]*decodeMatrix[0]+decodeMatrix[12];dest[1]=position[1]*decodeMatrix[5]+decodeMatrix[13];dest[2]=position[2]*decodeMatrix[10]+decodeMatrix[14];return dest;}function decompressAABB(aabb,decodeMatrix){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:aabb;dest[0]=aabb[0]*decodeMatrix[0]+decodeMatrix[12];dest[1]=aabb[1]*decodeMatrix[5]+decodeMatrix[13];dest[2]=aabb[2]*decodeMatrix[10]+decodeMatrix[14];dest[3]=aabb[3]*decodeMatrix[0]+decodeMatrix[12];dest[4]=aabb[4]*decodeMatrix[5]+decodeMatrix[13];dest[5]=aabb[5]*decodeMatrix[10]+decodeMatrix[14];return dest;}/**
 * @private
 */function decompressPositions(positions,decodeMatrix){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Float32Array(positions.length);for(var _i75=0,len=positions.length;_i75<len;_i75+=3){dest[_i75+0]=positions[_i75+0]*decodeMatrix[0]+decodeMatrix[12];dest[_i75+1]=positions[_i75+1]*decodeMatrix[5]+decodeMatrix[13];dest[_i75+2]=positions[_i75+2]*decodeMatrix[10]+decodeMatrix[14];}return dest;}//--------------- UVs --------------------------------------------------------------------------------------------------
/**
 * @private
 * @param array
 * @returns {{min: Float32Array, max: Float32Array}}
 */function getUVBounds(array){var min=new Float32Array(2);var max=new Float32Array(2);var i,j;for(i=0;i<2;i++){min[i]=Number.MAX_VALUE;max[i]=-Number.MAX_VALUE;}for(i=0;i<array.length;i+=2){for(j=0;j<2;j++){min[j]=Math.min(min[j],array[i+j]);max[j]=Math.max(max[j],array[i+j]);}}return{min:min,max:max};}/**
 * @private
 */var compressUVs=function(){var translate=math.mat3();var scale=math.mat3();return function(array,min,max){var quantized=new Uint16Array(array.length);var multiplier=new Float32Array([65535/(max[0]-min[0]),65535/(max[1]-min[1])]);var i;for(i=0;i<array.length;i+=2){quantized[i+0]=Math.max(0,Math.min(65535,Math.floor((array[i+0]-min[0])*multiplier[0])));quantized[i+1]=Math.max(0,Math.min(65535,Math.floor((array[i+1]-min[1])*multiplier[1])));}math.identityMat3(translate);math.translationMat3v(min,translate);math.identityMat3(scale);math.scalingMat3v([(max[0]-min[0])/65535,(max[1]-min[1])/65535],scale);var decodeMat=math.mulMat3(translate,scale,math.identityMat3());return{quantized:quantized,decodeMatrix:decodeMat};};}();//--------------- Normals ----------------------------------------------------------------------------------------------
/**
 * @private
 */function compressNormals(array){// http://jcgt.org/published/0003/02/01/
// Note: three elements for each encoded normal, in which the last element in each triplet is redundant.
// This is to work around a mysterious WebGL issue where 2-element normals just wouldn't work in the shader :/
var encoded=new Int8Array(array.length);var oct,dec,best,currentCos,bestCos;for(var _i76=0;_i76<array.length;_i76+=3){// Test various combinations of ceil and floor
// to minimize rounding errors
best=oct=octEncodeVec3$1(array,_i76,"floor","floor");dec=octDecodeVec2$1(oct);currentCos=bestCos=dot(array,_i76,dec);oct=octEncodeVec3$1(array,_i76,"ceil","floor");dec=octDecodeVec2$1(oct);currentCos=dot(array,_i76,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos;}oct=octEncodeVec3$1(array,_i76,"floor","ceil");dec=octDecodeVec2$1(oct);currentCos=dot(array,_i76,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos;}oct=octEncodeVec3$1(array,_i76,"ceil","ceil");dec=octDecodeVec2$1(oct);currentCos=dot(array,_i76,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos;}encoded[_i76]=best[0];encoded[_i76+1]=best[1];}return encoded;}/**
 * @private
 */function octEncodeVec3$1(array,i,xfunc,yfunc){// Oct-encode single normal vector in 2 bytes
var x=array[i]/(Math.abs(array[i])+Math.abs(array[i+1])+Math.abs(array[i+2]));var y=array[i+1]/(Math.abs(array[i])+Math.abs(array[i+1])+Math.abs(array[i+2]));if(array[i+2]<0){var tempx=(1-Math.abs(y))*(x>=0?1:-1);var tempy=(1-Math.abs(x))*(y>=0?1:-1);x=tempx;y=tempy;}return new Int8Array([Math[xfunc](x*127.5+(x<0?-1:0)),Math[yfunc](y*127.5+(y<0?-1:0))]);}/**
 * Decode an oct-encoded normal
 */function octDecodeVec2$1(oct){var x=oct[0];var y=oct[1];x/=x<0?127:128;y/=y<0?127:128;var z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1);}var length=Math.sqrt(x*x+y*y+z*z);return[x/length,y/length,z/length];}/**
 * Dot product of a normal in an array against a candidate decoding
 * @private
 */function dot(array,i,vec3){return array[i]*vec3[0]+array[i+1]*vec3[1]+array[i+2]*vec3[2];}/**
 * @private
 */function decompressUV(uv,decodeMatrix,dest){dest[0]=uv[0]*decodeMatrix[0]+decodeMatrix[6];dest[1]=uv[1]*decodeMatrix[4]+decodeMatrix[7];}/**
 * @private
 */function decompressUVs(uvs,decodeMatrix){var dest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Float32Array(uvs.length);for(var _i77=0,len=uvs.length;_i77<len;_i77+=3){dest[_i77+0]=uvs[_i77+0]*decodeMatrix[0]+decodeMatrix[6];dest[_i77+1]=uvs[_i77+1]*decodeMatrix[4]+decodeMatrix[7];}return dest;}/**
 * @private
 */function decompressNormal(oct,result){var x=oct[0];var y=oct[1];x=(2*x+1)/255;y=(2*y+1)/255;var z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1);}var length=Math.sqrt(x*x+y*y+z*z);result[0]=x/length;result[1]=y/length;result[2]=z/length;return result;}/**
 * @private
 */function decompressNormals(octs,result){for(var _i78=0,j=0,len=octs.length;_i78<len;_i78+=2){var x=octs[_i78+0];var y=octs[_i78+1];x=(2*x+1)/255;y=(2*y+1)/255;var _z2=1-Math.abs(x)-Math.abs(y);if(_z2<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1);}var length=Math.sqrt(x*x+y*y+_z2*_z2);result[j+0]=x/length;result[j+1]=y/length;result[j+2]=_z2/length;j+=3;}return result;}/**
 * @private
 */var geometryCompressionUtils={getPositionsBounds:getPositionsBounds,createPositionsDecodeMatrix:createPositionsDecodeMatrix$1,compressPositions:compressPositions,compressPosition:compressPosition,decompressPositions:decompressPositions,decompressPosition:decompressPosition,decompressAABB:decompressAABB,getUVBounds:getUVBounds,compressUVs:compressUVs,decompressUVs:decompressUVs,decompressUV:decompressUV,compressNormals:compressNormals,decompressNormals:decompressNormals,decompressNormal:decompressNormal};var memoryStats$1=stats.memory;var tempAABB$3=math.AABB3();/**
 * @desc A {@link Geometry} that keeps its geometry data in both browser and GPU memory.
 *
 * ReadableGeometry uses more memory than {@link VBOGeometry}, which only stores its geometry data in GPU memory.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a ReadableGeometry that defines a single triangle, plus a {@link PhongMaterial} with diffuse {@link Texture}:
 *
 * [[Run this example](/examples/#geometry_ReadableGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 *     });
 *
 * const myMesh = new Mesh(viewer.scene, {
 *         geometry: new ReadableGeometry(viewer.scene, {
 *             primitive: "triangles",
 *             positions: [0.0, 3, 0.0, -3, -3, 0.0, 3, -3, 0.0],
 *             normals: [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0],
 *             uv: [0.0, 0.0, 0.5, 1.0, 1.0, 0.0],
 *             indices: [0, 1, 2]
 *         }),
 *         material: new PhongMaterial(viewer.scene, {
 *             diffuseMap: new Texture(viewer.scene, {
 *                 src: "textures/diffuse/uvGrid2.jpg"
 *             }),
 *             backfaces: true
 *         })
 *     });
 *
 * // Get geometry data from browser memory:
 *
 * const positions = myMesh.geometry.positions; // Flat arrays
 * const normals = myMesh.geometry.normals;
 * const uv = myMesh.geometry.uv;
 * const indices = myMesh.geometry.indices;
 *
 * ````
 */var ReadableGeometry=/*#__PURE__*/function(_Geometry){_inherits(ReadableGeometry,_Geometry);var _super24=_createSuper(ReadableGeometry);/**
     *
     @class ReadableGeometry
     @module xeokit
     @submodule geometry
     @constructor
     @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     @param {*} [cfg] Configs
     @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene},
     generated automatically when omitted.
     @param {String:Object} [cfg.meta] Optional map of user-defined metadata to attach to this Geometry.
     @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
     @param [cfg.positions] {Number[]} Positions array.
     @param [cfg.normals] {Number[]} Vertex normal vectors array.
     @param [cfg.uv] {Number[]} UVs array.
     @param [cfg.colors] {Number[]} Vertex colors.
     @param [cfg.indices] {Number[]} Indices array.
     @param [cfg.autoVertexNormals=false] {Boolean} Set true to automatically generate normal vectors from the positions and
     indices, if those are supplied.
     @param [cfg.compressGeometry=false] {Boolean} Stores positions, colors, normals and UVs in compressGeometry and oct-encoded formats
     for reduced memory footprint and GPU bus usage.
     @param [cfg.edgeThreshold=10] {Number} When a {@link Mesh} renders this Geometry as wireframe,
     this indicates the threshold angle (in degrees) between the face normals of adjacent triangles below which the edge is discarded.
     @extends Component
     * @param owner
     * @param cfg
     */function ReadableGeometry(owner){var _this43;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ReadableGeometry);_this43=_super24.call(this,owner,cfg);_this43._state=new RenderState({// Arrays for emphasis effects are got from xeokit.Geometry friend methods
compressGeometry:!!cfg.compressGeometry,primitive:null,// WebGL enum
primitiveName:null,// String
positions:null,// Uint16Array when compressGeometry == true, else Float32Array
normals:null,// Uint8Array when compressGeometry == true, else Float32Array
colors:null,uv:null,// Uint8Array when compressGeometry == true, else Float32Array
indices:null,positionsDecodeMatrix:null,// Set when compressGeometry == true
uvDecodeMatrix:null,// Set when compressGeometry == true
positionsBuf:null,normalsBuf:null,colorsbuf:null,uvBuf:null,indicesBuf:null,hash:""});_this43._numTriangles=0;_this43._edgeThreshold=cfg.edgeThreshold||10.0;// Lazy-generated VBOs
_this43._edgeIndicesBuf=null;_this43._pickTrianglePositionsBuf=null;_this43._pickTriangleColorsBuf=null;// Local-space Boundary3D
_this43._aabbDirty=true;_this43._boundingSphere=true;_this43._aabb=null;_this43._aabbDirty=true;_this43._obb=null;_this43._obbDirty=true;var state=_this43._state;var gl=_this43.scene.canvas.gl;// Primitive type
cfg.primitive=cfg.primitive||"triangles";switch(cfg.primitive){case"points":state.primitive=gl.POINTS;state.primitiveName=cfg.primitive;break;case"lines":state.primitive=gl.LINES;state.primitiveName=cfg.primitive;break;case"line-loop":state.primitive=gl.LINE_LOOP;state.primitiveName=cfg.primitive;break;case"line-strip":state.primitive=gl.LINE_STRIP;state.primitiveName=cfg.primitive;break;case"triangles":state.primitive=gl.TRIANGLES;state.primitiveName=cfg.primitive;break;case"triangle-strip":state.primitive=gl.TRIANGLE_STRIP;state.primitiveName=cfg.primitive;break;case"triangle-fan":state.primitive=gl.TRIANGLE_FAN;state.primitiveName=cfg.primitive;break;default:_this43.error("Unsupported value for 'primitive': '"+cfg.primitive+"' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', "+"'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");state.primitive=gl.TRIANGLES;state.primitiveName=cfg.primitive;}if(cfg.positions){if(_this43._state.compressGeometry){var bounds=geometryCompressionUtils.getPositionsBounds(cfg.positions);var result=geometryCompressionUtils.compressPositions(cfg.positions,bounds.min,bounds.max);state.positions=result.quantized;state.positionsDecodeMatrix=result.decodeMatrix;}else{state.positions=cfg.positions.constructor===Float32Array?cfg.positions:new Float32Array(cfg.positions);}}if(cfg.colors){state.colors=cfg.colors.constructor===Float32Array?cfg.colors:new Float32Array(cfg.colors);}if(cfg.uv){if(_this43._state.compressGeometry){var _bounds=geometryCompressionUtils.getUVBounds(cfg.uv);var _result=geometryCompressionUtils.compressUVs(cfg.uv,_bounds.min,_bounds.max);state.uv=_result.quantized;state.uvDecodeMatrix=_result.decodeMatrix;}else{state.uv=cfg.uv.constructor===Float32Array?cfg.uv:new Float32Array(cfg.uv);}}if(cfg.normals){if(_this43._state.compressGeometry){state.normals=geometryCompressionUtils.compressNormals(cfg.normals);}else{state.normals=cfg.normals.constructor===Float32Array?cfg.normals:new Float32Array(cfg.normals);}}if(cfg.indices){state.indices=cfg.indices.constructor===Uint32Array||cfg.indices.constructor===Uint16Array?cfg.indices:new Uint32Array(cfg.indices);if(_this43._state.primitiveName==="triangles"){_this43._numTriangles=cfg.indices.length/3;}}_this43._buildHash();memoryStats$1.meshes++;_this43._buildVBOs();return _this43;}_createClass(ReadableGeometry,[{key:"type",get:/**
     @private
     */function get(){return"ReadableGeometry";}/**
     * @private
     * @returns {Boolean}
     */},{key:"isReadableGeometry",get:function get(){return true;}},{key:"_buildVBOs",value:function _buildVBOs(){var state=this._state;var gl=this.scene.canvas.gl;if(state.indices){state.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,state.indices,state.indices.length,1,gl.STATIC_DRAW);memoryStats$1.indices+=state.indicesBuf.numItems;}if(state.positions){state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,state.positions,state.positions.length,3,gl.STATIC_DRAW);memoryStats$1.positions+=state.positionsBuf.numItems;}if(state.normals){var normalized=state.compressGeometry;state.normalsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,state.normals,state.normals.length,3,gl.STATIC_DRAW,normalized);memoryStats$1.normals+=state.normalsBuf.numItems;}if(state.colors){state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,state.colors,state.colors.length,4,gl.STATIC_DRAW);memoryStats$1.colors+=state.colorsBuf.numItems;}if(state.uv){state.uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,state.uv,state.uv.length,2,gl.STATIC_DRAW);memoryStats$1.uvs+=state.uvBuf.numItems;}}},{key:"_buildHash",value:function _buildHash(){var state=this._state;var hash=["/g"];hash.push("/"+state.primitive+";");if(state.positions){hash.push("p");}if(state.colors){hash.push("c");}if(state.normals||state.autoVertexNormals){hash.push("n");}if(state.uv){hash.push("u");}if(state.compressGeometry){hash.push("cp");}hash.push(";");state.hash=hash.join("");}},{key:"_getEdgeIndices",value:function _getEdgeIndices(){if(!this._edgeIndicesBuf){this._buildEdgeIndices();}return this._edgeIndicesBuf;}},{key:"_getPickTrianglePositions",value:function _getPickTrianglePositions(){if(!this._pickTrianglePositionsBuf){this._buildPickTriangleVBOs();}return this._pickTrianglePositionsBuf;}},{key:"_getPickTriangleColors",value:function _getPickTriangleColors(){if(!this._pickTriangleColorsBuf){this._buildPickTriangleVBOs();}return this._pickTriangleColorsBuf;}},{key:"_buildEdgeIndices",value:function _buildEdgeIndices(){// FIXME: Does not adjust indices after other objects are deleted from vertex buffer!!
var state=this._state;if(!state.positions||!state.indices){return;}var gl=this.scene.canvas.gl;var edgeIndices=buildEdgeIndices(state.positions,state.indices,state.positionsDecodeMatrix,this._edgeThreshold);this._edgeIndicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,edgeIndices,edgeIndices.length,1,gl.STATIC_DRAW);memoryStats$1.indices+=this._edgeIndicesBuf.numItems;}},{key:"_buildPickTriangleVBOs",value:function _buildPickTriangleVBOs(){// Builds positions and indices arrays that allow each triangle to have a unique color
var state=this._state;if(!state.positions||!state.indices){return;}var gl=this.scene.canvas.gl;var arrays=math.buildPickTriangles(state.positions,state.indices,state.compressGeometry);var positions=arrays.positions;var colors=arrays.colors;this._pickTrianglePositionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,positions,positions.length,3,gl.STATIC_DRAW);this._pickTriangleColorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colors,colors.length,4,gl.STATIC_DRAW,true);memoryStats$1.positions+=this._pickTrianglePositionsBuf.numItems;memoryStats$1.colors+=this._pickTriangleColorsBuf.numItems;}},{key:"_buildPickVertexVBOs",value:function _buildPickVertexVBOs(){// var state = this._state;
// if (!state.positions || !state.indices) {
//     return;
// }
// var gl = this.scene.canvas.gl;
// var arrays = math.buildPickVertices(state.positions, state.indices, state.compressGeometry);
// var pickVertexPositions = arrays.positions;
// var pickColors = arrays.colors;
// this._pickVertexPositionsBuf = new xeokit.renderer.ArrayBuf(gl, gl.ARRAY_BUFFER, pickVertexPositions, pickVertexPositions.length, 3, gl.STATIC_DRAW);
// this._pickVertexColorsBuf = new xeokit.renderer.ArrayBuf(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW, true);
// memoryStats.positions += this._pickVertexPositionsBuf.numItems;
// memoryStats.colors += this._pickVertexColorsBuf.numItems;
}},{key:"_webglContextLost",value:function _webglContextLost(){if(this._sceneVertexBufs){this._sceneVertexBufs.webglContextLost();}}},{key:"_webglContextRestored",value:function _webglContextRestored(){if(this._sceneVertexBufs){this._sceneVertexBufs.webglContextRestored();}this._buildVBOs();this._edgeIndicesBuf=null;this._pickVertexPositionsBuf=null;this._pickTrianglePositionsBuf=null;this._pickTriangleColorsBuf=null;this._pickVertexPositionsBuf=null;this._pickVertexColorsBuf=null;}/**
     * Gets the Geometry's primitive type.

     Valid types are: 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.

     @property primitive
     @default "triangles"
     @type {String}
     */},{key:"primitive",get:function get(){return this._state.primitiveName;}/**
     Indicates if this Geometry is quantized.

     Compression is an internally-performed optimization which stores positions, colors, normals and UVs
     in quantized and oct-encoded formats for reduced memory footprint and GPU bus usage.

     Quantized geometry may not be updated.

     @property compressGeometry
     @default false
     @type {Boolean}
     @final
     */},{key:"compressGeometry",get:function get(){return this._state.compressGeometry;}/**
     The Geometry's vertex positions.

     @property positions
     @default null
     @type {Number[]}
     */},{key:"positions",get:function get(){if(!this._state.positions){return null;}if(!this._state.compressGeometry){return this._state.positions;}if(!this._decompressedPositions){this._decompressedPositions=new Float32Array(this._state.positions.length);geometryCompressionUtils.decompressPositions(this._state.positions,this._state.positionsDecodeMatrix,this._decompressedPositions);}return this._decompressedPositions;},set:function set(newPositions){var state=this._state;var positions=state.positions;if(!positions){this.error("can't update geometry positions - geometry has no positions");return;}if(positions.length!==newPositions.length){this.error("can't update geometry positions - new positions are wrong length");return;}if(this._state.compressGeometry){var bounds=geometryCompressionUtils.getPositionsBounds(newPositions);var result=geometryCompressionUtils.compressPositions(newPositions,bounds.min,bounds.max);newPositions=result.quantized;// TODO: Copy in-place
state.positionsDecodeMatrix=result.decodeMatrix;}positions.set(newPositions);if(state.positionsBuf){state.positionsBuf.setData(positions);}this._setAABBDirty();this.glRedraw();}/**
     The Geometry's vertex normals.

     @property normals
     @default null
     @type {Number[]}
     */},{key:"normals",get:function get(){if(!this._state.normals){return;}if(!this._state.compressGeometry){return this._state.normals;}if(!this._decompressedNormals){var lenCompressed=this._state.normals.length;var lenDecompressed=lenCompressed+lenCompressed/2;// 2 -> 3
this._decompressedNormals=new Float32Array(lenDecompressed);geometryCompressionUtils.decompressNormals(this._state.normals,this._decompressedNormals);}return this._decompressedNormals;},set:function set(newNormals){if(this._state.compressGeometry){this.error("can't update geometry normals - quantized geometry is immutable");// But will be eventually
return;}var state=this._state;var normals=state.normals;if(!normals){this.error("can't update geometry normals - geometry has no normals");return;}if(normals.length!==newNormals.length){this.error("can't update geometry normals - new normals are wrong length");return;}normals.set(newNormals);if(state.normalsBuf){state.normalsBuf.setData(normals);}this.glRedraw();}/**
     The Geometry's UV coordinates.

     @property uv
     @default null
     @type {Number[]}
     */},{key:"uv",get:function get(){if(!this._state.uv){return null;}if(!this._state.compressGeometry){return this._state.uv;}if(!this._decompressedUV){this._decompressedUV=new Float32Array(this._state.uv.length);geometryCompressionUtils.decompressUVs(this._state.uv,this._state.uvDecodeMatrix,this._decompressedUV);}return this._decompressedUV;},set:function set(newUV){if(this._state.compressGeometry){this.error("can't update geometry UVs - quantized geometry is immutable");// But will be eventually
return;}var state=this._state;var uv=state.uv;if(!uv){this.error("can't update geometry UVs - geometry has no UVs");return;}if(uv.length!==newUV.length){this.error("can't update geometry UVs - new UVs are wrong length");return;}uv.set(newUV);if(state.uvBuf){state.uvBuf.setData(uv);}this.glRedraw();}/**
     The Geometry's vertex colors.

     @property colors
     @default null
     @type {Number[]}
     */},{key:"colors",get:function get(){return this._state.colors;},set:function set(newColors){if(this._state.compressGeometry){this.error("can't update geometry colors - quantized geometry is immutable");// But will be eventually
return;}var state=this._state;var colors=state.colors;if(!colors){this.error("can't update geometry colors - geometry has no colors");return;}if(colors.length!==newColors.length){this.error("can't update geometry colors - new colors are wrong length");return;}colors.set(newColors);if(state.colorsBuf){state.colorsBuf.setData(colors);}this.glRedraw();}/**
     The Geometry's indices.

     If ````xeokit.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]```` is true, then this can be
     a ````Uint32Array````, otherwise it needs to be a ````Uint16Array````.

     @property indices
     @default null
     @type Uint16Array | Uint32Array
     @final
     */},{key:"indices",get:function get(){return this._state.indices;}/**
     * Local-space axis-aligned 3D boundary (AABB) of this geometry.
     *
     * The AABB is represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @property aabb
     * @final
     * @type {Number[]}
     */},{key:"aabb",get:function get(){if(this._aabbDirty){if(!this._aabb){this._aabb=math.AABB3();}math.positions3ToAABB3(this._state.positions,this._aabb,this._state.positionsDecodeMatrix);this._aabbDirty=false;}return this._aabb;}/**
     * Local-space oriented 3D boundary (OBB) of this geometry.
     *
     * The OBB is represented by a 32-element Float64Array containing the eight vertices of the box,
     * where each vertex is a homogeneous coordinate having [x,y,z,w] elements.
     *
     * @property obb
     * @final
     * @type {Number[]}
     */},{key:"obb",get:function get(){if(this._obbDirty){if(!this._obb){this._obb=math.OBB3();}math.positions3ToAABB3(this._state.positions,tempAABB$3,this._state.positionsDecodeMatrix);math.AABB3ToOBB3(tempAABB$3,this._obb);this._obbDirty=false;}return this._obb;}/**
     * Approximate number of triangles in this ReadableGeometry.
     *
     * Will be zero if {@link ReadableGeometry#primitive} is not 'triangles', 'triangle-strip' or 'triangle-fan'.
     *
     * @type {Number}
     */},{key:"numTriangles",get:function get(){return this._numTriangles;}},{key:"_setAABBDirty",value:function _setAABBDirty(){if(this._aabbDirty){return;}this._aabbDirty=true;this._aabbDirty=true;this._obbDirty=true;}},{key:"_getState",value:function _getState(){return this._state;}/**
     * Destroys this ReadableGeometry
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(ReadableGeometry.prototype),"destroy",this).call(this);var state=this._state;if(state.indicesBuf){state.indicesBuf.destroy();}if(state.positionsBuf){state.positionsBuf.destroy();}if(state.normalsBuf){state.normalsBuf.destroy();}if(state.uvBuf){state.uvBuf.destroy();}if(state.colorsBuf){state.colorsBuf.destroy();}if(this._edgeIndicesBuf){this._edgeIndicesBuf.destroy();}if(this._pickTrianglePositionsBuf){this._pickTrianglePositionsBuf.destroy();}if(this._pickTriangleColorsBuf){this._pickTriangleColorsBuf.destroy();}if(this._pickVertexPositionsBuf){this._pickVertexPositionsBuf.destroy();}if(this._pickVertexColorsBuf){this._pickVertexColorsBuf.destroy();}state.destroy();memoryStats$1.meshes--;}}]);return ReadableGeometry;}(Geometry);/**
 * @desc Creates box-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a box-shaped {@link ReadableGeometry}.
 *
 * [[Run this example](/examples/#geometry_builders_buildBoxGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildBoxGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildBoxGeometry({
 *         center: [0,0,0],
 *         xSize: 1,  // Half-size on each axis
 *         ySize: 1,
 *         zSize: 1
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildBoxGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.
 * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.
 * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildBoxGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var xSize=cfg.xSize||1;if(xSize<0){console.error("negative xSize not allowed - will invert");xSize*=-1;}var ySize=cfg.ySize||1;if(ySize<0){console.error("negative ySize not allowed - will invert");ySize*=-1;}var zSize=cfg.zSize||1;if(zSize<0){console.error("negative zSize not allowed - will invert");zSize*=-1;}var center=cfg.center;var centerX=center?center[0]:0;var centerY=center?center[1]:0;var centerZ=center?center[2]:0;var xmin=-xSize+centerX;var ymin=-ySize+centerY;var zmin=-zSize+centerZ;var xmax=xSize+centerX;var ymax=ySize+centerY;var zmax=zSize+centerZ;return utils.apply(cfg,{// The vertices - eight for our cube, each
// one spanning three array elements for X,Y and Z
positions:[// v0-v1-v2-v3 front
xmax,ymax,zmax,xmin,ymax,zmax,xmin,ymin,zmax,xmax,ymin,zmax,// v0-v3-v4-v1 right
xmax,ymax,zmax,xmax,ymin,zmax,xmax,ymin,zmin,xmax,ymax,zmin,// v0-v1-v6-v1 top
xmax,ymax,zmax,xmax,ymax,zmin,xmin,ymax,zmin,xmin,ymax,zmax,// v1-v6-v7-v2 left
xmin,ymax,zmax,xmin,ymax,zmin,xmin,ymin,zmin,xmin,ymin,zmax,// v7-v4-v3-v2 bottom
xmin,ymin,zmin,xmax,ymin,zmin,xmax,ymin,zmax,xmin,ymin,zmax,// v4-v7-v6-v1 back
xmax,ymin,zmin,xmin,ymin,zmin,xmin,ymax,zmin,xmax,ymax,zmin],// Normal vectors, one for each vertex
normals:[// v0-v1-v2-v3 front
0,0,1,0,0,1,0,0,1,0,0,1,// v0-v3-v4-v5 right
1,0,0,1,0,0,1,0,0,1,0,0,// v0-v5-v6-v1 top
0,1,0,0,1,0,0,1,0,0,1,0,// v1-v6-v7-v2 left
-1,0,0,-1,0,0,-1,0,0,-1,0,0,// v7-v4-v3-v2 bottom
0,-1,0,0,-1,0,0,-1,0,0,-1,0,// v4-v7-v6-v5 back
0,0,-1,0,0,-1,0,0,-1,0,0,-1],// UV coords
uv:[// v0-v1-v2-v3 front
1,0,0,0,0,1,1,1,// v0-v3-v4-v1 right
0,0,0,1,1,1,1,0,// v0-v1-v6-v1 top
1,1,1,0,0,0,0,1,// v1-v6-v7-v2 left
1,0,0,0,0,1,1,1,// v7-v4-v3-v2 bottom
0,1,1,1,1,0,0,0,// v4-v7-v6-v1 back
0,1,1,1,1,0,0,0],// Indices - these organise the
// positions and uv texture coordinates
// into geometric primitives in accordance
// with the "primitive" parameter,
// in this case a set of three indices
// for each triangle.
//
// Note that each triangle is specified
// in counter-clockwise winding order.
//
// You can specify them in clockwise
// order if you configure the Modes
// node's frontFace flag as "cw", instead of
// the default "ccw".
indices:[0,1,2,0,2,3,// front
4,5,6,4,6,7,// right
8,9,10,8,10,11,// top
12,13,14,12,14,15,// left
16,17,18,16,18,19,// bottom
20,21,22,20,22,23]});}/**
 * @desc A **Material** defines the surface appearance of attached {@link Mesh}es.
 *
 * Material is the base class for:
 *
 * * {@link MetallicMaterial} - physically-based material for metallic surfaces. Use this one for things made of metal.
 * * {@link SpecularMaterial} - physically-based material for non-metallic (dielectric) surfaces. Use this one for insulators, such as ceramics, plastics, wood etc.
 * * {@link PhongMaterial} - material for classic Blinn-Phong shading. This is less demanding of graphics hardware than the physically-based materials.
 * * {@link LambertMaterial} - material for fast, flat-shaded CAD rendering without textures. Use this for navigating huge CAD or BIM models interactively. This material gives the best rendering performance and uses the least memory.
 * * {@link EmphasisMaterial} - defines the appearance of Meshes when "xrayed" or "highlighted".
 * * {@link EdgeMaterial} - defines the appearance of Meshes when edges are emphasized.
 *
 * A {@link Scene} is allowed to contain a mixture of these material types.
 *
 */var Material=/*#__PURE__*/function(_Component17){_inherits(Material,_Component17);var _super25=_createSuper(Material);function Material(owner){var _this44;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Material);_this44=_super25.call(this,owner,cfg);stats.memory.materials++;return _this44;}_createClass(Material,[{key:"type",get:/**
     @private
     */function get(){return"Material";}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Material.prototype),"destroy",this).call(this);stats.memory.materials--;}}]);return Material;}(Component);var alphaModes$1={"opaque":0,"mask":1,"blend":2};var alphaModeNames$1=["opaque","mask","blend"];/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the non-physically-correct Blinn-Phong shading model.
 *
 * * Useful for non-realistic objects like gizmos.
 * * {@link SpecularMaterial} is best for insulators, such as wood, ceramics and plastic.
 * * {@link MetallicMaterial} is best for conductive materials, such as metal.
 * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Mesh} with a PhongMaterial with a diffuse {@link Texture} and a specular {@link Fresnel}, using a {@link buildTorusGeometry} to create the {@link Geometry}.
 *
 * [[Run this example](/examples/#materials_PhongMaterial)]
 *
 *  ```` javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 *     ReadableGeometry, PhongMaterial, Texture, Fresnel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas"
 *    });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          specularFresnel: new Fresnel(viewer.scene, {
 *              leftColor: [1.0, 1.0, 1.0],
 *              rightColor: [0.0, 0.0, 0.0],
 *              power: 4
 *          })
 *     })
 * });
 * ````
 *
 * ## PhongMaterial Properties
 *
 *  The following table summarizes PhongMaterial properties:
 *
 * | Property | Type | Range | Default Value | Space | Description |
 * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 * | {@link PhongMaterial#ambient} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |
 * | {@link PhongMaterial#diffuse} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |
 * | {@link PhongMaterial#specular} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular light reflected by the material. |
 * | {@link PhongMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |
 * | {@link PhongMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 * | {@link PhongMaterial#shininess} | Number | [0, 128] | 80 | linear | Determines the size and sharpness of specular highlights. |
 * | {@link PhongMaterial#reflectivity} | Number | [0, 1] | 1 | linear | Determines the amount of reflectivity. |
 * | {@link PhongMaterial#diffuseMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link PhongMaterial#diffuse}. If the fourth component (A) is present, it multiplies by {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#specularMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link PhongMaterial#specular}. If the fourth component (A) is present, it multiplies by {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link PhongMaterial#emissive}. |
 * | {@link PhongMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by {@link PhongMaterial#ambient}, {@link PhongMaterial#diffuse} and {@link PhongMaterial#specular}. |
 * | {@link PhongMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |
 * | {@link PhongMaterial#diffuseFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#diffuse}. |
 * | {@link PhongMaterial#specularFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#specular}. |
 * | {@link PhongMaterial#emissiveFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#emissive}. |
 * | {@link PhongMaterial#reflectivityFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#reflectivity}. |
 * | {@link PhongMaterial#alphaFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#lineWidth} | Number | [0..100] | 1 |  | Line width in pixels. |
 * | {@link PhongMaterial#pointSize} | Number | [0..100] | 1 |  | Point size in pixels. |
 * | {@link PhongMaterial#alphaMode} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 * | {@link PhongMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 * | {@link PhongMaterial#backfaces} | Boolean |  | false |  | Whether to render geometry backfaces. |
 * | {@link PhongMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for geometry frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 */var PhongMaterial=/*#__PURE__*/function(_Material){_inherits(PhongMaterial,_Material);var _super26=_createSuper(PhongMaterial);/**
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The PhongMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.ambient=[1.0, 1.0, 1.0 ]]  PhongMaterial ambient color.
     * @param {Number[]} [cfg.diffuse=[ 1.0, 1.0, 1.0 ]] PhongMaterial diffuse color.
     * @param {Number[]} [cfg.specular=[ 1.0, 1.0, 1.0 ]]  PhongMaterial specular color.
     * @param {Number[]} [cfg.emissive=[ 0.0, 0.0, 0.0 ]] PhongMaterial emissive color.
     * @param {Number} [cfg.alpha=1] Scalar in range 0-1 that controls alpha, where 0 is completely transparent and 1 is completely opaque.
     * @param {Number} [cfg.shininess=80] Scalar in range 0-128 that determines the size and sharpness of specular highlights.
     * @param {Number} [cfg.reflectivity=1] Scalar in range 0-1 that controls how much {@link ReflectionMap} is reflected.
     * @param {Number} [cfg.lineWidth=1] Scalar that controls the width of lines.
     * @param {Number} [cfg.pointSize=1] Scalar that controls the size of points.
     * @param {Texture} [cfg.ambientMap=null] A ambient map {@link Texture}, which will multiply by the diffuse property. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.diffuseMap=null] A diffuse map {@link Texture}, which will override the effect of the diffuse property. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.specularMap=null] A specular map {@link Texture}, which will override the effect of the specular property. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.emissiveMap=undefined] An emissive map {@link Texture}, which will override the effect of the emissive property. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.normalMap=undefined] A normal map {@link Texture}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.alphaMap=undefined] An alpha map {@link Texture}, which will override the effect of the alpha property. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.reflectivityMap=undefined] A reflectivity control map {@link Texture}, which will override the effect of the reflectivity property. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Texture} [cfg.occlusionMap=null] An occlusion map {@link Texture}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Fresnel} [cfg.diffuseFresnel=undefined] A diffuse {@link Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Fresnel} [cfg.specularFresnel=undefined] A specular {@link Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Fresnel} [cfg.emissiveFresnel=undefined] An emissive {@link Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Fresnel} [cfg.alphaFresnel=undefined] An alpha {@link Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {Fresnel} [cfg.reflectivityFresnel=undefined] A reflectivity {@link Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.
     * @param {String} [cfg.alphaMode="opaque"] The alpha blend mode - accepted values are "opaque", "blend" and "mask". See the {@link PhongMaterial#alphaMode} property for more info.
     * @param {Number} [cfg.alphaCutoff=0.5] The alpha cutoff value. See the {@link PhongMaterial#alphaCutoff} property for more info.
     * @param {Boolean} [cfg.backfaces=false] Whether to render geometry backfaces.
     * @param {Boolean} [cfg.frontface="ccw"] The winding order for geometry front faces - "cw" for clockwise, or "ccw" for counter-clockwise.
     */function PhongMaterial(owner){var _this45;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PhongMaterial);_this45=_super26.call(this,owner,cfg);_this45._state=new RenderState({type:"PhongMaterial",ambient:math.vec3([1.0,1.0,1.0]),diffuse:math.vec3([1.0,1.0,1.0]),specular:math.vec3([1.0,1.0,1.0]),emissive:math.vec3([0.0,0.0,0.0]),alpha:null,shininess:null,reflectivity:null,alphaMode:null,alphaCutoff:null,lineWidth:null,pointSize:null,backfaces:null,frontface:null,// Boolean for speed; true == "ccw", false == "cw"
hash:null});_this45.ambient=cfg.ambient;_this45.diffuse=cfg.diffuse;_this45.specular=cfg.specular;_this45.emissive=cfg.emissive;_this45.alpha=cfg.alpha;_this45.shininess=cfg.shininess;_this45.reflectivity=cfg.reflectivity;_this45.lineWidth=cfg.lineWidth;_this45.pointSize=cfg.pointSize;if(cfg.ambientMap){_this45._ambientMap=_this45._checkComponent("Texture",cfg.ambientMap);}if(cfg.diffuseMap){_this45._diffuseMap=_this45._checkComponent("Texture",cfg.diffuseMap);}if(cfg.specularMap){_this45._specularMap=_this45._checkComponent("Texture",cfg.specularMap);}if(cfg.emissiveMap){_this45._emissiveMap=_this45._checkComponent("Texture",cfg.emissiveMap);}if(cfg.alphaMap){_this45._alphaMap=_this45._checkComponent("Texture",cfg.alphaMap);}if(cfg.reflectivityMap){_this45._reflectivityMap=_this45._checkComponent("Texture",cfg.reflectivityMap);}if(cfg.normalMap){_this45._normalMap=_this45._checkComponent("Texture",cfg.normalMap);}if(cfg.occlusionMap){_this45._occlusionMap=_this45._checkComponent("Texture",cfg.occlusionMap);}if(cfg.diffuseFresnel){_this45._diffuseFresnel=_this45._checkComponent("Fresnel",cfg.diffuseFresnel);}if(cfg.specularFresnel){_this45._specularFresnel=_this45._checkComponent("Fresnel",cfg.specularFresnel);}if(cfg.emissiveFresnel){_this45._emissiveFresnel=_this45._checkComponent("Fresnel",cfg.emissiveFresnel);}if(cfg.alphaFresnel){_this45._alphaFresnel=_this45._checkComponent("Fresnel",cfg.alphaFresnel);}if(cfg.reflectivityFresnel){_this45._reflectivityFresnel=_this45._checkComponent("Fresnel",cfg.reflectivityFresnel);}_this45.alphaMode=cfg.alphaMode;_this45.alphaCutoff=cfg.alphaCutoff;_this45.backfaces=cfg.backfaces;_this45.frontface=cfg.frontface;_this45._makeHash();return _this45;}_createClass(PhongMaterial,[{key:"type",get:/**
     @private
     */function get(){return"PhongMaterial";}},{key:"_makeHash",value:function _makeHash(){var state=this._state;var hash=["/p"];// 'P' for Phong
if(this._normalMap){hash.push("/nm");if(this._normalMap.hasMatrix){hash.push("/mat");}}if(this._ambientMap){hash.push("/am");if(this._ambientMap.hasMatrix){hash.push("/mat");}hash.push("/"+this._ambientMap.encoding);}if(this._diffuseMap){hash.push("/dm");if(this._diffuseMap.hasMatrix){hash.push("/mat");}hash.push("/"+this._diffuseMap.encoding);}if(this._specularMap){hash.push("/sm");if(this._specularMap.hasMatrix){hash.push("/mat");}}if(this._emissiveMap){hash.push("/em");if(this._emissiveMap.hasMatrix){hash.push("/mat");}hash.push("/"+this._emissiveMap.encoding);}if(this._alphaMap){hash.push("/opm");if(this._alphaMap.hasMatrix){hash.push("/mat");}}if(this._reflectivityMap){hash.push("/rm");if(this._reflectivityMap.hasMatrix){hash.push("/mat");}}if(this._occlusionMap){hash.push("/ocm");if(this._occlusionMap.hasMatrix){hash.push("/mat");}}if(this._diffuseFresnel){hash.push("/df");}if(this._specularFresnel){hash.push("/sf");}if(this._emissiveFresnel){hash.push("/ef");}if(this._alphaFresnel){hash.push("/of");}if(this._reflectivityFresnel){hash.push("/rf");}hash.push(";");state.hash=hash.join("");}/**
     * Sets the PhongMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */},{key:"ambient",get:/**
     * Gets the PhongMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */function get(){return this._state.ambient;}/**
     * Sets the PhongMaterial's diffuse color.
     *
     * Multiplies by {@link PhongMaterial#diffuseMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */,set:function set(value){var ambient=this._state.ambient;if(!ambient){ambient=this._state.ambient=new Float32Array(3);}else if(value&&ambient[0]===value[0]&&ambient[1]===value[1]&&ambient[2]===value[2]){return;}if(value){ambient[0]=value[0];ambient[1]=value[1];ambient[2]=value[2];}else{ambient[0]=.2;ambient[1]=.2;ambient[2]=.2;}this.glRedraw();}},{key:"diffuse",get:/**
     * Sets the PhongMaterial's diffuse color.
     *
     * Multiplies by {@link PhongMaterial#diffuseMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */function get(){return this._state.diffuse;}/**
     * Sets the PhongMaterial's specular color.
     *
     * Multiplies by {@link PhongMaterial#specularMap}.
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */,set:function set(value){var diffuse=this._state.diffuse;if(!diffuse){diffuse=this._state.diffuse=new Float32Array(3);}else if(value&&diffuse[0]===value[0]&&diffuse[1]===value[1]&&diffuse[2]===value[2]){return;}if(value){diffuse[0]=value[0];diffuse[1]=value[1];diffuse[2]=value[2];}else{diffuse[0]=1;diffuse[1]=1;diffuse[2]=1;}this.glRedraw();}},{key:"specular",get:/**
     * Gets the PhongMaterial's specular color.
     *
     * Multiplies by {@link PhongMaterial#specularMap}.
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */function get(){return this._state.specular;}/**
     * Sets the PhongMaterial's emissive color.
     *
     * Multiplies by {@link PhongMaterial#emissiveMap}.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     * @type {Number[]}
     */,set:function set(value){var specular=this._state.specular;if(!specular){specular=this._state.specular=new Float32Array(3);}else if(value&&specular[0]===value[0]&&specular[1]===value[1]&&specular[2]===value[2]){return;}if(value){specular[0]=value[0];specular[1]=value[1];specular[2]=value[2];}else{specular[0]=1;specular[1]=1;specular[2]=1;}this.glRedraw();}},{key:"emissive",get:/**
     * Gets the PhongMaterial's emissive color.
     *
     * Multiplies by {@link PhongMaterial#emissiveMap}.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     * @type {Number[]}
     */function get(){return this._state.emissive;}/**
     * Sets the PhongMaterial alpha.
     *
     * This is a factor in the range [0..1] indicating how transparent the PhongMaterial is.
     *
     * A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
     *
     * Multiplies by {@link PhongMaterial#alphaMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){var emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3);}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return;}if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2];}else{emissive[0]=0;emissive[1]=0;emissive[2]=0;}this.glRedraw();}},{key:"alpha",get:/**
     * Gets the PhongMaterial alpha.
     *
     * This is a factor in the range [0..1] indicating how transparent the PhongMaterial is.
     *
     * A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
     *
     * Multiplies by {@link PhongMaterial#alphaMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */function get(){return this._state.alpha;}/**
     * Sets the PhongMaterial shininess.
     *
     * This is a factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.
     *
     * Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never
     * desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp
     * highlight.
     *
     * Default value is ```` 80.0````.
     *
     * @type {Number}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.alpha===value){return;}this._state.alpha=value;this.glRedraw();}},{key:"shininess",get:/**
     * Gets the PhongMaterial shininess.
     *
     * This is a factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.
     *
     * Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never
     * desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp
     * highlight.
     *
     * Default value is ```` 80.0````.
     *
     * @type {Number}
     */function get(){return this._state.shininess;}/**
     * Sets the PhongMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){this._state.shininess=value!==undefined?value:80;this.glRedraw();}},{key:"lineWidth",get:/**
     * Gets the PhongMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */function get(){return this._state.lineWidth;}/**
     * Sets the PhongMaterial's point size.
     *
     * Default value is 1.0.
     *
     * @type {Number}
     */,set:function set(value){this._state.lineWidth=value||1.0;this.glRedraw();}},{key:"pointSize",get:/**
     * Gets the PhongMaterial's point size.
     *
     * Default value is 1.0.
     *
     * @type {Number}
     */function get(){return this._state.pointSize;}/**
     * Sets how much {@link ReflectionMap} is reflected by this PhongMaterial.
     *
     * This is a scalar in range ````[0-1]````. Default value is ````1.0````.
     *
     * The surface will be non-reflective when this is ````0````, and completely mirror-like when it is ````1.0````.
     *
     * Multiplies by {@link PhongMaterial#reflectivityMap}.
     *
     * @type {Number}
     */,set:function set(value){this._state.pointSize=value||1.0;this.glRedraw();}},{key:"reflectivity",get:/**
     * Gets how much {@link ReflectionMap} is reflected by this PhongMaterial.
     *
     * This is a scalar in range ````[0-1]````. Default value is ````1.0````.
     *
     * The surface will be non-reflective when this is ````0````, and completely mirror-like when it is ````1.0````.
     *
     * Multiplies by {@link PhongMaterial#reflectivityMap}.
     *
     * @type {Number}
     */function get(){return this._state.reflectivity;}/**
     * Gets the PhongMaterials's normal map {@link Texture}.
     *
     * @type {Texture}
     */,set:function set(value){this._state.reflectivity=value!==undefined?value:1.0;this.glRedraw();}},{key:"normalMap",get:function get(){return this._normalMap;}/**
     * Gets the PhongMaterials's ambient {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#ambient}.
     *
     * @type {Texture}
     */},{key:"ambientMap",get:function get(){return this._ambientMap;}/**
     * Gets the PhongMaterials's diffuse {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#diffuse}.
     *
     * @type {Texture}
     */},{key:"diffuseMap",get:function get(){return this._diffuseMap;}/**
     * Gets the PhongMaterials's specular {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#specular}.
     *
     * @type {Texture}
     */},{key:"specularMap",get:function get(){return this._specularMap;}/**
     * Gets the PhongMaterials's emissive {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#emissive}.
     *
     * @type {Texture}
     */},{key:"emissiveMap",get:function get(){return this._emissiveMap;}/**
     * Gets the PhongMaterials's alpha {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#alpha}.
     *
     * @type {Texture}
     */},{key:"alphaMap",get:function get(){return this._alphaMap;}/**
     * Gets the PhongMaterials's reflectivity {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#reflectivity}.
     *
     * @type {Texture}
     */},{key:"reflectivityMap",get:function get(){return this._reflectivityMap;}/**
     * Gets the PhongMaterials's ambient occlusion {@link Texture}.
     *
     * @type {Texture}
     */},{key:"occlusionMap",get:function get(){return this._occlusionMap;}/**
     * Gets the PhongMaterials's diffuse {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#diffuse}.
     *
     * @type {Fresnel}
     */},{key:"diffuseFresnel",get:function get(){return this._diffuseFresnel;}/**
     * Gets the PhongMaterials's specular {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#specular}.
     *
     * @type {Fresnel}
     */},{key:"specularFresnel",get:function get(){return this._specularFresnel;}/**
     * Gets the PhongMaterials's emissive {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#emissive}.
     *
     * @type {Fresnel}
     */},{key:"emissiveFresnel",get:function get(){return this._emissiveFresnel;}/**
     * Gets the PhongMaterials's alpha {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#alpha}.
     *
     * @type {Fresnel}
     */},{key:"alphaFresnel",get:function get(){return this._alphaFresnel;}/**
     * Gets the PhongMaterials's reflectivity {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#reflectivity}.
     *
     * @type {Fresnel}
     */},{key:"reflectivityFresnel",get:function get(){return this._reflectivityFresnel;}/**
     * Sets the PhongMaterial's alpha rendering mode.
     *
     * This governs how alpha is treated. Alpha is the combined result of {@link PhongMaterial#alpha} and {@link PhongMaterial#alphaMap}.
     *
     * Supported values are:
     *
     * * "opaque" - The alpha value is ignored and the rendered output is fully opaque (default).
     * * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.
     * * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).
     *
     *@type {String}
     */},{key:"alphaMode",get:/**
     * Gets the PhongMaterial's alpha rendering mode.
     *
     *@type {String}
     */function get(){return alphaModeNames$1[this._state.alphaMode];}/**
     * Sets the PhongMaterial's alpha cutoff value.
     *
     * This specifies the cutoff threshold when {@link PhongMaterial#alphaMode} equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully
     * opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes.
     *
     * Alpha is the combined result of {@link PhongMaterial#alpha} and {@link PhongMaterial#alphaMap}.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */,set:function set(alphaMode){alphaMode=alphaMode||"opaque";var value=alphaModes$1[alphaMode];if(value===undefined){this.error("Unsupported value for 'alphaMode': "+alphaMode+" - defaulting to 'opaque'");value="opaque";}if(this._state.alphaMode===value){return;}this._state.alphaMode=value;this.glRedraw();}},{key:"alphaCutoff",get:/**
     * Gets the PhongMaterial's alpha cutoff value.
     *
     * @type {Number}
     */function get(){return this._state.alphaCutoff;}/**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * The backfaces will belong to {@link Geometry} compoents that are also attached to the {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */,set:function set(alphaCutoff){if(alphaCutoff===null||alphaCutoff===undefined){alphaCutoff=0.5;}if(this._state.alphaCutoff===alphaCutoff){return;}this._state.alphaCutoff=alphaCutoff;}},{key:"backfaces",get:/**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._state.backfaces;}/**
     * Sets the winding direction of geometry front faces.
     *
     * Default is ````"ccw"````.
     * @type {String}
     */,set:function set(value){value=!!value;if(this._state.backfaces===value){return;}this._state.backfaces=value;this.glRedraw();}},{key:"frontface",get:/**
     * Gets the winding direction of front faces on attached {@link Mesh}es.
     *
     * Default is ````"ccw"````.
     * @type {String}
     */function get(){return this._state.frontface?"ccw":"cw";}/**
     * Destroys this PhongMaterial.
     */,set:function set(value){value=value!=="cw";if(this._state.frontface===value){return;}this._state.frontface=value;this.glRedraw();}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(PhongMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return PhongMaterial;}(Material);var PRESETS$3={"default":{fill:true,fillColor:[0.4,0.4,0.4],fillAlpha:0.2,edges:true,edgeColor:[0.2,0.2,0.2],edgeAlpha:0.5,edgeWidth:1},"defaultWhiteBG":{fill:true,fillColor:[1,1,1],fillAlpha:0.6,edgeColor:[0.2,0.2,0.2],edgeAlpha:1.0,edgeWidth:1},"defaultLightBG":{fill:true,fillColor:[0.4,0.4,0.4],fillAlpha:0.2,edges:true,edgeColor:[0.2,0.2,0.2],edgeAlpha:0.5,edgeWidth:1},"defaultDarkBG":{fill:true,fillColor:[0.4,0.4,0.4],fillAlpha:0.2,edges:true,edgeColor:[0.5,0.5,0.5],edgeAlpha:0.5,edgeWidth:1},"phosphorous":{fill:true,fillColor:[0.0,0.0,0.0],fillAlpha:0.4,edges:true,edgeColor:[0.9,0.9,0.9],edgeAlpha:0.5,edgeWidth:2},"sunset":{fill:true,fillColor:[0.9,0.9,0.6],fillAlpha:0.2,edges:true,edgeColor:[0.9,0.9,0.9],edgeAlpha:0.5,edgeWidth:1},"vectorscope":{fill:true,fillColor:[0.0,0.0,0.0],fillAlpha:0.7,edges:true,edgeColor:[0.2,1.0,0.2],edgeAlpha:1,edgeWidth:2},"battlezone":{fill:true,fillColor:[0.0,0.0,0.0],fillAlpha:1.0,edges:true,edgeColor:[0.2,1.0,0.2],edgeAlpha:1,edgeWidth:3},"sepia":{fill:true,fillColor:[0.970588207244873,0.7965892553329468,0.6660899519920349],fillAlpha:0.4,edges:true,edgeColor:[0.529411792755127,0.4577854573726654,0.4100345969200134],edgeAlpha:1.0,edgeWidth:1},"yellowHighlight":{fill:true,fillColor:[1.0,1.0,0.0],fillAlpha:0.5,edges:true,edgeColor:[1.0,1.0,1.0],edgeAlpha:1.0,edgeWidth:1},"greenSelected":{fill:true,fillColor:[0.0,1.0,0.0],fillAlpha:0.5,edges:true,edgeColor:[1.0,1.0,1.0],edgeAlpha:1.0,edgeWidth:1},"gamegrid":{fill:true,fillColor:[0.2,0.2,0.7],fillAlpha:0.9,edges:true,edgeColor:[0.4,0.4,1.6],edgeAlpha:0.8,edgeWidth:3}};/**
 * Configures the appearance of {@link Entity}s when they are xrayed, highlighted or selected.
 *
 * * XRay an {@link Entity} by setting {@link Entity#xrayed} ````true````.
 * * Highlight an {@link Entity} by setting {@link Entity#highlighted} ````true````.
 * * Select an {@link Entity} by setting {@link Entity#selected} ````true````.
 * * When {@link Entity}s are within the subtree of a root {@link Entity}, then setting {@link Entity#xrayed}, {@link Entity#highlighted} or {@link Entity#selected}
 * on the root will collectively set those properties on all sub-{@link Entity}s.
 * * EmphasisMaterial provides several presets. Select a preset by setting {@link EmphasisMaterial#preset} to the ID of a preset in {@link EmphasisMaterial#presets}.
 * * By default, a {@link Mesh} uses the default EmphasisMaterials in {@link Scene#xrayMaterial}, {@link Scene#highlightMaterial} and {@link Scene#selectedMaterial}
 * but you can assign each {@link Mesh#xrayMaterial}, {@link Mesh#highlightMaterial} or {@link Mesh#selectedMaterial} to a custom EmphasisMaterial, if required.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Mesh} with its own XRayMaterial and set {@link Mesh#xrayed} ````true```` to xray it.
 *
 * Recall that {@link Mesh} is a concrete subtype of the abstract {@link Entity} base class.
 *
 * ````javascript
 * new Mesh(viewer.scene, {
 *     geometry: new BoxGeometry(viewer.scene, {
 *         edgeThreshold: 1
 *     }),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuse: [0.2, 0.2, 1.0]
 *     }),
 *     xrayMaterial: new EmphasisMaterial(viewer.scene, {
 *         fill: true,
 *         fillColor: [0, 0, 0],
 *         fillAlpha: 0.7,
 *         edges: true,
 *         edgeColor: [0.2, 1.0, 0.2],
 *         edgeAlpha: 1.0,
 *         edgeWidth: 2
 *     }),
 *     xrayed: true
 * });
 * ````
 *
 * Note the ````edgeThreshold```` configuration for the {@link ReadableGeometry} on our {@link Mesh}.  EmphasisMaterial configures
 * a wireframe representation of the {@link ReadableGeometry} for the selected emphasis mode, which will have inner edges (those edges between
 * adjacent co-planar triangles) removed for visual clarity. The ````edgeThreshold```` indicates that, for
 * this particular {@link ReadableGeometry}, an inner edge is one where the angle between the surface normals of adjacent triangles
 * is not greater than ````5```` degrees. That's set to ````2```` by default, but we can override it to tweak the effect
 * as needed for particular Geometries.
 *
 * Here's the example again, this time implicitly defaulting to the {@link Scene#edgeMaterial}. We'll also modify that EdgeMaterial
 * to customize the effect.
 *
 * ````javascript
 * new Mesh({
 *     geometry: new TeapotGeometry(viewer.scene, {
 *         edgeThreshold: 5
 *     }),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuse: [0.2, 0.2, 1.0]
 *     }),
 *     xrayed: true
 * });
 *
 * var xrayMaterial = viewer.scene.xrayMaterial;
 *
 * xrayMaterial.fillColor = [0.2, 1.0, 0.2];
 * xrayMaterial.fillAlpha = 1.0;
 * ````
 *
 * ## Presets
 *
 * Let's switch the {@link Scene#xrayMaterial} to one of the presets in {@link EmphasisMaterial#presets}:
 *
 * ````javascript
 * viewer.xrayMaterial.preset = EmphasisMaterial.presets["sepia"];
 * ````
 *
 * We can also create an EmphasisMaterial from a preset, while overriding properties of the preset as required:
 *
 * ````javascript
 * var myEmphasisMaterial = new EMphasisMaterial(viewer.scene, {
 *      preset: "sepia",
 *      fillColor = [1.0, 0.5, 0.5]
 * });
 * ````
 */var EmphasisMaterial=/*#__PURE__*/function(_Material2){_inherits(EmphasisMaterial,_Material2);var _super27=_createSuper(EmphasisMaterial);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The EmphasisMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Boolean} [cfg.fill=true] Indicates if xray surfaces are filled with color.
     * @param {Number[]} [cfg.fillColor=[0.4,0.4,0.4]] EmphasisMaterial fill color.
     * @param  {Number} [cfg.fillAlpha=0.2] Transparency of filled xray faces. A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     * @param {Boolean} [cfg.edges=true] Indicates if xray edges are visible.
     * @param {Number[]} [cfg.edgeColor=[0.2,0.2,0.2]]  RGB color of xray edges.
     * @param {Number} [cfg.edgeAlpha=0.5] Transparency of xray edges. A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     * @param {Number} [cfg.edgeWidth=1] Width of xray edges, in pixels.
     * @param {String} [cfg.preset] Selects a preset EmphasisMaterial configuration - see {@link EmphasisMaterial#presets}.
     * @param {Boolean} [cfg.backfaces=false] Whether to render geometry backfaces when emphasising.
     * @param {Boolean} [cfg.glowThrough=true] Whether to make the emphasized object appear to float on top of other objects, as if it were "glowing through" them.
     */function EmphasisMaterial(owner){var _this46;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,EmphasisMaterial);_this46=_super27.call(this,owner,cfg);_this46._state=new RenderState({type:"EmphasisMaterial",fill:null,fillColor:null,fillAlpha:null,edges:null,edgeColor:null,edgeAlpha:null,edgeWidth:null,backfaces:true,glowThrough:true});_this46._preset="default";if(cfg.preset){// Apply preset then override with configs where provided
_this46.preset=cfg.preset;if(cfg.fill!==undefined){_this46.fill=cfg.fill;}if(cfg.fillColor){_this46.fillColor=cfg.fillColor;}if(cfg.fillAlpha!==undefined){_this46.fillAlpha=cfg.fillAlpha;}if(cfg.edges!==undefined){_this46.edges=cfg.edges;}if(cfg.edgeColor){_this46.edgeColor=cfg.edgeColor;}if(cfg.edgeAlpha!==undefined){_this46.edgeAlpha=cfg.edgeAlpha;}if(cfg.edgeWidth!==undefined){_this46.edgeWidth=cfg.edgeWidth;}if(cfg.backfaces!==undefined){_this46.backfaces=cfg.backfaces;}if(cfg.glowThrough!==undefined){_this46.glowThrough=cfg.glowThrough;}}else{_this46.fill=cfg.fill;_this46.fillColor=cfg.fillColor;_this46.fillAlpha=cfg.fillAlpha;_this46.edges=cfg.edges;_this46.edgeColor=cfg.edgeColor;_this46.edgeAlpha=cfg.edgeAlpha;_this46.edgeWidth=cfg.edgeWidth;_this46.backfaces=cfg.backfaces;_this46.glowThrough=cfg.glowThrough;}return _this46;}/**
     * Sets if surfaces are filled with color.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */_createClass(EmphasisMaterial,[{key:"type",get:/**
     @private
     */function get(){return"EmphasisMaterial";}/**
     * Gets available EmphasisMaterial presets.
     *
     * @type {Object}
     */},{key:"presets",get:function get(){return PRESETS$3;}},{key:"fill",get:/**
     * Gets if surfaces are filled with color.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._state.fill;}/**
     * Sets the RGB color of filled faces.
     *
     * Default is ````[0.4, 0.4, 0.4]````.
     *
     * @type {Number[]}
     */,set:function set(value){value=value!==false;if(this._state.fill===value){return;}this._state.fill=value;this.glRedraw();}},{key:"fillColor",get:/**
     * Gets the RGB color of filled faces.
     *
     * Default is ````[0.4, 0.4, 0.4]````.
     *
     * @type {Number[]}
     */function get(){return this._state.fillColor;}/**
     * Sets the transparency of filled faces.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */,set:function set(value){var fillColor=this._state.fillColor;if(!fillColor){fillColor=this._state.fillColor=new Float32Array(3);}else if(value&&fillColor[0]===value[0]&&fillColor[1]===value[1]&&fillColor[2]===value[2]){return;}if(value){fillColor[0]=value[0];fillColor[1]=value[1];fillColor[2]=value[2];}else{fillColor[0]=0.4;fillColor[1]=0.4;fillColor[2]=0.4;}this.glRedraw();}},{key:"fillAlpha",get:/**
     * Gets the transparency of filled faces.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */function get(){return this._state.fillAlpha;}/**
     * Sets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined&&value!==null?value:0.2;if(this._state.fillAlpha===value){return;}this._state.fillAlpha=value;this.glRedraw();}},{key:"edges",get:/**
     * Gets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._state.edges;}/**
     * Sets the RGB color of edges.
     *
     * Default is ```` [0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */,set:function set(value){value=value!==false;if(this._state.edges===value){return;}this._state.edges=value;this.glRedraw();}},{key:"edgeColor",get:/**
     * Gets the RGB color of edges.
     *
     * Default is ```` [0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */function get(){return this._state.edgeColor;}/**
     * Sets the transparency of edges.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */,set:function set(value){var edgeColor=this._state.edgeColor;if(!edgeColor){edgeColor=this._state.edgeColor=new Float32Array(3);}else if(value&&edgeColor[0]===value[0]&&edgeColor[1]===value[1]&&edgeColor[2]===value[2]){return;}if(value){edgeColor[0]=value[0];edgeColor[1]=value[1];edgeColor[2]=value[2];}else{edgeColor[0]=0.2;edgeColor[1]=0.2;edgeColor[2]=0.2;}this.glRedraw();}},{key:"edgeAlpha",get:/**
     * Gets the transparency of edges.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */function get(){return this._state.edgeAlpha;}/**
     * Sets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */,set:function set(value){value=value!==undefined&&value!==null?value:0.5;if(this._state.edgeAlpha===value){return;}this._state.edgeAlpha=value;this.glRedraw();}},{key:"edgeWidth",get:/**
     * Gets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */function get(){return this._state.edgeWidth;}/**
     * Sets whether to render backfaces when {@link EmphasisMaterial#fill} is ````true````.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){this._state.edgeWidth=value||1.0;this.glRedraw();}},{key:"backfaces",get:/**
     * Gets whether to render backfaces when {@link EmphasisMaterial#fill} is ````true````.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._state.backfaces;}/**
     * Sets whether to render emphasized objects over the top of other objects, as if they were "glowing through".
     *
     * Default is ````true````.
     *
     * Note: updating this property will not affect the appearance of objects that are already emphasized.
     *
     * @type {Boolean}
     */,set:function set(value){value=!!value;if(this._state.backfaces===value){return;}this._state.backfaces=value;this.glRedraw();}},{key:"glowThrough",get:/**
     * Sets whether to render emphasized objects over the top of other objects, as if they were "glowing through".
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._state.glowThrough;}/**
     * Selects a preset EmphasisMaterial configuration.
     *
     * Default value is "default".
     *
     * @type {String}
     */,set:function set(value){value=value!==false;if(this._state.glowThrough===value){return;}this._state.glowThrough=value;this.glRedraw();}},{key:"preset",get:/**
     * Gets the current preset EmphasisMaterial configuration.
     *
     * Default value is "default".
     *
     * @type {String}
     */function get(){return this._preset;}/**
     * Destroys this EmphasisMaterial.
     */,set:function set(value){value=value||"default";if(this._preset===value){return;}var preset=PRESETS$3[value];if(!preset){this.error("unsupported preset: '"+value+"' - supported values are "+Object.keys(PRESETS$3).join(", "));return;}this.fill=preset.fill;this.fillColor=preset.fillColor;this.fillAlpha=preset.fillAlpha;this.edges=preset.edges;this.edgeColor=preset.edgeColor;this.edgeAlpha=preset.edgeAlpha;this.edgeWidth=preset.edgeWidth;this.glowThrough=preset.glowThrough;this._preset=value;}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(EmphasisMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return EmphasisMaterial;}(Material);var PRESETS$2={"default":{edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1},"defaultWhiteBG":{edgeColor:[0.2,0.2,0.2],edgeAlpha:1.0,edgeWidth:1},"defaultLightBG":{edgeColor:[0.2,0.2,0.2],edgeAlpha:1.0,edgeWidth:1},"defaultDarkBG":{edgeColor:[0.5,0.5,0.5],edgeAlpha:1.0,edgeWidth:1}};/**
 * @desc Configures the appearance of {@link Entity}s when their edges are emphasised.
 *
 * * Emphasise edges of an {@link Entity} by setting {@link Entity#edges} ````true````.
 * * When {@link Entity}s are within the subtree of a root {@link Entity}, then setting {@link Entity#edges} on the root
 * will collectively set that property on all sub-{@link Entity}s.
 * * EdgeMaterial provides several presets. Select a preset by setting {@link EdgeMaterial#preset} to the ID of a preset in {@link EdgeMaterial#presets}.
 * * By default, a {@link Mesh} uses the default EdgeMaterial in {@link Scene#edgeMaterial}, but you can assign each {@link Mesh#edgeMaterial} to a custom EdgeMaterial if required.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Mesh} with its own EdgeMaterial and set {@link Mesh#edges} ````true```` to emphasise its edges.
 *
 * Recall that {@link Mesh} is a concrete subtype of the abstract {@link Entity} base class.
 *
 * [[Run this example](/examples/#materials_EdgeMaterial)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      ReadableGeometry, PhongMaterial, EdgeMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 1.5,
 *          heightSegments: 24,
 *          widthSegments: 16,
 *          edgeThreshold: 2 // Default is 10
 *      })),
 *
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuse: [0.4, 0.4, 1.0],
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          alpha: 0.5,
 *          alphaMode: "blend"
 *      }),
 *
 *      edgeMaterial: new EdgeMaterial(viewer.scene, {
 *          edgeColor: [0.0, 0.0, 1.0]
 *          edgeAlpha: 1.0,
 *          edgeWidth: 2
 *      }),
 *
 *      edges: true
 * });
 * ````
 *
 * Note the ````edgeThreshold```` configuration for the {@link ReadableGeometry} on our {@link Mesh}.  EdgeMaterial configures
 * a wireframe representation of the {@link ReadableGeometry}, which will have inner edges (those edges between
 * adjacent co-planar triangles) removed for visual clarity. The ````edgeThreshold```` indicates that, for
 * this particular {@link ReadableGeometry}, an inner edge is one where the angle between the surface normals of adjacent triangles
 * is not greater than ````5```` degrees. That's set to ````2```` by default, but we can override it to tweak the effect
 * as needed for particular Geometries.
 *
 * Here's the example again, this time implicitly defaulting to the {@link Scene#edgeMaterial}. We'll also modify that EdgeMaterial
 * to customize the effect.
 *
 * ````javascript
 * new Mesh({
 *     geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 1.5,
 *          heightSegments: 24,
 *          widthSegments: 16,
 *          edgeThreshold: 2 // Default is 10
 *      })),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuse: [0.2, 0.2, 1.0]
 *     }),
 *     edges: true
 * });
 *
 * var edgeMaterial = viewer.scene.edgeMaterial;
 *
 * edgeMaterial.edgeColor = [0.2, 1.0, 0.2];
 * edgeMaterial.edgeAlpha = 1.0;
 * edgeMaterial.edgeWidth = 2;
 * ````
 *
 *  ## Presets
 *
 * Let's switch the {@link Scene#edgeMaterial} to one of the presets in {@link EdgeMaterial#presets}:
 *
 * ````javascript
 * viewer.edgeMaterial.preset = EdgeMaterial.presets["sepia"];
 * ````
 *
 * We can also create an EdgeMaterial from a preset, while overriding properties of the preset as required:
 *
 * ````javascript
 * var myEdgeMaterial = new EdgeMaterial(viewer.scene, {
 *      preset: "sepia",
 *      edgeColor = [1.0, 0.5, 0.5]
 * });
 * ````
 */var EdgeMaterial=/*#__PURE__*/function(_Material3){_inherits(EdgeMaterial,_Material3);var _super28=_createSuper(EdgeMaterial);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The EdgeMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.edgeColor=[0.2,0.2,0.2]] RGB edge color.
     * @param {Number} [cfg.edgeAlpha=1.0] Edge transparency. A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     * @param {Number} [cfg.edgeWidth=1] Edge width in pixels.
     * @param {String} [cfg.preset] Selects a preset EdgeMaterial configuration - see {@link EdgeMaterial#presets}.
     */function EdgeMaterial(owner){var _this47;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,EdgeMaterial);_this47=_super28.call(this,owner,cfg);_this47._state=new RenderState({type:"EdgeMaterial",edges:null,edgeColor:null,edgeAlpha:null,edgeWidth:null});_this47._preset="default";if(cfg.preset){// Apply preset then override with configs where provided
_this47.preset=cfg.preset;if(cfg.edgeColor){_this47.edgeColor=cfg.edgeColor;}if(cfg.edgeAlpha!==undefined){_this47.edgeAlpha=cfg.edgeAlpha;}if(cfg.edgeWidth!==undefined){_this47.edgeWidth=cfg.edgeWidth;}}else{_this47.edgeColor=cfg.edgeColor;_this47.edgeAlpha=cfg.edgeAlpha;_this47.edgeWidth=cfg.edgeWidth;}_this47.edges=cfg.edges!==false;return _this47;}/**
     * Sets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */_createClass(EdgeMaterial,[{key:"type",get:/**
     @private
     */function get(){return"EdgeMaterial";}/**
     * Gets available EdgeMaterial presets.
     *
     * @type {Object}
     */},{key:"presets",get:function get(){return PRESETS$2;}},{key:"edges",get:/**
     * Gets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._state.edges;}/**
     * Sets RGB edge color.
     *
     * Default value is ````[0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */,set:function set(value){value=value!==false;if(this._state.edges===value){return;}this._state.edges=value;this.glRedraw();}},{key:"edgeColor",get:/**
     * Gets RGB edge color.
     *
     * Default value is ````[0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */function get(){return this._state.edgeColor;}/**
     * Sets edge transparency.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){var edgeColor=this._state.edgeColor;if(!edgeColor){edgeColor=this._state.edgeColor=new Float32Array(3);}else if(value&&edgeColor[0]===value[0]&&edgeColor[1]===value[1]&&edgeColor[2]===value[2]){return;}if(value){edgeColor[0]=value[0];edgeColor[1]=value[1];edgeColor[2]=value[2];}else{edgeColor[0]=0.2;edgeColor[1]=0.2;edgeColor[2]=0.2;}this.glRedraw();}},{key:"edgeAlpha",get:/**
     * Gets edge transparency.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */function get(){return this._state.edgeAlpha;}/**
     * Sets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.edgeAlpha===value){return;}this._state.edgeAlpha=value;this.glRedraw();}},{key:"edgeWidth",get:/**
     * Gets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */function get(){return this._state.edgeWidth;}/**
     * Selects a preset EdgeMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */,set:function set(value){this._state.edgeWidth=value||1.0;this.glRedraw();}},{key:"preset",get:/**
     * The current preset EdgeMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */function get(){return this._preset;}/**
     * Destroys this EdgeMaterial.
     */,set:function set(value){value=value||"default";if(this._preset===value){return;}var preset=PRESETS$2[value];if(!preset){this.error("unsupported preset: '"+value+"' - supported values are "+Object.keys(PRESETS$2).join(", "));return;}this.edgeColor=preset.edgeColor;this.edgeAlpha=preset.edgeAlpha;this.edgeWidth=preset.edgeWidth;this._preset=value;}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(EdgeMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return EdgeMaterial;}(Material);//----------------------------------------------------------------------------------------------------------------------
var unitsInfo={meters:{abbrev:"m"},metres:{abbrev:"m"},centimeters:{abbrev:"cm"},centimetres:{abbrev:"cm"},millimeters:{abbrev:"mm"},millimetres:{abbrev:"mm"},yards:{abbrev:"yd"},feet:{abbrev:"ft"},inches:{abbrev:"in"}};/**
 * @desc Configures its {@link Scene}'s measurement unit and mapping between the Real-space and World-space 3D Cartesian coordinate systems.
 *
 *
 * ## Overview
 *
 * * Located at {@link Scene#metrics}.
 * * {@link Metrics#units} configures the Real-space unit type, which is ````"meters"```` by default.
 * * {@link Metrics#scale} configures the number of Real-space units represented by each unit within the World-space 3D coordinate system. This is ````1.0```` by default.
 * * {@link Metrics#origin} configures the 3D Real-space origin, in current Real-space units, at which this {@link Scene}'s World-space coordinate origin sits, This is ````[0,0,0]```` by default.
 *
 * ## Usage
 *
 * Let's load a model using an {@link XKTLoaderPlugin}, then configure the Real-space unit type and the coordinate
 * mapping between the Real-space and World-space 3D coordinate systems.
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * const metrics = viewer.scene.metrics;
 *
 * metrics.units = "meters";
 * metrics.scale = 10.0;
 * metrics.origin = [100.0, 0.0, 200.0];
 * ````
 */var Metrics=/*#__PURE__*/function(_Component18){_inherits(Metrics,_Component18);var _super29=_createSuper(Metrics);/**
     * @constructor
     * @private
     */function Metrics(owner){var _this48;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Metrics);_this48=_super29.call(this,owner,cfg);_this48._units="meters";_this48._scale=1.0;_this48._origin=math.vec3([0,0,0]);_this48.units=cfg.units;_this48.scale=cfg.scale;_this48.origin=cfg.origin;return _this48;}/**
     * Gets info about the supported Real-space unit types.
     *
     * This will be:
     *
     * ````javascript
     * {
     *      {
     *          meters: {
     *              abbrev: "m"
     *          },
     *          metres: {
     *              abbrev: "m"
     *          },
     *          centimeters: {
     *              abbrev: "cm"
     *          },
     *          centimetres: {
     *              abbrev: "cm"
     *          },
     *          millimeters: {
     *              abbrev: "mm"
     *          },
     *          millimetres: {
     *              abbrev: "mm"
     *          },
     *          yards: {
     *              abbrev: "yd"
     *          },
     *          feet: {
     *              abbrev: "ft"
     *          },
     *          inches: {
     *              abbrev: "in"
     *          }
     *      }
     * }
     * ````
     *
     * @type {*}
     */_createClass(Metrics,[{key:"unitsInfo",get:function get(){return unitsInfo;}/**
     * Sets the {@link Scene}'s Real-space unit type.
     *
     * Accepted values are ````"meters"````, ````"centimeters"````, ````"millimeters"````, ````"metres"````, ````"centimetres"````, ````"millimetres"````, ````"yards"````, ````"feet"```` and ````"inches"````.
     *
     * @emits ````"units"```` event on change, with the value of this property.
     * @type {String}
     */},{key:"units",get:/**
     * Gets the {@link Scene}'s Real-space unit type.
     *
     * @type {String}
     */function get(){return this._units;}/**
     * Sets the number of Real-space units represented by each unit of the {@link Scene}'s World-space coordinate system.
     *
     * For example, if {@link Metrics#units} is ````"meters"````, and there are ten meters per World-space coordinate system unit, then ````scale```` would have a value of ````10.0````.
     *
     * @emits ````"scale"```` event on change, with the value of this property.
     * @type {Number}
     */,set:function set(value){if(!value){value="meters";}var info=unitsInfo[value];if(!info){this.error("Unsupported value for 'units': "+value+" defaulting to 'meters'");value="meters";}this._units=value;this.fire("units",this._units);}},{key:"scale",get:/**
     * Gets the number of Real-space units represented by each unit of the {@link Scene}'s World-space coordinate system.
     *
     * @type {Number}
     */function get(){return this._scale;}/**
     * Sets the Real-space 3D origin, in Real-space units, at which this {@link Scene}'s World-space coordinate origin ````[0,0,0]```` sits.
     *
     * @emits "origin" event on change, with the value of this property.
     * @type {Number[]}
     */,set:function set(value){value=value||1;if(value<=0){this.error("scale value should be larger than zero");return;}this._scale=value;this.fire("scale",this._scale);}},{key:"origin",get:/**
     * Gets the 3D Real-space origin, in Real-space units, at which this {@link Scene}'s World-space coordinate origin ````[0,0,0]```` sits.
     *
     * @type {Number[]}
     */function get(){return this._origin;}/**
     * Converts a 3D position from World-space to Real-space.
     *
     * This is equivalent to ````realPos = #origin + (worldPos * #scale)````.
     *
     * @param {Number[]} worldPos World-space 3D position, in World coordinate system units.
     * @param {Number[]} [realPos] Destination for Real-space 3D position.
     * @returns {Number[]} Real-space 3D position, in units indicated by {@link Metrics#units}.
     */,set:function set(value){if(!value){this._origin[0]=0;this._origin[1]=0;this._origin[2]=0;return;}this._origin[0]=value[0];this._origin[1]=value[1];this._origin[2]=value[2];this.fire("origin",this._origin);}},{key:"worldToRealPos",value:function worldToRealPos(worldPos){var realPos=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec3(3);realPos[0]=this._origin[0]+this._scale*worldPos[0];realPos[1]=this._origin[1]+this._scale*worldPos[1];realPos[2]=this._origin[2]+this._scale*worldPos[2];}/**
     * Converts a 3D position from Real-space to World-space.
     *
     * This is equivalent to ````worldPos = (worldPos - #origin) / #scale````.
     *
     * @param {Number[]} realPos Real-space 3D position.
     * @param {Number[]} [worldPos] Destination for World-space 3D position.
     * @returns {Number[]} World-space 3D position.
     */},{key:"realToWorldPos",value:function realToWorldPos(realPos){var worldPos=arguments.length>1&&arguments[1]!==undefined?arguments[1]:math.vec3(3);worldPos[0]=(realPos[0]-this._origin[0])/this._scale;worldPos[1]=(realPos[1]-this._origin[1])/this._scale;worldPos[2]=(realPos[2]-this._origin[2])/this._scale;return worldPos;}}]);return Metrics;}(Component);/**
 * @desc Configures Scalable Ambient Obscurance (SAO) for a {@link Scene}.
 *
 *  <a href="https://xeokit.github.io/xeokit-sdk/examples/#postEffects_SAO_OTCConferenceCenter"><img src="http://xeokit.io/img/docs/SAO/saoEnabledDisabled.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#postEeffects_SAO_OTCConferenceCenter)]
 *
 * ## Overview
 *
 * SAO approximates [Ambient Occlusion](https://en.wikipedia.org/wiki/Ambient_occlusion) in realtime. It darkens creases, cavities and surfaces
 * that are close to each other, which tend to be occluded from ambient light and appear darker.
 *
 * The animated GIF above shows the effect as we repeatedly enable and disable SAO. When SAO is enabled, we can see darkening
 * in regions such as the corners, and the crevices between stairs. This increases the amount of detail we can see when ambient
 * light is high, or when objects have uniform colors across their surfaces. Run the example to experiment with the various
 * SAO configurations.
 *
 * xeokit's implementation of SAO is based on the paper [Scalable Ambient Obscurance](https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf).
 *
 * ## Caveats
 *
 * Currently, SAO only works with perspective and orthographic projections. Therefore, to use SAO, make sure {@link Camera#projection} is
 * either "perspective" or "ortho".
 *
 * {@link SAO#scale} and {@link SAO#intensity} must be tuned to the distance
 * between {@link Perspective#near} and {@link Perspective#far}, or the distance
 * between {@link Ortho#near} and {@link Ortho#far}, depending on which of those two projections the {@link Camera} is currently
 * using. Use the [live example](https://xeokit.github.io/xeokit-sdk/examples/#postEeffects_SAO_OTCConferenceCenter) to get a
 * feel for that.
 *
 * ## Usage
 *
 * In the example below, we'll start by logging a warning message to the console if SAO is not supported by the
 * system.
 *
 *Then we'll enable and configure SAO, position the camera, and configure the near and far perspective and orthographic
 * clipping planes. Finally, we'll use {@link XKTLoaderPlugin} to load the OTC Conference Center model.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * const sao = viewer.scene.sao;
 *
 * if (!sao.supported) {
 *     sao.warn("SAO is not supported on this system - ignoring SAO configs")
 * }
 *
 * sao.enabled = true; // Enable SAO - only works if supported (see above)
 * sao.intensity = 0.15;
 * sao.bias = 0.5;
 * sao.scale = 1.0;
 * sao.minResolution = 0.0;
 * sao.numSamples = 10;
 * sao.kernelRadius = 100;
 * sao.blendCutoff = 0.1;
 *
 * const camera = viewer.scene.camera;
 *
 * camera.eye = [3.69, 5.83, -23.98];
 * camera.look = [84.31, -29.88, -116.21];
 * camera.up = [0.18, 0.96, -0.21];
 *
 * camera.perspective.near = 0.1;
 * camera.perspective.far = 2000.0;
 *
 * camera.ortho.near = 0.1;
 * camera.ortho.far = 2000.0;
 * camera.projection = "perspective";
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/OTCConferenceCenter.xkt"
 *     edges: true
 * });
 * ````
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#postEeffects_SAO_OTCConferenceCenter)]
 *
 * ## Efficiency
 *
 * SAO can incur some rendering overhead, especially on objects that are viewed close to the camera. For this reason,
 * it's recommended to use a low value for {@link SAO#kernelRadius}.  A low radius will sample pixels that are close
 * to the source pixel, which will allow the GPU to efficiently cache those pixels. When {@link Camera#projection} is "perspective",
 * objects near to the viewpoint will use larger radii than farther pixels. Therefore, computing  SAO for close objects
 * is more expensive than for objects far away, that occupy fewer pixels on the canvas.
 *
 * ## Selectively enabling SAO for models
 *
 * When loading multiple models into a Scene, we sometimes only want SAO on the models that are actually going to
 * show it, such as the architecture or structure, and not show SAO on models that won't show it well, such as the
 * electrical wiring, or plumbing.
 *
 * To illustrate, lets load some of the models for the West Riverside Hospital. We'll enable SAO on the structure model,
 * but disable it on the electrical and plumbing.
 *
 * This will only apply SAO to those models if {@link SAO#supported} and {@link SAO#enabled} are both true.
 *
 * Note, by the way, how we load the models in sequence. Since XKTLoaderPlugin uses scratch memory as part of its loading
 * process, this allows the plugin to reuse that same memory across multiple loads, instead of having to create multiple
 * pools of scratch memory.
 *
 * ````javascript
 * const structure = xktLoader.load({
 *      id: "structure",
 *      src: "./models/xkt/WestRiverSideHospital/structure.xkt"
 *      edges: true,
 *      saoEnabled: true
 *  });
 *
 *  structure.on("loaded", () => {
 *
 *      const electrical = xktLoader.load({
 *          id: "electrical",
 *          src: "./models/xkt/WestRiverSideHospital/electrical.xkt",
 *          edges: true
 *      });
 *
 *      electrical.on("loaded", () => {
 *
 *          const plumbing = xktLoader.load({
 *              id: "plumbing",
 *              src: "./models/xkt/WestRiverSideHospital/plumbing.xkt",
 *              edges: true
 *          });
 *      });
 * });
 * ````
 *
 * ## Disabling SAO while camera is moving
 *
 * For smoother interaction with large models on low-power hardware, we can disable SAO while the {@link Camera} is moving:
 *
 * ````javascript
 * const timeoutDuration = 150; // Milliseconds
 * var timer = timeoutDuration;
 * var saoDisabled = false;
 *
 * const onCameraMatrix = scene.camera.on("matrix", () => {
 *     timer = timeoutDuration;
 *     if (!saoDisabled) {
 *         scene.sao.enabled = false;
 *         saoDisabled = true;
 *     }
 * });
 *
 * const onSceneTick = scene.on("tick", (tickEvent) => {
 *     if (!saoDisabled) {
 *         return;
 *     }
 *     timer -= tickEvent.deltaTime; // Milliseconds
 *     if (timer <= 0) {
 *         if (saoDisabled) {
 *             scene.sao.enabled = true;
 *             saoDisabled = false;
 *         }
 *     }
 * });
 * ````
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#techniques_nonInteractiveQuality)]
 */var SAO=/*#__PURE__*/function(_Component19){_inherits(SAO,_Component19);var _super30=_createSuper(SAO);/** @private */function SAO(owner){var _this49;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SAO);_this49=_super30.call(this,owner,cfg);_this49._supported=WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_standard_derivatives"];// For computing normals in SAO fragment shader
_this49.enabled=cfg.enabled;_this49.kernelRadius=cfg.kernelRadius;_this49.intensity=cfg.intensity;_this49.bias=cfg.bias;_this49.scale=cfg.scale;_this49.minResolution=cfg.minResolution;_this49.numSamples=cfg.numSamples;_this49.blur=cfg.blur;_this49.blendCutoff=cfg.blendCutoff;_this49.blendFactor=cfg.blendFactor;return _this49;}/**
     * Gets whether or not SAO is supported by this browser and GPU.
     *
     * Even when enabled, SAO will only work if supported.
     *
     * @type {Boolean}
     */_createClass(SAO,[{key:"supported",get:function get(){return this._supported;}/**
     * Sets whether SAO is enabled for the {@link Scene}.
     *
     * Even when enabled, SAO will only work if supported.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */},{key:"enabled",get:/**
     * Gets whether SAO is enabled for the {@link Scene}.
     *
     * Even when enabled, SAO will only apply if supported.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._enabled;}/**
     * Returns true if SAO is currently possible, where it is supported, enabled, and the current scene state is compatible.
     * Called internally by renderer logic.
     * @private
     * @returns {Boolean}
     */,set:function set(value){value=!!value;if(this._enabled===value){return;}this._enabled=value;this.glRedraw();}},{key:"possible",get:function get(){if(!this._supported){return false;}if(!this._enabled){return false;}var projection=this.scene.camera.projection;if(projection==="customProjection"){return false;}if(projection==="frustum"){return false;}return true;}/**
     * @private
     * @returns {boolean|*}
     */},{key:"active",get:function get(){return this._active;}/**
     * Sets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
     *
     * Default value is ````100.0````.
     *
     * @type {Number}
     */},{key:"kernelRadius",get:/**
     * Gets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
     *
     * Default value is ````100.0````.
     *
     * @type {Number}
     */function get(){return this._kernelRadius;}/**
     * Sets the degree of darkening (ambient obscurance) produced by the SAO effect.
     *
     * Default value is ````0.15````.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=100.0;}if(this._kernelRadius===value){return;}this._kernelRadius=value;this.glRedraw();}},{key:"intensity",get:/**
     * Gets the degree of darkening (ambient obscurance) produced by the SAO effect.
     *
     * Default value is ````0.15````.
     *
     * @type {Number}
     */function get(){return this._intensity;}/**
     * Sets the SAO bias.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=0.15;}if(this._intensity===value){return;}this._intensity=value;this.glRedraw();}},{key:"bias",get:/**
     * Gets the SAO bias.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */function get(){return this._bias;}/**
     * Sets the SAO occlusion scale.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=0.5;}if(this._bias===value){return;}this._bias=value;this.glRedraw();}},{key:"scale",get:/**
     * Gets the SAO occlusion scale.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */function get(){return this._scale;}/**
     * Sets the SAO minimum resolution.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=1.0;}if(this._scale===value){return;}this._scale=value;this.glRedraw();}},{key:"minResolution",get:/**
     * Gets the SAO minimum resolution.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */function get(){return this._minResolution;}/**
     * Sets the number of SAO samples.
     *
     * Default value is ````10````.
     *
     * Update this sparingly, since it causes a shader recompile.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=0.0;}if(this._minResolution===value){return;}this._minResolution=value;this.glRedraw();}},{key:"numSamples",get:/**
     * Gets the number of SAO samples.
     *
     * Default value is ````10````.
     *
     * @type {Number}
     */function get(){return this._numSamples;}/**
     * Sets whether Guassian blur is enabled.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){if(value===undefined||value===null){value=10;}if(this._numSamples===value){return;}this._numSamples=value;this.glRedraw();}},{key:"blur",get:/**
     * Gets whether Guassian blur is enabled.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._blur;}/**
     * Sets the SAO blend cutoff.
     *
     * Default value is ````0.3````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */,set:function set(value){value=value!==false;if(this._blur===value){return;}this._blur=value;this.glRedraw();}},{key:"blendCutoff",get:/**
     * Gets the SAO blend cutoff.
     *
     * Default value is ````0.3````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */function get(){return this._blendCutoff;}/**
     * Sets the SAO blend factor.
     *
     * Default value is ````1.0````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=0.3;}if(this._blendCutoff===value){return;}this._blendCutoff=value;this.glRedraw();}},{key:"blendFactor",get:/**
     * Gets the SAO blend scale.
     *
     * Default value is ````1.0````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */function get(){return this._blendFactor;}/**
     * Destroys this component.
     */,set:function set(value){if(value===undefined||value===null){value=1.0;}if(this._blendFactor===value){return;}this._blendFactor=value;this.glRedraw();}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(SAO.prototype),"destroy",this).call(this);}}]);return SAO;}(Component);var PRESETS$1={"default":{pointSize:4,roundPoints:true,perspectivePoints:true},"square":{pointSize:4,roundPoints:false,perspectivePoints:true},"round":{pointSize:4,roundPoints:true,perspectivePoints:true}};/**
 * @desc Configures the size and shape of "points" geometry primitives.
 *
 * * Located at {@link Scene#pointsMaterial}.
 * * Supports round and square points.
 * * Optional perspective point scaling.
 * * Globally configures "points" primitives for all {@link VBOSceneModel}s.
 *
 * ## Usage
 *
 * In the example below, we'll customize the {@link Scene}'s global ````PointsMaterial````, then use
 * an {@link XKTLoaderPlugin} to load a model containing a point cloud.
 *
 * [[Run this example](/examples/#materials_PointsMaterial)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * viewer.scene.pointsMaterial.pointSize = 2;
 * viewer.scene.pointsMaterial.roundPoints = true;
 * viewer.scene.pointsMaterial.perspectivePoints = true;
 * viewer.scene.pointsMaterial.minPerspectivePointSize = 1;
 * viewer.scene.pointsMaterial.maxPerspectivePointSize = 6;
 * viewer.scene.pointsMaterial.filterIntensity = true;
 * viewer.scene.pointsMaterial.minIntensity = 0.0;
 * viewer.scene.pointsMaterial.maxIntensity = 1.0;
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "../assets/models/xkt/MAP-PointCloud.xkt"
 * });
 * ````
 */var PointsMaterial=/*#__PURE__*/function(_Material4){_inherits(PointsMaterial,_Material4);var _super31=_createSuper(PointsMaterial);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The PointsMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number} [cfg.pointSize=2] Point size in pixels.
     * @param {Boolean} [cfg.roundPoints=true] Whether points are round (````true````) or square (````false````).
     * @param {Boolean} [cfg.perspectivePoints=true] Whether apparent point size reduces with distance when {@link Camera#projection} is set to "perspective".
     * @param {Number} [cfg.minPerspectivePointSize=1] When ````perspectivePoints```` is ````true````, this is the minimum rendered size of each point in pixels.
     * @param {Number} [cfg.maxPerspectivePointSize=6] When ````perspectivePoints```` is ````true````, this is the maximum rendered size of each point in pixels.
     * @param {Boolean} [cfg.filterIntensity=false] When this is true, points are only rendered when their intensity value falls within the range given in {@link }
     * @param {Number} [cfg.minIntensity=0] When ````filterIntensity```` is ````true````, points with intensity below this value will not be rendered.
     * @param {Number} [cfg.maxIntensity=1] When ````filterIntensity```` is ````true````, points with intensity above this value will not be rendered.
     * @param {String} [cfg.preset] Selects a preset PointsMaterial configuration - see {@link PointsMaterial#presets}.
     */function PointsMaterial(owner){var _this50;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PointsMaterial);_this50=_super31.call(this,owner,cfg);_this50._state=new RenderState({type:"PointsMaterial",pointSize:null,roundPoints:null,perspectivePoints:null,minPerspectivePointSize:null,maxPerspectivePointSize:null,filterIntensity:null,minIntensity:null,maxIntensity:null});if(cfg.preset){// Apply preset then override with configs where provided
_this50.preset=cfg.preset;if(cfg.pointSize!==undefined){_this50.pointSize=cfg.pointSize;}if(cfg.roundPoints!==undefined){_this50.roundPoints=cfg.roundPoints;}if(cfg.perspectivePoints!==undefined){_this50.perspectivePoints=cfg.perspectivePoints;}if(cfg.minPerspectivePointSize!==undefined){_this50.minPerspectivePointSize=cfg.minPerspectivePointSize;}if(cfg.maxPerspectivePointSize!==undefined){_this50.maxPerspectivePointSize=cfg.minPerspectivePointSize;}}else{_this50._preset="default";_this50.pointSize=cfg.pointSize;_this50.roundPoints=cfg.roundPoints;_this50.perspectivePoints=cfg.perspectivePoints;_this50.minPerspectivePointSize=cfg.minPerspectivePointSize;_this50.maxPerspectivePointSize=cfg.maxPerspectivePointSize;}_this50.filterIntensity=cfg.filterIntensity;_this50.minIntensity=cfg.minIntensity;_this50.maxIntensity=cfg.maxIntensity;return _this50;}/**
     * Sets point size.
     *
     * Default value is ````2.0```` pixels.
     *
     * @type {Number}
     */_createClass(PointsMaterial,[{key:"type",get:/**
     @private
     */function get(){return"PointsMaterial";}/**
     * Gets available PointsMaterial presets.
     *
     * @type {Object}
     */},{key:"presets",get:function get(){return PRESETS$1;}},{key:"pointSize",get:/**
     * Gets point size.
     *
     * Default value is ````2.0```` pixels.
     *
     * @type {Number}
     */function get(){return this._state.pointSize;}/**
     * Sets if points are round or square.
     *
     * Default is ````true```` to set points round.
     *
     * @type {Boolean}
     */,set:function set(value){this._state.pointSize=value||2.0;this.glRedraw();}},{key:"roundPoints",get:/**
     * Gets if points are round or square.
     *
     * Default is ````true```` to set points round.
     *
     * @type {Boolean}
     */function get(){return this._state.roundPoints;}/**
     * Sets if rendered point size reduces with distance when {@link Camera#projection} is set to ````"perspective"````.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(this._state.roundPoints===value){return;}this._state.roundPoints=value;this.scene._needRecompile=true;this.glRedraw();}},{key:"perspectivePoints",get:/**
     * Gets if rendered point size reduces with distance when {@link Camera#projection} is set to "perspective".
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._state.perspectivePoints;}/**
     * Sets the minimum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */,set:function set(value){value=value!==false;if(this._state.perspectivePoints===value){return;}this._state.perspectivePoints=value;this.scene._needRecompile=true;this.glRedraw();}},{key:"minPerspectivePointSize",get:/**
     * Gets the minimum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */function get(){return this._state.minPerspectivePointSize;}/**
     * Sets the maximum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````6```` pixels.
     *
     * @type {Number}
     */,set:function set(value){this._state.minPerspectivePointSize=value||1.0;this.scene._needRecompile=true;this.glRedraw();}},{key:"maxPerspectivePointSize",get:/**
     * Gets the maximum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````6```` pixels.
     *
     * @type {Number}
     */function get(){return this._state.maxPerspectivePointSize;}/**
     * Sets if rendered point size reduces with distance when {@link Camera#projection} is set to ````"perspective"````.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){this._state.maxPerspectivePointSize=value||6;this.scene._needRecompile=true;this.glRedraw();}},{key:"filterIntensity",get:/**
     * Gets if rendered point size reduces with distance when {@link Camera#projection} is set to "perspective".
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._state.filterIntensity;}/**
     * Sets the minimum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */,set:function set(value){value=value!==false;if(this._state.filterIntensity===value){return;}this._state.filterIntensity=value;this.scene._needRecompile=true;this.glRedraw();}},{key:"minIntensity",get:/**
     * Gets the minimum rendered size of points when {@link PointsMaterial#filterIntensity} is ````true````.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */function get(){return this._state.minIntensity;}/**
     * Sets the maximum rendered size of points when {@link PointsMaterial#filterIntensity} is ````true````.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */,set:function set(value){this._state.minIntensity=value!==undefined&&value!==null?value:0.0;this.glRedraw();}},{key:"maxIntensity",get:/**
     * Gets the maximum rendered size of points when {@link PointsMaterial#filterIntensity} is ````true````.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */function get(){return this._state.maxIntensity;}/**
     * Selects a preset ````PointsMaterial```` configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */,set:function set(value){this._state.maxIntensity=value!==undefined&&value!==null?value:1.0;this.glRedraw();}},{key:"preset",get:/**
     * The current preset ````PointsMaterial```` configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */function get(){return this._preset;}/**
     * @private
     * @return {string}
     */,set:function set(value){value=value||"default";if(this._preset===value){return;}var preset=PRESETS$1[value];if(!preset){this.error("unsupported preset: '"+value+"' - supported values are "+Object.keys(PRESETS$1).join(", "));return;}this.pointSize=preset.pointSize;this.roundPoints=preset.roundPoints;this.perspectivePoints=preset.perspectivePoints;this.minPerspectivePointSize=preset.minPerspectivePointSize;this.maxPerspectivePointSize=preset.maxPerspectivePointSize;this._preset=value;}},{key:"hash",get:function get(){return[this.pointSize,this.roundPoints,this.perspectivePoints,this.minPerspectivePointSize,this.maxPerspectivePointSize,this.filterIntensity].join(";");}/**
     * Destroys this ````PointsMaterial````.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(PointsMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return PointsMaterial;}(Material);var PRESETS={"default":{lineWidth:1},"thick":{lineWidth:2},"thicker":{lineWidth:4}};/**
 * @desc Configures the shape of "lines" geometry primitives.
 *
 * * Located at {@link Scene#linesMaterial}.
 * * Globally configures "lines" primitives for all {@link VBOSceneModel}s.
 *
 * ## Usage
 *
 * In the example below, we'll customize the {@link Scene}'s global ````LinesMaterial````, then use
 * an {@link XKTLoaderPlugin} to load a model containing line segments.
 *
 * [[Run this example](/examples/#materials_LinesMaterial)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * viewer.scene.linesMaterial.lineWidth = 3;
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Duplex.ifc.xkt"
 * });
 * ````
 */var LinesMaterial=/*#__PURE__*/function(_Material5){_inherits(LinesMaterial,_Material5);var _super32=_createSuper(LinesMaterial);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The LinesMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number} [cfg.lineWidth=1] Line width in pixels.
     * @param {String} [cfg.preset] Selects a preset LinesMaterial configuration - see {@link LinesMaterial#presets}.
     */function LinesMaterial(owner){var _this51;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,LinesMaterial);_this51=_super32.call(this,owner,cfg);_this51._state=new RenderState({type:"LinesMaterial",lineWidth:null});if(cfg.preset){// Apply preset then override with configs where provided
_this51.preset=cfg.preset;if(cfg.lineWidth!==undefined){_this51.lineWidth=cfg.lineWidth;}}else{_this51._preset="default";_this51.lineWidth=cfg.lineWidth;}return _this51;}/**
     * Sets line width.
     *
     * Default value is ````1```` pixels.
     *
     * @type {Number}
     */_createClass(LinesMaterial,[{key:"type",get:/**
     @private
     */function get(){return"LinesMaterial";}/**
     * Gets available LinesMaterial presets.
     *
     * @type {Object}
     */},{key:"presets",get:function get(){return PRESETS;}},{key:"lineWidth",get:/**
     * Gets the line width.
     *
     * Default value is ````1```` pixels.
     *
     * @type {Number}
     */function get(){return this._state.lineWidth;}/**
     * Selects a preset LinesMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */,set:function set(value){this._state.lineWidth=value||1;this.glRedraw();}},{key:"preset",get:/**
     * The current preset LinesMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */function get(){return this._preset;}/**
     * @private
     * @return {string}
     */,set:function set(value){value=value||"default";if(this._preset===value){return;}var preset=PRESETS[value];if(!preset){this.error("unsupported preset: '"+value+"' - supported values are "+Object.keys(PRESETS).join(", "));return;}this.lineWidth=preset.lineWidth;this._preset=value;}},{key:"hash",get:function get(){return[""+this.lineWidth].join(";");}/**
     * Destroys this LinesMaterial.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(LinesMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return LinesMaterial;}(Material);// Cached vars to avoid garbage collection
function getEntityIDMap(scene,entityIds){var map={};var entityId;var entity;for(var _i79=0,len=entityIds.length;_i79<len;_i79++){entityId=entityIds[_i79];entity=scene.components[entityId];if(!entity){scene.warn("pick(): Component not found: "+entityId);continue;}if(!entity.isEntity){scene.warn("pick(): Component is not an Entity: "+entityId);continue;}map[entityId]=true;}return map;}/**
 * Fired whenever a debug message is logged on a component within this Scene.
 * @event log
 * @param {String} value The debug message
 */ /**
 * Fired whenever an error is logged on a component within this Scene.
 * @event error
 * @param {String} value The error message
 */ /**
 * Fired whenever a warning is logged on a component within this Scene.
 * @event warn
 * @param {String} value The warning message
 */ /**
 * @desc Contains the components that comprise a 3D scene.
 *
 * * A {@link Viewer} has a single Scene, which it provides in {@link Viewer#scene}.
 * * Plugins like {@link AxisGizmoPlugin} also have their own private Scenes.
 * * Each Scene has a corresponding {@link MetaScene}, which the Viewer provides in {@link Viewer#metaScene}.
 *
 * ## Getting a Viewer's Scene
 *
 * ````javascript
 * var scene = viewer.scene;
 * ````
 *
 * ## Creating and accessing Scene components
 *
 * As a brief introduction to creating Scene components, we'll create a {@link Mesh} that has a
 * {@link buildTorusGeometry} and a {@link PhongMaterial}:
 *
 * ````javascript
 * var teapotMesh = new Mesh(scene, {
 *     id: "myMesh",                               // <<---------- ID automatically generated if not provided
 *     geometry: new TorusGeometry(scene),
 *     material: new PhongMaterial(scene, {
 *         id: "myMaterial",
 *         diffuse: [0.2, 0.2, 1.0]
 *     })
 * });
 *
 * teapotMesh.scene.camera.eye = [45, 45, 45];
 * ````
 *
 * Find components by ID in their Scene's {@link Scene#components} map:
 *
 * ````javascript
 * var teapotMesh = scene.components["myMesh"];
 * teapotMesh.visible = false;
 *
 * var teapotMaterial = scene.components["myMaterial"];
 * teapotMaterial.diffuse = [1,0,0]; // Change to red
 * ````
 *
 * A Scene also has a map of component instances for each {@link Component} subtype:
 *
 * ````javascript
 * var meshes = scene.types["Mesh"];
 * var teapotMesh = meshes["myMesh"];
 * teapotMesh.xrayed = true;
 *
 * var phongMaterials = scene.types["PhongMaterial"];
 * var teapotMaterial = phongMaterials["myMaterial"];
 * teapotMaterial.diffuse = [0,1,0]; // Change to green
 * ````
 *
 * See {@link Node}, {@link Node} and {@link Model} for how to create and access more sophisticated content.
 *
 * ## Controlling the camera
 *
 * Use the Scene's {@link Camera} to control the current viewpoint and projection:
 *
 * ````javascript
 * var camera = myScene.camera;
 *
 * camera.eye = [-10,0,0];
 * camera.look = [-10,0,0];
 * camera.up = [0,1,0];
 *
 * camera.projection = "perspective";
 * camera.perspective.fov = 45;
 * //...
 * ````
 *
 * ## Managing the canvas
 *
 * The Scene's {@link Canvas} component provides various conveniences relevant to the WebGL canvas, such
 * as firing resize events etc:
 *
 * ````javascript
 * var canvas = scene.canvas;
 *
 * canvas.on("boundary", function(boundary) {
 *     //...
 * });
 * ````
 *
 * ## Picking
 *
 * Use {@link Scene#pick} to pick and raycast entites.
 *
 * For example, to pick a point on the surface of the closest entity at the given canvas coordinates:
 *
 * ````javascript
 * var pickResult = scene.pick({
 *      pickSurface: true,
 *      canvasPos: [23, 131]
 * });
 *
 * if (pickResult) { // Picked an entity
 *
 *     var entity = pickResult.entity;
 *
 *     var primitive = pickResult.primitive; // Type of primitive that was picked, usually "triangles"
 *     var primIndex = pickResult.primIndex; // Position of triangle's first index in the picked Mesh's Geometry's indices array
 *     var indices = pickResult.indices; // UInt32Array containing the triangle's vertex indices
 *     var localPos = pickResult.localPos; // Float64Array containing the picked Local-space position on the triangle
 *     var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the triangle
 *     var viewPos = pickResult.viewPos; // Float64Array containing the picked View-space position on the triangle
 *     var bary = pickResult.bary; // Float64Array containing the picked barycentric position within the triangle
 *     var normal = pickResult.normal; // Float64Array containing the interpolated normal vector at the picked position on the triangle
 *     var uv = pickResult.uv; // Float64Array containing the interpolated UV coordinates at the picked position on the triangle
 * }
 * ````
 *
 * ## Pick masking
 *
 * We can use {@link Scene#pick}'s ````includeEntities```` and ````excludeEntities````  options to mask which {@link Mesh}es we attempt to pick.
 *
 * This is useful for picking through things, to pick only the Entities of interest.
 *
 * To pick only Entities ````"gearbox#77.0"```` and ````"gearbox#79.0"````, picking through any other Entities that are
 * in the way, as if they weren't there:
 *
 * ````javascript
 * var pickResult = scene.pick({
 *      canvasPos: [23, 131],
 *      includeEntities: ["gearbox#77.0", "gearbox#79.0"]
 * });
 *
 * if (pickResult) {
 *       // Entity will always be either "gearbox#77.0" or "gearbox#79.0"
 *       var entity = pickResult.entity;
 * }
 * ````
 *
 * To pick any pickable Entity, except for ````"gearbox#77.0"```` and ````"gearbox#79.0"````, picking through those
 * Entities if they happen to be in the way:
 *
 * ````javascript
 * var pickResult = scene.pick({
 *      canvasPos: [23, 131],
 *      excludeEntities: ["gearbox#77.0", "gearbox#79.0"]
 * });
 *
 * if (pickResult) {
 *       // Entity will never be "gearbox#77.0" or "gearbox#79.0"
 *       var entity = pickResult.entity;
 * }
 * ````
 *
 * See {@link Scene#pick} for more info on picking.
 *
 * ## Querying and tracking boundaries
 *
 * Getting a Scene's World-space axis-aligned boundary (AABB):
 *
 * ````javascript
 * var aabb = scene.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 * ````
 *
 * Subscribing to updates to the AABB, which occur whenever {@link Entity}s are transformed, their
 * {@link ReadableGeometry}s have been updated, or the {@link Camera} has moved:
 *
 * ````javascript
 * scene.on("boundary", function() {
 *      var aabb = scene.aabb;
 * });
 * ````
 *
 * Getting the AABB of the {@link Entity}s with the given IDs:
 *
 * ````JavaScript
 * scene.getAABB(); // Gets collective boundary of all Entities in the scene
 * scene.getAABB("saw"); // Gets boundary of an Object
 * scene.getAABB(["saw", "gearbox"]); // Gets collective boundary of two Objects
 * ````
 *
 * See {@link Scene#getAABB} and {@link Entity} for more info on querying and tracking boundaries.
 *
 * ## Managing the viewport
 *
 * The Scene's {@link Viewport} component manages the WebGL viewport:
 *
 * ````javascript
 * var viewport = scene.viewport
 * viewport.boundary = [0, 0, 500, 400];;
 * ````
 *
 * ## Controlling rendering
 *
 * You can configure a Scene to perform multiple "passes" (renders) per frame. This is useful when we want to render the
 * scene to multiple viewports, such as for stereo effects.
 *
 * In the example, below, we'll configure the Scene to render twice on each frame, each time to different viewport. We'll do this
 * with a callback that intercepts the Scene before each render and sets its {@link Viewport} to a
 * different portion of the canvas. By default, the Scene will clear the canvas only before the first render, allowing the
 * two views to be shown on the canvas at the same time.
 *
 * ````Javascript
 * var viewport = scene.viewport;
 *
 * // Configure Scene to render twice for each frame
 * scene.passes = 2; // Default is 1
 * scene.clearEachPass = false; // Default is false
 *
 * // Render to a separate viewport on each render
 *
 * var viewport = scene.viewport;
 * viewport.autoBoundary = false;
 *
 * scene.on("rendering", function (e) {
 *      switch (e.pass) {
 *          case 0:
 *              viewport.boundary = [0, 0, 200, 200]; // xmin, ymin, width, height
 *              break;
 *
 *          case 1:
 *              viewport.boundary = [200, 0, 200, 200];
 *              break;
 *      }
 * });
 *
 * // We can also intercept the Scene after each render,
 * // (though we're not using this for anything here)
 * scene.on("rendered", function (e) {
 *      switch (e.pass) {
 *          case 0:
 *              break;
 *
 *          case 1:
 *              break;
 *      }
 * });
 * ````
 *
 * ## Gamma correction
 *
 * Within its shaders, xeokit performs shading calculations in linear space.
 *
 * By default, the Scene expects color textures (eg. {@link PhongMaterial#diffuseMap},
 * {@link MetallicMaterial#baseColorMap} and {@link SpecularMaterial#diffuseMap}) to
 * be in pre-multipled gamma space, so will convert those to linear space before they are used in shaders. Other textures are
 * always expected to be in linear space.
 *
 * By default, the Scene will also gamma-correct its rendered output.
 *
 * You can configure the Scene to expect all those color textures to be linear space, so that it does not gamma-correct them:
 *
 * ````javascript
 * scene.gammaInput = false;
 * ````
 *
 * You would still need to gamma-correct the output, though, if it's going straight to the canvas, so normally we would
 * leave that enabled:
 *
 * ````javascript
 * scene.gammaOutput = true;
 * ````
 *
 * See {@link Texture} for more information on texture encoding and gamma.
 *
 * @class Scene
 */var Scene=/*#__PURE__*/function(_Component20){_inherits(Scene,_Component20);var _super33=_createSuper(Scene);/**
     * @private
     * @constructor
     * @param {Viewer} viewer The Viewer this Scene belongs to.
     * @param {Object} cfg Scene configuration.
     * @param {String} [cfg.canvasId]  ID of an existing HTML canvas for the {@link Scene#canvas} - either this or canvasElement is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLCanvasElement} [cfg.canvasElement] Reference of an existing HTML canvas for the {@link Scene#canvas} - either this or canvasId is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLElement} [cfg.keyboardEventsElement] Optional reference to HTML element on which key events should be handled. Defaults to the HTML Document.
     * @param {number} [cfg.numCachedSectionPlanes=0] Enhances the efficiency of SectionPlane creation by proactively allocating Viewer resources for a specified quantity
     * of SectionPlanes. Introducing this parameter streamlines the initial creation speed of SectionPlanes, particularly up to the designated quantity. This parameter internally
     * configures renderer logic for the specified number of SectionPlanes, eliminating the need for setting up logic with each SectionPlane creation and thereby enhancing
     * responsiveness. It is important to consider that each SectionPlane imposes rendering performance, so it is recommended to set this value to a quantity that aligns with
     * your expected usage.
     * @throws {String} Throws an exception when both canvasId or canvasElement are missing or they aren't pointing to a valid HTMLCanvasElement.
     */function Scene(viewer){var _this52;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Scene);_this52=_super33.call(this,null,cfg);var canvas=cfg.canvasElement||document.getElementById(cfg.canvasId);if(!(canvas instanceof HTMLCanvasElement)){throw"Mandatory config expected: valid canvasId or canvasElement";}/**
         * @type {{[key: string]: {wrapperFunc: Function, tickSubId: string}}}
         */_this52._tickifiedFunctions={};var transparent=!!cfg.transparent;var alphaDepthMask=!!cfg.alphaDepthMask;_this52._aabbDirty=true;/**
         * The {@link Viewer} this Scene belongs to.
         * @type {Viewer}
         */_this52.viewer=viewer;/** Decremented each frame, triggers occlusion test for occludable {@link Marker}s when zero.
         * @private
         * @type {number}
         */_this52.occlusionTestCountdown=0;/**
         The number of models currently loading.

         @property loading
         @final
         @type {Number}
         */_this52.loading=0;/**
         The epoch time (in milliseconds since 1970) when this Scene was instantiated.

         @property timeCreated
         @final
         @type {Number}
         */_this52.startTime=new Date().getTime();/**
         * Map of {@link Entity}s that represent models.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id} when {@link Entity#isModel} is ````true````.
         *
         * @property models
         * @final
         * @type {{String:Entity}}
         */_this52.models={};/**
         * Map of {@link Entity}s that represents objects.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id} when {@link Entity#isObject} is ````true````.
         *
         * @property objects
         * @final
         * @type {{String:Entity}}
         */_this52.objects={};_this52._numObjects=0;/**
         * Map of currently visible {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````, and is visible when {@link Entity#visible} is true.
         *
         * @property visibleObjects
         * @final
         * @type {{String:Object}}
         */_this52.visibleObjects={};_this52._numVisibleObjects=0;/**
         * Map of currently xrayed {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````, and is xrayed when {@link Entity#xrayed} is true.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property xrayedObjects
         * @final
         * @type {{String:Object}}
         */_this52.xrayedObjects={};_this52._numXRayedObjects=0;/**
         * Map of currently highlighted {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true```` is true, and is highlighted when {@link Entity#highlighted} is true.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property highlightedObjects
         * @final
         * @type {{String:Object}}
         */_this52.highlightedObjects={};_this52._numHighlightedObjects=0;/**
         * Map of currently selected {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is true, and is selected while {@link Entity#selected} is true.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property selectedObjects
         * @final
         * @type {{String:Object}}
         */_this52.selectedObjects={};_this52._numSelectedObjects=0;/**
         * Map of currently colorized {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property colorizedObjects
         * @final
         * @type {{String:Object}}
         */_this52.colorizedObjects={};_this52._numColorizedObjects=0;/**
         * Map of {@link Entity}s that represent objects whose opacity was updated.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property opacityObjects
         * @final
         * @type {{String:Object}}
         */_this52.opacityObjects={};_this52._numOpacityObjects=0;/**
         * Map of {@link Entity}s that represent objects whose {@link Entity#offset}s were updated.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property offsetObjects
         * @final
         * @type {{String:Object}}
         */_this52.offsetObjects={};_this52._numOffsetObjects=0;// Cached ID arrays, lazy-rebuilt as needed when stale after map updates
/**
         Lazy-regenerated ID lists.
         */_this52._modelIds=null;_this52._objectIds=null;_this52._visibleObjectIds=null;_this52._xrayedObjectIds=null;_this52._highlightedObjectIds=null;_this52._selectedObjectIds=null;_this52._colorizedObjectIds=null;_this52._opacityObjectIds=null;_this52._offsetObjectIds=null;_this52._collidables={};// Components that contribute to the Scene AABB
_this52._compilables={};// Components that require shader compilation
_this52._needRecompile=false;/**
         * For each {@link Component} type, a map of IDs to {@link Component} instances of that type.
         *
         * @type {{String:{String:Component}}}
         */_this52.types={};/**
         * The {@link Component}s within this Scene, each mapped to its {@link Component#id}.
         *
         * *@type {{String:Component}}
         */_this52.components={};/**
         * The {@link SectionPlane}s in this Scene, each mapped to its {@link SectionPlane#id}.
         *
         * @type {{String:SectionPlane}}
         */_this52.sectionPlanes={};/**
         * The {@link Light}s in this Scene, each mapped to its {@link Light#id}.
         *
         * @type {{String:Light}}
         */_this52.lights={};/**
         * The {@link LightMap}s in this Scene, each mapped to its {@link LightMap#id}.
         *
         * @type {{String:LightMap}}
         */_this52.lightMaps={};/**
         * The {@link ReflectionMap}s in this Scene, each mapped to its {@link ReflectionMap#id}.
         *
         * @type {{String:ReflectionMap}}
         */_this52.reflectionMaps={};/**
         * The {@link Bitmap}s in this Scene, each mapped to its {@link Bitmap#id}.
         *
         * @type {{String:Bitmap}}
         */_this52.bitmaps={};/**
         * The {@link LineSet}s in this Scene, each mapped to its {@link LineSet#id}.
         *
         * @type {{String:LineSet}}
         */_this52.lineSets={};/**
         * The real world offset for this Scene
         *
         * @type {Number[]}
         */_this52.realWorldOffset=cfg.realWorldOffset||new Float64Array([0,0,0]);/**
         * Manages the HTML5 canvas for this Scene.
         *
         * @type {Canvas}
         */_this52.canvas=new Canvas(_assertThisInitialized(_this52),{dontClear:true,// Never destroy this component with Scene#clear();
canvas:canvas,spinnerElementId:cfg.spinnerElementId,transparent:transparent,webgl2:cfg.webgl2!==false,contextAttr:cfg.contextAttr||{},backgroundColor:cfg.backgroundColor,backgroundColorFromAmbientLight:cfg.backgroundColorFromAmbientLight,premultipliedAlpha:cfg.premultipliedAlpha});_this52.canvas.on("boundary",function(){_this52.glRedraw();});_this52.canvas.on("webglContextFailed",function(){alert("xeokit failed to find WebGL!");});_this52._renderer=new Renderer$1(_assertThisInitialized(_this52),{transparent:transparent,alphaDepthMask:alphaDepthMask});_this52._sectionPlanesState=new function(){this.sectionPlanes=[];this.clippingCaps=false;this._numCachedSectionPlanes=0;var hash=null;this.getHash=function(){if(hash){return hash;}var numAllocatedSectionPlanes=this.getNumAllocatedSectionPlanes();this.sectionPlanes;if(numAllocatedSectionPlanes===0){return this.hash=";";}var hashParts=[];for(var _i80=0,len=numAllocatedSectionPlanes;_i80<len;_i80++){hashParts.push("cp");}hashParts.push(";");hash=hashParts.join("");return hash;};this.addSectionPlane=function(sectionPlane){this.sectionPlanes.push(sectionPlane);hash=null;};this.removeSectionPlane=function(sectionPlane){for(var _i81=0,len=this.sectionPlanes.length;_i81<len;_i81++){if(this.sectionPlanes[_i81].id===sectionPlane.id){this.sectionPlanes.splice(_i81,1);hash=null;return;}}};this.setNumCachedSectionPlanes=function(numCachedSectionPlanes){this._numCachedSectionPlanes=numCachedSectionPlanes;hash=null;};this.getNumCachedSectionPlanes=function(){return this._numCachedSectionPlanes;};this.getNumAllocatedSectionPlanes=function(){var num=this.sectionPlanes.length;return num>this._numCachedSectionPlanes?num:this._numCachedSectionPlanes;};}();_this52._sectionPlanesState.setNumCachedSectionPlanes(cfg.numCachedSectionPlanes||0);_this52._lightsState=new function(){var DEFAULT_AMBIENT=math.vec4([0,0,0,0]);var ambientColorIntensity=math.vec4();this.lights=[];this.reflectionMaps=[];this.lightMaps=[];var hash=null;var ambientLight=null;this.getHash=function(){if(hash){return hash;}var hashParts=[];var lights=this.lights;var light;for(var _i82=0,len=lights.length;_i82<len;_i82++){light=lights[_i82];hashParts.push("/");hashParts.push(light.type);hashParts.push(light.space==="world"?"w":"v");if(light.castsShadow){hashParts.push("sh");}}if(this.lightMaps.length>0){hashParts.push("/lm");}if(this.reflectionMaps.length>0){hashParts.push("/rm");}hashParts.push(";");hash=hashParts.join("");return hash;};this.addLight=function(state){this.lights.push(state);ambientLight=null;hash=null;};this.removeLight=function(state){for(var _i83=0,len=this.lights.length;_i83<len;_i83++){var light=this.lights[_i83];if(light.id===state.id){this.lights.splice(_i83,1);if(ambientLight&&ambientLight.id===state.id){ambientLight=null;}hash=null;return;}}};this.addReflectionMap=function(state){this.reflectionMaps.push(state);hash=null;};this.removeReflectionMap=function(state){for(var _i84=0,len=this.reflectionMaps.length;_i84<len;_i84++){if(this.reflectionMaps[_i84].id===state.id){this.reflectionMaps.splice(_i84,1);hash=null;return;}}};this.addLightMap=function(state){this.lightMaps.push(state);hash=null;};this.removeLightMap=function(state){for(var _i85=0,len=this.lightMaps.length;_i85<len;_i85++){if(this.lightMaps[_i85].id===state.id){this.lightMaps.splice(_i85,1);hash=null;return;}}};this.getAmbientColorAndIntensity=function(){if(!ambientLight){for(var _i86=0,len=this.lights.length;_i86<len;_i86++){var light=this.lights[_i86];if(light.type==="ambient"){ambientLight=light;break;}}}if(ambientLight){var _color2=ambientLight.color;var intensity=ambientLight.intensity;ambientColorIntensity[0]=_color2[0];ambientColorIntensity[1]=_color2[1];ambientColorIntensity[2]=_color2[2];ambientColorIntensity[3]=intensity;return ambientColorIntensity;}else{return DEFAULT_AMBIENT;}};}();/**
         * Publishes input events that occur on this Scene's canvas.
         *
         * @property input
         * @type {Input}
         * @final
         */_this52.input=new Input(_assertThisInitialized(_this52),{dontClear:true,// Never destroy this component with Scene#clear();
element:_this52.canvas.canvas,keyboardEventsElement:cfg.keyboardEventsElement});/**
         * Configures this Scene's units of measurement and coordinate mapping between Real-space and World-space 3D coordinate systems.
         *
         * @property metrics
         * @type {Metrics}
         * @final
         */_this52.metrics=new Metrics(_assertThisInitialized(_this52),{units:cfg.units,scale:cfg.scale,origin:cfg.origin});/** Configures Scalable Ambient Obscurance (SAO) for this Scene.
         * @type {SAO}
         * @final
         */_this52.sao=new SAO(_assertThisInitialized(_this52),{enabled:cfg.saoEnabled});_this52.ticksPerRender=cfg.ticksPerRender;_this52.ticksPerOcclusionTest=cfg.ticksPerOcclusionTest;_this52.passes=cfg.passes;_this52.clearEachPass=cfg.clearEachPass;_this52.gammaInput=cfg.gammaInput;_this52.gammaOutput=cfg.gammaOutput;_this52.gammaFactor=cfg.gammaFactor;_this52._entityOffsetsEnabled=!!cfg.entityOffsetsEnabled;_this52._logarithmicDepthBufferEnabled=!!cfg.logarithmicDepthBufferEnabled;_this52._dtxEnabled=cfg.dtxEnabled!==false;_this52._pbrEnabled=!!cfg.pbrEnabled;_this52._colorTextureEnabled=cfg.colorTextureEnabled!==false;_this52._dtxEnabled=!!cfg.dtxEnabled;// Register Scene on xeokit
// Do this BEFORE we add components below
core._addScene(_assertThisInitialized(_this52));_this52._initDefaults();// Global components
_this52._viewport=new Viewport(_assertThisInitialized(_this52),{id:"default.viewport",autoBoundary:true,dontClear:true// Never destroy this component with Scene#clear();
});_this52._camera=new Camera(_assertThisInitialized(_this52),{id:"default.camera",dontClear:true// Never destroy this component with Scene#clear();
});// Default lights
new AmbientLight(_assertThisInitialized(_this52),{color:[1.0,1.0,1.0],intensity:0.7});new DirLight(_assertThisInitialized(_this52),{dir:[0.8,-.5,-0.5],color:[0.67,0.67,1.0],intensity:0.7,space:"world"});new DirLight(_assertThisInitialized(_this52),{dir:[-0.8,-1.0,0.5],color:[1,1,.9],intensity:0.9,space:"world"});_this52._camera.on("dirty",function(){_this52._renderer.imageDirty();});return _this52;}_createClass(Scene,[{key:"type",get:/**
     @private
     */function get(){return"Scene";}},{key:"_initDefaults",value:function _initDefaults(){}},{key:"_addComponent",value:function _addComponent(component){if(component.id){// Manual ID
if(this.components[component.id]){this.error("Component "+utils.inQuotes(component.id)+" already exists in Scene - ignoring ID, will randomly-generate instead");component.id=null;}}if(!component.id){// Auto ID
if(window.nextID===undefined){window.nextID=0;}//component.id = math.createUUID();
component.id="__"+window.nextID++;while(this.components[component.id]){component.id=math.createUUID();}}this.components[component.id]=component;// Register for class type
var type=component.type;var types=this.types[component.type];if(!types){types=this.types[type]={};}types[component.id]=component;if(component.compile){this._compilables[component.id]=component;}if(component.isDrawable){this._renderer.addDrawable(component.id,component);this._collidables[component.id]=component;}}},{key:"_removeComponent",value:function _removeComponent(component){var id=component.id;var type=component.type;delete this.components[id];// Unregister for types
var types=this.types[type];if(types){delete types[id];if(utils.isEmptyObject(types)){delete this.types[type];}}if(component.compile){delete this._compilables[component.id];}if(component.isDrawable){this._renderer.removeDrawable(component.id);delete this._collidables[component.id];}}// Methods below are called by various component types to register themselves on their
// Scene. Violates Hollywood Principle, where we could just filter on type in _addComponent,
// but this is faster than checking the type of each component in such a filter.
},{key:"_sectionPlaneCreated",value:function _sectionPlaneCreated(sectionPlane){this.sectionPlanes[sectionPlane.id]=sectionPlane;this.scene._sectionPlanesState.addSectionPlane(sectionPlane._state);this.scene.fire("sectionPlaneCreated",sectionPlane,true/* Don't retain event */);this._needRecompile=true;}},{key:"_bitmapCreated",value:function _bitmapCreated(bitmap){this.bitmaps[bitmap.id]=bitmap;this.scene.fire("bitmapCreated",bitmap,true/* Don't retain event */);}},{key:"_lineSetCreated",value:function _lineSetCreated(lineSet){this.lineSets[lineSet.id]=lineSet;this.scene.fire("lineSetCreated",lineSet,true/* Don't retain event */);}},{key:"_lightCreated",value:function _lightCreated(light){this.lights[light.id]=light;this.scene._lightsState.addLight(light._state);this._needRecompile=true;}},{key:"_lightMapCreated",value:function _lightMapCreated(lightMap){this.lightMaps[lightMap.id]=lightMap;this.scene._lightsState.addLightMap(lightMap._state);this._needRecompile=true;}},{key:"_reflectionMapCreated",value:function _reflectionMapCreated(reflectionMap){this.reflectionMaps[reflectionMap.id]=reflectionMap;this.scene._lightsState.addReflectionMap(reflectionMap._state);this._needRecompile=true;}},{key:"_sectionPlaneDestroyed",value:function _sectionPlaneDestroyed(sectionPlane){delete this.sectionPlanes[sectionPlane.id];this.scene._sectionPlanesState.removeSectionPlane(sectionPlane._state);this.scene.fire("sectionPlaneDestroyed",sectionPlane,true/* Don't retain event */);this._needRecompile=true;}},{key:"_bitmapDestroyed",value:function _bitmapDestroyed(bitmap){delete this.bitmaps[bitmap.id];this.scene.fire("bitmapDestroyed",bitmap,true/* Don't retain event */);}},{key:"_lineSetDestroyed",value:function _lineSetDestroyed(lineSet){delete this.lineSets[lineSet.id];this.scene.fire("lineSetDestroyed",lineSet,true/* Don't retain event */);}},{key:"_lightDestroyed",value:function _lightDestroyed(light){delete this.lights[light.id];this.scene._lightsState.removeLight(light._state);this._needRecompile=true;}},{key:"_lightMapDestroyed",value:function _lightMapDestroyed(lightMap){delete this.lightMaps[lightMap.id];this.scene._lightsState.removeLightMap(lightMap._state);this._needRecompile=true;}},{key:"_reflectionMapDestroyed",value:function _reflectionMapDestroyed(reflectionMap){delete this.reflectionMaps[reflectionMap.id];this.scene._lightsState.removeReflectionMap(reflectionMap._state);this._needRecompile=true;}},{key:"_registerModel",value:function _registerModel(entity){this.models[entity.id]=entity;this._modelIds=null;// Lazy regenerate
}},{key:"_deregisterModel",value:function _deregisterModel(entity){var modelId=entity.id;delete this.models[modelId];this._modelIds=null;// Lazy regenerate
this.fire("modelUnloaded",modelId);}},{key:"_registerObject",value:function _registerObject(entity){this.objects[entity.id]=entity;this._numObjects++;this._objectIds=null;// Lazy regenerate
}},{key:"_deregisterObject",value:function _deregisterObject(entity){delete this.objects[entity.id];this._numObjects--;this._objectIds=null;// Lazy regenerate
}},{key:"_objectVisibilityUpdated",value:function _objectVisibilityUpdated(entity){var notify=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(entity.visible){this.visibleObjects[entity.id]=entity;this._numVisibleObjects++;}else{delete this.visibleObjects[entity.id];this._numVisibleObjects--;}this._visibleObjectIds=null;// Lazy regenerate
if(notify){this.fire("objectVisibility",entity,true);}}},{key:"_deRegisterVisibleObject",value:function _deRegisterVisibleObject(entity){delete this.visibleObjects[entity.id];this._numVisibleObjects--;this._visibleObjectIds=null;// Lazy regenerate
}},{key:"_objectXRayedUpdated",value:function _objectXRayedUpdated(entity){var notify=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(entity.xrayed){this.xrayedObjects[entity.id]=entity;this._numXRayedObjects++;}else{delete this.xrayedObjects[entity.id];this._numXRayedObjects--;}this._xrayedObjectIds=null;// Lazy regenerate
if(notify){this.fire("objectXRayed",entity,true);}}},{key:"_deRegisterXRayedObject",value:function _deRegisterXRayedObject(entity){delete this.xrayedObjects[entity.id];this._numXRayedObjects--;this._xrayedObjectIds=null;// Lazy regenerate
}},{key:"_objectHighlightedUpdated",value:function _objectHighlightedUpdated(entity){if(entity.highlighted){this.highlightedObjects[entity.id]=entity;this._numHighlightedObjects++;}else{delete this.highlightedObjects[entity.id];this._numHighlightedObjects--;}this._highlightedObjectIds=null;// Lazy regenerate
}},{key:"_deRegisterHighlightedObject",value:function _deRegisterHighlightedObject(entity){delete this.highlightedObjects[entity.id];this._numHighlightedObjects--;this._highlightedObjectIds=null;// Lazy regenerate
}},{key:"_objectSelectedUpdated",value:function _objectSelectedUpdated(entity){var notify=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(entity.selected){this.selectedObjects[entity.id]=entity;this._numSelectedObjects++;}else{delete this.selectedObjects[entity.id];this._numSelectedObjects--;}this._selectedObjectIds=null;// Lazy regenerate
if(notify){this.fire("objectSelected",entity,true);}}},{key:"_deRegisterSelectedObject",value:function _deRegisterSelectedObject(entity){delete this.selectedObjects[entity.id];this._numSelectedObjects--;this._selectedObjectIds=null;// Lazy regenerate
}},{key:"_objectColorizeUpdated",value:function _objectColorizeUpdated(entity,colorized){if(colorized){this.colorizedObjects[entity.id]=entity;this._numColorizedObjects++;}else{delete this.colorizedObjects[entity.id];this._numColorizedObjects--;}this._colorizedObjectIds=null;// Lazy regenerate
}},{key:"_deRegisterColorizedObject",value:function _deRegisterColorizedObject(entity){delete this.colorizedObjects[entity.id];this._numColorizedObjects--;this._colorizedObjectIds=null;// Lazy regenerate
}},{key:"_objectOpacityUpdated",value:function _objectOpacityUpdated(entity,opacityUpdated){if(opacityUpdated){this.opacityObjects[entity.id]=entity;this._numOpacityObjects++;}else{delete this.opacityObjects[entity.id];this._numOpacityObjects--;}this._opacityObjectIds=null;// Lazy regenerate
}},{key:"_deRegisterOpacityObject",value:function _deRegisterOpacityObject(entity){delete this.opacityObjects[entity.id];this._numOpacityObjects--;this._opacityObjectIds=null;// Lazy regenerate
}},{key:"_objectOffsetUpdated",value:function _objectOffsetUpdated(entity,offset){if(!offset||offset[0]===0&&offset[1]===0&&offset[2]===0){this.offsetObjects[entity.id]=entity;this._numOffsetObjects++;}else{delete this.offsetObjects[entity.id];this._numOffsetObjects--;}this._offsetObjectIds=null;// Lazy regenerate
}},{key:"_deRegisterOffsetObject",value:function _deRegisterOffsetObject(entity){delete this.offsetObjects[entity.id];this._numOffsetObjects--;this._offsetObjectIds=null;// Lazy regenerate
}},{key:"_webglContextLost",value:function _webglContextLost(){//  this.loading++;
this.canvas.spinner.processes++;for(var id in this.components){if(this.components.hasOwnProperty(id)){var component=this.components[id];if(component._webglContextLost){component._webglContextLost();}}}this._renderer.webglContextLost();}},{key:"_webglContextRestored",value:function _webglContextRestored(){var gl=this.canvas.gl;for(var id in this.components){if(this.components.hasOwnProperty(id)){var component=this.components[id];if(component._webglContextRestored){component._webglContextRestored(gl);}}}this._renderer.webglContextRestored(gl);//this.loading--;
this.canvas.spinner.processes--;}/**
     * Returns the capabilities of this Scene.
     *
     * @private
     * @returns {{astcSupported: boolean, etc1Supported: boolean, pvrtcSupported: boolean, etc2Supported: boolean, dxtSupported: boolean, bptcSupported: boolean}}
     */},{key:"capabilities",get:function get(){return this._renderer.capabilities;}/**
     * Whether {@link Entity#offset} is enabled.
     *
     * This is set via the {@link Viewer} constructor and is ````false```` by default.
     *
     * @returns {Boolean} True if {@link Entity#offset} is enabled.
     */},{key:"entityOffsetsEnabled",get:function get(){return this._entityOffsetsEnabled;}/**
     * Whether precision surface picking is enabled.
     *
     * This is set via the {@link Viewer} constructor and is ````false```` by default.
     *
     * The ````pickSurfacePrecision```` option for ````Scene#pick```` only works if this is set ````true````.
     *
     * Note that when ````true````, this configuration will increase the amount of browser memory used by the Viewer.
     *
     * @returns {Boolean} True if precision picking is enabled.
     */},{key:"pickSurfacePrecisionEnabled",get:function get(){return false;// Removed
}/**
     * Whether logarithmic depth buffer is enabled.
     *
     * This is set via the {@link Viewer} constructor and is ````false```` by default.
     *
     * @returns {Boolean} True if logarithmic depth buffer is enabled.
     */},{key:"logarithmicDepthBufferEnabled",get:function get(){return this._logarithmicDepthBufferEnabled;}/**
     * Sets the number of {@link SectionPlane}s for which this Scene pre-caches resources.
     *
     * This property enhances the efficiency of SectionPlane creation by proactively allocating and caching Viewer resources for a specified quantity
     * of SectionPlanes. Introducing this parameter streamlines the initial creation speed of SectionPlanes, particularly up to the designated quantity. This parameter internally
     * configures renderer logic for the specified number of SectionPlanes, eliminating the need for setting up logic with each SectionPlane creation and thereby enhancing
     * responsiveness. It is important to consider that each SectionPlane impacts rendering performance, so it is recommended to set this value to a quantity that aligns with
     * your expected usage.
     *
     * Default is ````0````.
     */},{key:"numCachedSectionPlanes",get:/**
     * Gets the number of {@link SectionPlane}s for which this Scene pre-caches resources.
     *
     * This property enhances the efficiency of SectionPlane creation by proactively allocating and caching Viewer resources for a specified quantity
     * of SectionPlanes. Introducing this parameter streamlines the initial creation speed of SectionPlanes, particularly up to the designated quantity. This parameter internally
     * configures renderer logic for the specified number of SectionPlanes, eliminating the need for setting up logic with each SectionPlane creation and thereby enhancing
     * responsiveness. It is important to consider that each SectionPlane impacts rendering performance, so it is recommended to set this value to a quantity that aligns with
     * your expected usage.
     *
     * Default is ````0````.
     *
     * @returns {number} The number of {@link SectionPlane}s for which this Scene pre-caches resources.
     */function get(){return this._sectionPlanesState.getNumCachedSectionPlanes();}/**
     * Sets whether physically-based rendering is enabled.
     *
     * Default is ````false````.
     */,set:function set(numCachedSectionPlanes){numCachedSectionPlanes=numCachedSectionPlanes||0;if(this._sectionPlanesState.getNumCachedSectionPlanes()!==numCachedSectionPlanes){this._sectionPlanesState.setNumCachedSectionPlanes(numCachedSectionPlanes);this._needRecompile=true;this.glRedraw();}}},{key:"pbrEnabled",get:/**
     * Gets whether physically-based rendering is enabled.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} True if quality rendering is enabled.
     */function get(){return this._pbrEnabled;}/**
     * Sets whether data texture scene representation (DTX) is enabled for the {@link Scene}.
     *
     * Even when enabled, DTX will only work if supported.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */,set:function set(pbrEnabled){this._pbrEnabled=!!pbrEnabled;this.glRedraw();}},{key:"dtxEnabled",get:/**
     * Gets whether data texture-based scene representation (DTX) is enabled for the {@link Scene}.
     *
     * Even when enabled, DTX will only apply if supported.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._dtxEnabled;}/**
     * Sets whether basic color texture rendering is enabled.
     *
     * Default is ````true````.
     *
     * @returns {Boolean} True if basic color texture rendering is enabled.
     */,set:function set(value){value=!!value;if(this._dtxEnabled===value){return;}this._dtxEnabled=value;}},{key:"colorTextureEnabled",get:/**
     * Gets whether basic color texture rendering is enabled.
     *
     * Default is ````true````.
     *
     * @returns {Boolean} True if basic color texture rendering is enabled.
     */function get(){return this._colorTextureEnabled;}/**
     * Performs an occlusion test on all {@link Marker}s in this {@link Scene}.
     *
     * Sets each {@link Marker#visible} ````true```` if the Marker is currently not occluded by any opaque {@link Entity}s
     * in the Scene, or ````false```` if an Entity is occluding it.
     */,set:function set(colorTextureEnabled){this._colorTextureEnabled=!!colorTextureEnabled;this.glRedraw();}},{key:"doOcclusionTest",value:function doOcclusionTest(){if(this._needRecompile){this._recompile();this._needRecompile=false;}this._renderer.doOcclusionTest();}/**
     * Renders a single frame of this Scene.
     *
     * The Scene will periodically render itself after any updates, but you can call this method to force a render
     * if required.
     *
     * @param {Boolean} [forceRender=false] Forces a render when true, otherwise only renders if something has changed in this Scene
     * since the last render.
     */},{key:"render",value:function render(forceRender){if(forceRender){core.runTasks();}var renderEvent={sceneId:null,pass:0};if(this._needRecompile){this._recompile();this._renderer.imageDirty();this._needRecompile=false;}if(!forceRender&&!this._renderer.needsRender()){return;}renderEvent.sceneId=this.id;var passes=this._passes;var clearEachPass=this._clearEachPass;var pass;var clear;for(pass=0;pass<passes;pass++){renderEvent.pass=pass;/**
             * Fired when about to render a frame for a Scene.
             *
             * @event rendering
             * @param {String} sceneID The ID of this Scene.
             * @param {Number} pass Index of the pass we are about to render (see {@link Scene#passes}).
             */this.fire("rendering",renderEvent,true);clear=clearEachPass||pass===0;this._renderer.render({pass:pass,clear:clear,force:forceRender});/**
             * Fired when we have just rendered a frame for a Scene.
             *
             * @event rendering
             * @param {String} sceneID The ID of this Scene.
             * @param {Number} pass Index of the pass we rendered (see {@link Scene#passes}).
             */this.fire("rendered",renderEvent,true);}this._saveAmbientColor();}/**
     * @private
     */},{key:"compile",value:function compile(){if(this._needRecompile){this._recompile();this._renderer.imageDirty();this._needRecompile=false;}}},{key:"_recompile",value:function _recompile(){for(var id in this._compilables){if(this._compilables.hasOwnProperty(id)){this._compilables[id].compile();}}this._renderer.shadowsDirty();this.fire("compile",this,true);}},{key:"_saveAmbientColor",value:function _saveAmbientColor(){var canvas=this.canvas;if(!canvas.transparent&&!canvas.backgroundImage&&!canvas.backgroundColor){var ambientColorIntensity=this._lightsState.getAmbientColorAndIntensity();if(!this._lastAmbientColor||this._lastAmbientColor[0]!==ambientColorIntensity[0]||this._lastAmbientColor[1]!==ambientColorIntensity[1]||this._lastAmbientColor[2]!==ambientColorIntensity[2]||this._lastAmbientColor[3]!==ambientColorIntensity[3]){canvas.backgroundColor=ambientColorIntensity;if(!this._lastAmbientColor){this._lastAmbientColor=math.vec4([0,0,0,1]);}this._lastAmbientColor.set(ambientColorIntensity);}}else{this._lastAmbientColor=null;}}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#models}.
     *
     * @type {String[]}
     */},{key:"modelIds",get:function get(){if(!this._modelIds){this._modelIds=Object.keys(this.models);}return this._modelIds;}/**
     * Gets the number of {@link Entity}s in {@link Scene#objects}.
     *
     * @type {Number}
     */},{key:"numObjects",get:function get(){return this._numObjects;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#objects}.
     *
     * @type {String[]}
     */},{key:"objectIds",get:function get(){if(!this._objectIds){this._objectIds=Object.keys(this.objects);}return this._objectIds;}/**
     * Gets the number of {@link Entity}s in {@link Scene#visibleObjects}.
     *
     * @type {Number}
     */},{key:"numVisibleObjects",get:function get(){return this._numVisibleObjects;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#visibleObjects}.
     *
     * @type {String[]}
     */},{key:"visibleObjectIds",get:function get(){if(!this._visibleObjectIds){this._visibleObjectIds=Object.keys(this.visibleObjects);}return this._visibleObjectIds;}/**
     * Gets the number of {@link Entity}s in {@link Scene#xrayedObjects}.
     *
     * @type {Number}
     */},{key:"numXRayedObjects",get:function get(){return this._numXRayedObjects;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#xrayedObjects}.
     *
     * @type {String[]}
     */},{key:"xrayedObjectIds",get:function get(){if(!this._xrayedObjectIds){this._xrayedObjectIds=Object.keys(this.xrayedObjects);}return this._xrayedObjectIds;}/**
     * Gets the number of {@link Entity}s in {@link Scene#highlightedObjects}.
     *
     * @type {Number}
     */},{key:"numHighlightedObjects",get:function get(){return this._numHighlightedObjects;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#highlightedObjects}.
     *
     * @type {String[]}
     */},{key:"highlightedObjectIds",get:function get(){if(!this._highlightedObjectIds){this._highlightedObjectIds=Object.keys(this.highlightedObjects);}return this._highlightedObjectIds;}/**
     * Gets the number of {@link Entity}s in {@link Scene#selectedObjects}.
     *
     * @type {Number}
     */},{key:"numSelectedObjects",get:function get(){return this._numSelectedObjects;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#selectedObjects}.
     *
     * @type {String[]}
     */},{key:"selectedObjectIds",get:function get(){if(!this._selectedObjectIds){this._selectedObjectIds=Object.keys(this.selectedObjects);}return this._selectedObjectIds;}/**
     * Gets the number of {@link Entity}s in {@link Scene#colorizedObjects}.
     *
     * @type {Number}
     */},{key:"numColorizedObjects",get:function get(){return this._numColorizedObjects;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#colorizedObjects}.
     *
     * @type {String[]}
     */},{key:"colorizedObjectIds",get:function get(){if(!this._colorizedObjectIds){this._colorizedObjectIds=Object.keys(this.colorizedObjects);}return this._colorizedObjectIds;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#opacityObjects}.
     *
     * @type {String[]}
     */},{key:"opacityObjectIds",get:function get(){if(!this._opacityObjectIds){this._opacityObjectIds=Object.keys(this.opacityObjects);}return this._opacityObjectIds;}/**
     * Gets the IDs of the {@link Entity}s in {@link Scene#offsetObjects}.
     *
     * @type {String[]}
     */},{key:"offsetObjectIds",get:function get(){if(!this._offsetObjectIds){this._offsetObjectIds=Object.keys(this.offsetObjects);}return this._offsetObjectIds;}/**
     * Sets the number of "ticks" that happen between each render or this Scene.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */},{key:"ticksPerRender",get:/**
     * Gets the number of "ticks" that happen between each render or this Scene.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */function get(){return this._ticksPerRender;}/**
     * Sets the number of "ticks" that happen between occlusion testing for {@link Marker}s.
     *
     * Default value is ````20````.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=1;}else if(!utils.isNumeric(value)||value<=0){this.error("Unsupported value for 'ticksPerRender': '"+value+"' - should be an integer greater than zero.");value=1;}if(value===this._ticksPerRender){return;}this._ticksPerRender=value;}},{key:"ticksPerOcclusionTest",get:/**
     * Gets the number of "ticks" that happen between each render of this Scene.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */function get(){return this._ticksPerOcclusionTest;}/**
     * Sets the number of times this Scene renders per frame.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */,set:function set(value){if(value===undefined||value===null){value=20;}else if(!utils.isNumeric(value)||value<=0){this.error("Unsupported value for 'ticksPerOcclusionTest': '"+value+"' - should be an integer greater than zero.");value=20;}if(value===this._ticksPerOcclusionTest){return;}this._ticksPerOcclusionTest=value;}},{key:"passes",get:/**
     * Gets the number of times this Scene renders per frame.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */function get(){return this._passes;}/**
     * When {@link Scene#passes} is greater than ````1````, indicates whether or not to clear the canvas before each pass (````true````) or just before the first pass (````false````).
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){if(value===undefined||value===null){value=1;}else if(!utils.isNumeric(value)||value<=0){this.error("Unsupported value for 'passes': '"+value+"' - should be an integer greater than zero.");value=1;}if(value===this._passes){return;}this._passes=value;this.glRedraw();}},{key:"clearEachPass",get:/**
     * When {@link Scene#passes} is greater than ````1````, indicates whether or not to clear the canvas before each pass (````true````) or just before the first pass (````false````).
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._clearEachPass;}/**
     * Sets whether or not {@link Scene} should expect all {@link Texture}s and colors to have pre-multiplied gamma.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){value=!!value;if(value===this._clearEachPass){return;}this._clearEachPass=value;this.glRedraw();}},{key:"gammaInput",get:/**
     * Gets whether or not {@link Scene} should expect all {@link Texture}s and colors to have pre-multiplied gamma.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */function get(){return this._renderer.gammaInput;}/**
     * Sets whether or not to render pixels with pre-multiplied gama.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(value===this._renderer.gammaInput){return;}this._renderer.gammaInput=value;this._needRecompile=true;this.glRedraw();}},{key:"gammaOutput",get:/**
     * Gets whether or not to render pixels with pre-multiplied gama.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._renderer.gammaOutput;}/**
     * Sets the gamma factor to use when {@link Scene#gammaOutput} is set true.
     *
     * Default value is ````2.2````.
     *
     * @type {Number}
     */,set:function set(value){value=!!value;if(value===this._renderer.gammaOutput){return;}this._renderer.gammaOutput=value;this._needRecompile=true;this.glRedraw();}},{key:"gammaFactor",get:/**
     * Gets the gamma factor to use when {@link Scene#gammaOutput} is set true.
     *
     * Default value is ````2.2````.
     *
     * @type {Number}
     */function get(){return this._renderer.gammaFactor;}/**
     * Gets the default {@link Geometry} for this Scene, which is a {@link ReadableGeometry} with a unit-sized box shape.
     *
     * Has {@link ReadableGeometry#id} set to "default.geometry".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#geometry} set to this {@link ReadableGeometry} by default.
     *
     * @type {ReadableGeometry}
     */,set:function set(value){value=value===undefined||value===null?2.2:value;if(value===this._renderer.gammaFactor){return;}this._renderer.gammaFactor=value;this.glRedraw();}},{key:"geometry",get:function get(){return this.components["default.geometry"]||buildBoxGeometry(ReadableGeometry);}/**
     * Gets the default {@link Material} for this Scene, which is a {@link PhongMaterial}.
     *
     * Has {@link PhongMaterial#id} set to "default.material".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#material} set to this {@link PhongMaterial} by default.
     *
     * @type {PhongMaterial}
     */},{key:"material",get:function get(){return this.components["default.material"]||new PhongMaterial(this,{id:"default.material",emissive:[0.4,0.4,0.4],// Visible by default on geometry without normals
dontClear:true});}/**
     * Gets the default xraying {@link EmphasisMaterial} for this Scene.
     *
     * Has {@link EmphasisMaterial#id} set to "default.xrayMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#xrayMaterial} set to this {@link EmphasisMaterial} by default.
     *
     * {@link Mesh}s are xrayed while {@link Mesh#xrayed} is ````true````.
     *
     * @type {EmphasisMaterial}
     */},{key:"xrayMaterial",get:function get(){return this.components["default.xrayMaterial"]||new EmphasisMaterial(this,{id:"default.xrayMaterial",preset:"sepia",dontClear:true});}/**
     * Gets the default highlight {@link EmphasisMaterial} for this Scene.
     *
     * Has {@link EmphasisMaterial#id} set to "default.highlightMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#highlightMaterial} set to this {@link EmphasisMaterial} by default.
     *
     * {@link Mesh}s are highlighted while {@link Mesh#highlighted} is ````true````.
     *
     * @type {EmphasisMaterial}
     */},{key:"highlightMaterial",get:function get(){return this.components["default.highlightMaterial"]||new EmphasisMaterial(this,{id:"default.highlightMaterial",preset:"yellowHighlight",dontClear:true});}/**
     * Gets the default selection {@link EmphasisMaterial} for this Scene.
     *
     * Has {@link EmphasisMaterial#id} set to "default.selectedMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#highlightMaterial} set to this {@link EmphasisMaterial} by default.
     *
     * {@link Mesh}s are highlighted while {@link Mesh#highlighted} is ````true````.
     *
     * @type {EmphasisMaterial}
     */},{key:"selectedMaterial",get:function get(){return this.components["default.selectedMaterial"]||new EmphasisMaterial(this,{id:"default.selectedMaterial",preset:"greenSelected",dontClear:true});}/**
     * Gets the default {@link EdgeMaterial} for this Scene.
     *
     * Has {@link EdgeMaterial#id} set to "default.edgeMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#edgeMaterial} set to this {@link EdgeMaterial} by default.
     *
     * {@link Mesh}s have their edges emphasized while {@link Mesh#edges} is ````true````.
     *
     * @type {EdgeMaterial}
     */},{key:"edgeMaterial",get:function get(){return this.components["default.edgeMaterial"]||new EdgeMaterial(this,{id:"default.edgeMaterial",preset:"default",edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1,dontClear:true});}/**
     * Gets the {@link PointsMaterial} for this Scene.
     *
     * @type {PointsMaterial}
     */},{key:"pointsMaterial",get:function get(){return this.components["default.pointsMaterial"]||new PointsMaterial(this,{id:"default.pointsMaterial",preset:"default",dontClear:true});}/**
     * Gets the {@link LinesMaterial} for this Scene.
     *
     * @type {LinesMaterial}
     */},{key:"linesMaterial",get:function get(){return this.components["default.linesMaterial"]||new LinesMaterial(this,{id:"default.linesMaterial",preset:"default",dontClear:true});}/**
     * Gets the {@link Viewport} for this Scene.
     *
     * @type Viewport
     */},{key:"viewport",get:function get(){return this._viewport;}/**
     * Gets the {@link Camera} for this Scene.
     *
     * @type {Camera}
     */},{key:"camera",get:function get(){return this._camera;}/**
     * Gets the World-space 3D center of this Scene.
     *
     *@type {Number[]}
     */},{key:"center",get:function get(){if(this._aabbDirty||!this._center){if(!this._center||!this._center){this._center=math.vec3();}var aabb=this.aabb;this._center[0]=(aabb[0]+aabb[3])/2;this._center[1]=(aabb[1]+aabb[4])/2;this._center[2]=(aabb[2]+aabb[5])/2;}return this._center;}/**
     * Gets the World-space axis-aligned 3D boundary (AABB) of this Scene.
     *
     * The AABB is represented by a six-element Float64Array containing the min/max extents of the axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * When the Scene has no content, will be ````[-100,-100,-100,100,100,100]````.
     *
     * @type {Number[]}
     */},{key:"aabb",get:function get(){if(this._aabbDirty){if(!this._aabb){this._aabb=math.AABB3();}var xmin=math.MAX_DOUBLE;var ymin=math.MAX_DOUBLE;var zmin=math.MAX_DOUBLE;var xmax=math.MIN_DOUBLE;var ymax=math.MIN_DOUBLE;var zmax=math.MIN_DOUBLE;var aabb;var collidables=this._collidables;var collidable;var valid=false;for(var collidableId in collidables){if(collidables.hasOwnProperty(collidableId)){collidable=collidables[collidableId];if(collidable.collidable===false){continue;}aabb=collidable.aabb;if(aabb[0]<xmin){xmin=aabb[0];}if(aabb[1]<ymin){ymin=aabb[1];}if(aabb[2]<zmin){zmin=aabb[2];}if(aabb[3]>xmax){xmax=aabb[3];}if(aabb[4]>ymax){ymax=aabb[4];}if(aabb[5]>zmax){zmax=aabb[5];}valid=true;}}if(!valid){xmin=-100;ymin=-100;zmin=-100;xmax=100;ymax=100;zmax=100;}this._aabb[0]=xmin;this._aabb[1]=ymin;this._aabb[2]=zmin;this._aabb[3]=xmax;this._aabb[4]=ymax;this._aabb[5]=zmax;this._aabbDirty=false;}return this._aabb;}},{key:"_setAABBDirty",value:function _setAABBDirty(){//if (!this._aabbDirty) {
this._aabbDirty=true;this.fire("boundary");// }
}/**
     * Attempts to pick an {@link Entity} in this Scene.
     *
     * Ignores {@link Entity}s with {@link Entity#pickable} set ````false````.
     *
     * When an {@link Entity} is picked, fires a "pick" event on the {@link Entity} with the pick result as parameters.
     *
     * Picking the {@link Entity} at the given canvas coordinates:

     * ````javascript
     * var pickResult = scene.pick({
     *          canvasPos: [23, 131]
     *       });
     *
     * if (pickResult) { // Picked an Entity
     *         var entity = pickResult.entity;
     *     }
     * ````
     *
     * Picking, with a ray cast through the canvas, hits an {@link Entity}:
     *
     * ````javascript
     * var pickResult = scene.pick({
     *         pickSurface: true,
     *         canvasPos: [23, 131]
     *      });
     *
     * if (pickResult) { // Picked an Entity
     *
     *     var entity = pickResult.entity;
     *
     *     if (pickResult.primitive === "triangle") {
     *
     *         // Picked a triangle on the entity surface
     *
     *         var primIndex = pickResult.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
     *         var indices = pickResult.indices; // UInt32Array containing the triangle's vertex indices
     *         var localPos = pickResult.localPos; // Float64Array containing the picked Local-space position on the triangle
     *         var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the triangle
     *         var viewPos = pickResult.viewPos; // Float64Array containing the picked View-space position on the triangle
     *         var bary = pickResult.bary; // Float64Array containing the picked barycentric position within the triangle
     *         var worldNormal = pickResult.worldNormal; // Float64Array containing the interpolated World-space normal vector at the picked position on the triangle
     *         var uv = pickResult.uv; // Float64Array containing the interpolated UV coordinates at the picked position on the triangle
     *
     *     } else if (pickResult.worldPos && pickResult.worldNormal) {
     *
     *         // Picked a point and normal on the entity surface
     *
     *         var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the Entity surface
     *         var worldNormal = pickResult.worldNormal; // Float64Array containing the picked World-space normal vector on the Entity Surface
     *     }
     * }
     * ````
     *
     * Picking the {@link Entity} that intersects an arbitrarily-aligned World-space ray:
     *
     * ````javascript
     * var pickResult = scene.pick({
     *       pickSurface: true,   // Picking with arbitrarily-positioned ray
     *       origin: [0,0,-5],    // Ray origin
     *       direction: [0,0,1]   // Ray direction
     * });
     *
     * if (pickResult) { // Picked an Entity with the ray
     *
     *       var entity = pickResult.entity;
     *
     *       if (pickResult.primitive == "triangle") {
     *
     *          // Picked a triangle on the entity surface
     *
     *           var primitive = pickResult.primitive; // Type of primitive that was picked, usually "triangles"
     *           var primIndex = pickResult.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
     *           var indices = pickResult.indices; // UInt32Array containing the triangle's vertex indices
     *           var localPos = pickResult.localPos; // Float64Array containing the picked Local-space position on the triangle
     *           var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the triangle
     *           var viewPos = pickResult.viewPos; // Float64Array containing the picked View-space position on the triangle
     *           var bary = pickResult.bary; // Float64Array containing the picked barycentric position within the triangle
     *           var worldNormal = pickResult.worldNormal; // Float64Array containing the interpolated World-space normal vector at the picked position on the triangle
     *           var uv = pickResult.uv; // Float64Array containing the interpolated UV coordinates at the picked position on the triangle
     *           var origin = pickResult.origin; // Float64Array containing the World-space ray origin
     *           var direction = pickResult.direction; // Float64Array containing the World-space ray direction
     *
     *     } else if (pickResult.worldPos && pickResult.worldNormal) {
     *
     *         // Picked a point and normal on the entity surface
     *
     *         var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the Entity surface
     *         var worldNormal = pickResult.worldNormal; // Float64Array containing the picked World-space normal vector on the Entity Surface
     *     }
     * }
     *  ````
     *
     * @param {*} params Picking parameters.
     * @param {Boolean} [params.pickSurface=false] Whether to find the picked position on the surface of the Entity.
     * @param {Boolean} [params.pickSurfacePrecision=false] When picking an Entity surface position, indicates whether or not we want full-precision {@link PickResult#worldPos}. Only works when {@link Scene#pickSurfacePrecisionEnabled} is ````true````. If pick succeeds, the returned {@link PickResult} will have {@link PickResult#precision} set ````true````, to indicate that it contains full-precision surface pick results.
     * @param {Boolean} [params.pickSurfaceNormal=false] Whether to find the picked normal on the surface of the Entity. Only works if ````pickSurface```` is given.
     * @param {Number[]} [params.canvasPos] Canvas-space coordinates. When ray-picking, this will override the **origin** and ** direction** parameters and will cause the ray to be fired through the canvas at this position, directly along the negative View-space Z-axis.
     * @param {Number[]} [params.origin] World-space ray origin when ray-picking. Ignored when canvasPos given.
     * @param {Number[]} [params.direction] World-space ray direction when ray-picking. Also indicates the length of the ray. Ignored when canvasPos given.
     * @param {Number[]} [params.matrix] 4x4 transformation matrix to define the World-space ray origin and direction, as an alternative to ````origin```` and ````direction````.
     * @param {String[]} [params.includeEntities] IDs of {@link Entity}s to restrict picking to. When given, ignores {@link Entity}s whose IDs are not in this list.
     * @param {String[]} [params.excludeEntities] IDs of {@link Entity}s to ignore. When given, will pick *through* these {@link Entity}s, as if they were not there.
     * @param {Number} [params.snapRadius=30] The snap radius, in canvas pixels
     * @param {boolean} [params.snapToVertex=true] Whether to snap to vertex.
     * @param {boolean} [params.snapToEdge=true] Whether to snap to edge.
     * @param {PickResult} [pickResult] Holds the results of the pick attempt. Will use the Scene's singleton PickResult if you don't supply your own.
     * @returns {PickResult} Holds results of the pick attempt, returned when an {@link Entity} is picked, else null. See method comments for description.
     */},{key:"pick",value:function pick(params,pickResult){if(this.canvas.boundary[2]===0||this.canvas.boundary[3]===0){this.error("Picking not allowed while canvas has zero width or height");return null;}params=params||{};params.pickSurface=params.pickSurface||params.rayPick;// Backwards compatibility
if(!params.canvasPos&&!params.matrix&&(!params.origin||!params.direction)){this.warn("picking without canvasPos, matrix, or ray origin and direction");}var includeEntities=params.includeEntities||params.include;// Backwards compat
if(includeEntities){params.includeEntityIds=getEntityIDMap(this,includeEntities);}var excludeEntities=params.excludeEntities||params.exclude;// Backwards compat
if(excludeEntities){params.excludeEntityIds=getEntityIDMap(this,excludeEntities);}if(this._needRecompile){this._recompile();this._renderer.imageDirty();this._needRecompile=false;}if(params.snapToEdge||params.snapToVertex){pickResult=this._renderer.snapPick(params.canvasPos,params.snapRadius||30,params.snapToVertex,params.snapToEdge,pickResult);}else{pickResult=this._renderer.pick(params,pickResult);}if(pickResult){if(pickResult.entity&&pickResult.entity.fire){pickResult.entity.fire("picked",pickResult);// TODO: SceneModelEntity doesn't fire events
}}return pickResult;}/**
     * @param {Object} params Picking parameters.
     * @param {Number[]} [params.canvasPos] Canvas-space coordinates. When ray-picking, this will override the **origin** and ** direction** parameters and will cause the ray to be fired through the canvas at this position, directly along the negative View-space Z-axis.
     * @param {Number} [params.snapRadius=30] The snap radius, in canvas pixels
     * @param {boolean} [params.snapToVertex=true] Whether to snap to vertex.
     * @param {boolean} [params.snapToEdge=true] Whether to snap to edge.
     * @deprecated
     */},{key:"snapPick",value:function snapPick(params){if(undefined===this._warnSnapPickDeprecated){this._warnSnapPickDeprecated=true;this.warn("Scene.snapPick() is deprecated since v2.4.2 - use Scene.pick() instead");}return this._renderer.snapPick(params.canvasPos,params.snapRadius||30,params.snapToVertex,params.snapToEdge);}/**
     * Destroys all non-default {@link Component}s in this Scene.
     */},{key:"clear",value:function clear(){var component;for(var id in this.components){if(this.components.hasOwnProperty(id)){component=this.components[id];if(!component._dontClear){// Don't destroy components like Camera, Input, Viewport etc.
component.destroy();}}}}/**
     * Destroys all {@link Light}s in this Scene..
     */},{key:"clearLights",value:function clearLights(){var ids=Object.keys(this.lights);for(var _i87=0,len=ids.length;_i87<len;_i87++){this.lights[ids[_i87]].destroy();}}/**
     * Destroys all {@link SectionPlane}s in this Scene.
     */},{key:"clearSectionPlanes",value:function clearSectionPlanes(){var ids=Object.keys(this.sectionPlanes);for(var _i88=0,len=ids.length;_i88<len;_i88++){this.sectionPlanes[ids[_i88]].destroy();}}/**
     * Destroys all {@link Line}s in this Scene.
     */},{key:"clearBitmaps",value:function clearBitmaps(){var ids=Object.keys(this.bitmaps);for(var _i89=0,len=ids.length;_i89<len;_i89++){this.bitmaps[ids[_i89]].destroy();}}/**
     * Destroys all {@link Line}s in this Scene.
     */},{key:"clearLines",value:function clearLines(){var ids=Object.keys(this.lineSets);for(var _i90=0,len=ids.length;_i90<len;_i90++){this.lineSets[ids[_i90]].destroy();}}/**
     * Gets the collective axis-aligned boundary (AABB) of a batch of {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which {@link Entity#isObject} is registered by {@link Entity#id} in {@link Scene#visibleObjects}.
     *
     * Each {@link Entity} is only included in the AABB when {@link Entity#collidable} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @returns {[Number, Number, Number, Number, Number, Number]} An axis-aligned World-space bounding box, given as elements ````[xmin, ymin, zmin, xmax, ymax, zmax]````.
     */},{key:"getAABB",value:function getAABB(ids){if(ids===undefined){return this.aabb;}if(utils.isString(ids)){var entity=this.objects[ids];if(entity&&entity.aabb){// A Component subclass with an AABB
return entity.aabb;}ids=[ids];// Must be an entity type
}if(ids.length===0){return this.aabb;}var xmin=math.MAX_DOUBLE;var ymin=math.MAX_DOUBLE;var zmin=math.MAX_DOUBLE;var xmax=math.MIN_DOUBLE;var ymax=math.MIN_DOUBLE;var zmax=math.MIN_DOUBLE;var valid;this.withObjects(ids,function(entity){if(entity.collidable){var aabb=entity.aabb;if(aabb[0]<xmin){xmin=aabb[0];}if(aabb[1]<ymin){ymin=aabb[1];}if(aabb[2]<zmin){zmin=aabb[2];}if(aabb[3]>xmax){xmax=aabb[3];}if(aabb[4]>ymax){ymax=aabb[4];}if(aabb[5]>zmax){zmax=aabb[5];}valid=true;}});if(valid){var aabb2=math.AABB3();aabb2[0]=xmin;aabb2[1]=ymin;aabb2[2]=zmin;aabb2[3]=xmax;aabb2[4]=ymax;aabb2[5]=zmax;return aabb2;}else{return this.aabb;// Scene AABB
}}/**
     * Batch-updates {@link Entity#visible} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#visible} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#visibleObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} visible Whether or not to set visible.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsVisible",value:function setObjectsVisible(ids,visible){return this.withObjects(ids,function(entity){var changed=entity.visible!==visible;entity.visible=visible;return changed;});}/**
     * Batch-updates {@link Entity#collidable} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} collidable Whether or not to set collidable.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsCollidable",value:function setObjectsCollidable(ids,collidable){return this.withObjects(ids,function(entity){var changed=entity.collidable!==collidable;entity.collidable=collidable;return changed;});}/**
     * Batch-updates {@link Entity#culled} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} culled Whether or not to cull.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsCulled",value:function setObjectsCulled(ids,culled){return this.withObjects(ids,function(entity){var changed=entity.culled!==culled;entity.culled=culled;return changed;});}/**
     * Batch-updates {@link Entity#selected} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#selected} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#selectedObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} selected Whether or not to select.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsSelected",value:function setObjectsSelected(ids,selected){return this.withObjects(ids,function(entity){var changed=entity.selected!==selected;entity.selected=selected;return changed;});}/**
     * Batch-updates {@link Entity#highlighted} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#highlighted} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#highlightedObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} highlighted Whether or not to highlight.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsHighlighted",value:function setObjectsHighlighted(ids,highlighted){return this.withObjects(ids,function(entity){var changed=entity.highlighted!==highlighted;entity.highlighted=highlighted;return changed;});}/**
     * Batch-updates {@link Entity#xrayed} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} xrayed Whether or not to xray.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsXRayed",value:function setObjectsXRayed(ids,xrayed){return this.withObjects(ids,function(entity){var changed=entity.xrayed!==xrayed;entity.xrayed=xrayed;return changed;});}/**
     * Batch-updates {@link Entity#edges} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} edges Whether or not to show edges.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsEdges",value:function setObjectsEdges(ids,edges){return this.withObjects(ids,function(entity){var changed=entity.edges!==edges;entity.edges=edges;return changed;});}/**
     * Batch-updates {@link Entity#colorize} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Number[]} [colorize=(1,1,1)] RGB colorize factors, multiplied by the rendered pixel colors.
     * @returns {Boolean} True if any {@link Entity}s changed opacity, else false if all updates were redundant and not applied.
     */},{key:"setObjectsColorized",value:function setObjectsColorized(ids,colorize){return this.withObjects(ids,function(entity){entity.colorize=colorize;});}/**
     * Batch-updates {@link Entity#opacity} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Number} [opacity=1.0] Opacity factor, multiplied by the rendered pixel alphas.
     * @returns {Boolean} True if any {@link Entity}s changed opacity, else false if all updates were redundant and not applied.
     */},{key:"setObjectsOpacity",value:function setObjectsOpacity(ids,opacity){return this.withObjects(ids,function(entity){var changed=entity.opacity!==opacity;entity.opacity=opacity;return changed;});}/**
     * Batch-updates {@link Entity#pickable} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} pickable Whether or not to set pickable.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"setObjectsPickable",value:function setObjectsPickable(ids,pickable){return this.withObjects(ids,function(entity){var changed=entity.pickable!==pickable;entity.pickable=pickable;return changed;});}/**
     * Batch-updates {@link Entity#offset} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Number[]} [offset] 3D offset vector.
     */},{key:"setObjectsOffset",value:function setObjectsOffset(ids,offset){this.withObjects(ids,function(entity){entity.offset=offset;});}/**
     * Iterates with a callback over {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Function} callback Callback to execute on eacn {@link Entity}.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */},{key:"withObjects",value:function withObjects(ids,callback){if(utils.isString(ids)){ids=[ids];}var changed=false;for(var _i91=0,len=ids.length;_i91<len;_i91++){var id=ids[_i91];var entity=this.objects[id];if(entity){changed=callback(entity)||changed;}else{var modelIds=this.modelIds;for(var _i92=0,_len6=modelIds.length;_i92<_len6;_i92++){var modelId=modelIds[_i92];var globalObjectId=math.globalizeObjectId(modelId,id);entity=this.objects[globalObjectId];if(entity){changed=callback(entity)||changed;}}}}return changed;}/**
     * This method will "tickify" the provided `cb` function.
     *
     * This means, the function will be wrapped so:
     *
     * - it runs time-aligned to scene ticks
     * - it runs maximum once per scene-tick
     *
     * @param {Function} cb The function to tickify
     * @returns {Function}
     */},{key:"tickify",value:function tickify(cb){var cbString=cb.toString();/**
         * Check if the function is already tickified, and if so return the cached one.
         */if(cbString in this._tickifiedFunctions){return this._tickifiedFunctions[cbString].wrapperFunc;}var alreadyRun=0;var needToRun=0;var lastArgs;/**
         * The provided `cb` function is replaced with a "set-dirty" function
         *
         * @type {Function}
         */var wrapperFunc=function wrapperFunc(){for(var _len7=arguments.length,args=new Array(_len7),_key4=0;_key4<_len7;_key4++){args[_key4]=arguments[_key4];}lastArgs=args;needToRun++;};/**
         * An each scene tick, if the "dirty-flag" is set, run the `cb` function.
         *
         * This will make it run time-aligned to the scene tick.
         */var tickSubId=this.on("tick",function(){var tmp=needToRun;if(tmp>alreadyRun){alreadyRun=tmp;cb.apply(void 0,_toConsumableArray(lastArgs));}});/**
         * And, store the list of subscribers.
         */this._tickifiedFunctions[cbString]={tickSubId:tickSubId,wrapperFunc:wrapperFunc};return wrapperFunc;}/**
     * Destroys this Scene.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Scene.prototype),"destroy",this).call(this);for(var id in this.components){if(this.components.hasOwnProperty(id)){this.components[id].destroy();}}this.canvas.gl=null;// Memory leak prevention
this.components=null;this.models=null;this.objects=null;this.visibleObjects=null;this.xrayedObjects=null;this.highlightedObjects=null;this.selectedObjects=null;this.colorizedObjects=null;this.opacityObjects=null;this.sectionPlanes=null;this.lights=null;this.lightMaps=null;this.reflectionMaps=null;this._objectIds=null;this._visibleObjectIds=null;this._xrayedObjectIds=null;this._highlightedObjectIds=null;this._selectedObjectIds=null;this._colorizedObjectIds=null;this.types=null;this.components=null;this.canvas=null;this._renderer=null;this.input=null;this._viewport=null;this._camera=null;}}]);return Scene;}(Component);/**
 * Texture wrapping mode in which the texture repeats to infinity.
 */var RepeatWrapping=1000;/**
 * Texture wrapping mode in which the last pixel of the texture stretches to the edge of the mesh.
 */var ClampToEdgeWrapping=1001;/**
 * Texture wrapping mode in which the texture repeats to infinity, mirroring on each repeat.
 */var MirroredRepeatWrapping=1002;/**
 * Texture magnification and minification filter that returns the nearest texel to the given sample coordinates.
 */var NearestFilter=1003;/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and returns the nearest texel to the given sample coordinates.
 */var NearestMipMapNearestFilter=1004;/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured
 * and returns the nearest texel to the given sample coordinates.
 */var NearestMipmapNearestFilter=1004;/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured
 * and returns the nearest texel to the center of the pixel at the given sample coordinates.
 */var NearestMipmapLinearFilter=1005;/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured
 * and returns the nearest texel to the center of the pixel at the given sample coordinates.
 */var NearestMipMapLinearFilter=1005;/**
 * Texture magnification and minification filter that returns the weighted average of the four nearest texels to the given sample coordinates.
 */var LinearFilter=1006;/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and
 * returns the weighted average of the four nearest texels to the given sample coordinates.
 */var LinearMipmapNearestFilter=1007;/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and
 * returns the weighted average of the four nearest texels to the given sample coordinates.
 */var LinearMipMapNearestFilter=1007;/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,
 * finds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the
 * weighted average of those two values.
 */var LinearMipmapLinearFilter=1008;/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,
 * finds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the
 * weighted average of those two values.
 */var LinearMipMapLinearFilter=1008;/**
 * Unsigned 8-bit integer type.
 */var UnsignedByteType=1009;/**
 * Signed 8-bit integer type.
 */var ByteType=1010;/**
 * Signed 16-bit integer type.
 */var ShortType=1011;/**
 * Unsigned 16-bit integer type.
 */var UnsignedShortType=1012;/**
 * Signed 32-bit integer type.
 */var IntType=1013;/**
 * Unsigned 32-bit integer type.
 */var UnsignedIntType=1014;/**
 * Signed 32-bit floating-point type.
 */var FloatType=1015;/**
 * Signed 16-bit half-precision floating-point type.
 */var HalfFloatType=1016;/**
 * Texture packing mode in which each ````RGBA```` channel is packed into 4 bits, for a combined total of 16 bits.
 */var UnsignedShort4444Type=1017;/**
 * Texture packing mode in which the ````RGB```` channels are each packed into 5 bits, and the ````A```` channel is packed into 1 bit, for a combined total of 16 bits.
 */var UnsignedShort5551Type=1018;/**
 * Unsigned integer type for 24-bit depth texture data.
 */var UnsignedInt248Type=1020;/**
 * Texture sampling mode that discards the ````RGBA```` components and just reads the ````A```` component.
 */var AlphaFormat=1021;/**
 * Texture sampling mode that discards the ````A```` component and reads the ````RGB```` components.
 */var RGBFormat=1022;/**
 * Texture sampling mode that reads the ````RGBA```` components.
 */var RGBAFormat=1023;/**
 * Texture sampling mode that reads each ````RGB```` texture component as a luminance value, converted to a float and clamped
 * to ````[0,1]````, while always reading the ````A```` channel as ````1.0````.
 */var LuminanceFormat=1024;/**
 * Texture sampling mode that reads each of the ````RGBA```` texture components as a luminance/alpha value, converted to a float and clamped to ````[0,1]````.
 */var LuminanceAlphaFormat=1025;/**
 * Texture sampling mode that reads each element as a single depth value, converts it to a float and clamps to ````[0,1]````.
 */var DepthFormat=1026;/**
 * Texture sampling mode that
 */var DepthStencilFormat=1027;/**
 * Texture sampling mode that discards the ````GBA```` components and just reads the ````R```` component.
 */var RedFormat=1028;/**
 * Texture sampling mode that discards the ````GBA```` components and just reads the ````R```` component, as an integer instead of as a float.
 */var RedIntegerFormat=1029;/**
 * Texture sampling mode that discards the ````A```` and ````B```` components and just reads the ````R```` and ````G```` components.
 */var RGFormat=1030;/**
 * Texture sampling mode that discards the ````A```` and ````B```` components and just reads the ````R```` and ````G```` components, as integers instead of floats.
 */var RGIntegerFormat=1031;/**
 * Texture sampling mode that reads the ````RGBA```` components as integers instead of floats.
 */var RGBAIntegerFormat=1033;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT1 compressed</a> ````RGB```` image.
 */var RGB_S3TC_DXT1_Format=33776;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT1 compressed</a> ````RGBA```` image.
 */var RGBA_S3TC_DXT1_Format=33777;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT3 compressed</a> ````RGBA```` image.
 */var RGBA_S3TC_DXT3_Format=33778;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT5 compressed</a> ````RGBA```` image.
 */var RGBA_S3TC_DXT5_Format=33779;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGB```` compression in 4-bit mode and one block for each 44 pixels.
 */var RGB_PVRTC_4BPPV1_Format=35840;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGB```` compression in 2-bit mode and one block for each 84 pixels.
 */var RGB_PVRTC_2BPPV1_Format=35841;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGBA```` compression in 4-bit mode and one block for each 44 pixels.
 */var RGBA_PVRTC_4BPPV1_Format=35842;/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGBA```` compression in 2-bit mode and one block for each 84 pixels.
 */var RGBA_PVRTC_2BPPV1_Format=35843;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc1/">ETC1 compressed</a>
 * ````RGB```` image.
 */var RGB_ETC1_Format=36196;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc2/">ETC2 compressed</a>
 * ````RGB```` image.
 */var RGB_ETC2_Format=37492;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc2/">ETC2 compressed</a>
 * ````RGBA```` image.
 */var RGBA_ETC2_EAC_Format=37496;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_4x4_Format=37808;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_5x4_Format=37809;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_5x5_Format=37810;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_6x5_Format=37811;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_6x6_Format=37812;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_8x5_Format=37813;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_8x6_Format=37814;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_8x8_Format=37815;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_10x5_Format=37816;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_10x6_Format=37817;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_10x8_Format=37818;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_10x10_Format=37819;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_12x10_Format=37820;/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */var RGBA_ASTC_12x12_Format=37821;/**
 * Texture format mode in which the texture is formatted as an <a href="https://www.khronos.org/opengl/wiki/BPTC_Texture_Compression">BPTC compressed</a>
 * ````RGBA```` image.
 */var RGBA_BPTC_Format=36492;/**
 * Texture encoding mode in which the texture image is in linear color space.
 */var LinearEncoding=3000;/**
 * Texture encoding mode in which the texture image is in sRGB color space.
 */var sRGBEncoding=3001;/**
 * Media type for GIF images.
 */var GIFMediaType=10000;/**
 * Media type for JPEG images.
 */var JPEGMediaType=10001;/**
 * Media type for PNG images.
 */var PNGMediaType=10002;/**
 * Media type for compressed texture data.
 */var CompressedMediaType=10003;/**
 * @private
 */var DrawShaderSource=function DrawShaderSource(mesh){if(mesh._material._state.type==="LambertMaterial"){this.vertex=buildVertexLambert(mesh);this.fragment=buildFragmentLambert(mesh);}else{this.vertex=buildVertexDraw(mesh);this.fragment=buildFragmentDraw(mesh);}};var TEXTURE_DECODE_FUNCS$1={};TEXTURE_DECODE_FUNCS$1[LinearEncoding]="linearToLinear";TEXTURE_DECODE_FUNCS$1[sRGBEncoding]="sRGBToLinear";function getReceivesShadow(mesh){if(!mesh.receivesShadow){return false;}var lights=mesh.scene._lightsState.lights;if(!lights||lights.length===0){return false;}for(var _i93=0,len=lights.length;_i93<len;_i93++){if(lights[_i93].castsShadow){return true;}}return false;}function hasTextures(mesh){if(!mesh._geometry._state.uvBuf){return false;}var material=mesh._material;return!!(material._ambientMap||material._occlusionMap||material._baseColorMap||material._diffuseMap||material._alphaMap||material._specularMap||material._glossinessMap||material._specularGlossinessMap||material._emissiveMap||material._metallicMap||material._roughnessMap||material._metallicRoughnessMap||material._reflectivityMap||material._normalMap);}function hasNormals$1(mesh){var primitive=mesh._geometry._state.primitiveName;if((mesh._geometry._state.autoVertexNormals||mesh._geometry._state.normalsBuf)&&(primitive==="triangles"||primitive==="triangle-strip"||primitive==="triangle-fan")){return true;}return false;}function buildVertexLambert(mesh){var scene=mesh.scene;var sectionPlanesState=mesh.scene._sectionPlanesState;var lightsState=mesh.scene._lightsState;var geometryState=mesh._geometry._state;var billboard=mesh._state.billboard;var stationary=mesh._state.stationary;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var quantizedGeometry=!!geometryState.compressGeometry;var src=[];src.push("#version 300 es");src.push("// Lambertian drawing vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 colorize;");src.push("uniform vec3 offset;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");}src.push("uniform vec4 lightAmbient;");src.push("uniform vec4 materialColor;");src.push("uniform vec3 materialEmissive;");if(geometryState.normalsBuf){src.push("in vec3 normal;");src.push("uniform mat4 modelNormalMatrix;");src.push("uniform mat4 viewNormalMatrix;");for(var _i94=0,len=lightsState.lights.length;_i94<len;_i94++){var light=lightsState.lights[_i94];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i94+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i94+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i94+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i94+";");src.push("uniform vec3 lightDir"+_i94+";");}}if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");}}src.push("out vec4 vColor;");if(geometryState.primitiveName==="points"){src.push("uniform float pointSize;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;");}src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}");}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}if(geometryState.normalsBuf){if(quantizedGeometry){src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");}else{src.push("vec4 localNormal = vec4(normal, 0.0); ");}src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;");}src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");if(geometryState.normalsBuf){src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");src.push("billboard(modelNormalMatrix2);");src.push("billboard(viewNormalMatrix2);");src.push("billboard(modelViewNormalMatrix);");}src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;");}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");}if(geometryState.normalsBuf){src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);");}src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");if(geometryState.normalsBuf){for(var _i95=0,_len8=lightsState.lights.length;_i95<_len8;_i95++){var _light=lightsState.lights[_i95];if(_light.type==="ambient"){continue;}if(_light.type==="dir"){if(_light.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i95+");");}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir"+_i95+", 0.0)).xyz);");}}else if(_light.type==="point"){if(_light.space==="view"){src.push("viewLightDir = -normalize(lightPos"+_i95+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix2 * vec4(lightPos"+_i95+", 0.0)).xyz);");}}else if(_light.type==="spot"){if(_light.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i95+");");}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir"+_i95+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+_i95+".rgb * lightColor"+_i95+".a);");}}src.push("vColor = vec4((lightAmbient.rgb * lightAmbient.a * materialColor.rgb) + materialEmissive.rgb + (reflectedColor * materialColor.rgb), materialColor.a) * colorize;");// TODO: How to have ambient bright enough for canvas BG but not too bright for scene?
if(clipping){src.push("vWorldPosition = worldPosition;");}if(geometryState.primitiveName==="points"){src.push("gl_PointSize = pointSize;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");return src;}function buildFragmentLambert(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;mesh._material._state;var geometryState=mesh._geometry._state;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var gammaOutput=scene.gammaOutput;// If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
var src=[];src.push("#version 300 es");src.push("// Lambertian drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("uniform bool clippable;");for(var _i96=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i96<len;_i96++){src.push("uniform bool sectionPlaneActive"+_i96+";");src.push("uniform vec3 sectionPlanePos"+_i96+";");src.push("uniform vec3 sectionPlaneDir"+_i96+";");}}src.push("in vec4 vColor;");if(gammaOutput){src.push("uniform float gammaFactor;");src.push("    vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var _i97=0,_len9=sectionPlanesState.getNumAllocatedSectionPlanes();_i97<_len9;_i97++){src.push("if (sectionPlaneActive"+_i97+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i97+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i97+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(geometryState.primitiveName==="points"){src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}if(gammaOutput){src.push("outColor = linearToGamma(vColor, gammaFactor);");}else{src.push("outColor = vColor;");}src.push("}");return src;}function buildVertexDraw(mesh){var scene=mesh.scene;mesh._material;var meshState=mesh._state;var sectionPlanesState=scene._sectionPlanesState;var geometryState=mesh._geometry._state;var lightsState=scene._lightsState;var light;var billboard=meshState.billboard;var background=meshState.background;var stationary=meshState.stationary;var texturing=hasTextures(mesh);var normals=hasNormals$1(mesh);var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var receivesShadow=getReceivesShadow(mesh);var quantizedGeometry=!!geometryState.compressGeometry;var src=[];src.push("#version 300 es");src.push("// Drawing vertex shader");src.push("in  vec3 position;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}src.push("uniform  mat4 modelMatrix;");src.push("uniform  mat4 viewMatrix;");src.push("uniform  mat4 projMatrix;");src.push("out  vec3 vViewPosition;");src.push("uniform  vec3 offset;");if(clipping){src.push("out vec4 vWorldPosition;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(lightsState.lightMaps.length>0){src.push("out    vec3 vWorldNormal;");}if(normals){src.push("in  vec3 normal;");src.push("uniform    mat4 modelNormalMatrix;");src.push("uniform    mat4 viewNormalMatrix;");src.push("out    vec3 vViewNormal;");for(var _i98=0,len=lightsState.lights.length;_i98<len;_i98++){light=lightsState.lights[_i98];if(light.type==="ambient"){continue;}if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i98+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i98+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i98+";");src.push("uniform vec3 lightDir"+_i98+";");}if(!(light.type==="dir"&&light.space==="view")){src.push("out vec4 vViewLightReverseDirAndDist"+_i98+";");}}if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");}}if(texturing){src.push("in vec2 uv;");src.push("out vec2 vUV;");if(quantizedGeometry){src.push("uniform mat3 uvDecodeMatrix;");}}if(geometryState.colors){src.push("in vec4 color;");src.push("out vec4 vColor;");}if(geometryState.primitiveName==="points"){src.push("uniform float pointSize;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;");}src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}");}if(receivesShadow){src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");for(var _i99=0,_len10=lightsState.lights.length;_i99<_len10;_i99++){// Light sources
if(lightsState.lights[_i99].castsShadow){src.push("uniform mat4 shadowViewMatrix"+_i99+";");src.push("uniform mat4 shadowProjMatrix"+_i99+";");src.push("out vec4 vShadowPosFromLight"+_i99+";");}}}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}if(normals){if(quantizedGeometry){src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");}else{src.push("vec4 localNormal = vec4(normal, 0.0); ");}src.push("mat4 modelNormalMatrix2    = modelNormalMatrix;");src.push("mat4 viewNormalMatrix2     = viewNormalMatrix;");}src.push("mat4 viewMatrix2           = viewMatrix;");src.push("mat4 modelMatrix2          = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");}else if(background){src.push("viewMatrix2[3] = vec4(0.0, 0.0, 0.0 ,1.0);");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");if(normals){src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");src.push("billboard(modelNormalMatrix2);");src.push("billboard(viewNormalMatrix2);");src.push("billboard(modelViewNormalMatrix);");}src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;");}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");}if(normals){src.push("vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; ");if(lightsState.lightMaps.length>0){src.push("vWorldNormal = worldNormal;");}src.push("vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);");src.push("vec3 tmpVec3;");src.push("float lightDist;");for(var _i100=0,_len11=lightsState.lights.length;_i100<_len11;_i100++){// Lights
light=lightsState.lights[_i100];if(light.type==="ambient"){continue;}if(light.type==="dir"){if(light.space==="world"){src.push("tmpVec3 = vec3(viewMatrix2 * vec4(lightDir"+_i100+", 0.0) ).xyz;");src.push("vViewLightReverseDirAndDist"+_i100+" = vec4(-tmpVec3, 0.0);");}}if(light.type==="point"){if(light.space==="world"){src.push("tmpVec3 = (viewMatrix2 * vec4(lightPos"+_i100+", 1.0)).xyz - viewPosition.xyz;");src.push("lightDist = abs(length(tmpVec3));");}else{src.push("tmpVec3 = lightPos"+_i100+".xyz - viewPosition.xyz;");src.push("lightDist = abs(length(tmpVec3));");}src.push("vViewLightReverseDirAndDist"+_i100+" = vec4(tmpVec3, lightDist);");}}}if(texturing){if(quantizedGeometry){src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");}else{src.push("vUV = uv;");}}if(geometryState.colors){src.push("vColor = color;");}if(geometryState.primitiveName==="points"){src.push("gl_PointSize = pointSize;");}if(clipping){src.push("vWorldPosition = worldPosition;");}src.push("   vViewPosition = viewPosition.xyz;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(background){src.push("clipPos.z = clipPos.w;");}src.push("gl_Position = clipPos;");if(receivesShadow){src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");src.push("vec4 tempx; ");for(var _i101=0,_len12=lightsState.lights.length;_i101<_len12;_i101++){// Light sources
if(lightsState.lights[_i101].castsShadow){src.push("vShadowPosFromLight"+_i101+" = texUnitConverter * shadowProjMatrix"+_i101+" * (shadowViewMatrix"+_i101+" * worldPosition); ");}}}src.push("}");return src;}function buildFragmentDraw(mesh){var scene=mesh.scene;scene.canvas.gl;var material=mesh._material;var geometryState=mesh._geometry._state;var sectionPlanesState=mesh.scene._sectionPlanesState;var lightsState=mesh.scene._lightsState;var materialState=mesh._material._state;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var normals=hasNormals$1(mesh);var uvs=geometryState.uvBuf;var phongMaterial=materialState.type==="PhongMaterial";var metallicMaterial=materialState.type==="MetallicMaterial";var specularMaterial=materialState.type==="SpecularMaterial";var receivesShadow=getReceivesShadow(mesh);scene.gammaInput;// If set, then it expects that all textures and colors are premultiplied gamma. Default is false.
var gammaOutput=scene.gammaOutput;// If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
var src=[];src.push("#version 300 es");src.push("// Drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(receivesShadow){src.push("float unpackDepth (vec4 color) {");src.push("  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0*256.0*256.0));");src.push("  return dot(color, bitShift);");src.push("}");}//--------------------------------------------------------------------------------
// GAMMA CORRECTION
//--------------------------------------------------------------------------------
src.push("uniform float gammaFactor;");src.push("vec4 linearToLinear( in vec4 value ) {");src.push("  return value;");src.push("}");src.push("vec4 sRGBToLinear( in vec4 value ) {");src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");src.push("}");src.push("vec4 gammaToLinear( in vec4 value) {");src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");src.push("}");if(gammaOutput){src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}//--------------------------------------------------------------------------------
// USER CLIP PLANES
//--------------------------------------------------------------------------------
if(clipping){src.push("in vec4 vWorldPosition;");src.push("uniform bool clippable;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}if(normals){//--------------------------------------------------------------------------------
// LIGHT AND REFLECTION MAP INPUTS
// Define here so available globally to shader functions
//--------------------------------------------------------------------------------
if(lightsState.lightMaps.length>0){src.push("uniform samplerCube lightMap;");src.push("uniform mat4 viewNormalMatrix;");}if(lightsState.reflectionMaps.length>0){src.push("uniform samplerCube reflectionMap;");}if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("uniform mat4 viewMatrix;");}//--------------------------------------------------------------------------------
// SHADING FUNCTIONS
//--------------------------------------------------------------------------------
// CONSTANT DEFINITIONS
src.push("#define PI 3.14159265359");src.push("#define RECIPROCAL_PI 0.31830988618");src.push("#define RECIPROCAL_PI2 0.15915494");src.push("#define EPSILON 1e-6");src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");// UTILITY DEFINITIONS
src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");src.push("}");// STRUCTURES
src.push("struct IncidentLight {");src.push("   vec3 color;");src.push("   vec3 direction;");src.push("};");src.push("struct ReflectedLight {");src.push("   vec3 diffuse;");src.push("   vec3 specular;");src.push("};");src.push("struct Geometry {");src.push("   vec3 position;");src.push("   vec3 viewNormal;");src.push("   vec3 worldNormal;");src.push("   vec3 viewEyeDir;");src.push("};");src.push("struct Material {");src.push("   vec3    diffuseColor;");src.push("   float   specularRoughness;");src.push("   vec3    specularColor;");src.push("   float   shine;");// Only used for Phong
src.push("};");// COMMON UTILS
if(phongMaterial){if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");if(lightsState.lightMaps.length>0){src.push("   vec3 irradiance = "+TEXTURE_DECODE_FUNCS$1[lightsState.lightMaps[0].encoding]+"(texture(lightMap, geometry.worldNormal)).rgb;");src.push("   irradiance *= PI;");src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");}if(lightsState.reflectionMaps.length>0){src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");src.push("   vec3 radiance               = texture(reflectionMap, reflectVec).rgb * 0.2;");src.push("   radiance *= PI;");src.push("   reflectedLight.specular     += radiance;");}src.push("}");}src.push("void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");src.push("   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));");src.push("   vec3 irradiance = dotNL * directLight.color * PI;");src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);");src.push("}");}if(metallicMaterial||specularMaterial){// IRRADIANCE EVALUATION
src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");src.push("   float r = ggxRoughness + 0.0001;");src.push("   return (2.0 / (r * r) - 2.0);");src.push("}");src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");src.push("}");if(lightsState.reflectionMaps.length>0){src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);");//TODO: a random factor - fix this
src.push("   vec3 envMapColor = "+TEXTURE_DECODE_FUNCS$1[lightsState.reflectionMaps[0].encoding]+"(texture(reflectionMap, reflectVec, mipLevel)).rgb;");src.push("  return envMapColor;");src.push("}");}// SPECULAR BRDF EVALUATION
src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");src.push("}");src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   return 1.0 / ( gl * gv );");src.push("}");src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   return 0.5 / max( gv + gl, EPSILON );");src.push("}");src.push("float D_GGX(const in float alpha, const in float dotNH) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");src.push("}");src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float alpha = ( roughness * roughness );");src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");src.push("   vec3  F = F_Schlick( specularColor, dotLH );");src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");src.push("   float D = D_GGX( alpha, dotNH );");src.push("   return F * (G * D);");src.push("}");src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");src.push("   vec4 r = roughness * c0 + c1;");src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");src.push("   return specularColor * AB.x + AB.y;");src.push("}");if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");if(lightsState.lightMaps.length>0){src.push("   vec3 irradiance = sRGBToLinear(texture(lightMap, geometry.worldNormal)).rgb;");src.push("   irradiance *= PI;");src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");//   src.push("   reflectedLight.diffuse = vec3(1.0, 0.0, 0.0);");
}if(lightsState.reflectionMaps.length>0){src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");}src.push("}");}// MAIN LIGHTING COMPUTATION FUNCTION
src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");src.push("}");}// (metallicMaterial || specularMaterial)
}// geometry.normals
//--------------------------------------------------------------------------------
// GEOMETRY INPUTS
//--------------------------------------------------------------------------------
src.push("in vec3 vViewPosition;");if(geometryState.colors){src.push("in vec4 vColor;");}if(uvs&&(normals&&material._normalMap||material._ambientMap||material._baseColorMap||material._diffuseMap||material._emissiveMap||material._metallicMap||material._roughnessMap||material._metallicRoughnessMap||material._specularMap||material._glossinessMap||material._specularGlossinessMap||material._occlusionMap||material._alphaMap)){src.push("in vec2 vUV;");}if(normals){if(lightsState.lightMaps.length>0){src.push("in vec3 vWorldNormal;");}src.push("in vec3 vViewNormal;");}//--------------------------------------------------------------------------------
// MATERIAL CHANNEL INPUTS
//--------------------------------------------------------------------------------
if(materialState.ambient){src.push("uniform vec3 materialAmbient;");}if(materialState.baseColor){src.push("uniform vec3 materialBaseColor;");}if(materialState.alpha!==undefined&&materialState.alpha!==null){src.push("uniform vec4 materialAlphaModeCutoff;");// [alpha, alphaMode, alphaCutoff]
}if(materialState.emissive){src.push("uniform vec3 materialEmissive;");}if(materialState.diffuse){src.push("uniform vec3 materialDiffuse;");}if(materialState.glossiness!==undefined&&materialState.glossiness!==null){src.push("uniform float materialGlossiness;");}if(materialState.shininess!==undefined&&materialState.shininess!==null){src.push("uniform float materialShininess;");// Phong channel
}if(materialState.specular){src.push("uniform vec3 materialSpecular;");}if(materialState.metallic!==undefined&&materialState.metallic!==null){src.push("uniform float materialMetallic;");}if(materialState.roughness!==undefined&&materialState.roughness!==null){src.push("uniform float materialRoughness;");}if(materialState.specularF0!==undefined&&materialState.specularF0!==null){src.push("uniform float materialSpecularF0;");}//--------------------------------------------------------------------------------
// MATERIAL TEXTURE INPUTS
//--------------------------------------------------------------------------------
if(uvs&&material._ambientMap){src.push("uniform sampler2D ambientMap;");if(material._ambientMap._state.matrix){src.push("uniform mat4 ambientMapMatrix;");}}if(uvs&&material._baseColorMap){src.push("uniform sampler2D baseColorMap;");if(material._baseColorMap._state.matrix){src.push("uniform mat4 baseColorMapMatrix;");}}if(uvs&&material._diffuseMap){src.push("uniform sampler2D diffuseMap;");if(material._diffuseMap._state.matrix){src.push("uniform mat4 diffuseMapMatrix;");}}if(uvs&&material._emissiveMap){src.push("uniform sampler2D emissiveMap;");if(material._emissiveMap._state.matrix){src.push("uniform mat4 emissiveMapMatrix;");}}if(normals&&uvs&&material._metallicMap){src.push("uniform sampler2D metallicMap;");if(material._metallicMap._state.matrix){src.push("uniform mat4 metallicMapMatrix;");}}if(normals&&uvs&&material._roughnessMap){src.push("uniform sampler2D roughnessMap;");if(material._roughnessMap._state.matrix){src.push("uniform mat4 roughnessMapMatrix;");}}if(normals&&uvs&&material._metallicRoughnessMap){src.push("uniform sampler2D metallicRoughnessMap;");if(material._metallicRoughnessMap._state.matrix){src.push("uniform mat4 metallicRoughnessMapMatrix;");}}if(normals&&material._normalMap){src.push("uniform sampler2D normalMap;");if(material._normalMap._state.matrix){src.push("uniform mat4 normalMapMatrix;");}src.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");src.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");src.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");src.push("      vec2 st0 = dFdx( uv.st );");src.push("      vec2 st1 = dFdy( uv.st );");src.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");src.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");src.push("      vec3 N = normalize( surf_norm );");src.push("      vec3 mapN = texture( normalMap, uv ).xyz * 2.0 - 1.0;");src.push("      mat3 tsn = mat3( S, T, N );");//     src.push("      mapN *= 3.0;");
src.push("      return normalize( tsn * mapN );");src.push("}");}if(uvs&&material._occlusionMap){src.push("uniform sampler2D occlusionMap;");if(material._occlusionMap._state.matrix){src.push("uniform mat4 occlusionMapMatrix;");}}if(uvs&&material._alphaMap){src.push("uniform sampler2D alphaMap;");if(material._alphaMap._state.matrix){src.push("uniform mat4 alphaMapMatrix;");}}if(normals&&uvs&&material._specularMap){src.push("uniform sampler2D specularMap;");if(material._specularMap._state.matrix){src.push("uniform mat4 specularMapMatrix;");}}if(normals&&uvs&&material._glossinessMap){src.push("uniform sampler2D glossinessMap;");if(material._glossinessMap._state.matrix){src.push("uniform mat4 glossinessMapMatrix;");}}if(normals&&uvs&&material._specularGlossinessMap){src.push("uniform sampler2D materialSpecularGlossinessMap;");if(material._specularGlossinessMap._state.matrix){src.push("uniform mat4 materialSpecularGlossinessMapMatrix;");}}//--------------------------------------------------------------------------------
// MATERIAL FRESNEL INPUTS
//--------------------------------------------------------------------------------
if(normals&&(material._diffuseFresnel||material._specularFresnel||material._alphaFresnel||material._emissiveFresnel||material._reflectivityFresnel)){src.push("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {");src.push("    float fr = abs(dot(eyeDir, normal));");src.push("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");src.push("    return pow(finalFr, power);");src.push("}");if(material._diffuseFresnel){src.push("uniform float  diffuseFresnelCenterBias;");src.push("uniform float  diffuseFresnelEdgeBias;");src.push("uniform float  diffuseFresnelPower;");src.push("uniform vec3   diffuseFresnelCenterColor;");src.push("uniform vec3   diffuseFresnelEdgeColor;");}if(material._specularFresnel){src.push("uniform float  specularFresnelCenterBias;");src.push("uniform float  specularFresnelEdgeBias;");src.push("uniform float  specularFresnelPower;");src.push("uniform vec3   specularFresnelCenterColor;");src.push("uniform vec3   specularFresnelEdgeColor;");}if(material._alphaFresnel){src.push("uniform float  alphaFresnelCenterBias;");src.push("uniform float  alphaFresnelEdgeBias;");src.push("uniform float  alphaFresnelPower;");src.push("uniform vec3   alphaFresnelCenterColor;");src.push("uniform vec3   alphaFresnelEdgeColor;");}if(material._reflectivityFresnel){src.push("uniform float  materialSpecularF0FresnelCenterBias;");src.push("uniform float  materialSpecularF0FresnelEdgeBias;");src.push("uniform float  materialSpecularF0FresnelPower;");src.push("uniform vec3   materialSpecularF0FresnelCenterColor;");src.push("uniform vec3   materialSpecularF0FresnelEdgeColor;");}if(material._emissiveFresnel){src.push("uniform float  emissiveFresnelCenterBias;");src.push("uniform float  emissiveFresnelEdgeBias;");src.push("uniform float  emissiveFresnelPower;");src.push("uniform vec3   emissiveFresnelCenterColor;");src.push("uniform vec3   emissiveFresnelEdgeColor;");}}//--------------------------------------------------------------------------------
// LIGHT SOURCES
//--------------------------------------------------------------------------------
src.push("uniform vec4   lightAmbient;");if(normals){for(var _i102=0,len=lightsState.lights.length;_i102<len;_i102++){// Light sources
var light=lightsState.lights[_i102];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i102+";");if(light.type==="point"){src.push("uniform vec3 lightAttenuation"+_i102+";");}if(light.type==="dir"&&light.space==="view"){src.push("uniform vec3 lightDir"+_i102+";");}if(light.type==="point"&&light.space==="view"){src.push("uniform vec3 lightPos"+_i102+";");}else{src.push("in vec4 vViewLightReverseDirAndDist"+_i102+";");}}}if(receivesShadow){// Variance castsShadow mapping filter
// src.push("float linstep(float low, float high, float v){");
// src.push("      return clamp((v-low)/(high-low), 0.0, 1.0);");
// src.push("}");
//
// src.push("float VSM(sampler2D depths, vec2 uv, float compare){");
// src.push("      vec2 moments = texture(depths, uv).xy;");
// src.push("      float p = smoothstep(compare-0.02, compare, moments.x);");
// src.push("      float variance = max(moments.y - moments.x*moments.x, -0.001);");
// src.push("      float d = compare - moments.x;");
// src.push("      float p_max = linstep(0.2, 1.0, variance / (variance + d*d));");
// src.push("      return clamp(max(p, p_max), 0.0, 1.0);");
// src.push("}");
for(var _i103=0,_len13=lightsState.lights.length;_i103<_len13;_i103++){// Light sources
if(lightsState.lights[_i103].castsShadow){src.push("in vec4 vShadowPosFromLight"+_i103+";");src.push("uniform sampler2D shadowMap"+_i103+";");}}}src.push("uniform vec4 colorize;");//================================================================================
// MAIN
//================================================================================
src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(geometryState.primitiveName==="points"){src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}");}src.push("float occlusion = 1.0;");if(materialState.ambient){src.push("vec3 ambientColor = materialAmbient;");}else{src.push("vec3 ambientColor = vec3(1.0, 1.0, 1.0);");}if(materialState.diffuse){src.push("vec3 diffuseColor = materialDiffuse;");}else if(materialState.baseColor){src.push("vec3 diffuseColor = materialBaseColor;");}else{src.push("vec3 diffuseColor = vec3(1.0, 1.0, 1.0);");}if(geometryState.colors){src.push("diffuseColor *= vColor.rgb;");}if(materialState.emissive){src.push("vec3 emissiveColor = materialEmissive;");// Emissive default is (0,0,0), so initializing here
}else{src.push("vec3  emissiveColor = vec3(0.0, 0.0, 0.0);");}if(materialState.specular){src.push("vec3 specular = materialSpecular;");}else{src.push("vec3 specular = vec3(1.0, 1.0, 1.0);");}if(materialState.alpha!==undefined){src.push("float alpha = materialAlphaModeCutoff[0];");}else{src.push("float alpha = 1.0;");}if(geometryState.colors){src.push("alpha *= vColor.a;");}if(materialState.glossiness!==undefined){src.push("float glossiness = materialGlossiness;");}else{src.push("float glossiness = 1.0;");}if(materialState.metallic!==undefined){src.push("float metallic = materialMetallic;");}else{src.push("float metallic = 1.0;");}if(materialState.roughness!==undefined){src.push("float roughness = materialRoughness;");}else{src.push("float roughness = 1.0;");}if(materialState.specularF0!==undefined){src.push("float specularF0 = materialSpecularF0;");}else{src.push("float specularF0 = 1.0;");}//--------------------------------------------------------------------------------
// TEXTURING
//--------------------------------------------------------------------------------
if(uvs&&(normals&&material._normalMap||material._ambientMap||material._baseColorMap||material._diffuseMap||material._occlusionMap||material._emissiveMap||material._metallicMap||material._roughnessMap||material._metallicRoughnessMap||material._specularMap||material._glossinessMap||material._specularGlossinessMap||material._alphaMap)){src.push("vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);");src.push("vec2 textureCoord;");}if(uvs&&material._ambientMap){if(material._ambientMap._state.matrix){src.push("textureCoord = (ambientMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec4 ambientTexel = texture(ambientMap, textureCoord).rgb;");src.push("ambientTexel = "+TEXTURE_DECODE_FUNCS$1[material._ambientMap._state.encoding]+"(ambientTexel);");src.push("ambientColor *= ambientTexel.rgb;");}if(uvs&&material._diffuseMap){if(material._diffuseMap._state.matrix){src.push("textureCoord = (diffuseMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec4 diffuseTexel = texture(diffuseMap, textureCoord);");src.push("diffuseTexel = "+TEXTURE_DECODE_FUNCS$1[material._diffuseMap._state.encoding]+"(diffuseTexel);");src.push("diffuseColor *= diffuseTexel.rgb;");src.push("alpha *= diffuseTexel.a;");}if(uvs&&material._baseColorMap){if(material._baseColorMap._state.matrix){src.push("textureCoord = (baseColorMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec4 baseColorTexel = texture(baseColorMap, textureCoord);");src.push("baseColorTexel = "+TEXTURE_DECODE_FUNCS$1[material._baseColorMap._state.encoding]+"(baseColorTexel);");src.push("diffuseColor *= baseColorTexel.rgb;");src.push("alpha *= baseColorTexel.a;");}if(uvs&&material._emissiveMap){if(material._emissiveMap._state.matrix){src.push("textureCoord = (emissiveMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec4 emissiveTexel = texture(emissiveMap, textureCoord);");src.push("emissiveTexel = "+TEXTURE_DECODE_FUNCS$1[material._emissiveMap._state.encoding]+"(emissiveTexel);");src.push("emissiveColor = emissiveTexel.rgb;");}if(uvs&&material._alphaMap){if(material._alphaMap._state.matrix){src.push("textureCoord = (alphaMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("alpha *= texture(alphaMap, textureCoord).r;");}if(uvs&&material._occlusionMap){if(material._occlusionMap._state.matrix){src.push("textureCoord = (occlusionMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("occlusion *= texture(occlusionMap, textureCoord).r;");}if(normals&&(lightsState.lights.length>0||lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0)){//--------------------------------------------------------------------------------
// SHADING
//--------------------------------------------------------------------------------
if(uvs&&material._normalMap){if(material._normalMap._state.matrix){src.push("textureCoord = (normalMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition, normalize(vViewNormal), textureCoord );");}else{src.push("vec3 viewNormal = normalize(vViewNormal);");}if(uvs&&material._specularMap){if(material._specularMap._state.matrix){src.push("textureCoord = (specularMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("specular *= texture(specularMap, textureCoord).rgb;");}if(uvs&&material._glossinessMap){if(material._glossinessMap._state.matrix){src.push("textureCoord = (glossinessMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("glossiness *= texture(glossinessMap, textureCoord).r;");}if(uvs&&material._specularGlossinessMap){if(material._specularGlossinessMap._state.matrix){src.push("textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec4 specGlossRGB = texture(materialSpecularGlossinessMap, textureCoord).rgba;");// TODO: what if only RGB texture?
src.push("specular *= specGlossRGB.rgb;");src.push("glossiness *= specGlossRGB.a;");}if(uvs&&material._metallicMap){if(material._metallicMap._state.matrix){src.push("textureCoord = (metallicMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("metallic *= texture(metallicMap, textureCoord).r;");}if(uvs&&material._roughnessMap){if(material._roughnessMap._state.matrix){src.push("textureCoord = (roughnessMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("roughness *= texture(roughnessMap, textureCoord).r;");}if(uvs&&material._metallicRoughnessMap){if(material._metallicRoughnessMap._state.matrix){src.push("textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;");}else{src.push("textureCoord = texturePos.xy;");}src.push("vec3 metalRoughRGB = texture(metallicRoughnessMap, textureCoord).rgb;");src.push("metallic *= metalRoughRGB.b;");src.push("roughness *= metalRoughRGB.g;");}src.push("vec3 viewEyeDir = normalize(-vViewPosition);");if(material._diffuseFresnel){src.push("float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);");src.push("diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);");}if(material._specularFresnel){src.push("float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);");src.push("specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);");}if(material._alphaFresnel){src.push("float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);");src.push("alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);");}if(material._emissiveFresnel){src.push("float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);");src.push("emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);");}src.push("if (materialAlphaModeCutoff[1] == 1.0 && alpha < materialAlphaModeCutoff[2]) {");// ie. (alphaMode == "mask" && alpha < alphaCutoff)
src.push("   discard;");// TODO: Discard earlier within this shader?
src.push("}");// PREPARE INPUTS FOR SHADER FUNCTIONS
src.push("IncidentLight  light;");src.push("Material       material;");src.push("Geometry       geometry;");src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");src.push("vec3           viewLightDir;");if(phongMaterial){src.push("material.diffuseColor      = diffuseColor;");src.push("material.specularColor     = specular;");src.push("material.shine             = materialShininess;");}if(specularMaterial){src.push("float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);");// Energy conservation
src.push("material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;");src.push("material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );");src.push("material.specularColor     = specular;");}if(metallicMaterial){src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");src.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");src.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);");}src.push("geometry.position      = vViewPosition;");if(lightsState.lightMaps.length>0){src.push("geometry.worldNormal   = normalize(vWorldNormal);");}src.push("geometry.viewNormal    = viewNormal;");src.push("geometry.viewEyeDir    = viewEyeDir;");// ENVIRONMENT AND REFLECTION MAP SHADING
if(phongMaterial&&(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0)){src.push("computePhongLightMapping(geometry, material, reflectedLight);");}if((specularMaterial||metallicMaterial)&&(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0)){src.push("computePBRLightMapping(geometry, material, reflectedLight);");}// LIGHT SOURCE SHADING
src.push("float shadow = 1.0;");// if (receivesShadow) {
//
//     src.push("float lightDepth2 = clamp(length(lightPos)/40.0, 0.0, 1.0);");
//     src.push("float illuminated = VSM(sLightDepth, lightUV, lightDepth2);");
//
src.push("float shadowAcneRemover = 0.007;");src.push("vec3 fragmentDepth;");src.push("float texelSize = 1.0 / 1024.0;");src.push("float amountInLight = 0.0;");src.push("vec3 shadowCoord;");src.push('vec4 rgbaDepth;');src.push("float depth;");for(var _i104=0,_len14=lightsState.lights.length;_i104<_len14;_i104++){var _light2=lightsState.lights[_i104];if(_light2.type==="ambient"){continue;}if(_light2.type==="dir"&&_light2.space==="view"){src.push("viewLightDir = -normalize(lightDir"+_i104+");");}else if(_light2.type==="point"&&_light2.space==="view"){src.push("viewLightDir = normalize(lightPos"+_i104+" - vViewPosition);");//src.push("tmpVec3 = lightPos" + i + ".xyz - viewPosition.xyz;");
//src.push("lightDist = abs(length(tmpVec3));");
}else{src.push("viewLightDir = normalize(vViewLightReverseDirAndDist"+_i104+".xyz);");// If normal mapping, the fragment->light vector will be in tangent space
}if(receivesShadow&&_light2.castsShadow){// if (true) {
//     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');
//     src.push("lightDepth2 = clamp(length(vec3[0.0, 20.0, 20.0])/40.0, 0.0, 1.0);");
//     src.push("castsShadow *= VSM(shadowMap' + i + ', shadowCoord, lightDepth2);");
// }
//
// if (false) {
//
// PCF
src.push("shadow = 0.0;");src.push("fragmentDepth = vShadowPosFromLight"+_i104+".xyz;");src.push("fragmentDepth.z -= shadowAcneRemover;");src.push("for (int x = -3; x <= 3; x++) {");src.push("  for (int y = -3; y <= 3; y++) {");src.push("      float texelDepth = unpackDepth(texture(shadowMap"+_i104+", fragmentDepth.xy + vec2(x, y) * texelSize));");src.push("      if (fragmentDepth.z < texelDepth) {");src.push("          shadow += 1.0;");src.push("      }");src.push("  }");src.push("}");src.push("shadow = shadow / 9.0;");src.push("light.color =  lightColor"+_i104+".rgb * (lightColor"+_i104+".a * shadow);");// a is intensity
//
// }
//
// if (false){
//
//     src.push("shadow = 1.0;");
//
//     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');
//
//     src.push('shadow -= (shadowCoord.z > unpackDepth(texture(shadowMap' + i + ', shadowCoord.xy + vec2( -0.94201624, -0.39906216 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
//     src.push('shadow -= (shadowCoord.z > unpackDepth(texture(shadowMap' + i + ', shadowCoord.xy + vec2( 0.94558609, -0.76890725 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
//     src.push('shadow -= (shadowCoord.z > unpackDepth(texture(shadowMap' + i + ', shadowCoord.xy + vec2( -0.094184101, -0.92938870 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
//     src.push('shadow -= (shadowCoord.z > unpackDepth(texture(shadowMap' + i + ', shadowCoord.xy + vec2( 0.34495938, 0.29387760 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
//
//     src.push("light.color =  lightColor" + i + ".rgb * (lightColor" + i + ".a * shadow);");
// }
}else{src.push("light.color =  lightColor"+_i104+".rgb * (lightColor"+_i104+".a );");// a is intensity
}src.push("light.direction = viewLightDir;");if(phongMaterial){src.push("computePhongLighting(light, geometry, material, reflectedLight);");}if(specularMaterial||metallicMaterial){src.push("computePBRLighting(light, geometry, material, reflectedLight);");}}//src.push("reflectedLight.diffuse *= shadow;");
// COMBINE TERMS
if(phongMaterial){src.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * diffuseColor) + ((occlusion * (( reflectedLight.diffuse + reflectedLight.specular)))) + emissiveColor;");}else{src.push("vec3 outgoingLight = (occlusion * (reflectedLight.diffuse)) + (occlusion * reflectedLight.specular) + emissiveColor;");}}else{//--------------------------------------------------------------------------------
// NO SHADING - EMISSIVE and AMBIENT ONLY
//--------------------------------------------------------------------------------
src.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);");src.push("vec3 outgoingLight = emissiveColor + ambientColor;");}src.push("vec4 fragColor = vec4(outgoingLight, alpha) * colorize;");if(gammaOutput){src.push("fragColor = linearToGamma(fragColor, gammaFactor);");}src.push("outColor = fragColor;");if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}/**
 * @author xeolabs / https://github.com/xeolabs
 */var tempVec3a$I=math.vec3();var ids$2=new Map$1({});/**
 * @private
 */var DrawRenderer=function DrawRenderer(hash,mesh){this.id=ids$2.addItem({});this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new DrawShaderSource(mesh);this._allocate(mesh);};var drawRenderers={};DrawRenderer.get=function(mesh){var scene=mesh.scene;var hash=[scene.canvas.canvas.id,(scene.gammaInput?"gi;":";")+(scene.gammaOutput?"go":""),scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),mesh._geometry._state.hash,mesh._material._state.hash,mesh._state.drawHash].join(";");var renderer=drawRenderers[hash];if(!renderer){renderer=new DrawRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null;}drawRenderers[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};DrawRenderer.prototype.put=function(){if(--this._useCount===0){ids$2.removeItem(this.id);if(this._program){this._program.destroy();}delete drawRenderers[this._hash];stats.memory.programs--;}};DrawRenderer.prototype.webglContextRestored=function(){this._program=null;};DrawRenderer.prototype.drawMesh=function(frameCtx,mesh){if(!this._program){this._allocate(mesh);}var maxTextureUnits=WEBGL_INFO.MAX_TEXTURE_UNITS;var scene=mesh.scene;var material=mesh._material;var gl=scene.canvas.gl;var program=this._program;var meshState=mesh._state;var materialState=mesh._material._state;var geometryState=mesh._geometry._state;var camera=scene.camera;var origin=mesh.origin;var background=meshState.background;if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;if(background){gl.depthFunc(gl.LEQUAL);}this._bindProgram(frameCtx);}gl.uniformMatrix4fv(this._uViewMatrix,false,origin?frameCtx.getRTCViewMatrix(meshState.originHash,origin):camera.viewMatrix);gl.uniformMatrix4fv(this._uViewNormalMatrix,false,camera.viewNormalMatrix);if(meshState.clippable){var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var renderFlags=mesh.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$I);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}if(materialState.id!==this._lastMaterialId){frameCtx.textureUnit=this._baseTextureUnit;var backfaces=materialState.backfaces;if(frameCtx.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frameCtx.backfaces=backfaces;}var frontface=materialState.frontface;if(frameCtx.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW);}else{gl.frontFace(gl.CW);}frameCtx.frontface=frontface;}if(frameCtx.lineWidth!==materialState.lineWidth){gl.lineWidth(materialState.lineWidth);frameCtx.lineWidth=materialState.lineWidth;}if(this._uPointSize){gl.uniform1f(this._uPointSize,materialState.pointSize);}switch(materialState.type){case"LambertMaterial":if(this._uMaterialAmbient){gl.uniform3fv(this._uMaterialAmbient,materialState.ambient);}if(this._uMaterialColor){gl.uniform4f(this._uMaterialColor,materialState.color[0],materialState.color[1],materialState.color[2],materialState.alpha);}if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive);}break;case"PhongMaterial":if(this._uMaterialShininess){gl.uniform1f(this._uMaterialShininess,materialState.shininess);}if(this._uMaterialAmbient){gl.uniform3fv(this._uMaterialAmbient,materialState.ambient);}if(this._uMaterialDiffuse){gl.uniform3fv(this._uMaterialDiffuse,materialState.diffuse);}if(this._uMaterialSpecular){gl.uniform3fv(this._uMaterialSpecular,materialState.specular);}if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive);}if(this._uAlphaModeCutoff){gl.uniform4f(this._uAlphaModeCutoff,1.0*materialState.alpha,materialState.alphaMode===1?1.0:0.0,materialState.alphaCutoff,0);}if(material._ambientMap&&material._ambientMap._state.texture&&this._uMaterialAmbientMap){program.bindTexture(this._uMaterialAmbientMap,material._ambientMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uMaterialAmbientMapMatrix){gl.uniformMatrix4fv(this._uMaterialAmbientMapMatrix,false,material._ambientMap._state.matrix);}}if(material._diffuseMap&&material._diffuseMap._state.texture&&this._uDiffuseMap){program.bindTexture(this._uDiffuseMap,material._diffuseMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uDiffuseMapMatrix){gl.uniformMatrix4fv(this._uDiffuseMapMatrix,false,material._diffuseMap._state.matrix);}}if(material._specularMap&&material._specularMap._state.texture&&this._uSpecularMap){program.bindTexture(this._uSpecularMap,material._specularMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uSpecularMapMatrix){gl.uniformMatrix4fv(this._uSpecularMapMatrix,false,material._specularMap._state.matrix);}}if(material._emissiveMap&&material._emissiveMap._state.texture&&this._uEmissiveMap){program.bindTexture(this._uEmissiveMap,material._emissiveMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uEmissiveMapMatrix){gl.uniformMatrix4fv(this._uEmissiveMapMatrix,false,material._emissiveMap._state.matrix);}}if(material._alphaMap&&material._alphaMap._state.texture&&this._uAlphaMap){program.bindTexture(this._uAlphaMap,material._alphaMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uAlphaMapMatrix){gl.uniformMatrix4fv(this._uAlphaMapMatrix,false,material._alphaMap._state.matrix);}}if(material._reflectivityMap&&material._reflectivityMap._state.texture&&this._uReflectivityMap){program.bindTexture(this._uReflectivityMap,material._reflectivityMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;if(this._uReflectivityMapMatrix){gl.uniformMatrix4fv(this._uReflectivityMapMatrix,false,material._reflectivityMap._state.matrix);}}if(material._normalMap&&material._normalMap._state.texture&&this._uNormalMap){program.bindTexture(this._uNormalMap,material._normalMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uNormalMapMatrix){gl.uniformMatrix4fv(this._uNormalMapMatrix,false,material._normalMap._state.matrix);}}if(material._occlusionMap&&material._occlusionMap._state.texture&&this._uOcclusionMap){program.bindTexture(this._uOcclusionMap,material._occlusionMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uOcclusionMapMatrix){gl.uniformMatrix4fv(this._uOcclusionMapMatrix,false,material._occlusionMap._state.matrix);}}if(material._diffuseFresnel){if(this._uDiffuseFresnelEdgeBias){gl.uniform1f(this._uDiffuseFresnelEdgeBias,material._diffuseFresnel.edgeBias);}if(this._uDiffuseFresnelCenterBias){gl.uniform1f(this._uDiffuseFresnelCenterBias,material._diffuseFresnel.centerBias);}if(this._uDiffuseFresnelEdgeColor){gl.uniform3fv(this._uDiffuseFresnelEdgeColor,material._diffuseFresnel.edgeColor);}if(this._uDiffuseFresnelCenterColor){gl.uniform3fv(this._uDiffuseFresnelCenterColor,material._diffuseFresnel.centerColor);}if(this._uDiffuseFresnelPower){gl.uniform1f(this._uDiffuseFresnelPower,material._diffuseFresnel.power);}}if(material._specularFresnel){if(this._uSpecularFresnelEdgeBias){gl.uniform1f(this._uSpecularFresnelEdgeBias,material._specularFresnel.edgeBias);}if(this._uSpecularFresnelCenterBias){gl.uniform1f(this._uSpecularFresnelCenterBias,material._specularFresnel.centerBias);}if(this._uSpecularFresnelEdgeColor){gl.uniform3fv(this._uSpecularFresnelEdgeColor,material._specularFresnel.edgeColor);}if(this._uSpecularFresnelCenterColor){gl.uniform3fv(this._uSpecularFresnelCenterColor,material._specularFresnel.centerColor);}if(this._uSpecularFresnelPower){gl.uniform1f(this._uSpecularFresnelPower,material._specularFresnel.power);}}if(material._alphaFresnel){if(this._uAlphaFresnelEdgeBias){gl.uniform1f(this._uAlphaFresnelEdgeBias,material._alphaFresnel.edgeBias);}if(this._uAlphaFresnelCenterBias){gl.uniform1f(this._uAlphaFresnelCenterBias,material._alphaFresnel.centerBias);}if(this._uAlphaFresnelEdgeColor){gl.uniform3fv(this._uAlphaFresnelEdgeColor,material._alphaFresnel.edgeColor);}if(this._uAlphaFresnelCenterColor){gl.uniform3fv(this._uAlphaFresnelCenterColor,material._alphaFresnel.centerColor);}if(this._uAlphaFresnelPower){gl.uniform1f(this._uAlphaFresnelPower,material._alphaFresnel.power);}}if(material._reflectivityFresnel){if(this._uReflectivityFresnelEdgeBias){gl.uniform1f(this._uReflectivityFresnelEdgeBias,material._reflectivityFresnel.edgeBias);}if(this._uReflectivityFresnelCenterBias){gl.uniform1f(this._uReflectivityFresnelCenterBias,material._reflectivityFresnel.centerBias);}if(this._uReflectivityFresnelEdgeColor){gl.uniform3fv(this._uReflectivityFresnelEdgeColor,material._reflectivityFresnel.edgeColor);}if(this._uReflectivityFresnelCenterColor){gl.uniform3fv(this._uReflectivityFresnelCenterColor,material._reflectivityFresnel.centerColor);}if(this._uReflectivityFresnelPower){gl.uniform1f(this._uReflectivityFresnelPower,material._reflectivityFresnel.power);}}if(material._emissiveFresnel){if(this._uEmissiveFresnelEdgeBias){gl.uniform1f(this._uEmissiveFresnelEdgeBias,material._emissiveFresnel.edgeBias);}if(this._uEmissiveFresnelCenterBias){gl.uniform1f(this._uEmissiveFresnelCenterBias,material._emissiveFresnel.centerBias);}if(this._uEmissiveFresnelEdgeColor){gl.uniform3fv(this._uEmissiveFresnelEdgeColor,material._emissiveFresnel.edgeColor);}if(this._uEmissiveFresnelCenterColor){gl.uniform3fv(this._uEmissiveFresnelCenterColor,material._emissiveFresnel.centerColor);}if(this._uEmissiveFresnelPower){gl.uniform1f(this._uEmissiveFresnelPower,material._emissiveFresnel.power);}}break;case"MetallicMaterial":if(this._uBaseColor){gl.uniform3fv(this._uBaseColor,materialState.baseColor);}if(this._uMaterialMetallic){gl.uniform1f(this._uMaterialMetallic,materialState.metallic);}if(this._uMaterialRoughness){gl.uniform1f(this._uMaterialRoughness,materialState.roughness);}if(this._uMaterialSpecularF0){gl.uniform1f(this._uMaterialSpecularF0,materialState.specularF0);}if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive);}if(this._uAlphaModeCutoff){gl.uniform4f(this._uAlphaModeCutoff,1.0*materialState.alpha,materialState.alphaMode===1?1.0:0.0,materialState.alphaCutoff,0.0);}var baseColorMap=material._baseColorMap;if(baseColorMap&&baseColorMap._state.texture&&this._uBaseColorMap){program.bindTexture(this._uBaseColorMap,baseColorMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uBaseColorMapMatrix){gl.uniformMatrix4fv(this._uBaseColorMapMatrix,false,baseColorMap._state.matrix);}}var metallicMap=material._metallicMap;if(metallicMap&&metallicMap._state.texture&&this._uMetallicMap){program.bindTexture(this._uMetallicMap,metallicMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uMetallicMapMatrix){gl.uniformMatrix4fv(this._uMetallicMapMatrix,false,metallicMap._state.matrix);}}var roughnessMap=material._roughnessMap;if(roughnessMap&&roughnessMap._state.texture&&this._uRoughnessMap){program.bindTexture(this._uRoughnessMap,roughnessMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uRoughnessMapMatrix){gl.uniformMatrix4fv(this._uRoughnessMapMatrix,false,roughnessMap._state.matrix);}}var metallicRoughnessMap=material._metallicRoughnessMap;if(metallicRoughnessMap&&metallicRoughnessMap._state.texture&&this._uMetallicRoughnessMap){program.bindTexture(this._uMetallicRoughnessMap,metallicRoughnessMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uMetallicRoughnessMapMatrix){gl.uniformMatrix4fv(this._uMetallicRoughnessMapMatrix,false,metallicRoughnessMap._state.matrix);}}var emissiveMap=material._emissiveMap;if(emissiveMap&&emissiveMap._state.texture&&this._uEmissiveMap){program.bindTexture(this._uEmissiveMap,emissiveMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uEmissiveMapMatrix){gl.uniformMatrix4fv(this._uEmissiveMapMatrix,false,emissiveMap._state.matrix);}}var occlusionMap=material._occlusionMap;if(occlusionMap&&material._occlusionMap._state.texture&&this._uOcclusionMap){program.bindTexture(this._uOcclusionMap,occlusionMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uOcclusionMapMatrix){gl.uniformMatrix4fv(this._uOcclusionMapMatrix,false,occlusionMap._state.matrix);}}var alphaMap=material._alphaMap;if(alphaMap&&alphaMap._state.texture&&this._uAlphaMap){program.bindTexture(this._uAlphaMap,alphaMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uAlphaMapMatrix){gl.uniformMatrix4fv(this._uAlphaMapMatrix,false,alphaMap._state.matrix);}}var normalMap=material._normalMap;if(normalMap&&normalMap._state.texture&&this._uNormalMap){program.bindTexture(this._uNormalMap,normalMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uNormalMapMatrix){gl.uniformMatrix4fv(this._uNormalMapMatrix,false,normalMap._state.matrix);}}break;case"SpecularMaterial":if(this._uMaterialDiffuse){gl.uniform3fv(this._uMaterialDiffuse,materialState.diffuse);}if(this._uMaterialSpecular){gl.uniform3fv(this._uMaterialSpecular,materialState.specular);}if(this._uMaterialGlossiness){gl.uniform1f(this._uMaterialGlossiness,materialState.glossiness);}if(this._uMaterialReflectivity){gl.uniform1f(this._uMaterialReflectivity,materialState.reflectivity);}if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive);}if(this._uAlphaModeCutoff){gl.uniform4f(this._uAlphaModeCutoff,1.0*materialState.alpha,materialState.alphaMode===1?1.0:0.0,materialState.alphaCutoff,0.0);}var diffuseMap=material._diffuseMap;if(diffuseMap&&diffuseMap._state.texture&&this._uDiffuseMap){program.bindTexture(this._uDiffuseMap,diffuseMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uDiffuseMapMatrix){gl.uniformMatrix4fv(this._uDiffuseMapMatrix,false,diffuseMap._state.matrix);}}var specularMap=material._specularMap;if(specularMap&&specularMap._state.texture&&this._uSpecularMap){program.bindTexture(this._uSpecularMap,specularMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uSpecularMapMatrix){gl.uniformMatrix4fv(this._uSpecularMapMatrix,false,specularMap._state.matrix);}}var glossinessMap=material._glossinessMap;if(glossinessMap&&glossinessMap._state.texture&&this._uGlossinessMap){program.bindTexture(this._uGlossinessMap,glossinessMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uGlossinessMapMatrix){gl.uniformMatrix4fv(this._uGlossinessMapMatrix,false,glossinessMap._state.matrix);}}var specularGlossinessMap=material._specularGlossinessMap;if(specularGlossinessMap&&specularGlossinessMap._state.texture&&this._uSpecularGlossinessMap){program.bindTexture(this._uSpecularGlossinessMap,specularGlossinessMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uSpecularGlossinessMapMatrix){gl.uniformMatrix4fv(this._uSpecularGlossinessMapMatrix,false,specularGlossinessMap._state.matrix);}}var emissiveMap=material._emissiveMap;if(emissiveMap&&emissiveMap._state.texture&&this._uEmissiveMap){program.bindTexture(this._uEmissiveMap,emissiveMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uEmissiveMapMatrix){gl.uniformMatrix4fv(this._uEmissiveMapMatrix,false,emissiveMap._state.matrix);}}var occlusionMap=material._occlusionMap;if(occlusionMap&&occlusionMap._state.texture&&this._uOcclusionMap){program.bindTexture(this._uOcclusionMap,occlusionMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uOcclusionMapMatrix){gl.uniformMatrix4fv(this._uOcclusionMapMatrix,false,occlusionMap._state.matrix);}}var alphaMap=material._alphaMap;if(alphaMap&&alphaMap._state.texture&&this._uAlphaMap){program.bindTexture(this._uAlphaMap,alphaMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uAlphaMapMatrix){gl.uniformMatrix4fv(this._uAlphaMapMatrix,false,alphaMap._state.matrix);}}var normalMap=material._normalMap;if(normalMap&&normalMap._state.texture&&this._uNormalMap){program.bindTexture(this._uNormalMap,normalMap._state.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;if(this._uNormalMapMatrix){gl.uniformMatrix4fv(this._uNormalMapMatrix,false,normalMap._state.matrix);}}break;}this._lastMaterialId=materialState.id;}gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix);}if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable);}if(this._uColorize){var colorize=meshState.colorize;var lastColorize=this._lastColorize;if(lastColorize[0]!==colorize[0]||lastColorize[1]!==colorize[1]||lastColorize[2]!==colorize[2]||lastColorize[3]!==colorize[3]){gl.uniform4fv(this._uColorize,colorize);lastColorize[0]=colorize[0];lastColorize[1]=colorize[1];lastColorize[2]=colorize[2];lastColorize[3]=colorize[3];}}gl.uniform3fv(this._uOffset,meshState.offset);// Bind VBOs
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);}if(this._uUVDecodeMatrix){gl.uniformMatrix3fv(this._uUVDecodeMatrix,false,geometryState.uvDecodeMatrix);}if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf);frameCtx.bindArray++;}if(this._aNormal){this._aNormal.bindArrayBuffer(geometryState.normalsBuf);frameCtx.bindArray++;}if(this._aUV){this._aUV.bindArrayBuffer(geometryState.uvBuf);frameCtx.bindArray++;}if(this._aColor){this._aColor.bindArrayBuffer(geometryState.colorsBuf);frameCtx.bindArray++;}if(this._aFlags){this._aFlags.bindArrayBuffer(geometryState.flagsBuf);frameCtx.bindArray++;}if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frameCtx.bindArray++;}this._lastGeometryId=geometryState.id;}// Draw (indices bound in prev step)
if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frameCtx.drawElements++;}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);frameCtx.drawArrays++;}if(background){gl.depthFunc(gl.LESS);}};DrawRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var gl=scene.canvas.gl;var material=mesh._material;var lightsState=scene._lightsState;var sectionPlanesState=scene._sectionPlanesState;var materialState=mesh._material._state;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uUVDecodeMatrix=program.getLocation("uvDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uModelNormalMatrix=program.getLocation("modelNormalMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uViewNormalMatrix=program.getLocation("viewNormalMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uGammaFactor=program.getLocation("gammaFactor");this._uLightAmbient=[];this._uLightColor=[];this._uLightDir=[];this._uLightPos=[];this._uLightAttenuation=[];this._uShadowViewMatrix=[];this._uShadowProjMatrix=[];if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}var lights=lightsState.lights;var light;for(var i=0,len=lights.length;i<len;i++){light=lights[i];switch(light.type){case"ambient":this._uLightAmbient[i]=program.getLocation("lightAmbient");break;case"dir":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=null;this._uLightDir[i]=program.getLocation("lightDir"+i);break;case"point":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=program.getLocation("lightPos"+i);this._uLightDir[i]=null;this._uLightAttenuation[i]=program.getLocation("lightAttenuation"+i);break;case"spot":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=program.getLocation("lightPos"+i);this._uLightDir[i]=program.getLocation("lightDir"+i);this._uLightAttenuation[i]=program.getLocation("lightAttenuation"+i);break;}if(light.castsShadow){this._uShadowViewMatrix[i]=program.getLocation("shadowViewMatrix"+i);this._uShadowProjMatrix[i]=program.getLocation("shadowProjMatrix"+i);}}if(lightsState.lightMaps.length>0){this._uLightMap="lightMap";}if(lightsState.reflectionMaps.length>0){this._uReflectionMap="reflectionMap";}this._uSectionPlanes=[];var sectionPlanes=sectionPlanesState.sectionPlanes;for(var i=0,len=sectionPlanes.length;i<len;i++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+i),pos:program.getLocation("sectionPlanePos"+i),dir:program.getLocation("sectionPlaneDir"+i)});}this._uPointSize=program.getLocation("pointSize");switch(materialState.type){case"LambertMaterial":this._uMaterialColor=program.getLocation("materialColor");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");break;case"PhongMaterial":this._uMaterialAmbient=program.getLocation("materialAmbient");this._uMaterialDiffuse=program.getLocation("materialDiffuse");this._uMaterialSpecular=program.getLocation("materialSpecular");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");this._uMaterialShininess=program.getLocation("materialShininess");if(material._ambientMap){this._uMaterialAmbientMap="ambientMap";this._uMaterialAmbientMapMatrix=program.getLocation("ambientMapMatrix");}if(material._diffuseMap){this._uDiffuseMap="diffuseMap";this._uDiffuseMapMatrix=program.getLocation("diffuseMapMatrix");}if(material._specularMap){this._uSpecularMap="specularMap";this._uSpecularMapMatrix=program.getLocation("specularMapMatrix");}if(material._emissiveMap){this._uEmissiveMap="emissiveMap";this._uEmissiveMapMatrix=program.getLocation("emissiveMapMatrix");}if(material._alphaMap){this._uAlphaMap="alphaMap";this._uAlphaMapMatrix=program.getLocation("alphaMapMatrix");}if(material._reflectivityMap){this._uReflectivityMap="reflectivityMap";this._uReflectivityMapMatrix=program.getLocation("reflectivityMapMatrix");}if(material._normalMap){this._uNormalMap="normalMap";this._uNormalMapMatrix=program.getLocation("normalMapMatrix");}if(material._occlusionMap){this._uOcclusionMap="occlusionMap";this._uOcclusionMapMatrix=program.getLocation("occlusionMapMatrix");}if(material._diffuseFresnel){this._uDiffuseFresnelEdgeBias=program.getLocation("diffuseFresnelEdgeBias");this._uDiffuseFresnelCenterBias=program.getLocation("diffuseFresnelCenterBias");this._uDiffuseFresnelEdgeColor=program.getLocation("diffuseFresnelEdgeColor");this._uDiffuseFresnelCenterColor=program.getLocation("diffuseFresnelCenterColor");this._uDiffuseFresnelPower=program.getLocation("diffuseFresnelPower");}if(material._specularFresnel){this._uSpecularFresnelEdgeBias=program.getLocation("specularFresnelEdgeBias");this._uSpecularFresnelCenterBias=program.getLocation("specularFresnelCenterBias");this._uSpecularFresnelEdgeColor=program.getLocation("specularFresnelEdgeColor");this._uSpecularFresnelCenterColor=program.getLocation("specularFresnelCenterColor");this._uSpecularFresnelPower=program.getLocation("specularFresnelPower");}if(material._alphaFresnel){this._uAlphaFresnelEdgeBias=program.getLocation("alphaFresnelEdgeBias");this._uAlphaFresnelCenterBias=program.getLocation("alphaFresnelCenterBias");this._uAlphaFresnelEdgeColor=program.getLocation("alphaFresnelEdgeColor");this._uAlphaFresnelCenterColor=program.getLocation("alphaFresnelCenterColor");this._uAlphaFresnelPower=program.getLocation("alphaFresnelPower");}if(material._reflectivityFresnel){this._uReflectivityFresnelEdgeBias=program.getLocation("reflectivityFresnelEdgeBias");this._uReflectivityFresnelCenterBias=program.getLocation("reflectivityFresnelCenterBias");this._uReflectivityFresnelEdgeColor=program.getLocation("reflectivityFresnelEdgeColor");this._uReflectivityFresnelCenterColor=program.getLocation("reflectivityFresnelCenterColor");this._uReflectivityFresnelPower=program.getLocation("reflectivityFresnelPower");}if(material._emissiveFresnel){this._uEmissiveFresnelEdgeBias=program.getLocation("emissiveFresnelEdgeBias");this._uEmissiveFresnelCenterBias=program.getLocation("emissiveFresnelCenterBias");this._uEmissiveFresnelEdgeColor=program.getLocation("emissiveFresnelEdgeColor");this._uEmissiveFresnelCenterColor=program.getLocation("emissiveFresnelCenterColor");this._uEmissiveFresnelPower=program.getLocation("emissiveFresnelPower");}break;case"MetallicMaterial":this._uBaseColor=program.getLocation("materialBaseColor");this._uMaterialMetallic=program.getLocation("materialMetallic");this._uMaterialRoughness=program.getLocation("materialRoughness");this._uMaterialSpecularF0=program.getLocation("materialSpecularF0");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");if(material._baseColorMap){this._uBaseColorMap="baseColorMap";this._uBaseColorMapMatrix=program.getLocation("baseColorMapMatrix");}if(material._metallicMap){this._uMetallicMap="metallicMap";this._uMetallicMapMatrix=program.getLocation("metallicMapMatrix");}if(material._roughnessMap){this._uRoughnessMap="roughnessMap";this._uRoughnessMapMatrix=program.getLocation("roughnessMapMatrix");}if(material._metallicRoughnessMap){this._uMetallicRoughnessMap="metallicRoughnessMap";this._uMetallicRoughnessMapMatrix=program.getLocation("metallicRoughnessMapMatrix");}if(material._emissiveMap){this._uEmissiveMap="emissiveMap";this._uEmissiveMapMatrix=program.getLocation("emissiveMapMatrix");}if(material._occlusionMap){this._uOcclusionMap="occlusionMap";this._uOcclusionMapMatrix=program.getLocation("occlusionMapMatrix");}if(material._alphaMap){this._uAlphaMap="alphaMap";this._uAlphaMapMatrix=program.getLocation("alphaMapMatrix");}if(material._normalMap){this._uNormalMap="normalMap";this._uNormalMapMatrix=program.getLocation("normalMapMatrix");}break;case"SpecularMaterial":this._uMaterialDiffuse=program.getLocation("materialDiffuse");this._uMaterialSpecular=program.getLocation("materialSpecular");this._uMaterialGlossiness=program.getLocation("materialGlossiness");this._uMaterialReflectivity=program.getLocation("reflectivityFresnel");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");if(material._diffuseMap){this._uDiffuseMap="diffuseMap";this._uDiffuseMapMatrix=program.getLocation("diffuseMapMatrix");}if(material._specularMap){this._uSpecularMap="specularMap";this._uSpecularMapMatrix=program.getLocation("specularMapMatrix");}if(material._glossinessMap){this._uGlossinessMap="glossinessMap";this._uGlossinessMapMatrix=program.getLocation("glossinessMapMatrix");}if(material._specularGlossinessMap){this._uSpecularGlossinessMap="materialSpecularGlossinessMap";this._uSpecularGlossinessMapMatrix=program.getLocation("materialSpecularGlossinessMapMatrix");}if(material._emissiveMap){this._uEmissiveMap="emissiveMap";this._uEmissiveMapMatrix=program.getLocation("emissiveMapMatrix");}if(material._occlusionMap){this._uOcclusionMap="occlusionMap";this._uOcclusionMapMatrix=program.getLocation("occlusionMapMatrix");}if(material._alphaMap){this._uAlphaMap="alphaMap";this._uAlphaMapMatrix=program.getLocation("alphaMapMatrix");}if(material._normalMap){this._uNormalMap="normalMap";this._uNormalMapMatrix=program.getLocation("normalMapMatrix");}break;}this._aPosition=program.getAttribute("position");this._aNormal=program.getAttribute("normal");this._aUV=program.getAttribute("uv");this._aColor=program.getAttribute("color");this._aFlags=program.getAttribute("flags");this._uClippable=program.getLocation("clippable");this._uColorize=program.getLocation("colorize");this._uOffset=program.getLocation("offset");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;this._lastColorize=new Float32Array(4);this._baseTextureUnit=0;};DrawRenderer.prototype._bindProgram=function(frameCtx){var maxTextureUnits=WEBGL_INFO.MAX_TEXTURE_UNITS;var scene=this._scene;var gl=scene.canvas.gl;var lightsState=scene._lightsState;var project=scene.camera.project;var light;var program=this._program;program.bind();frameCtx.useProgram++;frameCtx.textureUnit=0;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;this._lastColorize[0]=-1;this._lastColorize[1]=-1;this._lastColorize[2]=-1;this._lastColorize[3]=-1;gl.uniformMatrix4fv(this._uProjMatrix,false,project.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}for(var i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(this._uLightAmbient[i]){gl.uniform4f(this._uLightAmbient[i],light.color[0],light.color[1],light.color[2],light.intensity);}else{if(this._uLightColor[i]){gl.uniform4f(this._uLightColor[i],light.color[0],light.color[1],light.color[2],light.intensity);}if(this._uLightPos[i]){gl.uniform3fv(this._uLightPos[i],light.pos);if(this._uLightAttenuation[i]){gl.uniform1f(this._uLightAttenuation[i],light.attenuation);}}if(this._uLightDir[i]){gl.uniform3fv(this._uLightDir[i],light.dir);}if(light.castsShadow){if(this._uShadowViewMatrix[i]){gl.uniformMatrix4fv(this._uShadowViewMatrix[i],false,light.getShadowViewMatrix());}if(this._uShadowProjMatrix[i]){gl.uniformMatrix4fv(this._uShadowProjMatrix[i],false,light.getShadowProjMatrix());}var shadowRenderBuf=light.getShadowRenderBuf();if(shadowRenderBuf){program.bindTexture("shadowMap"+i,shadowRenderBuf.getTexture(),frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;}}}}if(lightsState.lightMaps.length>0&&lightsState.lightMaps[0].texture&&this._uLightMap){program.bindTexture(this._uLightMap,lightsState.lightMaps[0].texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;}if(lightsState.reflectionMaps.length>0&&lightsState.reflectionMaps[0].texture&&this._uReflectionMap){program.bindTexture(this._uReflectionMap,lightsState.reflectionMaps[0].texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;}if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor);}this._baseTextureUnit=frameCtx.textureUnit;};/**
 * @private
 */var EmphasisFillShaderSource=/*#__PURE__*/_createClass(function EmphasisFillShaderSource(mesh){_classCallCheck(this,EmphasisFillShaderSource);this.vertex=buildVertex$5(mesh);this.fragment=buildFragment$5(mesh);});function buildVertex$5(mesh){var scene=mesh.scene;var lightsState=scene._lightsState;var normals=hasNormals(mesh);var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var quantizedGeometry=!!mesh._geometry._state.compressGeometry;var billboard=mesh._state.billboard;var stationary=mesh._state.stationary;var src=[];src.push("#version 300 es");src.push("// EmphasisFillShaderSource vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 colorize;");src.push("uniform vec3 offset;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");}src.push("uniform vec4   lightAmbient;");src.push("uniform vec4   fillColor;");if(normals){src.push("in vec3 normal;");src.push("uniform mat4 modelNormalMatrix;");src.push("uniform mat4 viewNormalMatrix;");for(var _i105=0,len=lightsState.lights.length;_i105<len;_i105++){var light=lightsState.lights[_i105];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i105+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i105+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i105+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i105+";");}}if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");}}src.push("out vec4 vColor;");if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;");}src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}");}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}if(normals){if(quantizedGeometry){src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");}else{src.push("vec4 localNormal = vec4(normal, 0.0); ");}src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;");}src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");if(normals){src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");src.push("billboard(modelNormalMatrix2);");src.push("billboard(viewNormalMatrix2);");src.push("billboard(modelViewNormalMatrix);");}src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;");}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");}if(normals){src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);");}src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");if(normals){for(var _i106=0,_len15=lightsState.lights.length;_i106<_len15;_i106++){var _light3=lightsState.lights[_i106];if(_light3.type==="ambient"){continue;}if(_light3.type==="dir"){if(_light3.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i106+");");}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir"+_i106+", 0.0)).xyz);");}}else if(_light3.type==="point"){if(_light3.space==="view"){src.push("viewLightDir = normalize(lightPos"+_i106+" - viewPosition.xyz);");}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos"+_i106+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+_i106+".rgb * lightColor"+_i106+".a);");}}// TODO: A blending mode for emphasis materials, to select add/multiply/mix
//src.push("vColor = vec4((mix(reflectedColor, fillColor.rgb, 0.7)), fillColor.a);");
src.push("vColor = vec4(reflectedColor * fillColor.rgb, fillColor.a);");//src.push("vColor = vec4(reflectedColor + fillColor.rgb, fillColor.a);");
if(clipping){src.push("vWorldPosition = worldPosition;");}if(mesh._geometry._state.primitiveName==="points"){src.push("gl_PointSize = pointSize;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");return src;}function hasNormals(mesh){var primitive=mesh._geometry._state.primitiveName;if((mesh._geometry._state.autoVertexNormals||mesh._geometry._state.normalsBuf)&&(primitive==="triangles"||primitive==="triangle-strip"||primitive==="triangle-fan")){return true;}return false;}function buildFragment$5(mesh){var scene=mesh.scene;var sectionPlanesState=mesh.scene._sectionPlanesState;var gammaOutput=mesh.scene.gammaOutput;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Lambertian drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(gammaOutput){src.push("uniform float gammaFactor;");src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("uniform bool clippable;");for(var _i107=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i107<len;_i107++){src.push("uniform bool sectionPlaneActive"+_i107+";");src.push("uniform vec3 sectionPlanePos"+_i107+";");src.push("uniform vec3 sectionPlaneDir"+_i107+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var _i108=0,_len16=sectionPlanesState.getNumAllocatedSectionPlanes();_i108<_len16;_i108++){src.push("if (sectionPlaneActive"+_i108+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i108+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i108+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(mesh._geometry._state.primitiveName==="points"){src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}if(gammaOutput){src.push("outColor = linearToGamma(vColor, gammaFactor);");}else{src.push("outColor = vColor;");}src.push("}");return src;}/**
 * @author xeolabs / https://github.com/xeolabs
 */var ids$1=new Map$1({});var tempVec3a$H=math.vec3();/**
 * @private
 */var EmphasisFillRenderer=function EmphasisFillRenderer(hash,mesh){this.id=ids$1.addItem({});this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new EmphasisFillShaderSource(mesh);this._allocate(mesh);};var xrayFillRenderers={};EmphasisFillRenderer.get=function(mesh){var hash=[mesh.scene.id,mesh.scene.gammaOutput?"go":"",// Gamma input not needed
mesh.scene._sectionPlanesState.getHash(),!!mesh._geometry._state.normalsBuf?"n":"",mesh._geometry._state.compressGeometry?"cp":"",mesh._state.hash].join(";");var renderer=xrayFillRenderers[hash];if(!renderer){renderer=new EmphasisFillRenderer(hash,mesh);xrayFillRenderers[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};EmphasisFillRenderer.prototype.put=function(){if(--this._useCount===0){ids$1.removeItem(this.id);if(this._program){this._program.destroy();}delete xrayFillRenderers[this._hash];stats.memory.programs--;}};EmphasisFillRenderer.prototype.webglContextRestored=function(){this._program=null;};EmphasisFillRenderer.prototype.drawMesh=function(frameCtx,mesh,mode){if(!this._program){this._allocate(mesh);}var scene=this._scene;var camera=scene.camera;var gl=scene.canvas.gl;var materialState=mode===0?mesh._xrayMaterial._state:mode===1?mesh._highlightMaterial._state:mesh._selectedMaterial._state;var meshState=mesh._state;var geometryState=mesh._geometry._state;var origin=mesh.origin;if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx);}gl.uniformMatrix4fv(this._uViewMatrix,false,origin?frameCtx.getRTCViewMatrix(meshState.originHash,origin):camera.viewMatrix);gl.uniformMatrix4fv(this._uViewNormalMatrix,false,camera.viewNormalMatrix);if(meshState.clippable){var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var renderFlags=mesh.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$H);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}if(materialState.id!==this._lastMaterialId){var fillColor=materialState.fillColor;var backfaces=materialState.backfaces;if(frameCtx.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frameCtx.backfaces=backfaces;}gl.uniform4f(this._uFillColor,fillColor[0],fillColor[1],fillColor[2],materialState.fillAlpha);this._lastMaterialId=materialState.id;}gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix);}if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable);}gl.uniform3fv(this._uOffset,meshState.offset);// Bind VBOs
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);}if(this._uUVDecodeMatrix){gl.uniformMatrix3fv(this._uUVDecodeMatrix,false,geometryState.uvDecodeMatrix);}if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf);frameCtx.bindArray++;}if(this._aNormal){this._aNormal.bindArrayBuffer(geometryState.normalsBuf);frameCtx.bindArray++;}if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frameCtx.bindArray++;// gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
// frameCtx.drawElements++;
}else if(geometryState.positionsBuf);this._lastGeometryId=geometryState.id;}if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frameCtx.drawElements++;}else if(geometryState.positionsBuf){gl.drawArrays(gl.TRIANGLES,0,geometryState.positionsBuf.numItems);frameCtx.drawArrays++;}};EmphasisFillRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var lightsState=scene._lightsState;var sectionPlanesState=scene._sectionPlanesState;var gl=scene.canvas.gl;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uModelNormalMatrix=program.getLocation("modelNormalMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uViewNormalMatrix=program.getLocation("viewNormalMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uLightAmbient=[];this._uLightColor=[];this._uLightDir=[];this._uLightPos=[];this._uLightAttenuation=[];for(var _i109=0,len=lightsState.lights.length;_i109<len;_i109++){var light=lightsState.lights[_i109];switch(light.type){case"ambient":this._uLightAmbient[_i109]=program.getLocation("lightAmbient");break;case"dir":this._uLightColor[_i109]=program.getLocation("lightColor"+_i109);this._uLightPos[_i109]=null;this._uLightDir[_i109]=program.getLocation("lightDir"+_i109);break;case"point":this._uLightColor[_i109]=program.getLocation("lightColor"+_i109);this._uLightPos[_i109]=program.getLocation("lightPos"+_i109);this._uLightDir[_i109]=null;this._uLightAttenuation[_i109]=program.getLocation("lightAttenuation"+_i109);break;}}this._uSectionPlanes=[];for(var _i110=0,_len17=sectionPlanesState.getNumAllocatedSectionPlanes();_i110<_len17;_i110++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i110),pos:program.getLocation("sectionPlanePos"+_i110),dir:program.getLocation("sectionPlaneDir"+_i110)});}this._uFillColor=program.getLocation("fillColor");this._aPosition=program.getAttribute("position");this._aNormal=program.getAttribute("normal");this._uClippable=program.getLocation("clippable");this._uGammaFactor=program.getLocation("gammaFactor");this._uOffset=program.getLocation("offset");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;};EmphasisFillRenderer.prototype._bindProgram=function(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var lightsState=scene._lightsState;var camera=scene.camera;var project=camera.project;var program=this._program;program.bind();frameCtx.useProgram++;frameCtx.textureUnit=0;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;this._lastIndicesBufId=null;gl.uniformMatrix4fv(this._uViewNormalMatrix,false,camera.normalMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,project.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}for(var _i111=0,len=lightsState.lights.length;_i111<len;_i111++){var light=lightsState.lights[_i111];if(this._uLightAmbient[_i111]){gl.uniform4f(this._uLightAmbient[_i111],light.color[0],light.color[1],light.color[2],light.intensity);}else{if(this._uLightColor[_i111]){gl.uniform4f(this._uLightColor[_i111],light.color[0],light.color[1],light.color[2],light.intensity);}if(this._uLightPos[_i111]){gl.uniform3fv(this._uLightPos[_i111],light.pos);if(this._uLightAttenuation[_i111]){gl.uniform1f(this._uLightAttenuation[_i111],light.attenuation);}}if(this._uLightDir[_i111]){gl.uniform3fv(this._uLightDir[_i111],light.dir);}}}if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor);}};/**
 * @private
 */var EmphasisEdgesShaderSource=/*#__PURE__*/_createClass(function EmphasisEdgesShaderSource(mesh){_classCallCheck(this,EmphasisEdgesShaderSource);this.vertex=buildVertex$4(mesh);this.fragment=buildFragment$4(mesh);});function buildVertex$4(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var quantizedGeometry=!!mesh._geometry._state.compressGeometry;var billboard=mesh._state.billboard;var stationary=mesh._state.stationary;var src=[];src.push("#version 300 es");src.push("// Edges drawing vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 edgeColor;");src.push("uniform vec3 offset;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");}src.push("out vec4 vColor;");if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;");}src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}");}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;");}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");}src.push("vColor = edgeColor;");if(clipping){src.push("vWorldPosition = worldPosition;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");return src;}function buildFragment$4(mesh){var scene=mesh.scene;var sectionPlanesState=mesh.scene._sectionPlanesState;var gammaOutput=mesh.scene.gammaOutput;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Edges drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(gammaOutput){src.push("uniform float gammaFactor;");src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("uniform bool clippable;");for(var _i112=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i112<len;_i112++){src.push("uniform bool sectionPlaneActive"+_i112+";");src.push("uniform vec3 sectionPlanePos"+_i112+";");src.push("uniform vec3 sectionPlaneDir"+_i112+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var _i113=0,_len18=sectionPlanesState.getNumAllocatedSectionPlanes();_i113<_len18;_i113++){src.push("if (sectionPlaneActive"+_i113+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i113+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i113+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}if(gammaOutput){src.push("outColor = linearToGamma(vColor, gammaFactor);");}else{src.push("outColor = vColor;");}src.push("}");return src;}/**
 * @author xeolabs / https://github.com/xeolabs
 */var ids=new Map$1({});var tempVec3a$G=math.vec3();/**
 * @private
 */var EmphasisEdgesRenderer=function EmphasisEdgesRenderer(hash,mesh){this.id=ids.addItem({});this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new EmphasisEdgesShaderSource(mesh);this._allocate(mesh);};var renderers$4={};EmphasisEdgesRenderer.get=function(mesh){var hash=[mesh.scene.id,mesh.scene.gammaOutput?"go":"",// Gamma input not needed
mesh.scene._sectionPlanesState.getHash(),mesh._geometry._state.compressGeometry?"cp":"",mesh._state.hash].join(";");var renderer=renderers$4[hash];if(!renderer){renderer=new EmphasisEdgesRenderer(hash,mesh);renderers$4[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};EmphasisEdgesRenderer.prototype.put=function(){if(--this._useCount===0){ids.removeItem(this.id);if(this._program){this._program.destroy();}delete renderers$4[this._hash];stats.memory.programs--;}};EmphasisEdgesRenderer.prototype.webglContextRestored=function(){this._program=null;};EmphasisEdgesRenderer.prototype.drawMesh=function(frameCtx,mesh,mode){if(!this._program){this._allocate(mesh);}var scene=this._scene;var camera=scene.camera;var gl=scene.canvas.gl;var materialState;var meshState=mesh._state;var geometry=mesh._geometry;var geometryState=geometry._state;var origin=mesh.origin;if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx);}gl.uniformMatrix4fv(this._uViewMatrix,false,origin?frameCtx.getRTCViewMatrix(meshState.originHash,origin):camera.viewMatrix);if(meshState.clippable){var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var renderFlags=mesh.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$G);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}switch(mode){case 0:materialState=mesh._xrayMaterial._state;break;case 1:materialState=mesh._highlightMaterial._state;break;case 2:materialState=mesh._selectedMaterial._state;break;case 3:default:materialState=mesh._edgeMaterial._state;break;}if(materialState.id!==this._lastMaterialId){var backfaces=materialState.backfaces;if(frameCtx.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frameCtx.backfaces=backfaces;}if(frameCtx.lineWidth!==materialState.edgeWidth){gl.lineWidth(materialState.edgeWidth);frameCtx.lineWidth=materialState.edgeWidth;}if(this._uEdgeColor){var edgeColor=materialState.edgeColor;var edgeAlpha=materialState.edgeAlpha;gl.uniform4f(this._uEdgeColor,edgeColor[0],edgeColor[1],edgeColor[2],edgeAlpha);}this._lastMaterialId=materialState.id;}gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable);}gl.uniform3fv(this._uOffset,meshState.offset);// Bind VBOs
var indicesBuf;if(geometryState.primitive===gl.TRIANGLES){indicesBuf=geometry._getEdgeIndices();}else if(geometryState.primitive===gl.LINES){indicesBuf=geometryState.indicesBuf;}if(indicesBuf){if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);}if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.compressGeometry?gl.UNSIGNED_SHORT:gl.FLOAT);frameCtx.bindArray++;}indicesBuf.bind();frameCtx.bindArray++;this._lastGeometryId=geometryState.id;}gl.drawElements(gl.LINES,indicesBuf.numItems,indicesBuf.itemType,0);frameCtx.drawElements++;}};EmphasisEdgesRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var gl=scene.canvas.gl;var sectionPlanesState=scene._sectionPlanesState;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i114=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i114<len;_i114++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i114),pos:program.getLocation("sectionPlanePos"+_i114),dir:program.getLocation("sectionPlaneDir"+_i114)});}this._uEdgeColor=program.getLocation("edgeColor");this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uGammaFactor=program.getLocation("gammaFactor");this._uOffset=program.getLocation("offset");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;};EmphasisEdgesRenderer.prototype._bindProgram=function(frameCtx){var program=this._program;var scene=this._scene;var gl=scene.canvas.gl;var camera=scene.camera;var project=camera.project;program.bind();frameCtx.useProgram++;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;gl.uniformMatrix4fv(this._uProjMatrix,false,project.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor);}};/**
 * @author xeolabs / https://github.com/xeolabs
 */ /**
 * @private
 */var PickMeshShaderSource=/*#__PURE__*/_createClass(function PickMeshShaderSource(mesh){_classCallCheck(this,PickMeshShaderSource);this.vertex=buildVertex$3(mesh);this.fragment=buildFragment$3(mesh);});function buildVertex$3(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var quantizedGeometry=!!mesh._geometry._state.compressGeometry;var billboard=mesh._state.billboard;var stationary=mesh._state.stationary;var src=[];src.push('#version 300 es');src.push("// Mesh picking vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("out vec4 vViewPosition;");src.push("uniform vec3 offset;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}if(clipping){src.push("out vec4 vWorldPosition;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;");}src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}");}src.push("uniform vec2 pickClipPos;");src.push("vec4 remapClipPos(vec4 clipPos) {");src.push("    clipPos.xy /= clipPos.w;");src.push("    clipPos.xy -= pickClipPos;");src.push("    clipPos.xy *= clipPos.w;");src.push("    return clipPos;");src.push("}");src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");}src.push("   vec4 worldPosition = modelMatrix2 * localPosition;");src.push("   worldPosition.xyz = worldPosition.xyz + offset;");src.push("   vec4 viewPosition = viewMatrix2 * worldPosition;");if(clipping){src.push("   vWorldPosition = worldPosition;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");return src;}function buildFragment$3(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Mesh picking fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform vec4 pickColor;");if(clipping){src.push("uniform bool clippable;");src.push("in vec4 vWorldPosition;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor = pickColor; ");src.push("}");return src;}/**
 * @author xeolabs / https://github.com/xeolabs
 */var tempVec3a$F=math.vec3();// No ID, because there is exactly one PickMeshRenderer per scene
/**
 * @private
 */var PickMeshRenderer=function PickMeshRenderer(hash,mesh){this._hash=hash;this._shaderSource=new PickMeshShaderSource(mesh);this._scene=mesh.scene;this._useCount=0;this._allocate(mesh);};var renderers$3={};PickMeshRenderer.get=function(mesh){var hash=[mesh.scene.canvas.canvas.id,mesh.scene._sectionPlanesState.getHash(),mesh._geometry._state.hash,mesh._state.hash].join(";");var renderer=renderers$3[hash];if(!renderer){renderer=new PickMeshRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null;}renderers$3[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};PickMeshRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy();}delete renderers$3[this._hash];stats.memory.programs--;}};PickMeshRenderer.prototype.webglContextRestored=function(){this._program=null;};PickMeshRenderer.prototype.drawMesh=function(frameCtx,mesh){if(!this._program){this._allocate(mesh);}var scene=this._scene;var gl=scene.canvas.gl;var meshState=mesh._state;var materialState=mesh._material._state;var geometryState=mesh._geometry._state;var origin=mesh.origin;if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx);}gl.uniformMatrix4fv(this._uViewMatrix,false,origin?frameCtx.getRTCPickViewMatrix(meshState.originHash,origin):frameCtx.pickViewMatrix);if(meshState.clippable){var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var renderFlags=mesh.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$F);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}if(materialState.id!==this._lastMaterialId){var backfaces=materialState.backfaces;if(frameCtx.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frameCtx.backfaces=backfaces;}var frontface=materialState.frontface;if(frameCtx.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW);}else{gl.frontFace(gl.CW);}frameCtx.frontface=frontface;}this._lastMaterialId=materialState.id;}gl.uniformMatrix4fv(this._uProjMatrix,false,frameCtx.pickProjMatrix);gl.uniformMatrix4fv(this._uModelMatrix,false,mesh.worldMatrix);if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable);}gl.uniform3fv(this._uOffset,mesh._state.offset);if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);}if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.compressGeometry?gl.UNSIGNED_SHORT:gl.FLOAT);frameCtx.bindArray++;}if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frameCtx.bindArray++;}this._lastGeometryId=geometryState.id;}// Mesh-indexed color
var pickID=mesh._state.pickID;var a=pickID>>24&0xFF;var b=pickID>>16&0xFF;var g=pickID>>8&0xFF;var r=pickID&0xFF;gl.uniform4f(this._uPickColor,r/255,g/255,b/255,a/255);gl.uniform2fv(this._uPickClipPos,frameCtx.pickClipPos);if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frameCtx.drawElements++;}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);}};PickMeshRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];var clips=scene._sectionPlanesState.sectionPlanes;for(var _i115=0,len=clips.length;_i115<len;_i115++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i115),pos:program.getLocation("sectionPlanePos"+_i115),dir:program.getLocation("sectionPlaneDir"+_i115)});}this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uPickColor=program.getLocation("pickColor");this._uPickClipPos=program.getLocation("pickClipPos");this._uOffset=program.getLocation("offset");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._lastMaterialId=null;this._lastGeometryId=null;};PickMeshRenderer.prototype._bindProgram=function(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var project=scene.camera.project;this._program.bind();frameCtx.useProgram++;if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this._lastMaterialId=null;this._lastGeometryId=null;};/**
 * @private
 */var PickTriangleShaderSource=/*#__PURE__*/_createClass(function PickTriangleShaderSource(mesh){_classCallCheck(this,PickTriangleShaderSource);this.vertex=buildVertex$2(mesh);this.fragment=buildFragment$2(mesh);});function buildVertex$2(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var quantizedGeometry=!!mesh._geometry._state.compressGeometry;var src=[];src.push('#version 300 es');src.push("// Surface picking vertex shader");src.push("in vec3 position;");src.push("in vec4 color;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec3 offset;");if(clipping){src.push("uniform bool clippable;");src.push("out vec4 vWorldPosition;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("uniform vec2 pickClipPos;");src.push("vec4 remapClipPos(vec4 clipPos) {");src.push("    clipPos.xy /= clipPos.w;");src.push("    clipPos.xy -= pickClipPos;");src.push("    clipPos.xy *= clipPos.w;");src.push("    return clipPos;");src.push("}");src.push("out vec4 vColor;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}src.push("   vec4 worldPosition = modelMatrix * localPosition; ");src.push("   worldPosition.xyz = worldPosition.xyz + offset;");src.push("   vec4 viewPosition = viewMatrix * worldPosition;");if(clipping){src.push("   vWorldPosition = worldPosition;");}src.push("   vColor = color;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");return src;}function buildFragment$2(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Surface picking fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");src.push("in vec4 vColor;");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("uniform bool clippable;");src.push("in vec4 vWorldPosition;");for(var _i116=0;_i116<sectionPlanesState.getNumAllocatedSectionPlanes();_i116++){src.push("uniform bool sectionPlaneActive"+_i116+";");src.push("uniform vec3 sectionPlanePos"+_i116+";");src.push("uniform vec3 sectionPlaneDir"+_i116+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var _i117=0;_i117<sectionPlanesState.getNumAllocatedSectionPlanes();_i117++){src.push("if (sectionPlaneActive"+_i117+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i117+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i117+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor = vColor;");src.push("}");return src;}/**
 * @author xeolabs / https://github.com/xeolabs
 */var tempVec3a$E=math.vec3();/**
 * @private
 */var PickTriangleRenderer=function PickTriangleRenderer(hash,mesh){this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new PickTriangleShaderSource(mesh);this._allocate(mesh);};var renderers$2={};PickTriangleRenderer.get=function(mesh){var hash=[mesh.scene.canvas.canvas.id,mesh.scene._sectionPlanesState.getHash(),mesh._geometry._state.compressGeometry?"cp":"",mesh._state.hash].join(";");var renderer=renderers$2[hash];if(!renderer){renderer=new PickTriangleRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null;}renderers$2[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};PickTriangleRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy();}delete renderers$2[this._hash];stats.memory.programs--;}};PickTriangleRenderer.prototype.webglContextRestored=function(){this._program=null;};PickTriangleRenderer.prototype.drawMesh=function(frameCtx,mesh){if(!this._program){this._allocate(mesh);}var scene=this._scene;var gl=scene.canvas.gl;var meshState=mesh._state;var materialState=mesh._material._state;var geometry=mesh._geometry;var geometryState=mesh._geometry._state;var origin=mesh.origin;var backfaces=materialState.backfaces;var frontface=materialState.frontface;var project=scene.camera.project;var positionsBuf=geometry._getPickTrianglePositions();var pickColorsBuf=geometry._getPickTriangleColors();this._program.bind();frameCtx.useProgram++;if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}gl.uniformMatrix4fv(this._uViewMatrix,false,origin?frameCtx.getRTCPickViewMatrix(meshState.originHash,origin):frameCtx.pickViewMatrix);if(meshState.clippable){var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var renderFlags=mesh.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$E);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}gl.uniformMatrix4fv(this._uProjMatrix,false,frameCtx.pickProjMatrix);if(scene.logarithmicDepthBufferEnabled){gl.uniform1f(this._uZFar,scene.camera.project.far);}if(frameCtx.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frameCtx.backfaces=backfaces;}if(frameCtx.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW);}else{gl.frontFace(gl.CW);}frameCtx.frontface=frontface;}gl.uniformMatrix4fv(this._uModelMatrix,false,mesh.worldMatrix);if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable);}gl.uniform3fv(this._uOffset,mesh._state.offset);if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);this._aPosition.bindArrayBuffer(positionsBuf,geometryState.compressGeometry?gl.UNSIGNED_SHORT:gl.FLOAT);}else{this._aPosition.bindArrayBuffer(positionsBuf);}gl.uniform2fv(this._uPickClipPos,frameCtx.pickClipPos);pickColorsBuf.bind();gl.enableVertexAttribArray(this._aColor.location);gl.vertexAttribPointer(this._aColor.location,pickColorsBuf.itemSize,pickColorsBuf.itemType,true,0,0);// Normalize
gl.drawArrays(geometryState.primitive,0,positionsBuf.numItems/3);};PickTriangleRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._shaderSource);this._useCount=0;if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];var sectionPlanes=scene._sectionPlanesState.sectionPlanes;for(var _i118=0,len=sectionPlanes.length;_i118<len;_i118++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i118),pos:program.getLocation("sectionPlanePos"+_i118),dir:program.getLocation("sectionPlaneDir"+_i118)});}this._aPosition=program.getAttribute("position");this._aColor=program.getAttribute("color");this._uPickClipPos=program.getLocation("pickClipPos");this._uClippable=program.getLocation("clippable");this._uOffset=program.getLocation("offset");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}};/**
 * @author xeolabs / https://github.com/xeolabs
 */ /**
 * @private
 */var OcclusionShaderSource=/*#__PURE__*/_createClass(function OcclusionShaderSource(mesh){_classCallCheck(this,OcclusionShaderSource);this.vertex=buildVertex$1(mesh);this.fragment=buildFragment$1(mesh);});function buildVertex$1(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var quantizedGeometry=!!mesh._geometry._state.compressGeometry;var billboard=mesh._state.billboard;var stationary=mesh._state.stationary;var src=[];src.push('#version 300 es');src.push("// Mesh occlusion vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec3 offset;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}if(clipping){src.push("out vec4 vWorldPosition;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;");}src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}");}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");}if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;");}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");}if(clipping){src.push("   vWorldPosition = worldPosition;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");return src;}function buildFragment$1(mesh){var scene=mesh.scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Mesh occlusion fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("uniform bool clippable;");src.push("in vec4 vWorldPosition;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}src.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); ");if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}/**
 * @author xeolabs / https://github.com/xeolabs
 */var tempVec3a$D=math.vec3();// No ID, because there is exactly one PickMeshRenderer per scene
/**
 * @private
 */var OcclusionRenderer=function OcclusionRenderer(hash,mesh){this._hash=hash;this._shaderSource=new OcclusionShaderSource(mesh);this._scene=mesh.scene;this._useCount=0;this._allocate(mesh);};var renderers$1={};OcclusionRenderer.get=function(mesh){var hash=[mesh.scene.canvas.canvas.id,mesh.scene._sectionPlanesState.getHash(),mesh._geometry._state.hash,mesh._state.occlusionHash].join(";");var renderer=renderers$1[hash];if(!renderer){renderer=new OcclusionRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null;}renderers$1[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};OcclusionRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy();}delete renderers$1[this._hash];stats.memory.programs--;}};OcclusionRenderer.prototype.webglContextRestored=function(){this._program=null;};OcclusionRenderer.prototype.drawMesh=function(frameCtx,mesh){if(!this._program){this._allocate(mesh);}var scene=this._scene;var gl=scene.canvas.gl;var materialState=mesh._material._state;var meshState=mesh._state;var geometryState=mesh._geometry._state;var origin=mesh.origin;if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx);}if(materialState.id!==this._lastMaterialId){var backfaces=materialState.backfaces;if(frameCtx.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frameCtx.backfaces=backfaces;}var frontface=materialState.frontface;if(frameCtx.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW);}else{gl.frontFace(gl.CW);}frameCtx.frontface=frontface;}this._lastMaterialId=materialState.id;}var camera=scene.camera;gl.uniformMatrix4fv(this._uViewMatrix,false,origin?frameCtx.getRTCViewMatrix(meshState.originHash,origin):camera.viewMatrix);if(meshState.clippable){var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var renderFlags=mesh.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$D);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}gl.uniformMatrix4fv(this._uProjMatrix,false,camera._project._state.matrix);gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable);}gl.uniform3fv(this._uOffset,mesh._state.offset);if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);}if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.compressGeometry?gl.UNSIGNED_SHORT:gl.FLOAT);frameCtx.bindArray++;}if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frameCtx.bindArray++;}this._lastGeometryId=geometryState.id;}if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frameCtx.drawElements++;}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);}};OcclusionRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];var clips=scene._sectionPlanesState.sectionPlanes;for(var _i119=0,len=clips.length;_i119<len;_i119++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i119),pos:program.getLocation("sectionPlanePos"+_i119),dir:program.getLocation("sectionPlaneDir"+_i119)});}this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uOffset=program.getLocation("offset");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;};OcclusionRenderer.prototype._bindProgram=function(frameCtx){var scene=this._scene;var project=scene.camera.project;var gl=scene.canvas.gl;this._program.bind();frameCtx.useProgram++;gl.uniformMatrix4fv(this._uProjMatrix,false,project.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;};/**
 * @private
 */var ShadowShaderSource=/*#__PURE__*/_createClass(function ShadowShaderSource(mesh){_classCallCheck(this,ShadowShaderSource);this.vertex=buildVertex(mesh);this.fragment=buildFragment(mesh);});function buildVertex(mesh){var scene=mesh.scene;var clipping=scene._sectionPlanesState.sectionPlanes.length>0;var quantizedGeometry=!!mesh._geometry._state.compressGeometry;var src=[];src.push("// Mesh shadow vertex shader");src.push("in vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 shadowViewMatrix;");src.push("uniform mat4 shadowProjMatrix;");src.push("uniform vec3 offset;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;");}if(clipping){src.push("out vec4 vWorldPosition;");}src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;");}src.push("worldPosition = modelMatrix * localPosition;");src.push("worldPosition.xyz = worldPosition.xyz + offset;");src.push("vec4 viewPosition  = shadowViewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");}src.push("   gl_Position = shadowProjMatrix * viewPosition;");src.push("}");return src;}function buildFragment(mesh){var scene=mesh.scene;scene.canvas.gl;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("// Mesh shadow fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(clipping){src.push("uniform bool clippable;");src.push("in vec4 vWorldPosition;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("vec4 encodeFloat( const in float depth ) {");src.push("  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);");src.push("  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);");src.push("  vec4 comp = fract(depth * bitShift);");src.push("  comp -= comp.xxyz * bitMask;");src.push("  return comp;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}src.push("outColor = encodeFloat(gl_FragCoord.z);");src.push("}");return src;}/**
 * @private
 */var ShadowRenderer=function ShadowRenderer(hash,mesh){this._hash=hash;this._shaderSource=new ShadowShaderSource(mesh);this._scene=mesh.scene;this._useCount=0;this._allocate(mesh);};var renderers={};ShadowRenderer.get=function(mesh){var scene=mesh.scene;var hash=[scene.canvas.canvas.id,scene._sectionPlanesState.getHash(),mesh._geometry._state.hash,mesh._state.hash].join(";");var renderer=renderers[hash];if(!renderer){renderer=new ShadowRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null;}renderers[hash]=renderer;stats.memory.programs++;}renderer._useCount++;return renderer;};ShadowRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy();}delete renderers[this._hash];stats.memory.programs--;}};ShadowRenderer.prototype.webglContextRestored=function(){this._program=null;};ShadowRenderer.prototype.drawMesh=function(frame,mesh){if(!this._program){this._allocate(mesh);}var scene=this._scene;var gl=scene.canvas.gl;var materialState=mesh._material._state;var geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame);}if(materialState.id!==this._lastMaterialId){var backfaces=materialState.backfaces;if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE);}else{gl.enable(gl.CULL_FACE);}frame.backfaces=backfaces;}var frontface=materialState.frontface;if(frame.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW);}else{gl.frontFace(gl.CW);}frame.frontface=frontface;}if(frame.lineWidth!==materialState.lineWidth){gl.lineWidth(materialState.lineWidth);frame.lineWidth=materialState.lineWidth;}if(this._uPointSize){gl.uniform1i(this._uPointSize,materialState.pointSize);}this._lastMaterialId=materialState.id;}gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(geometryState.combineGeometry){var vertexBufs=mesh.vertexBufs;if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.compressGeometry?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++;}this._lastVertexBufsId=vertexBufs.id;}}if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable);}gl.uniform3fv(this._uOffset,mesh._state.offset);if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,geometryState.positionsDecodeMatrix);}if(geometryState.combineGeometry){// VBOs were bound by the preceding VertexBufs chunk
if(geometryState.indicesBufCombined){geometryState.indicesBufCombined.bind();frame.bindArray++;}}else{if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.compressGeometry?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++;}if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frame.bindArray++;}}this._lastGeometryId=geometryState.id;}if(geometryState.combineGeometry){if(geometryState.indicesBufCombined){gl.drawElements(geometryState.primitive,geometryState.indicesBufCombined.numItems,geometryState.indicesBufCombined.itemType,0);frame.drawElements++;}}else{if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frame.drawElements++;}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);frame.drawArrays++;}}};ShadowRenderer.prototype._allocate=function(mesh){var scene=mesh.scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._shaderSource);this._scene=scene;this._useCount=0;if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uShadowViewMatrix=program.getLocation("shadowViewMatrix");this._uShadowProjMatrix=program.getLocation("shadowProjMatrix");this._uSectionPlanes={};var clips=scene._sectionPlanesState.sectionPlanes;for(var _i120=0,len=clips.length;_i120<len;_i120++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i120),pos:program.getLocation("sectionPlanePos"+_i120),dir:program.getLocation("sectionPlaneDir"+_i120)});}this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uOffset=program.getLocation("offset");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;};ShadowRenderer.prototype._bindProgram=function(frame){if(!this._program){this._allocate(mesh);}var scene=this._scene;var gl=scene.canvas.gl;var sectionPlanesState=scene._sectionPlanesState;this._program.bind();frame.useProgram++;gl.uniformMatrix4fv(this._uShadowViewMatrix,false,frame.shadowViewMatrix);gl.uniformMatrix4fv(this._uShadowProjMatrix,false,frame.shadowProjMatrix);this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;if(sectionPlanesState.getNumAllocatedSectionPlanes()>0){var sectionPlaneUniforms;var uSectionPlaneActive;var sectionPlane;var uSectionPlanePos;var uSectionPlaneDir;for(var _i121=0,len=this._uSectionPlanes.length;_i121<len;_i121++){sectionPlaneUniforms=this._uSectionPlanes[_i121];uSectionPlaneActive=sectionPlaneUniforms.active;sectionPlane=sectionPlanesState.sectionPlanes[_i121];if(uSectionPlaneActive){gl.uniform1i(uSectionPlaneActive,sectionPlane.active);}uSectionPlanePos=sectionPlaneUniforms.pos;if(uSectionPlanePos){gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}uSectionPlaneDir=sectionPlaneUniforms.dir;if(uSectionPlaneDir){gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}}};/**
 * Indicates what rendering needs to be done for the layers within a {@link Drawable}.
 *
 * Each Drawable has a RenderFlags in {@link Drawable#renderFlags}.
 *
 * Before rendering each frame, {@link Renderer} will call {@link Drawable#rebuildRenderFlags} on each {@link Drawable}.
 *
 * Then, when rendering a frame, Renderer will apply rendering passes to each Drawable according on what flags are set in {@link Drawable#renderFlags}.
 *
 * @private
 */var RenderFlags=/*#__PURE__*/function(){/**
     * @private
     */function RenderFlags(){_classCallCheck(this,RenderFlags);/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate which layers are visible within the {@link Drawable}.
         *
         * This is a list of IDs of visible layers within the {@link Drawable}. The IDs will be whatever the
         * {@link Drawable} uses to identify its layers, usually integers.
         *
         * @property visibleLayers
         * @type {Number[]}
         */this.visibleLayers=[];/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate which {@link SectionPlane}s are active within each layer of the {@link Drawable}.
         *
         * Layout is as follows:
         *
         * ````[
         *      false, false, true, // Layer 0, SectionPlanes 0, 1, 2
         *      false, true, true,  // Layer 1, SectionPlanes 0, 1, 2
         *      true, false, true   // Layer 2, SectionPlanes 0, 1, 2
         * ]````
         *
         * @property sectionPlanesActivePerLayer
         * @type {Boolean[]}
         */this.sectionPlanesActivePerLayer=[];this.reset();}/**
     * @private
     */_createClass(RenderFlags,[{key:"reset",value:function reset(){/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate whether the {@link Drawable} is culled.
         * 
         * When this is ````false````, then all of the other properties on ````RenderFlags```` will remain at their default values.
         * 
         * @property culled
         * @type {Boolean}
         */this.culled=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate whether the {@link Drawable} is sliced by any {@link SectionPlane}s.
         *
         * @property sectioned
         * @type {Boolean}
         */this.sectioned=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the number of layers within the {@link Drawable}.
         *
         * @property numLayers
         * @type {Number}
         */this.numLayers=0;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the number of visible layers within the {@link Drawable}.
         *
         * @property numVisibleLayers
         * @type {Number}
         */this.numVisibleLayers=0;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawColorOpaque}.
         * @property colorOpaque
         * @type {boolean}
         */this.colorOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawColorTransparent}.
         * @property colorTransparent
         * @type {boolean}
         */this.colorTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawEdgesColorOpaque}.
         * @property edgesOpaque
         * @type {boolean}
         */this.edgesOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawEdgesColorTransparent}.
         * @property edgesTransparent
         * @type {boolean}
         */this.edgesTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteXRayed}.
         * @property xrayedSilhouetteOpaque
         * @type {boolean}
         */this.xrayedSilhouetteOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesXRayed}.
         * @property xrayedEdgesOpaque
         * @type {boolean}
         */this.xrayedEdgesOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteXRayed}.
         * @property xrayedSilhouetteTransparent
         * @type {boolean}
         */this.xrayedSilhouetteTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesXRayed}.
         * @property xrayedEdgesTransparent
         * @type {boolean}
         */this.xrayedEdgesTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteHighlighted}.
         * @property highlightedSilhouetteOpaque
         * @type {boolean}
         */this.highlightedSilhouetteOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesHighlighted}.
         * @property highlightedEdgesOpaque
         * @type {boolean}
         */this.highlightedEdgesOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteHighlighted}.
         * @property highlightedSilhouetteTransparent
         * @type {boolean}
         */this.highlightedSilhouetteTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesHighlighted}.
         * @property highlightedEdgesTransparent
         * @type {boolean}
         */this.highlightedEdgesTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteSelected}.
         * @property selectedSilhouetteOpaque
         * @type {boolean}
         */this.selectedSilhouetteOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesSelected}.
         * @property selectedEdgesOpaque
         * @type {boolean}
         */this.selectedEdgesOpaque=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteSelected}.
         * @property selectedSilhouetteTransparent
         * @type {boolean}
         */this.selectedSilhouetteTransparent=false;/**
         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesSelected}.
         * @property selectedEdgesTransparent
         * @type {boolean}
         */this.selectedEdgesTransparent=false;}}]);return RenderFlags;}();/**
 Fired when this Mesh is picked via a call to {@link Scene/pick:method"}}Scene#pick(){{/crossLink}}.

 The event parameters will be the hit result returned by the {@link Scene/pick:method"}}Scene#pick(){{/crossLink}} method.
 @event picked
 */var obb=math.OBB3();var angleAxis$2=math.vec4();var q1$2=math.vec4();var q2$2=math.vec4();var xAxis$2=math.vec3([1,0,0]);var yAxis$2=math.vec3([0,1,0]);var zAxis$2=math.vec3([0,0,1]);var veca$1=math.vec3(3);var vecb$1=math.vec3(3);var identityMat$2=math.identityMat4();/**
 * @desc An {@link Entity} that is a drawable element, with a {@link Geometry} and a {@link Material}, that can be
 * connected into a scene graph using {@link Node}s.
 *
 * ## Usage
 *
 * The example below is the same as the one given for {@link Node}, since the two classes work together.  In this example,
 * we'll create a scene graph in which a root {@link Node} represents a group and the Meshes are leaves.
 *
 * Since {@link Node} implements {@link Entity}, we can designate the root {@link Node} as a model, causing it to be registered by its
 * ID in {@link Scene#models}.
 *
 * Since Mesh also implements {@link Entity}, we can designate the leaf Meshes as objects, causing them to
 * be registered by their IDs in {@link Scene#objects}.
 *
 * We can then find those {@link Entity} types in {@link Scene#models} and {@link Scene#objects}.
 *
 * We can also update properties of our object-Meshes via calls to {@link Scene#setObjectsHighlighted} etc.
 *
 * [[Run this example](/examples/#sceneRepresentation_SceneGraph)]
 *
 * ````javascript
 * import {Viewer, Mesh, Node, PhongMaterial, buildBoxGeometry, ReadableGeometry} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const boxGeometry = new ReadableGeometry(viewer.scene, buildBoxGeometry({
 *      xSize: 1,
 *      ySize: 1,
 *      zSize: 1
 * }));
 *
 * new Node(viewer.scene, {
 *      id: "table",
 *      isModel: true, // <---------- Node represents a model, so is registered by ID in viewer.scene.models
 *      rotation: [0, 50, 0],
 *      position: [0, 0, 0],
 *      scale: [1, 1, 1],
 *
 *      children: [
 *
 *          new Mesh(viewer.scene, { // Red table leg
 *              id: "redLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1, 0.3, 0.3]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, { // Green table leg
 *              id: "greenLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 1.0, 0.3]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, {// Blue table leg
 *              id: "blueLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 0.3, 1.0]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, {  // Yellow table leg
 *              id: "yellowLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                   diffuse: [1.0, 1.0, 0.0]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, { // Purple table top
 *              id: "tableTop",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [0, -3, 0],
 *              scale: [6, 0.5, 6],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1.0, 0.3, 1.0]
 *              }),
 *              geometry: boxGeometry
 *          })
 *      ]
 *  });
 *
 * // Find Nodes and Meshes by their IDs
 *
 * var table = viewer.scene.models["table"];                // Since table Node has isModel == true
 *
 * var redLeg = viewer.scene.objects["redLeg"];             // Since the Meshes have isObject == true
 * var greenLeg = viewer.scene.objects["greenLeg"];
 * var blueLeg = viewer.scene.objects["blueLeg"];
 *
 * // Highlight one of the table leg Meshes
 *
 * viewer.scene.setObjectsHighlighted(["redLeg"], true);    // Since the Meshes have isObject == true
 *
 * // Periodically update transforms on our Nodes and Meshes
 *
 * viewer.scene.on("tick", function () {
 *
 *       // Rotate legs
 *       redLeg.rotateY(0.5);
 *       greenLeg.rotateY(0.5);
 *       blueLeg.rotateY(0.5);
 *
 *       // Rotate table
 *       table.rotateY(0.5);
 *       table.rotateX(0.3);
 *   });
 * ````
 *
 * ## Metadata
 *
 * As mentioned, we can also associate {@link MetaModel}s and {@link MetaObject}s with our {@link Node}s and Meshes,
 * within a {@link MetaScene}. See {@link MetaScene} for an example.
 *
 * @implements {Entity}
 * @implements {Drawable}
 */var Mesh=/*#__PURE__*/function(_Component21){_inherits(Mesh,_Component21);var _super34=_createSuper(Mesh);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent scene, generated automatically when omitted.
     * @param {String} [cfg.originalSystemId] ID of the corresponding object within the originating system, if any.
     * @param {Boolean} [cfg.isModel] Specify ````true```` if this Mesh represents a model, in which case the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and may also have a corresponding {@link MetaModel} with matching {@link MetaModel#id}, registered by that ID in {@link MetaScene#metaModels}.
     * @param {Boolean} [cfg.isObject] Specify ````true```` if this Mesh represents an object, in which case the Mesh will be registered by {@link Mesh#id} in {@link Scene#objects} and may also have a corresponding {@link MetaObject} with matching {@link MetaObject#id}, registered by that ID in {@link MetaScene#metaObjects}.
     * @param {Node} [cfg.parent] The parent Node.
     * @param {Number[]} [cfg.origin] World-space origin for this Mesh. When this is given, then ````matrix````, ````position```` and ````geometry```` are all assumed to be relative to this center.
     * @param {Number[]} [cfg.rtcCenter] Deprecated - renamed to ````origin````.
     * @param {Number[]} [cfg.position=[0,0,0]] 3D position of this Mesh, relative to ````origin````.
     * @param {Number[]} [cfg.scale=[1,1,1]] Local scale.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Local modelling transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Number[]} [cfg.offset=[0,0,0]] World-space 3D translation offset. Translates the Mesh in World space, after modelling transforms.
     * @param {Boolean} [cfg.occluder=true] Indicates if the Mesh is able to occlude {@link Marker}s.
     * @param {Boolean} [cfg.visible=true] Indicates if the Mesh is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the Mesh is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the Mesh is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the Mesh is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the Mesh is initially included in boundary calculations.
     * @param {Boolean} [cfg.castsShadow=true] Indicates if the Mesh initially casts shadows.
     * @param {Boolean} [cfg.receivesShadow=true]  Indicates if the Mesh initially receives shadows.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the Mesh is initially xrayed.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the Mesh is initially highlighted.
     * @param {Boolean} [cfg.selected=false] Indicates if the Mesh is initially selected.
     * @param {Boolean} [cfg.edges=false] Indicates if the Mesh's edges are initially emphasized.
     * @param {Boolean} [cfg.background=false] Indicates if the Mesh should act as background, e.g., it can be used for a skybox.
     * @param {Number[]} [cfg.colorize=[1.0,1.0,1.0]] Mesh's initial RGB colorize color, multiplies by the rendered fragment colors.
     * @param {Number} [cfg.opacity=1.0] Mesh's initial opacity factor, multiplies by the rendered fragment alpha.
     * @param {String} [cfg.billboard="none"] Mesh's billboarding behaviour. Options are "none" for no billboarding, "spherical" to always directly face {@link Camera.eye}, rotating both vertically and horizontally, or "cylindrical" to face the {@link Camera#eye} while rotating only about its vertically axis (use that mode for things like trees on a landscape).
     * @param {Geometry} [cfg.geometry] {@link Geometry} to define the shape of this Mesh. Inherits {@link Scene#geometry} by default.
     * @param {Material} [cfg.material] {@link Material} to define the normal rendered appearance for this Mesh. Inherits {@link Scene#material} by default.
     * @param {EmphasisMaterial} [cfg.xrayMaterial] {@link EmphasisMaterial} to define the xrayed appearance for this Mesh. Inherits {@link Scene#xrayMaterial} by default.
     * @param {EmphasisMaterial} [cfg.highlightMaterial] {@link EmphasisMaterial} to define the xrayed appearance for this Mesh. Inherits {@link Scene#highlightMaterial} by default.
     * @param {EmphasisMaterial} [cfg.selectedMaterial] {@link EmphasisMaterial} to define the selected appearance for this Mesh. Inherits {@link Scene#selectedMaterial} by default.
     * @param {EmphasisMaterial} [cfg.edgeMaterial] {@link EdgeMaterial} to define the appearance of enhanced edges for this Mesh. Inherits {@link Scene#edgeMaterial} by default.
     */function Mesh(owner){var _this53;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Mesh);_this53=_super34.call(this,owner,cfg);/**
         * ID of the corresponding object within the originating system, if any.
         *
         * @type {String}
         * @abstract
         */_this53.originalSystemId=cfg.originalSystemId||_this53.id;/** @private **/_this53.renderFlags=new RenderFlags();_this53._state=new RenderState({// NOTE: Renderer gets modeling and normal matrices from Mesh#matrix and Mesh.#normalWorldMatrix
visible:true,culled:false,pickable:null,clippable:null,collidable:null,occluder:cfg.occluder!==false,castsShadow:null,receivesShadow:null,xrayed:false,highlighted:false,selected:false,edges:false,stationary:!!cfg.stationary,background:!!cfg.background,billboard:_this53._checkBillboard(cfg.billboard),layer:null,colorize:null,pickID:_this53.scene._renderer.getPickID(_assertThisInitialized(_this53)),drawHash:"",pickHash:"",offset:math.vec3(),origin:null,originHash:null});_this53._drawRenderer=null;_this53._shadowRenderer=null;_this53._emphasisFillRenderer=null;_this53._emphasisEdgesRenderer=null;_this53._pickMeshRenderer=null;_this53._pickTriangleRenderer=null;_this53._occlusionRenderer=null;_this53._geometry=cfg.geometry?_this53._checkComponent2(["ReadableGeometry","VBOGeometry"],cfg.geometry):_this53.scene.geometry;_this53._material=cfg.material?_this53._checkComponent2(["PhongMaterial","MetallicMaterial","SpecularMaterial","LambertMaterial"],cfg.material):_this53.scene.material;_this53._xrayMaterial=cfg.xrayMaterial?_this53._checkComponent("EmphasisMaterial",cfg.xrayMaterial):_this53.scene.xrayMaterial;_this53._highlightMaterial=cfg.highlightMaterial?_this53._checkComponent("EmphasisMaterial",cfg.highlightMaterial):_this53.scene.highlightMaterial;_this53._selectedMaterial=cfg.selectedMaterial?_this53._checkComponent("EmphasisMaterial",cfg.selectedMaterial):_this53.scene.selectedMaterial;_this53._edgeMaterial=cfg.edgeMaterial?_this53._checkComponent("EdgeMaterial",cfg.edgeMaterial):_this53.scene.edgeMaterial;_this53._parentNode=null;_this53._aabb=null;_this53._aabbDirty=true;_this53._numTriangles=_this53._geometry?_this53._geometry.numTriangles:0;_this53.scene._aabbDirty=true;_this53._scale=math.vec3();_this53._quaternion=math.identityQuaternion();_this53._rotation=math.vec3();_this53._position=math.vec3();_this53._worldMatrix=math.identityMat4();_this53._worldNormalMatrix=math.identityMat4();_this53._localMatrixDirty=true;_this53._worldMatrixDirty=true;_this53._worldNormalMatrixDirty=true;var origin=cfg.origin||cfg.rtcCenter;if(origin){_this53._state.origin=math.vec3(origin);_this53._state.originHash=origin.join();}if(cfg.matrix){_this53.matrix=cfg.matrix;}else{_this53.scale=cfg.scale;_this53.position=cfg.position;if(cfg.quaternion);else{_this53.rotation=cfg.rotation;}}_this53._isObject=cfg.isObject;if(_this53._isObject){_this53.scene._registerObject(_assertThisInitialized(_this53));}_this53._isModel=cfg.isModel;if(_this53._isModel){_this53.scene._registerModel(_assertThisInitialized(_this53));}_this53.visible=cfg.visible;_this53.culled=cfg.culled;_this53.pickable=cfg.pickable;_this53.clippable=cfg.clippable;_this53.collidable=cfg.collidable;_this53.castsShadow=cfg.castsShadow;_this53.receivesShadow=cfg.receivesShadow;_this53.xrayed=cfg.xrayed;_this53.highlighted=cfg.highlighted;_this53.selected=cfg.selected;_this53.edges=cfg.edges;_this53.layer=cfg.layer;_this53.colorize=cfg.colorize;_this53.opacity=cfg.opacity;_this53.offset=cfg.offset;if(cfg.parentId){var parentNode=_this53.scene.components[cfg.parentId];if(!parentNode){_this53.error("Parent not found: '"+cfg.parentId+"'");}else if(!parentNode.isNode){_this53.error("Parent is not a Node: '"+cfg.parentId+"'");}else{parentNode.addChild(_assertThisInitialized(_this53));}_this53._parentNode=parentNode;}else if(cfg.parent){if(!cfg.parent.isNode){_this53.error("Parent is not a Node");}cfg.parent.addChild(_assertThisInitialized(_this53));_this53._parentNode=cfg.parent;}_this53.compile();return _this53;}/**
     @private
     */_createClass(Mesh,[{key:"type",get:function get(){return"Mesh";}//------------------------------------------------------------------------------------------------------------------
// Mesh members
//------------------------------------------------------------------------------------------------------------------
/**
     * Returns true to indicate that this Component is a Mesh.
     * @final
     * @type {Boolean}
     */},{key:"isMesh",get:function get(){return true;}/**
     * The parent Node.
     *
     * The parent Node may also be set by passing the Mesh to the parent's {@link Node#addChild} method.
     *
     * @type {Node}
     */},{key:"parent",get:function get(){return this._parentNode;}/**
     * Defines the shape of this Mesh.
     *
     * Set to {@link Scene#geometry} by default.
     *
     * @type {Geometry}
     */},{key:"geometry",get:function get(){return this._geometry;}/**
     * Defines the appearance of this Mesh when rendering normally, ie. when not xrayed, highlighted or selected.
     *
     * Set to {@link Scene#material} by default.
     *
     * @type {Material}
     */},{key:"material",get:function get(){return this._material;}/**
     * Gets the Mesh's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */},{key:"position",get:function get(){return this._position;}/**
     * Sets the Mesh's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._position.set(value||[0,0,0]);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}/**
     * Gets the Mesh's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */},{key:"rotation",get:function get(){return this._rotation;}/**
     * Sets the Mesh's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._rotation.set(value||[0,0,0]);math.eulerToQuaternion(this._rotation,"XYZ",this._quaternion);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}/**
     * Gets the Mesh's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */},{key:"quaternion",get:function get(){return this._quaternion;}/**
     * Sets the Mesh's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._quaternion.set(value||[0,0,0,1]);math.quaternionToEuler(this._quaternion,"XYZ",this._rotation);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}/**
     * Gets the Mesh's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */},{key:"scale",get:function get(){return this._scale;}/**
     * Sets the Mesh's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._scale.set(value||[1,1,1]);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}/**
     * Gets the Mesh's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */},{key:"matrix",get:function get(){if(this._localMatrixDirty){if(!this.__localMatrix){this.__localMatrix=math.identityMat4();}math.composeMat4(this._position,this._quaternion,this._scale,this.__localMatrix);this._localMatrixDirty=false;}return this.__localMatrix;}/**
     * Sets the Mesh's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */,set:function set(value){if(!this.__localMatrix){this.__localMatrix=math.identityMat4();}this.__localMatrix.set(value||identityMat$2);math.decomposeMat4(this.__localMatrix,this._position,this._quaternion,this._scale);this._localMatrixDirty=false;this._setWorldMatrixDirty();this._setAABBDirty();this.glRedraw();}/**
     * Gets the Mesh's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */},{key:"worldMatrix",get:function get(){if(this._worldMatrixDirty){this._buildWorldMatrix();}return this._worldMatrix;}/**
     * Gets the Mesh's World normal matrix.
     *
     * @type {Number[]}
     */},{key:"worldNormalMatrix",get:function get(){if(this._worldNormalMatrixDirty){this._buildWorldNormalMatrix();}return this._worldNormalMatrix;}/**
     * Returns true to indicate that Mesh implements {@link Entity}.
     *
     * @returns {Boolean}
     */},{key:"isEntity",get:function get(){return true;}/**
     * Returns ````true```` if this Mesh represents a model.
     *
     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and
     * may also have a corresponding {@link MetaModel}.
     *
     * @type {Boolean}
     */},{key:"isModel",get:function get(){return this._isModel;}/**
     * Returns ````true```` if this Mesh represents an object.
     *
     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#objects} and
     * may also have a corresponding {@link MetaObject}.
     *
     * @type {Boolean}
     */},{key:"isObject",get:function get(){return this._isObject;}/**
     * Gets the Mesh's World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */},{key:"aabb",get:function get(){if(this._aabbDirty){this._updateAABB();}return this._aabb;}/**
     * Gets the 3D origin of the Mesh's {@link Geometry}'s vertex positions.
     *
     * When this is given, then {@link Mesh#matrix}, {@link Mesh#position} and {@link Mesh#geometry} are all assumed to be relative to this center position.
     *
     * @type {Float64Array}
     */},{key:"origin",get:function get(){return this._state.origin;}/**
     * Sets the 3D origin of the Mesh's {@link Geometry}'s vertex positions.
     *
     * When this is given, then {@link Mesh#matrix}, {@link Mesh#position} and {@link Mesh#geometry} are all assumed to be relative to this center position.
     *
     * @type {Float64Array}
     */,set:function set(origin){if(origin){if(!this._state.origin){this._state.origin=math.vec3();}this._state.origin.set(origin);this._state.originHash=origin.join();this._setAABBDirty();this.scene._aabbDirty=true;}else{if(this._state.origin){this._state.origin=null;this._state.originHash=null;this._setAABBDirty();this.scene._aabbDirty=true;}}}/**
     * Gets the World-space origin for this Mesh.
     *
     * Deprecated and replaced by {@link Mesh#origin}.
     *
     * @deprecated
     * @type {Float64Array}
     */},{key:"rtcCenter",get:function get(){return this.origin;}/**
     * Sets the World-space origin for this Mesh.
     *
     * Deprecated and replaced by {@link Mesh#origin}.
     *
     * @deprecated
     * @type {Float64Array}
     */,set:function set(rtcCenter){this.origin=rtcCenter;}/**
     * The approximate number of triangles in this Mesh.
     *
     * @type {Number}
     */},{key:"numTriangles",get:function get(){return this._numTriangles;}/**
     * Gets if this Mesh is visible.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * When {@link Mesh#isObject} and {@link Mesh#visible} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */},{key:"visible",get:function get(){return this._state.visible;}/**
     * Sets if this Mesh is visible.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * When {@link Mesh#isObject} and {@link Mesh#visible} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */,set:function set(visible){visible=visible!==false;this._state.visible=visible;if(this._isObject){this.scene._objectVisibilityUpdated(this,visible);}this.glRedraw();}/**
     * Gets if this Mesh is xrayed.
     *
     * XRayed appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#xrayMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#xrayed} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */},{key:"xrayed",get:function get(){return this._state.xrayed;}/**
     * Sets if this Mesh is xrayed.
     *
     * XRayed appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#xrayMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#xrayed} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */,set:function set(xrayed){xrayed=!!xrayed;if(this._state.xrayed===xrayed){return;}this._state.xrayed=xrayed;if(this._isObject){this.scene._objectXRayedUpdated(this,xrayed);}this.glRedraw();}/**
     * Gets if this Mesh is highlighted.
     *
     * Highlighted appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#highlightMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#highlighted} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */},{key:"highlighted",get:function get(){return this._state.highlighted;}/**
     * Sets if this Mesh is highlighted.
     *
     * Highlighted appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#highlightMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#highlighted} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */,set:function set(highlighted){highlighted=!!highlighted;if(highlighted===this._state.highlighted){return;}this._state.highlighted=highlighted;if(this._isObject){this.scene._objectHighlightedUpdated(this,highlighted);}this.glRedraw();}/**
     * Gets if this Mesh is selected.
     *
     * Selected appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#selectedMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#selected} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */},{key:"selected",get:function get(){return this._state.selected;}/**
     * Sets if this Mesh is selected.
     *
     * Selected appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#selectedMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#selected} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */,set:function set(selected){selected=!!selected;if(selected===this._state.selected){return;}this._state.selected=selected;if(this._isObject){this.scene._objectSelectedUpdated(this,selected);}this.glRedraw();}/**
     * Gets if this Mesh is edge-enhanced.
     *
     * Edge appearance is configured by the {@link EdgeMaterial} referenced by {@link Mesh#edgeMaterial}.
     *
     * @type {Boolean}
     */},{key:"edges",get:function get(){return this._state.edges;}/**
     * Sets if this Mesh is edge-enhanced.
     *
     * Edge appearance is configured by the {@link EdgeMaterial} referenced by {@link Mesh#edgeMaterial}.
     *
     * @type {Boolean}
     */,set:function set(edges){edges=!!edges;if(edges===this._state.edges){return;}this._state.edges=edges;this.glRedraw();}/**
     * Gets if this Mesh is culled.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * @type {Boolean}
     */},{key:"culled",get:function get(){return this._state.culled;}/**
     * Sets if this Mesh is culled.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){this._state.culled=!!value;this.glRedraw();}/**
     * Gets if this Mesh is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */},{key:"clippable",get:function get(){return this._state.clippable;}/**
     * Sets if this Mesh is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(this._state.clippable===value){return;}this._state.clippable=value;this.glRedraw();}/**
     * Gets if this Mesh included in boundary calculations.
     *
     * @type {Boolean}
     */},{key:"collidable",get:function get(){return this._state.collidable;}/**
     * Sets if this Mesh included in boundary calculations.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(value===this._state.collidable){return;}this._state.collidable=value;this._setAABBDirty();this.scene._aabbDirty=true;}//------------------------------------------------------------------------------------------------------------------
// Entity members
//------------------------------------------------------------------------------------------------------------------
/**
     * Gets if this Mesh is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */},{key:"pickable",get:function get(){return this._state.pickable;}/**
     * Sets if this Mesh is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(this._state.pickable===value){return;}this._state.pickable=value;// No need to trigger a render;
// state is only used when picking
}/**
     * Gets if this Mesh casts shadows.
     *
     * @type {Boolean}
     */},{key:"castsShadow",get:function get(){return this._state.castsShadow;}/**
     * Sets if this Mesh casts shadows.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(value===this._state.castsShadow){return;}this._state.castsShadow=value;this.glRedraw();}/**
     * Gets if this Mesh can have shadows cast upon it.
     *
     * @type {Boolean}
     */},{key:"receivesShadow",get:function get(){return this._state.receivesShadow;}/**
     * Sets if this Mesh can have shadows cast upon it.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==false;if(value===this._state.receivesShadow){return;}this._state.receivesShadow=value;this._state.hash=value?"/mod/rs;":"/mod;";this.fire("dirty",this);// Now need to (re)compile objectRenderers to include/exclude shadow mapping
}/**
     * Gets if this Mesh can have Scalable Ambient Obscurance (SAO) applied to it.
     *
     * SAO is configured by {@link SAO}.
     *
     * @type {Boolean}
     * @abstract
     */},{key:"saoEnabled",get:function get(){return false;// TODO: Support SAO on Meshes
}/**
     * Gets the RGB colorize color for this Mesh.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */},{key:"colorize",get:function get(){return this._state.colorize;}/**
     * Sets the RGB colorize color for this Mesh.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */,set:function set(value){var colorize=this._state.colorize;if(!colorize){colorize=this._state.colorize=new Float32Array(4);colorize[3]=1;}if(value){colorize[0]=value[0];colorize[1]=value[1];colorize[2]=value[2];}else{colorize[0]=1;colorize[1]=1;colorize[2]=1;}var colorized=!!value;this.scene._objectColorizeUpdated(this,colorized);this.glRedraw();}/**
     * Gets the opacity factor for this Mesh.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */},{key:"opacity",get:function get(){return this._state.colorize[3];}/**
     * Sets the opacity factor for this Mesh.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(opacity){var colorize=this._state.colorize;if(!colorize){colorize=this._state.colorize=new Float32Array(4);colorize[0]=1;colorize[1]=1;colorize[2]=1;}var opacityUpdated=opacity!==null&&opacity!==undefined;colorize[3]=opacityUpdated?opacity:1.0;this.scene._objectOpacityUpdated(this,opacityUpdated);this.glRedraw();}/**
     * Gets if this Mesh is transparent.
     * @returns {Boolean}
     */},{key:"transparent",get:function get(){return this._material.alphaMode===2/* blend */||this._state.colorize[3]<1;}/**
     * Gets the Mesh's rendering order relative to other Meshes.
     *
     * Default value is ````0````.
     *
     * This can be set on multiple transparent Meshes, to make them render in a specific order for correct alpha blending.
     *
     * @type {Number}
     */},{key:"layer",get:function get(){return this._state.layer;}/**
     * Sets the Mesh's rendering order relative to other Meshes.
     *
     * Default value is ````0````.
     *
     * This can be set on multiple transparent Meshes, to make them render in a specific order for correct alpha blending.
     *
     * @type {Number}
     */,set:function set(value){// TODO: Only accept rendering layer in range [0...MAX_layer]
value=value||0;value=Math.round(value);if(value===this._state.layer){return;}this._state.layer=value;this._renderer.needStateSort();}/**
     * Gets if the Node's position is stationary.
     *
     * When true, will disable the effect of {@link Camera} translations for this Mesh, while still allowing it to rotate. This is useful for skyboxes.
     *
     * @type {Boolean}
     */},{key:"stationary",get:function get(){return this._state.stationary;}/**
     * Gets the Node's billboarding behaviour.
     *
     * Options are:
     * * ````"none"```` -  (default) - No billboarding.
     * * ````"spherical"```` - Mesh is billboarded to face the viewpoint, rotating both vertically and horizontally.
     * * ````"cylindrical"```` - Mesh is billboarded to face the viewpoint, rotating only about its vertically axis. Use this mode for things like trees on a landscape.
     * @type {String}
     */},{key:"billboard",get:function get(){return this._state.billboard;}/**
     * Gets the Mesh's 3D World-space offset.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */},{key:"offset",get:function get(){return this._state.offset;}/**
     * Sets the Mesh's 3D World-space offset.
     *
     * The offset dynamically translates the Mesh in World-space.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * Provide a null or undefined value to reset to the default value.
     *
     * @type {Number[]}
     */,set:function set(value){this._state.offset.set(value||[0,0,0]);this._setAABBDirty();this.glRedraw();}/**
     * Returns true to indicate that Mesh implements {@link Drawable}.
     * @final
     * @type {Boolean}
     */},{key:"isDrawable",get:function get(){return true;}/**
     * Property with final value ````true```` to indicate that xeokit should render this Mesh in sorted order, relative to other Meshes.
     *
     * The sort order is determined by {@link Mesh#stateSortCompare}.
     *
     * Sorting is essential for rendering performance, so that xeokit is able to avoid applying runs of the same state changes to the GPU, ie. can collapse them.
     *
     * @type {Boolean}
     */},{key:"isStateSortable",get:function get(){return true;}/**
     * Defines the appearance of this Mesh when xrayed.
     *
     * Mesh is xrayed when {@link Mesh#xrayed} is ````true````.
     *
     * Set to {@link Scene#xrayMaterial} by default.
     *
     * @type {EmphasisMaterial}
     */},{key:"xrayMaterial",get:function get(){return this._xrayMaterial;}/**
     * Defines the appearance of this Mesh when highlighted.
     *
     * Mesh is xrayed when {@link Mesh#highlighted} is ````true````.
     *
     * Set to {@link Scene#highlightMaterial} by default.
     *
     * @type {EmphasisMaterial}
     */},{key:"highlightMaterial",get:function get(){return this._highlightMaterial;}/**
     * Defines the appearance of this Mesh when selected.
     *
     * Mesh is xrayed when {@link Mesh#selected} is ````true````.
     *
     * Set to {@link Scene#selectedMaterial} by default.
     *
     * @type {EmphasisMaterial}
     */},{key:"selectedMaterial",get:function get(){return this._selectedMaterial;}/**
     * Defines the appearance of this Mesh when edges are enhanced.
     *
     * Mesh is xrayed when {@link Mesh#edges} is ````true````.
     *
     * Set to {@link Scene#edgeMaterial} by default.
     *
     * @type {EdgeMaterial}
     */},{key:"edgeMaterial",get:function get(){return this._edgeMaterial;}},{key:"_checkBillboard",value:function _checkBillboard(value){value=value||"none";if(value!=="spherical"&&value!=="cylindrical"&&value!=="none"){this.error("Unsupported value for 'billboard': "+value+" - accepted values are "+"'spherical', 'cylindrical' and 'none' - defaulting to 'none'.");value="none";}return value;}/**
     * Called by xeokit to compile shaders for this Mesh.
     * @private
     */},{key:"compile",value:function compile(){var drawHash=this._makeDrawHash();if(this._state.drawHash!==drawHash){this._state.drawHash=drawHash;this._putDrawRenderers();this._drawRenderer=DrawRenderer.get(this);// this._shadowRenderer = ShadowRenderer.get(this);
this._emphasisFillRenderer=EmphasisFillRenderer.get(this);this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this);}var pickHash=this._makePickHash();if(this._state.pickHash!==pickHash){this._state.pickHash=pickHash;this._putPickRenderers();this._pickMeshRenderer=PickMeshRenderer.get(this);}if(this._state.occluder){var occlusionHash=this._makeOcclusionHash();if(this._state.occlusionHash!==occlusionHash){this._state.occlusionHash=occlusionHash;this._putOcclusionRenderer();this._occlusionRenderer=OcclusionRenderer.get(this);}}}},{key:"_setLocalMatrixDirty",value:function _setLocalMatrixDirty(){this._localMatrixDirty=true;this._setWorldMatrixDirty();}},{key:"_setWorldMatrixDirty",value:function _setWorldMatrixDirty(){this._worldMatrixDirty=true;this._worldNormalMatrixDirty=true;}},{key:"_buildWorldMatrix",value:function _buildWorldMatrix(){var localMatrix=this.matrix;if(!this._parentNode){for(var _i122=0,len=localMatrix.length;_i122<len;_i122++){this._worldMatrix[_i122]=localMatrix[_i122];}}else{math.mulMat4(this._parentNode.worldMatrix,localMatrix,this._worldMatrix);}this._worldMatrixDirty=false;}},{key:"_buildWorldNormalMatrix",value:function _buildWorldNormalMatrix(){if(this._worldMatrixDirty){this._buildWorldMatrix();}if(!this._worldNormalMatrix){this._worldNormalMatrix=math.mat4();}// Note: order of inverse and transpose doesn't matter
math.transposeMat4(this._worldMatrix,this._worldNormalMatrix);math.inverseMat4(this._worldNormalMatrix);this._worldNormalMatrixDirty=false;}},{key:"_setAABBDirty",value:function _setAABBDirty(){if(this.collidable){for(var _node=this;_node;_node=_node._parentNode){_node._aabbDirty=true;}}}},{key:"_updateAABB",value:function _updateAABB(){this.scene._aabbDirty=true;if(!this._aabb){this._aabb=math.AABB3();}this._buildAABB(this.worldMatrix,this._aabb);// Mesh or VBOSceneModel
this._aabbDirty=false;}},{key:"_webglContextRestored",value:function _webglContextRestored(){if(this._drawRenderer){this._drawRenderer.webglContextRestored();}if(this._shadowRenderer){this._shadowRenderer.webglContextRestored();}if(this._emphasisFillRenderer){this._emphasisFillRenderer.webglContextRestored();}if(this._emphasisEdgesRenderer){this._emphasisEdgesRenderer.webglContextRestored();}if(this._pickMeshRenderer){this._pickMeshRenderer.webglContextRestored();}if(this._pickTriangleRenderer){this._pickMeshRenderer.webglContextRestored();}if(this._occlusionRenderer){this._occlusionRenderer.webglContextRestored();}}},{key:"_makeDrawHash",value:function _makeDrawHash(){var scene=this.scene;var hash=[scene.canvas.canvas.id,(scene.gammaInput?"gi;":";")+(scene.gammaOutput?"go":""),scene._lightsState.getHash(),scene._sectionPlanesState.getHash()];var state=this._state;if(state.stationary){hash.push("/s");}if(state.billboard==="none"){hash.push("/n");}else if(state.billboard==="spherical"){hash.push("/s");}else if(state.billboard==="cylindrical"){hash.push("/c");}if(state.receivesShadow){hash.push("/rs");}hash.push(";");return hash.join("");}},{key:"_makePickHash",value:function _makePickHash(){var scene=this.scene;var hash=[scene.canvas.canvas.id,scene._sectionPlanesState.getHash()];var state=this._state;if(state.stationary){hash.push("/s");}if(state.billboard==="none"){hash.push("/n");}else if(state.billboard==="spherical"){hash.push("/s");}else if(state.billboard==="cylindrical"){hash.push("/c");}hash.push(";");return hash.join("");}},{key:"_makeOcclusionHash",value:function _makeOcclusionHash(){var scene=this.scene;var hash=[scene.canvas.canvas.id,scene._sectionPlanesState.getHash()];var state=this._state;if(state.stationary){hash.push("/s");}if(state.billboard==="none"){hash.push("/n");}else if(state.billboard==="spherical"){hash.push("/s");}else if(state.billboard==="cylindrical"){hash.push("/c");}hash.push(";");return hash.join("");}},{key:"_buildAABB",value:function _buildAABB(worldMatrix,aabb){math.transformOBB3(worldMatrix,this._geometry.obb,obb);math.OBB3ToAABB3(obb,aabb);var offset=this._state.offset;aabb[0]+=offset[0];aabb[1]+=offset[1];aabb[2]+=offset[2];aabb[3]+=offset[0];aabb[4]+=offset[1];aabb[5]+=offset[2];if(this._state.origin){var origin=this._state.origin;aabb[0]+=origin[0];aabb[1]+=origin[1];aabb[2]+=origin[2];aabb[3]+=origin[0];aabb[4]+=origin[1];aabb[5]+=origin[2];}}/**
     * Rotates the Mesh about the given local axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotate",value:function rotate(axis,angle){angleAxis$2[0]=axis[0];angleAxis$2[1]=axis[1];angleAxis$2[2]=axis[2];angleAxis$2[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis$2,q1$2);math.mulQuaternions(this.quaternion,q1$2,q2$2);this.quaternion=q2$2;this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();return this;}/**
     * Rotates the Mesh about the given World-space axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateOnWorldAxis",value:function rotateOnWorldAxis(axis,angle){angleAxis$2[0]=axis[0];angleAxis$2[1]=axis[1];angleAxis$2[2]=axis[2];angleAxis$2[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis$2,q1$2);math.mulQuaternions(q1$2,this.quaternion,q1$2);//this.quaternion.premultiply(q1);
return this;}/**
     * Rotates the Mesh about the local X-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateX",value:function rotateX(angle){return this.rotate(xAxis$2,angle);}/**
     * Rotates the Mesh about the local Y-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateY",value:function rotateY(angle){return this.rotate(yAxis$2,angle);}/**
     * Rotates the Mesh about the local Z-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateZ",value:function rotateZ(angle){return this.rotate(zAxis$2,angle);}/**
     * Translates the Mesh along local space vector by the given increment.
     *
     * @param {Number[]} axis Normalized local space 3D vector along which to translate.
     * @param {Number} distance Distance to translate along  the vector.
     */},{key:"translate",value:function translate(axis,distance){math.vec3ApplyQuaternion(this.quaternion,axis,veca$1);math.mulVec3Scalar(veca$1,distance,vecb$1);math.addVec3(this.position,vecb$1,this.position);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();return this;}//------------------------------------------------------------------------------------------------------------------
// Drawable members
//------------------------------------------------------------------------------------------------------------------
/**
     * Translates the Mesh along the local X-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the X-axis.
     */},{key:"translateX",value:function translateX(distance){return this.translate(xAxis$2,distance);}/**
     * Translates the Mesh along the local Y-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Y-axis.
     */},{key:"translateY",value:function translateY(distance){return this.translate(yAxis$2,distance);}/**
     * Translates the Mesh along the local Z-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Z-axis.
     */},{key:"translateZ",value:function translateZ(distance){return this.translate(zAxis$2,distance);}},{key:"_putDrawRenderers",value:function _putDrawRenderers(){if(this._drawRenderer){this._drawRenderer.put();this._drawRenderer=null;}if(this._shadowRenderer){this._shadowRenderer.put();this._shadowRenderer=null;}if(this._emphasisFillRenderer){this._emphasisFillRenderer.put();this._emphasisFillRenderer=null;}if(this._emphasisEdgesRenderer){this._emphasisEdgesRenderer.put();this._emphasisEdgesRenderer=null;}}},{key:"_putPickRenderers",value:function _putPickRenderers(){if(this._pickMeshRenderer){this._pickMeshRenderer.put();this._pickMeshRenderer=null;}if(this._pickTriangleRenderer){this._pickTriangleRenderer.put();this._pickTriangleRenderer=null;}}},{key:"_putOcclusionRenderer",value:function _putOcclusionRenderer(){if(this._occlusionRenderer){this._occlusionRenderer.put();this._occlusionRenderer=null;}}/**
     * Comparison function used by the renderer to determine the order in which xeokit should render the Mesh, relative to to other Meshes.
     *
     * xeokit requires this method because Mesh implements {@link Drawable}.
     *
     * Sorting is essential for rendering performance, so that xeokit is able to avoid needlessly applying runs of the same rendering state changes to the GPU, ie. can collapse them.
     *
     * @param {Mesh} mesh1
     * @param {Mesh} mesh2
     * @returns {number}
     */},{key:"stateSortCompare",value:function stateSortCompare(mesh1,mesh2){return mesh1._state.layer-mesh2._state.layer||mesh1._drawRenderer.id-mesh2._drawRenderer.id// Program state
||mesh1._material._state.id-mesh2._material._state.id// Material state
||mesh1._geometry._state.id-mesh2._geometry._state.id;// Geometry state
}/** @private */},{key:"rebuildRenderFlags",value:function rebuildRenderFlags(){this.renderFlags.reset();if(!this._getActiveSectionPlanes()){this.renderFlags.culled=true;return;}this.renderFlags.numLayers=1;this.renderFlags.numVisibleLayers=1;this.renderFlags.visibleLayers[0]=0;this._updateRenderFlags();}/**
     * @private
     */},{key:"_updateRenderFlags",value:function _updateRenderFlags(){var renderFlags=this.renderFlags;var state=this._state;if(state.xrayed){var xrayMaterial=this._xrayMaterial._state;if(xrayMaterial.fill){if(xrayMaterial.fillAlpha<1.0){renderFlags.xrayedSilhouetteTransparent=true;}else{renderFlags.xrayedSilhouetteOpaque=true;}}if(xrayMaterial.edges){if(xrayMaterial.edgeAlpha<1.0){renderFlags.xrayedEdgesTransparent=true;}else{renderFlags.xrayedEdgesOpaque=true;}}}else{var normalMaterial=this._material._state;if(normalMaterial.alpha<1.0||state.colorize[3]<1.0){renderFlags.colorTransparent=true;}else{renderFlags.colorOpaque=true;}if(state.edges){var edgeMaterial=this._edgeMaterial._state;if(edgeMaterial.alpha<1.0){renderFlags.edgesTransparent=true;}else{renderFlags.edgesOpaque=true;}}if(state.selected){var selectedMaterial=this._selectedMaterial._state;if(selectedMaterial.fill){if(selectedMaterial.fillAlpha<1.0){renderFlags.selectedSilhouetteTransparent=true;}else{renderFlags.selectedSilhouetteOpaque=true;}}if(selectedMaterial.edges){if(selectedMaterial.edgeAlpha<1.0){renderFlags.selectedEdgesTransparent=true;}else{renderFlags.selectedEdgesOpaque=true;}}}else if(state.highlighted){var highlightMaterial=this._highlightMaterial._state;if(highlightMaterial.fill){if(highlightMaterial.fillAlpha<1.0){renderFlags.highlightedSilhouetteTransparent=true;}else{renderFlags.highlightedSilhouetteOpaque=true;}}if(highlightMaterial.edges){if(highlightMaterial.edgeAlpha<1.0){renderFlags.highlightedEdgesTransparent=true;}else{renderFlags.highlightedEdgesOpaque=true;}}}}}},{key:"_getActiveSectionPlanes",value:function _getActiveSectionPlanes(){if(this._state.clippable){var sectionPlanes=this.scene._sectionPlanesState.sectionPlanes;var numSectionPlanes=sectionPlanes.length;if(numSectionPlanes>0){for(var _i123=0;_i123<numSectionPlanes;_i123++){var sectionPlane=sectionPlanes[_i123];var renderFlags=this.renderFlags;if(!sectionPlane.active){renderFlags.sectionPlanesActivePerLayer[_i123]=false;}else{if(this._state.origin){var intersect=math.planeAABB3Intersect(sectionPlane.dir,sectionPlane.dist,this.aabb);var outside=intersect===-1;if(outside){return false;}var intersecting=intersect===0;renderFlags.sectionPlanesActivePerLayer[_i123]=intersecting;}else{renderFlags.sectionPlanesActivePerLayer[_i123]=true;}}}}}return true;}// ---------------------- NORMAL RENDERING -----------------------------------
/** @private  */},{key:"drawColorOpaque",value:function drawColorOpaque(frameCtx){if(this._drawRenderer||(this._drawRenderer=DrawRenderer.get(this))){this._drawRenderer.drawMesh(frameCtx,this);}}/** @private  */},{key:"drawColorTransparent",value:function drawColorTransparent(frameCtx){if(this._drawRenderer||(this._drawRenderer=DrawRenderer.get(this))){this._drawRenderer.drawMesh(frameCtx,this);}}// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------
// TODO
// ---------------------- EMPHASIS RENDERING -----------------------------------
/** @private  */},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(frameCtx){if(this._emphasisFillRenderer||(this._emphasisFillRenderer=EmphasisFillRenderer.get(this))){this._emphasisFillRenderer.drawMesh(frameCtx,this,0);// 0 == xray
}}/** @private  */},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(frameCtx){if(this._emphasisFillRenderer||(this._emphasisFillRenderer=EmphasisFillRenderer.get(this))){this._emphasisFillRenderer.drawMesh(frameCtx,this,1);// 1 == highlight
}}/** @private  */},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(frameCtx){if(this._emphasisFillRenderer||(this._emphasisFillRenderer=EmphasisFillRenderer.get(this))){this._emphasisFillRenderer.drawMesh(frameCtx,this,2);// 2 == selected
}}// ---------------------- EDGES RENDERING -----------------------------------
/** @private  */},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(frameCtx){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frameCtx,this,3);// 3 == edges
}}/** @private  */},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(frameCtx){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frameCtx,this,3);// 3 == edges
}}/** @private  */},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(frameCtx){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frameCtx,this,0);// 0 == xray
}}/** @private  */},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(frameCtx){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frameCtx,this,1);// 1 == highlight
}}/** @private  */},{key:"drawEdgesSelected",value:function drawEdgesSelected(frameCtx){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frameCtx,this,2);// 2 == selected
}}// ---------------------- OCCLUSION CULL RENDERING -----------------------------------
/** @private  */},{key:"drawOcclusion",value:function drawOcclusion(frameCtx){if(this._state.occluder&&this._occlusionRenderer||(this._occlusionRenderer=OcclusionRenderer.get(this))){this._occlusionRenderer.drawMesh(frameCtx,this);}}// ---------------------- SHADOW BUFFER RENDERING -----------------------------------
/** @private  */},{key:"drawShadow",value:function drawShadow(frameCtx){if(this._shadowRenderer||(this._shadowRenderer=ShadowRenderer.get(this))){this._shadowRenderer.drawMesh(frameCtx,this);}}// ---------------------- PICKING RENDERING ----------------------------------
/** @private  */},{key:"drawPickMesh",value:function drawPickMesh(frameCtx){if(this._pickMeshRenderer||(this._pickMeshRenderer=PickMeshRenderer.get(this))){this._pickMeshRenderer.drawMesh(frameCtx,this);}}/** @private
     */},{key:"canPickTriangle",value:function canPickTriangle(){return this._geometry.isReadableGeometry;// VBOGeometry does not support surface picking because it has no geometry data in browser memory
}/** @private  */},{key:"drawPickTriangles",value:function drawPickTriangles(frameCtx){if(this._pickTriangleRenderer||(this._pickTriangleRenderer=PickTriangleRenderer.get(this))){this._pickTriangleRenderer.drawMesh(frameCtx,this);}}/** @private */},{key:"pickTriangleSurface",value:function pickTriangleSurface(pickViewMatrix,pickProjMatrix,pickResult){_pickTriangleSurface(this,pickViewMatrix,pickProjMatrix,pickResult);}/** @private  */},{key:"drawPickVertices",value:function drawPickVertices(frameCtx){}/**
     * @private
     * @returns {PerformanceNode}
     */},{key:"delegatePickedEntity",value:function delegatePickedEntity(){return this;}//------------------------------------------------------------------------------------------------------------------
// Component members
//------------------------------------------------------------------------------------------------------------------
/**
     * Destroys this Mesh.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Mesh.prototype),"destroy",this).call(this);// xeokit.Object
this._putDrawRenderers();this._putPickRenderers();this._putOcclusionRenderer();this.scene._renderer.putPickID(this._state.pickID);// TODO: somehow puch this down into xeokit framework?
if(this._isObject){this.scene._deregisterObject(this);if(this._visible){this.scene._objectVisibilityUpdated(this,false,false);}if(this._xrayed){this.scene._objectXRayedUpdated(this,false,false);}if(this._selected){this.scene._objectSelectedUpdated(this,false,false);}if(this._highlighted){this.scene._objectHighlightedUpdated(this,false,false);}this.scene._objectColorizeUpdated(this,false);this.scene._objectOpacityUpdated(this,false);if(this.offset.some(function(v){return v!==0;}))this.scene._objectOffsetUpdated(this,false);}if(this._isModel){this.scene._deregisterModel(this);}this.glRedraw();}}]);return Mesh;}(Component);var _pickTriangleSurface=function(){// Cached vars to avoid garbage collection
var localRayOrigin=math.vec3();var localRayDir=math.vec3();var positionA=math.vec3();var positionB=math.vec3();var positionC=math.vec3();var triangleVertices=math.vec3();var position=math.vec4();var worldPos=math.vec3();var viewPos=math.vec3();var bary=math.vec3();var normalA=math.vec3();var normalB=math.vec3();var normalC=math.vec3();var uva=math.vec3();var uvb=math.vec3();var uvc=math.vec3();var tempVec4a=math.vec4();var tempVec4b=math.vec4();var tempVec4c=math.vec4();var tempVec3=math.vec3();var tempVec3b=math.vec3();var tempVec3c=math.vec3();var tempVec3d=math.vec3();var tempVec3e=math.vec3();var tempVec3f=math.vec3();var tempVec3g=math.vec3();var tempVec3h=math.vec3();var tempVec3i=math.vec3();var tempVec3j=math.vec3();var tempVec3k=math.vec3();return function(mesh,pickViewMatrix,pickProjMatrix,pickResult){var primIndex=pickResult.primIndex;if(primIndex!==undefined&&primIndex!==null&&primIndex>-1){var geometry=mesh.geometry._state;var scene=mesh.scene;var camera=scene.camera;var _canvas2=scene.canvas;if(geometry.primitiveName==="triangles"){// Triangle picked; this only happens when the
// Mesh has a Geometry that has primitives of type "triangle"
pickResult.primitive="triangle";// Get the World-space positions of the triangle's vertices
var _i124=primIndex;// Indicates the first triangle index in the indices array
var indices=geometry.indices;// Indices into geometry arrays, not into shared VertexBufs
var positions=geometry.positions;var ia3;var ib3;var ic3;if(indices){var ia=indices[_i124+0];var ib=indices[_i124+1];var ic=indices[_i124+2];triangleVertices[0]=ia;triangleVertices[1]=ib;triangleVertices[2]=ic;pickResult.indices=triangleVertices;ia3=ia*3;ib3=ib*3;ic3=ic*3;}else{ia3=_i124*3;ib3=ia3+3;ic3=ib3+3;}positionA[0]=positions[ia3+0];positionA[1]=positions[ia3+1];positionA[2]=positions[ia3+2];positionB[0]=positions[ib3+0];positionB[1]=positions[ib3+1];positionB[2]=positions[ib3+2];positionC[0]=positions[ic3+0];positionC[1]=positions[ic3+1];positionC[2]=positions[ic3+2];if(geometry.compressGeometry){// Decompress vertex positions
var positionsDecodeMatrix=geometry.positionsDecodeMatrix;if(positionsDecodeMatrix){geometryCompressionUtils.decompressPosition(positionA,positionsDecodeMatrix,positionA);geometryCompressionUtils.decompressPosition(positionB,positionsDecodeMatrix,positionB);geometryCompressionUtils.decompressPosition(positionC,positionsDecodeMatrix,positionC);}}// Attempt to ray-pick the triangle in local space
if(pickResult.canvasPos){math.canvasPosToLocalRay(_canvas2.canvas,mesh.origin?createRTCViewMat(pickViewMatrix,mesh.origin):pickViewMatrix,pickProjMatrix,mesh.worldMatrix,pickResult.canvasPos,localRayOrigin,localRayDir);}else if(pickResult.origin&&pickResult.direction){math.worldRayToLocalRay(mesh.worldMatrix,pickResult.origin,pickResult.direction,localRayOrigin,localRayDir);}math.normalizeVec3(localRayDir);math.rayPlaneIntersect(localRayOrigin,localRayDir,positionA,positionB,positionC,position);// Get Local-space cartesian coordinates of the ray-triangle intersection
pickResult.localPos=position;pickResult.position=position;// Get interpolated World-space coordinates
// Need to transform homogeneous coords
tempVec4a[0]=position[0];tempVec4a[1]=position[1];tempVec4a[2]=position[2];tempVec4a[3]=1;// Get World-space cartesian coordinates of the ray-triangle intersection
math.transformVec4(mesh.worldMatrix,tempVec4a,tempVec4b);worldPos[0]=tempVec4b[0];worldPos[1]=tempVec4b[1];worldPos[2]=tempVec4b[2];if(pickResult.canvasPos&&mesh.origin){worldPos[0]+=mesh.origin[0];worldPos[1]+=mesh.origin[1];worldPos[2]+=mesh.origin[2];}pickResult.worldPos=worldPos;// Get View-space cartesian coordinates of the ray-triangle intersection
math.transformVec4(camera.matrix,tempVec4b,tempVec4c);viewPos[0]=tempVec4c[0];viewPos[1]=tempVec4c[1];viewPos[2]=tempVec4c[2];pickResult.viewPos=viewPos;// Get barycentric coordinates of the ray-triangle intersection
math.cartesianToBarycentric(position,positionA,positionB,positionC,bary);pickResult.bary=bary;// Get interpolated normal vector
var normals=geometry.normals;if(normals){if(geometry.compressGeometry){// Decompress vertex normals
var ia2=ia*3;var ib2=ib*3;var ic2=ic*3;geometryCompressionUtils.decompressNormal(normals.subarray(ia2,ia2+2),normalA);geometryCompressionUtils.decompressNormal(normals.subarray(ib2,ib2+2),normalB);geometryCompressionUtils.decompressNormal(normals.subarray(ic2,ic2+2),normalC);}else{normalA[0]=normals[ia3];normalA[1]=normals[ia3+1];normalA[2]=normals[ia3+2];normalB[0]=normals[ib3];normalB[1]=normals[ib3+1];normalB[2]=normals[ib3+2];normalC[0]=normals[ic3];normalC[1]=normals[ic3+1];normalC[2]=normals[ic3+2];}var normal=math.addVec3(math.addVec3(math.mulVec3Scalar(normalA,bary[0],tempVec3),math.mulVec3Scalar(normalB,bary[1],tempVec3b),tempVec3c),math.mulVec3Scalar(normalC,bary[2],tempVec3d),tempVec3e);pickResult.worldNormal=math.normalizeVec3(math.transformVec3(mesh.worldNormalMatrix,normal,tempVec3f));}// Get interpolated UV coordinates
var uvs=geometry.uv;if(uvs){uva[0]=uvs[ia*2];uva[1]=uvs[ia*2+1];uvb[0]=uvs[ib*2];uvb[1]=uvs[ib*2+1];uvc[0]=uvs[ic*2];uvc[1]=uvs[ic*2+1];if(geometry.compressGeometry){// Decompress vertex UVs
var uvDecodeMatrix=geometry.uvDecodeMatrix;if(uvDecodeMatrix){geometryCompressionUtils.decompressUV(uva,uvDecodeMatrix,uva);geometryCompressionUtils.decompressUV(uvb,uvDecodeMatrix,uvb);geometryCompressionUtils.decompressUV(uvc,uvDecodeMatrix,uvc);}}pickResult.uv=math.addVec3(math.addVec3(math.mulVec2Scalar(uva,bary[0],tempVec3g),math.mulVec2Scalar(uvb,bary[1],tempVec3h),tempVec3i),math.mulVec2Scalar(uvc,bary[2],tempVec3j),tempVec3k);}}}};}();/**
 * @desc Creates a cylinder-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a cylinder-shaped {@link ReadableGeometry} :
 *
 * [[Run this example](/examples/#geometry_builders_buildCylinderGeometry)]
 *
 * ````javascript
 *
 * import {Viewer, Mesh, buildCylinderGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 *  });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildCylinderGeometry({
 *          center: [0,0,0],
 *          radiusTop: 2.0,
 *          radiusBottom: 2.0,
 *          height: 5.0,
 *          radialSegments: 20,
 *          heightSegments: 1,
 *          openEnded: false
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildCylinderGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.radiusTop=1]  Radius of top.
 * @param {Number} [cfg.radiusBottom=1]  Radius of bottom.
 * @param {Number} [cfg.height=1] Height.
 * @param {Number} [cfg.radialSegments=60]  Number of horizontal segments.
 * @param {Number} [cfg.heightSegments=1]  Number of vertical segments.
 * @param {Boolean} [cfg.openEnded=false]  Whether or not the cylinder has solid caps on the ends.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildCylinderGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var radiusTop=cfg.radiusTop||1;if(radiusTop<0){console.error("negative radiusTop not allowed - will invert");radiusTop*=-1;}var radiusBottom=cfg.radiusBottom||1;if(radiusBottom<0){console.error("negative radiusBottom not allowed - will invert");radiusBottom*=-1;}var height=cfg.height||1;if(height<0){console.error("negative height not allowed - will invert");height*=-1;}var radialSegments=cfg.radialSegments||32;if(radialSegments<0){console.error("negative radialSegments not allowed - will invert");radialSegments*=-1;}if(radialSegments<3){radialSegments=3;}var heightSegments=cfg.heightSegments||1;if(heightSegments<0){console.error("negative heightSegments not allowed - will invert");heightSegments*=-1;}if(heightSegments<1){heightSegments=1;}var openEnded=!!cfg.openEnded;var center=cfg.center;var centerX=center?center[0]:0;var centerY=center?center[1]:0;var centerZ=center?center[2]:0;var heightHalf=height/2;var heightLength=height/heightSegments;var radialAngle=2.0*Math.PI/radialSegments;var radialLength=1.0/radialSegments;//var nextRadius = this._radiusBottom;
var radiusChange=(radiusTop-radiusBottom)/heightSegments;var positions=[];var normals=[];var uvs=[];var indices=[];var h;var i;var x;var z;var currentRadius;var currentHeight;var first;var second;var startIndex;var tu;var tv;// create vertices
var normalY=(90.0-Math.atan(height/(radiusBottom-radiusTop))*180/Math.PI)/90.0;for(h=0;h<=heightSegments;h++){currentRadius=radiusTop-h*radiusChange;currentHeight=heightHalf-h*heightLength;for(i=0;i<=radialSegments;i++){x=Math.sin(i*radialAngle);z=Math.cos(i*radialAngle);normals.push(currentRadius*x);normals.push(normalY);//todo
normals.push(currentRadius*z);uvs.push(i*radialLength);uvs.push(h*1/heightSegments);positions.push(currentRadius*x+centerX);positions.push(currentHeight+centerY);positions.push(currentRadius*z+centerZ);}}// create faces
for(h=0;h<heightSegments;h++){for(i=0;i<=radialSegments;i++){first=h*(radialSegments+1)+i;second=first+radialSegments;indices.push(first);indices.push(second);indices.push(second+1);indices.push(first);indices.push(second+1);indices.push(first+1);}}// create top cap
if(!openEnded&&radiusTop>0){startIndex=positions.length/3;// top center
normals.push(0.0);normals.push(1.0);normals.push(0.0);uvs.push(0.5);uvs.push(0.5);positions.push(0+centerX);positions.push(heightHalf+centerY);positions.push(0+centerZ);// top triangle fan
for(i=0;i<=radialSegments;i++){x=Math.sin(i*radialAngle);z=Math.cos(i*radialAngle);tu=0.5*Math.sin(i*radialAngle)+0.5;tv=0.5*Math.cos(i*radialAngle)+0.5;normals.push(radiusTop*x);normals.push(1.0);normals.push(radiusTop*z);uvs.push(tu);uvs.push(tv);positions.push(radiusTop*x+centerX);positions.push(heightHalf+centerY);positions.push(radiusTop*z+centerZ);}for(i=0;i<radialSegments;i++){center=startIndex;first=startIndex+1+i;indices.push(first);indices.push(first+1);indices.push(center);}}// create bottom cap
if(!openEnded&&radiusBottom>0){startIndex=positions.length/3;// top center
normals.push(0.0);normals.push(-1.0);normals.push(0.0);uvs.push(0.5);uvs.push(0.5);positions.push(0+centerX);positions.push(0-heightHalf+centerY);positions.push(0+centerZ);// top triangle fan
for(i=0;i<=radialSegments;i++){x=Math.sin(i*radialAngle);z=Math.cos(i*radialAngle);tu=0.5*Math.sin(i*radialAngle)+0.5;tv=0.5*Math.cos(i*radialAngle)+0.5;normals.push(radiusBottom*x);normals.push(-1.0);normals.push(radiusBottom*z);uvs.push(tu);uvs.push(tv);positions.push(radiusBottom*x+centerX);positions.push(0-heightHalf+centerY);positions.push(radiusBottom*z+centerZ);}for(i=0;i<radialSegments;i++){center=startIndex;first=startIndex+1+i;indices.push(center);indices.push(first+1);indices.push(first);}}return utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices});}/**
 * @desc Creates a sphere-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a sphere-shaped {@link ReadableGeometry} :
 *
 * [[Run this example](/examples/#geometry_builders_buildSphereGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          center: [0,0,0],
 *          radius: 1.5,
 *          heightSegments: 60,
 *          widthSegments: 60
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildSphereGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.radius=1]  Radius.
 * @param {Number} [cfg.heightSegments=24] Number of latitudinal bands.
 * @param  {Number} [cfg.widthSegments=18] Number of longitudinal bands.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildSphereGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var lod=cfg.lod||1;var centerX=cfg.center?cfg.center[0]:0;var centerY=cfg.center?cfg.center[1]:0;var centerZ=cfg.center?cfg.center[2]:0;var radius=cfg.radius||1;if(radius<0){console.error("negative radius not allowed - will invert");radius*=-1;}var heightSegments=cfg.heightSegments||18;if(heightSegments<0){console.error("negative heightSegments not allowed - will invert");heightSegments*=-1;}heightSegments=Math.floor(lod*heightSegments);if(heightSegments<18){heightSegments=18;}var widthSegments=cfg.widthSegments||18;if(widthSegments<0){console.error("negative widthSegments not allowed - will invert");widthSegments*=-1;}widthSegments=Math.floor(lod*widthSegments);if(widthSegments<18){widthSegments=18;}var positions=[];var normals=[];var uvs=[];var indices=[];var i;var j;var theta;var sinTheta;var cosTheta;var phi;var sinPhi;var cosPhi;var x;var y;var z;var u;var v;var first;var second;for(i=0;i<=heightSegments;i++){theta=i*Math.PI/heightSegments;sinTheta=Math.sin(theta);cosTheta=Math.cos(theta);for(j=0;j<=widthSegments;j++){phi=j*2*Math.PI/widthSegments;sinPhi=Math.sin(phi);cosPhi=Math.cos(phi);x=cosPhi*sinTheta;y=cosTheta;z=sinPhi*sinTheta;u=1.0-j/widthSegments;v=i/heightSegments;normals.push(x);normals.push(y);normals.push(z);uvs.push(u);uvs.push(v);positions.push(centerX+radius*x);positions.push(centerY+radius*y);positions.push(centerZ+radius*z);}}for(i=0;i<heightSegments;i++){for(j=0;j<widthSegments;j++){first=i*(widthSegments+1)+j;second=first+widthSegments+1;indices.push(first+1);indices.push(second+1);indices.push(second);indices.push(first+1);indices.push(second);indices.push(first);}}return utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices});}var letters={' ':{width:16,points:[]},'!':{width:10,points:[[5,21],[5,7],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]]},'"':{width:16,points:[[4,21],[4,14],[-1,-1],[12,21],[12,14]]},'#':{width:21,points:[[11,25],[4,-7],[-1,-1],[17,25],[10,-7],[-1,-1],[4,12],[18,12],[-1,-1],[3,6],[17,6]]},'$':{width:20,points:[[8,25],[8,-4],[-1,-1],[12,25],[12,-4],[-1,-1],[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]]},'%':{width:24,points:[[21,21],[3,0],[-1,-1],[8,21],[10,19],[10,17],[9,15],[7,14],[5,14],[3,16],[3,18],[4,20],[6,21],[8,21],[10,20],[13,19],[16,19],[19,20],[21,21],[-1,-1],[17,7],[15,6],[14,4],[14,2],[16,0],[18,0],[20,1],[21,3],[21,5],[19,7],[17,7]]},'&':{width:26,points:[[23,12],[23,13],[22,14],[21,14],[20,13],[19,11],[17,6],[15,3],[13,1],[11,0],[7,0],[5,1],[4,2],[3,4],[3,6],[4,8],[5,9],[12,13],[13,14],[14,16],[14,18],[13,20],[11,21],[9,20],[8,18],[8,16],[9,13],[11,10],[16,3],[18,1],[20,0],[22,0],[23,1],[23,2]]},'\'':{width:10,points:[[5,19],[4,20],[5,21],[6,20],[6,18],[5,16],[4,15]]},'(':{width:14,points:[[11,25],[9,23],[7,20],[5,16],[4,11],[4,7],[5,2],[7,-2],[9,-5],[11,-7]]},')':{width:14,points:[[3,25],[5,23],[7,20],[9,16],[10,11],[10,7],[9,2],[7,-2],[5,-5],[3,-7]]},'*':{width:16,points:[[8,21],[8,9],[-1,-1],[3,18],[13,12],[-1,-1],[13,18],[3,12]]},'+':{width:26,points:[[13,18],[13,0],[-1,-1],[4,9],[22,9]]},',':{width:10,points:[[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]]},'-':{width:26,points:[[4,9],[22,9]]},'.':{width:10,points:[[5,2],[4,1],[5,0],[6,1],[5,2]]},'/':{width:22,points:[[20,25],[2,-7]]},'0':{width:20,points:[[9,21],[6,20],[4,17],[3,12],[3,9],[4,4],[6,1],[9,0],[11,0],[14,1],[16,4],[17,9],[17,12],[16,17],[14,20],[11,21],[9,21]]},'1':{width:20,points:[[6,17],[8,18],[11,21],[11,0]]},'2':{width:20,points:[[4,16],[4,17],[5,19],[6,20],[8,21],[12,21],[14,20],[15,19],[16,17],[16,15],[15,13],[13,10],[3,0],[17,0]]},'3':{width:20,points:[[5,21],[16,21],[10,13],[13,13],[15,12],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]]},'4':{width:20,points:[[13,21],[3,7],[18,7],[-1,-1],[13,21],[13,0]]},'5':{width:20,points:[[15,21],[5,21],[4,12],[5,13],[8,14],[11,14],[14,13],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]]},'6':{width:20,points:[[16,18],[15,20],[12,21],[10,21],[7,20],[5,17],[4,12],[4,7],[5,3],[7,1],[10,0],[11,0],[14,1],[16,3],[17,6],[17,7],[16,10],[14,12],[11,13],[10,13],[7,12],[5,10],[4,7]]},'7':{width:20,points:[[17,21],[7,0],[-1,-1],[3,21],[17,21]]},'8':{width:20,points:[[8,21],[5,20],[4,18],[4,16],[5,14],[7,13],[11,12],[14,11],[16,9],[17,7],[17,4],[16,2],[15,1],[12,0],[8,0],[5,1],[4,2],[3,4],[3,7],[4,9],[6,11],[9,12],[13,13],[15,14],[16,16],[16,18],[15,20],[12,21],[8,21]]},'9':{width:20,points:[[16,14],[15,11],[13,9],[10,8],[9,8],[6,9],[4,11],[3,14],[3,15],[4,18],[6,20],[9,21],[10,21],[13,20],[15,18],[16,14],[16,9],[15,4],[13,1],[10,0],[8,0],[5,1],[4,3]]},':':{width:10,points:[[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]]},';':{width:10,points:[[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]]},'<':{width:24,points:[[20,18],[4,9],[20,0]]},'=':{width:26,points:[[4,12],[22,12],[-1,-1],[4,6],[22,6]]},'>':{width:24,points:[[4,18],[20,9],[4,0]]},'?':{width:18,points:[[3,16],[3,17],[4,19],[5,20],[7,21],[11,21],[13,20],[14,19],[15,17],[15,15],[14,13],[13,12],[9,10],[9,7],[-1,-1],[9,2],[8,1],[9,0],[10,1],[9,2]]},'@':{width:27,points:[[18,13],[17,15],[15,16],[12,16],[10,15],[9,14],[8,11],[8,8],[9,6],[11,5],[14,5],[16,6],[17,8],[-1,-1],[12,16],[10,14],[9,11],[9,8],[10,6],[11,5],[-1,-1],[18,16],[17,8],[17,6],[19,5],[21,5],[23,7],[24,10],[24,12],[23,15],[22,17],[20,19],[18,20],[15,21],[12,21],[9,20],[7,19],[5,17],[4,15],[3,12],[3,9],[4,6],[5,4],[7,2],[9,1],[12,0],[15,0],[18,1],[20,2],[21,3],[-1,-1],[19,16],[18,8],[18,6],[19,5]]},'A':{width:18,points:[[9,21],[1,0],[-1,-1],[9,21],[17,0],[-1,-1],[4,7],[14,7]]},'B':{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[-1,-1],[4,11],[13,11],[16,10],[17,9],[18,7],[18,4],[17,2],[16,1],[13,0],[4,0]]},'C':{width:21,points:[[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5]]},'D':{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[11,21],[14,20],[16,18],[17,16],[18,13],[18,8],[17,5],[16,3],[14,1],[11,0],[4,0]]},'E':{width:19,points:[[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11],[-1,-1],[4,0],[17,0]]},'F':{width:18,points:[[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11]]},'G':{width:21,points:[[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[18,8],[-1,-1],[13,8],[18,8]]},'H':{width:22,points:[[4,21],[4,0],[-1,-1],[18,21],[18,0],[-1,-1],[4,11],[18,11]]},'I':{width:8,points:[[4,21],[4,0]]},'J':{width:16,points:[[12,21],[12,5],[11,2],[10,1],[8,0],[6,0],[4,1],[3,2],[2,5],[2,7]]},'K':{width:21,points:[[4,21],[4,0],[-1,-1],[18,21],[4,7],[-1,-1],[9,12],[18,0]]},'L':{width:17,points:[[4,21],[4,0],[-1,-1],[4,0],[16,0]]},'M':{width:24,points:[[4,21],[4,0],[-1,-1],[4,21],[12,0],[-1,-1],[20,21],[12,0],[-1,-1],[20,21],[20,0]]},'N':{width:22,points:[[4,21],[4,0],[-1,-1],[4,21],[18,0],[-1,-1],[18,21],[18,0]]},'O':{width:22,points:[[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21]]},'P':{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,14],[17,12],[16,11],[13,10],[4,10]]},'Q':{width:22,points:[[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21],[-1,-1],[12,4],[18,-2]]},'R':{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[4,11],[-1,-1],[11,11],[18,0]]},'S':{width:20,points:[[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]]},'T':{width:16,points:[[8,21],[8,0],[-1,-1],[1,21],[15,21]]},'U':{width:22,points:[[4,21],[4,6],[5,3],[7,1],[10,0],[12,0],[15,1],[17,3],[18,6],[18,21]]},'V':{width:18,points:[[1,21],[9,0],[-1,-1],[17,21],[9,0]]},'W':{width:24,points:[[2,21],[7,0],[-1,-1],[12,21],[7,0],[-1,-1],[12,21],[17,0],[-1,-1],[22,21],[17,0]]},'X':{width:20,points:[[3,21],[17,0],[-1,-1],[17,21],[3,0]]},'Y':{width:18,points:[[1,21],[9,11],[9,0],[-1,-1],[17,21],[9,11]]},'Z':{width:20,points:[[17,21],[3,0],[-1,-1],[3,21],[17,21],[-1,-1],[3,0],[17,0]]},'[':{width:14,points:[[4,25],[4,-7],[-1,-1],[5,25],[5,-7],[-1,-1],[4,25],[11,25],[-1,-1],[4,-7],[11,-7]]},'\\':{width:14,points:[[0,21],[14,-3]]},']':{width:14,points:[[9,25],[9,-7],[-1,-1],[10,25],[10,-7],[-1,-1],[3,25],[10,25],[-1,-1],[3,-7],[10,-7]]},'^':{width:16,points:[[6,15],[8,18],[10,15],[-1,-1],[3,12],[8,17],[13,12],[-1,-1],[8,17],[8,0]]},'_':{width:16,points:[[0,-2],[16,-2]]},'`':{width:10,points:[[6,21],[5,20],[4,18],[4,16],[5,15],[6,16],[5,17]]},'a':{width:19,points:[[15,14],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},'b':{width:19,points:[[4,21],[4,0],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]]},'c':{width:18,points:[[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},'d':{width:19,points:[[15,21],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},'e':{width:18,points:[[3,8],[15,8],[15,10],[14,12],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},'f':{width:12,points:[[10,21],[8,21],[6,20],[5,17],[5,0],[-1,-1],[2,14],[9,14]]},'g':{width:19,points:[[15,14],[15,-2],[14,-5],[13,-6],[11,-7],[8,-7],[6,-6],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},'h':{width:19,points:[[4,21],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]]},'i':{width:8,points:[[3,21],[4,20],[5,21],[4,22],[3,21],[-1,-1],[4,14],[4,0]]},'j':{width:10,points:[[5,21],[6,20],[7,21],[6,22],[5,21],[-1,-1],[6,14],[6,-3],[5,-6],[3,-7],[1,-7]]},'k':{width:17,points:[[4,21],[4,0],[-1,-1],[14,14],[4,4],[-1,-1],[8,8],[15,0]]},'l':{width:8,points:[[4,21],[4,0]]},'m':{width:30,points:[[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0],[-1,-1],[15,10],[18,13],[20,14],[23,14],[25,13],[26,10],[26,0]]},'n':{width:19,points:[[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]]},'o':{width:19,points:[[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3],[16,6],[16,8],[15,11],[13,13],[11,14],[8,14]]},'p':{width:19,points:[[4,14],[4,-7],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]]},'q':{width:19,points:[[15,14],[15,-7],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},'r':{width:13,points:[[4,14],[4,0],[-1,-1],[4,8],[5,11],[7,13],[9,14],[12,14]]},'s':{width:17,points:[[14,11],[13,13],[10,14],[7,14],[4,13],[3,11],[4,9],[6,8],[11,7],[13,6],[14,4],[14,3],[13,1],[10,0],[7,0],[4,1],[3,3]]},'t':{width:12,points:[[5,21],[5,4],[6,1],[8,0],[10,0],[-1,-1],[2,14],[9,14]]},'u':{width:19,points:[[4,14],[4,4],[5,1],[7,0],[10,0],[12,1],[15,4],[-1,-1],[15,14],[15,0]]},'v':{width:16,points:[[2,14],[8,0],[-1,-1],[14,14],[8,0]]},'w':{width:22,points:[[3,14],[7,0],[-1,-1],[11,14],[7,0],[-1,-1],[11,14],[15,0],[-1,-1],[19,14],[15,0]]},'x':{width:17,points:[[3,14],[14,0],[-1,-1],[14,14],[3,0]]},'y':{width:16,points:[[2,14],[8,0],[-1,-1],[14,14],[8,0],[6,-4],[4,-6],[2,-7],[1,-7]]},'z':{width:17,points:[[14,14],[3,0],[-1,-1],[3,14],[14,14],[-1,-1],[3,0],[14,0]]},'{':{width:14,points:[[9,25],[7,24],[6,23],[5,21],[5,19],[6,17],[7,16],[8,14],[8,12],[6,10],[-1,-1],[7,24],[6,22],[6,20],[7,18],[8,17],[9,15],[9,13],[8,11],[4,9],[8,7],[9,5],[9,3],[8,1],[7,0],[6,-2],[6,-4],[7,-6],[-1,-1],[6,8],[8,6],[8,4],[7,2],[6,1],[5,-1],[5,-3],[6,-5],[7,-6],[9,-7]]},'|':{width:8,points:[[4,25],[4,-7]]},'}':{width:14,points:[[5,25],[7,24],[8,23],[9,21],[9,19],[8,17],[7,16],[6,14],[6,12],[8,10],[-1,-1],[7,24],[8,22],[8,20],[7,18],[6,17],[5,15],[5,13],[6,11],[10,9],[6,7],[5,5],[5,3],[6,1],[7,0],[8,-2],[8,-4],[7,-6],[-1,-1],[8,8],[6,6],[6,4],[7,2],[8,1],[9,-1],[9,-3],[8,-5],[7,-6],[5,-7]]},'~':{width:24,points:[[3,6],[3,8],[4,11],[6,12],[8,12],[10,11],[14,8],[16,7],[18,7],[20,8],[21,10],[-1,-1],[3,8],[4,10],[6,11],[8,11],[10,10],[14,7],[16,6],[18,6],[20,7],[21,10],[21,12]]}};/**
 * @desc Creates wireframe vector text {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with vector text {@link ReadableGeometry} :
 *
 * [[Run this example](/examples/#geometry_builders_buildVectorTextGeometry)]
 *
 * ````javascript
 *
 * import {Viewer, Mesh, buildVectorTextGeometry, ReadableGeometry, PhongMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 100];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildVectorTextGeometry({
 *          origin: [0,0,0],
 *          text: "On the other side of the screen, it all looked so easy"
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildVectorTextGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number[]} [cfg.origin] 3D point indicating the top left corner.
 * @param {Number} [cfg.size=1] Size of each character.
 * @param {String} [cfg.text=""] The text.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildVectorTextGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var origin=cfg.origin||[0,0,0];var xOrigin=origin[0];var yOrigin=origin[1];var zOrigin=origin[2];var size=cfg.size||1;var positions=[];var indices=[];var text=cfg.text;if(utils.isNumeric(text)){text=""+text;}var lines=(text||"").split("\n");var countVerts=0;var y=0;var x;var str;var len;var c;var mag=1.0/25.0;var penUp;var p1;var p2;var pointsLen;var a;for(var iLine=0;iLine<lines.length;iLine++){x=0;str=lines[iLine];len=str.length;for(var i=0;i<len;i++){c=letters[str.charAt(i)];if(!c){continue;}penUp=1;p1=-1;p2=-1;pointsLen=c.points.length;for(var j=0;j<pointsLen;j++){a=c.points[j];if(a[0]===-1&&a[1]===-1){penUp=1;continue;}positions.push(x+a[0]*size*mag+xOrigin);positions.push(y+a[1]*size*mag+yOrigin);positions.push(0+zOrigin);if(p1===-1){p1=countVerts;}else if(p2===-1){p2=countVerts;}else{p1=p2;p2=countVerts;}countVerts++;if(penUp){penUp=false;}else{indices.push(p1);indices.push(p2);}}x+=c.width*mag*size;}y-=35*mag*size;}return utils.apply(cfg,{primitive:"lines",positions:positions,indices:indices});}/**
 * {@link Viewer} plugin that shows the axii of the World-space coordinate system.
 *
 * ## Usage
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_AxisGizmoPlugin)]
 *
 * ````JavaScript````
 * import {Viewer, XKTLoaderPlugin, AxisGizmoPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * new AxisGizmoPlugin(viewer, {
 *     canvasId: "myAxisGizmoCanvas"
 * });
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "../assets/models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 * ````
 */var AxisGizmoPlugin=/*#__PURE__*/function(_Plugin3){_inherits(AxisGizmoPlugin,_Plugin3);var _super35=_createSuper(AxisGizmoPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="AxisGizmo"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} [cfg.canvasId] ID of an existing HTML canvas to display the AxisGizmo - either this or canvasElement is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLCanvasElement} [cfg.canvasElement] Reference of an existing HTML canvas to display the AxisGizmo - either this or canvasId is mandatory. When both values are given, the element reference is always preferred to the ID.
     */function AxisGizmoPlugin(viewer,cfg){var _this54;_classCallCheck(this,AxisGizmoPlugin);cfg=cfg||{};_this54=_super35.call(this,"AxisGizmo",viewer,cfg);var camera=viewer.scene.camera;if(!cfg.canvasId&&!cfg.canvasElement){_this54.error("Config expected: either 'canvasId' or 'canvasElement'");}try{_this54._axisGizmoScene=new Scene(viewer,{canvasId:cfg.canvasId,canvasElement:cfg.canvasElement,transparent:true});}catch(error){_this54.error(error);return _possibleConstructorReturn(_this54);}var axisGizmoScene=_this54._axisGizmoScene;axisGizmoScene.clearLights();new AmbientLight(axisGizmoScene,{color:[0.45,0.45,0.5],intensity:0.9});new DirLight(axisGizmoScene,{dir:[-0.5,0.5,-0.6],color:[0.8,0.8,0.7],intensity:1.0,space:"view"});new DirLight(axisGizmoScene,{dir:[0.5,-0.5,-0.6],color:[0.8,0.8,0.8],intensity:1.0,space:"view"});// Rotate helper in synch with target camera
var helperCamera=axisGizmoScene.camera;camera.on("matrix",function(){var eye=camera.eye;var look=camera.look;var up=camera.up;var eyeLook=math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye,look,[])),22);helperCamera.look=[0,0,0];helperCamera.eye=eyeLook;helperCamera.up=up;});// ----------------- Components that are shared among more than one mesh ---------------
var arrowHead=new ReadableGeometry(axisGizmoScene,buildCylinderGeometry({radiusTop:0.01,radiusBottom:0.6,height:1.7,radialSegments:20,heightSegments:1,openEnded:false}));var arrowShaft=new ReadableGeometry(axisGizmoScene,buildCylinderGeometry({radiusTop:0.2,radiusBottom:0.2,height:4.5,radialSegments:20,heightSegments:1,openEnded:false}));var xAxisMaterial=new PhongMaterial(axisGizmoScene,{// Red by convention
diffuse:[1,0.3,0.3],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});var xAxisLabelMaterial=new PhongMaterial(axisGizmoScene,{// Red by convention
emissive:[1,0.3,0.3],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});var yAxisMaterial=new PhongMaterial(axisGizmoScene,{// Green by convention
diffuse:[0.3,1,0.3],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});var yAxisLabelMaterial=new PhongMaterial(axisGizmoScene,{// Green by convention
emissive:[0.3,1,0.3],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});var zAxisMaterial=new PhongMaterial(axisGizmoScene,{// Blue by convention
diffuse:[0.3,0.3,1],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});var zAxisLabelMaterial=new PhongMaterial(axisGizmoScene,{emissive:[0.3,0.3,1],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});var ballMaterial=new PhongMaterial(axisGizmoScene,{diffuse:[0.5,0.5,0.5],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2});// ----------------- Meshes ------------------------------
_this54._meshes=[// Sphere behind gnomon
new Mesh(axisGizmoScene,{geometry:new ReadableGeometry(axisGizmoScene,buildSphereGeometry({radius:9.0,heightSegments:60,widthSegments:60})),material:new PhongMaterial(axisGizmoScene,{diffuse:[0.0,0.0,0.0],emissive:[0.1,0.1,0.1],ambient:[0.1,0.1,0.2],specular:[0,0,0],alpha:0.4,alphaMode:"blend",frontface:"cw"}),pickable:false,collidable:false,visible:cfg.visible!==false}),// Ball at center of axis
new Mesh(axisGizmoScene,{// Arrow
geometry:new ReadableGeometry(axisGizmoScene,buildSphereGeometry({radius:1.0})),material:ballMaterial,pickable:false,collidable:false,visible:cfg.visible!==false}),// X-axis arrow, shaft and label
new Mesh(axisGizmoScene,{// Arrow
geometry:arrowHead,material:xAxisMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[5,0,0],rotation:[0,0,-90]}),new Mesh(axisGizmoScene,{// Shaft
geometry:arrowShaft,material:xAxisMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[2,0,0],rotation:[0,0,90]}),new Mesh(axisGizmoScene,{// Label
geometry:new ReadableGeometry(axisGizmoScene,buildVectorTextGeometry({text:"X",size:1.5})),material:xAxisLabelMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[7,0,0],billboard:"spherical"}),// Y-axis arrow, shaft and label
new Mesh(axisGizmoScene,{// Arrow
geometry:arrowHead,material:yAxisMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[0,5,0]}),new Mesh(axisGizmoScene,{// Shaft
geometry:arrowShaft,material:yAxisMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[0,2,0]}),new Mesh(axisGizmoScene,{// Label
geometry:new ReadableGeometry(axisGizmoScene,buildVectorTextGeometry({text:"Y",size:1.5})),material:yAxisLabelMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[0,7,0],billboard:"spherical"}),// Z-axis arrow, shaft and label
new Mesh(axisGizmoScene,{// Arrow
geometry:arrowHead,material:zAxisMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[0,0,5],rotation:[90,0,0]}),new Mesh(axisGizmoScene,{// Shaft
geometry:arrowShaft,material:zAxisMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[0,0,2],rotation:[90,0,0]}),new Mesh(axisGizmoScene,{// Label
geometry:new ReadableGeometry(axisGizmoScene,buildVectorTextGeometry({text:"Z",size:1.5})),material:zAxisLabelMaterial,pickable:false,collidable:false,visible:cfg.visible!==false,position:[0,0,7],billboard:"spherical"})];return _this54;}/** Shows or hides this AxisGizmoPlugin.
     *
     * @param visible
     */_createClass(AxisGizmoPlugin,[{key:"setVisible",value:function setVisible(visible){for(var _i125=0;_i125<this._meshes.length;_i125++){this._meshes[_i125].visible=visible;}}/**
     * Destroys this AxisGizmoPlugin.
     */},{key:"destroy",value:function destroy(){this._axisGizmoCanvas=null;this._axisGizmoScene.destroy();this._axisGizmoScene=null;_get(_getPrototypeOf(AxisGizmoPlugin.prototype),"destroy",this).call(this);}}]);return AxisGizmoPlugin;}(Plugin);math.vec3();/**
 *  @desc An arbitrarily-aligned World-space clipping plane.
 *
 * * Slices portions off objects to create cross-section views or reveal interiors.
 * * Registered by {@link SectionPlane#id} in {@link Scene#sectionPlanes}.
 * * Indicates World-space position in {@link SectionPlane#pos} and orientation in {@link SectionPlane#dir}.
 * * Discards elements from the half-space in the direction of {@link SectionPlane#dir}.
 * * Can be be enabled or disabled via {@link SectionPlane#active}.
 *
 * ## Usage
 *
 * In the example below, we'll create two SectionPlanes to slice a model loaded from glTF. Note that we could also create them
 * using a {@link SectionPlanesPlugin}.
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin, SectionPlane} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * const gltfLoaderPlugin = new GLTFModelsPlugin(viewer, {
 *      id: "GLTFModels"
 * });
 *
 * const model = gltfLoaderPlugin.load({
 *      id: "myModel",
 *      src: "./models/gltf/mygltfmodel.gltf"
 * });
 *
 * // Create a SectionPlane on negative diagonal
 * const sectionPlane1 = new SectionPlane(viewer.scene, {
 *     pos: [1.0, 1.0, 1.0],
 *     dir: [-1.0, -1.0, -1.0],
 *     active: true
 * }),
 *
 * // Create a SectionPlane on positive diagonal
 * const sectionPlane2 = new SectionPlane(viewer.scene, {
 *     pos: [-1.0, -1.0, -1.0],
 *     dir: [1.0, 1.0, 1.0],
 *     active: true
 * });
 * ````
 */var SectionPlane=/*#__PURE__*/function(_Component22){_inherits(SectionPlane,_Component22);var _super36=_createSuper(SectionPlane);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this SectionPlane as well.
     * @param {*} [cfg]  SectionPlane configuration
     * @param  {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Boolean} [cfg.active=true] Indicates whether or not this SectionPlane is active.
     * @param {Number[]} [cfg.pos=[0,0,0]] World-space position of the SectionPlane.
     * @param {Number[]} [cfg.dir=[0,0,-1]] Vector perpendicular to the plane surface, indicating the SectionPlane plane orientation.
     */function SectionPlane(owner){var _this55;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SectionPlane);_this55=_super36.call(this,owner,cfg);_this55._state=new RenderState({active:true,pos:math.vec3(),dir:math.vec3(),dist:0});_this55.active=cfg.active;_this55.pos=cfg.pos;_this55.dir=cfg.dir;_this55.scene._sectionPlaneCreated(_assertThisInitialized(_this55));return _this55;}/**
     * Sets if this SectionPlane is active or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate else ````false```` to deactivate.
     */_createClass(SectionPlane,[{key:"type",get:/**
     @private
     */function get(){return"SectionPlane";}},{key:"active",get:/**
     * Gets if this SectionPlane is active or not.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if active.
     */function get(){return this._state.active;}/**
     * Sets the World-space position of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param {Number[]} value New position.
     */,set:function set(value){this._state.active=value!==false;this.glRedraw();this.fire("active",this._state.active);}},{key:"pos",get:/**
     * Gets the World-space position of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @returns {Number[]} Current position.
     */function get(){return this._state.pos;}/**
     * Sets the direction of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @param {Number[]} value New direction.
     */,set:function set(value){this._state.pos.set(value||[0,0,0]);this._state.dist=-math.dotVec3(this._state.pos,this._state.dir);this.fire("pos",this._state.pos);this.scene.fire("sectionPlaneUpdated",this);}},{key:"dir",get:/**
     * Gets the direction of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @returns {Number[]} value Current direction.
     */function get(){return this._state.dir;}/**
     * Gets this SectionPlane's distance to the origin of the World-space coordinate system.
     *
     * This is the dot product of {@link SectionPlane#pos} and {@link SectionPlane#dir} and is automatically re-calculated
     * each time either of two properties are updated.
     *
     * @returns {Number}
     */,set:function set(value){this._state.dir.set(value||[0,0,-1]);this._state.dist=-math.dotVec3(this._state.pos,this._state.dir);this.glRedraw();this.fire("dir",this._state.dir);this.scene.fire("sectionPlaneUpdated",this);}},{key:"dist",get:function get(){return this._state.dist;}/**
     * Inverts the direction of {@link SectionPlane#dir}.
     */},{key:"flipDir",value:function flipDir(){var dir=this._state.dir;dir[0]*=-1.0;dir[1]*=-1.0;dir[2]*=-1.0;this._state.dist=-math.dotVec3(this._state.pos,this._state.dir);this.fire("dir",this._state.dir);this.glRedraw();}/**
     * @destroy
     */},{key:"destroy",value:function destroy(){this._state.destroy();this.scene._sectionPlaneDestroyed(this);_get(_getPrototypeOf(SectionPlane.prototype),"destroy",this).call(this);}}]);return SectionPlane;}(Component);var angleAxis$1=math.vec4(4);var q1$1=math.vec4();var q2$1=math.vec4();var xAxis$1=math.vec3([1,0,0]);var yAxis$1=math.vec3([0,1,0]);var zAxis$1=math.vec3([0,0,1]);var veca=math.vec3(3);var vecb=math.vec3(3);var identityMat$1=math.identityMat4();/**
 * @desc An {@link Entity} that is a scene graph node that can have child Nodes and {@link Mesh}es.
 *
 * ## Usage
 *
 * The example below is the same as the one given for {@link Mesh}, since the two classes work together. In this example,
 * we'll create a scene graph in which a root Node represents a group and the {@link Mesh}s are leaves. Since Node
 * implements {@link Entity}, we can designate the root Node as a model, causing it to be registered by its ID in {@link Scene#models}.
 *
 * Since {@link Mesh} also implements {@link Entity}, we can designate the leaf {@link Mesh}es as objects, causing them to
 * be registered by their IDs in {@link Scene#objects}.
 *
 * We can then find those {@link Entity} types in {@link Scene#models} and {@link Scene#objects}.
 *
 * We can also update properties of our object-Meshes via calls to {@link Scene#setObjectsHighlighted} etc.
 *
 * [[Run this example](/examples/#sceneRepresentation_SceneGraph)]
 *
 * ````javascript
 * import {Viewer, Mesh, Node, PhongMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * new Node(viewer.scene, {
 *      id: "table",
 *      isModel: true, // <---------- Node represents a model, so is registered by ID in viewer.scene.models
 *      rotation: [0, 50, 0],
 *      position: [0, 0, 0],
 *      scale: [1, 1, 1],
 *
 *      children: [
 *
 *          new Mesh(viewer.scene, { // Red table leg
 *              id: "redLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1, 0.3, 0.3]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, { // Green table leg
 *              id: "greenLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 1.0, 0.3]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, {// Blue table leg
 *              id: "blueLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 0.3, 1.0]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, {  // Yellow table leg
 *              id: "yellowLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                   diffuse: [1.0, 1.0, 0.0]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, { // Purple table top
 *              id: "tableTop",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [0, -3, 0],
 *              scale: [6, 0.5, 6],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1.0, 0.3, 1.0]
 *              })
 *          })
 *      ]
 *  });
 *
 * // Find Nodes and Meshes by their IDs
 *
 * var table = viewer.scene.models["table"];                // Since table Node has isModel == true
 *
 * var redLeg = viewer.scene.objects["redLeg"];             // Since the Meshes have isObject == true
 * var greenLeg = viewer.scene.objects["greenLeg"];
 * var blueLeg = viewer.scene.objects["blueLeg"];
 *
 * // Highlight one of the table leg Meshes
 *
 * viewer.scene.setObjectsHighlighted(["redLeg"], true);    // Since the Meshes have isObject == true
 *
 * // Periodically update transforms on our Nodes and Meshes
 *
 * viewer.scene.on("tick", function () {
 *
 *       // Rotate legs
 *       redLeg.rotateY(0.5);
 *       greenLeg.rotateY(0.5);
 *       blueLeg.rotateY(0.5);
 *
 *       // Rotate table
 *       table.rotateY(0.5);
 *       table.rotateX(0.3);
 *   });
 * ````
 *
 * ## Metadata
 *
 * As mentioned, we can also associate {@link MetaModel}s and {@link MetaObject}s with our Nodes and {@link Mesh}es,
 * within a {@link MetaScene}. See {@link MetaScene} for an example.
 *
 * @implements {Entity}
 */var Node$2=/*#__PURE__*/function(_Component23){_inherits(Node$2,_Component23);var _super37=_createSuper(Node$2);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent scene, generated automatically when omitted.
     * @param {Boolean} [cfg.isModel] Specify ````true```` if this Mesh represents a model, in which case the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and may also have a corresponding {@link MetaModel} with matching {@link MetaModel#id}, registered by that ID in {@link MetaScene#metaModels}.
     * @param {Boolean} [cfg.isObject] Specify ````true```` if this Mesh represents an object, in which case the Mesh will be registered by {@link Mesh#id} in {@link Scene#objects} and may also have a corresponding {@link MetaObject} with matching {@link MetaObject#id}, registered by that ID in {@link MetaScene#metaObjects}.
     * @param {Node} [cfg.parent] The parent Node.
     * @param {Number[]} [cfg.origin] World-space origin for this Node.
     * @param {Number[]} [cfg.rtcCenter] Deprecated - renamed to ````origin````.
     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position.
     * @param {Number[]} [cfg.scale=[1,1,1]] Local scale.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1] Local modelling transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Number[]} [cfg.offset=[0,0,0]] World-space 3D translation offset. Translates the Node in World space, after modelling transforms.
     * @param {Boolean} [cfg.visible=true] Indicates if the Node is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the Node is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the Node is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the Node is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the Node is initially included in boundary calculations.
     * @param {Boolean} [cfg.castsShadow=true] Indicates if the Node initially casts shadows.
     * @param {Boolean} [cfg.receivesShadow=true]  Indicates if the Node initially receives shadows.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the Node is initially xrayed.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the Node is initially highlighted.
     * @param {Boolean} [cfg.selected=false] Indicates if the Mesh is initially selected.
     * @param {Boolean} [cfg.edges=false] Indicates if the Node's edges are initially emphasized.
     * @param {Number[]} [cfg.colorize=[1.0,1.0,1.0]] Node's initial RGB colorize color, multiplies by the rendered fragment colors.
     * @param {Number} [cfg.opacity=1.0] Node's initial opacity factor, multiplies by the rendered fragment alpha.
     * @param {Array} [cfg.children] Child Nodes or {@link Mesh}es to add initially. Children must be in the same {@link Scene} and will be removed first from whatever parents they may already have.
     * @param {Boolean} [cfg.inheritStates=true] Indicates if children given to this constructor should inherit rendering state from this parent as they are added. Rendering state includes {@link Node#visible}, {@link Node#culled}, {@link Node#pickable}, {@link Node#clippable}, {@link Node#castsShadow}, {@link Node#receivesShadow}, {@link Node#selected}, {@link Node#highlighted}, {@link Node#colorize} and {@link Node#opacity}.
     */function Node$2(owner){var _this56;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Node$2);_this56=_super37.call(this,owner,cfg);_this56._parentNode=null;_this56._children=[];_this56._aabb=null;_this56._aabbDirty=true;_this56.scene._aabbDirty=true;_this56._numTriangles=0;_this56._scale=math.vec3();_this56._quaternion=math.identityQuaternion();_this56._rotation=math.vec3();_this56._position=math.vec3();_this56._offset=math.vec3();_this56._localMatrix=math.identityMat4();_this56._worldMatrix=math.identityMat4();_this56._localMatrixDirty=true;_this56._worldMatrixDirty=true;if(cfg.matrix){_this56.matrix=cfg.matrix;}else{_this56.scale=cfg.scale;_this56.position=cfg.position;if(cfg.quaternion);else{_this56.rotation=cfg.rotation;}}_this56._isModel=cfg.isModel;if(_this56._isModel){_this56.scene._registerModel(_assertThisInitialized(_this56));}_this56._isObject=cfg.isObject;if(_this56._isObject){_this56.scene._registerObject(_assertThisInitialized(_this56));}_this56.origin=cfg.origin;_this56.visible=cfg.visible;_this56.culled=cfg.culled;_this56.pickable=cfg.pickable;_this56.clippable=cfg.clippable;_this56.collidable=cfg.collidable;_this56.castsShadow=cfg.castsShadow;_this56.receivesShadow=cfg.receivesShadow;_this56.xrayed=cfg.xrayed;_this56.highlighted=cfg.highlighted;_this56.selected=cfg.selected;_this56.edges=cfg.edges;_this56.colorize=cfg.colorize;_this56.opacity=cfg.opacity;_this56.offset=cfg.offset;// Add children, which inherit state from this Node
if(cfg.children){var children=cfg.children;for(var _i126=0,len=children.length;_i126<len;_i126++){_this56.addChild(children[_i126],cfg.inheritStates);}}if(cfg.parentId){var parentNode=_this56.scene.components[cfg.parentId];if(!parentNode){_this56.error("Parent not found: '"+cfg.parentId+"'");}else if(!parentNode.isNode){_this56.error("Parent is not a Node: '"+cfg.parentId+"'");}else{parentNode.addChild(_assertThisInitialized(_this56));}}else if(cfg.parent){if(!cfg.parent.isNode){_this56.error("Parent is not a Node");}cfg.parent.addChild(_assertThisInitialized(_this56));}return _this56;}//------------------------------------------------------------------------------------------------------------------
// Entity members
//------------------------------------------------------------------------------------------------------------------
/**
     * Returns true to indicate that this Component is an Entity.
     * @type {Boolean}
     */_createClass(Node$2,[{key:"isEntity",get:function get(){return true;}/**
     * Returns ````true```` if this Mesh represents a model.
     *
     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and
     * may also have a corresponding {@link MetaModel}.
     *
     * @type {Boolean}
     */},{key:"isModel",get:function get(){return this._isModel;}/**
     * Returns ````true```` if this Node represents an object.
     *
     * When ````true```` the Node will be registered by {@link Node#id} in
     * {@link Scene#objects} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.
     *
     * @type {Boolean}
     * @abstract
     */},{key:"isObject",get:function get(){return this._isObject;}/**
     * Gets the Node's World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */},{key:"aabb",get:function get(){if(this._aabbDirty){this._updateAABB();}return this._aabb;}/**
     * Sets the World-space origin for this Node.
     *
     * @type {Float64Array}
     */},{key:"origin",get:/**
     *  Gets the World-space origin for this Node.
     *
     * @type {Float64Array}
     */function get(){return this._origin;}/**
     * Sets the World-space origin for this Node.
     *
     * Deprecated and replaced by {@link Node#origin}.
     *
     * @deprecated
     * @type {Float64Array}
     */,set:function set(origin){if(origin){if(!this._origin){this._origin=math.vec3();}this._origin.set(origin);}else{if(this._origin){this._origin=null;}}for(var _i127=0,len=this._children.length;_i127<len;_i127++){this._children[_i127].origin=origin;}this.glRedraw();}},{key:"rtcCenter",get:/**
     * Gets the World-space origin for this Node.
     *
     * Deprecated and replaced by {@link Node#origin}.
     *
     * @deprecated
     * @type {Float64Array}
     */function get(){return this.origin;}/**
     * The number of triangles in this Node.
     *
     * @type {Number}
     */,set:function set(rtcCenter){this.origin=rtcCenter;}},{key:"numTriangles",get:function get(){return this._numTriangles;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are visible.
     *
     * Only rendered both {@link Node#visible} is ````true```` and {@link Node#culled} is ````false````.
     *
     * When {@link Node#isObject} and {@link Node#visible} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */},{key:"visible",get:/**
     * Gets if this Node is visible.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * When {@link Node#isObject} and {@link Node#visible} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */function get(){return this._visible;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are xrayed.
     *
     * When {@link Node#isObject} and {@link Node#xrayed} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */,set:function set(visible){visible=visible!==false;this._visible=visible;for(var _i128=0,len=this._children.length;_i128<len;_i128++){this._children[_i128].visible=visible;}if(this._isObject){this.scene._objectVisibilityUpdated(this,visible);}}},{key:"xrayed",get:/**
     * Gets if this Node is xrayed.
     *
     * When {@link Node#isObject} and {@link Node#xrayed} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#xrayedObjects}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._xrayed;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are highlighted.
     *
     * When {@link Node#isObject} and {@link Node#highlighted} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */,set:function set(xrayed){xrayed=!!xrayed;this._xrayed=xrayed;for(var _i129=0,len=this._children.length;_i129<len;_i129++){this._children[_i129].xrayed=xrayed;}if(this._isObject){this.scene._objectXRayedUpdated(this,xrayed);}}},{key:"highlighted",get:/**
     * Gets if this Node is highlighted.
     *
     * When {@link Node#isObject} and {@link Node#highlighted} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#highlightedObjects}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._highlighted;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are selected.
     *
     * When {@link Node#isObject} and {@link Node#selected} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */,set:function set(highlighted){highlighted=!!highlighted;this._highlighted=highlighted;for(var _i130=0,len=this._children.length;_i130<len;_i130++){this._children[_i130].highlighted=highlighted;}if(this._isObject){this.scene._objectHighlightedUpdated(this,highlighted);}}},{key:"selected",get:/**
     * Gets if this Node is selected.
     *
     * When {@link Node#isObject} and {@link Node#selected} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#selectedObjects}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._selected;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are edge-enhanced.
     *
     * @type {Boolean}
     */,set:function set(selected){selected=!!selected;this._selected=selected;for(var _i131=0,len=this._children.length;_i131<len;_i131++){this._children[_i131].selected=selected;}if(this._isObject){this.scene._objectSelectedUpdated(this,selected);}}},{key:"edges",get:/**
     * Gets if this Node's edges are enhanced.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._edges;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are culled.
     *
     * @type {Boolean}
     */,set:function set(edges){edges=!!edges;this._edges=edges;for(var _i132=0,len=this._children.length;_i132<len;_i132++){this._children[_i132].edges=edges;}}},{key:"culled",get:/**
     * Gets if this Node is culled.
     *
     * @type {Boolean}
     */function get(){return this._culled;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#clips}.
     *
     * @type {Boolean}
     */,set:function set(culled){culled=!!culled;this._culled=culled;for(var _i133=0,len=this._children.length;_i133<len;_i133++){this._children[_i133].culled=culled;}}},{key:"clippable",get:/**
     * Gets if this Node is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#clips}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._clippable;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are included in boundary calculations.
     *
     * @type {Boolean}
     */,set:function set(clippable){clippable=clippable!==false;this._clippable=clippable;for(var _i134=0,len=this._children.length;_i134<len;_i134++){this._children[_i134].clippable=clippable;}}},{key:"collidable",get:/**
     * Gets if this Node is included in boundary calculations.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._collidable;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es are pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */,set:function set(collidable){collidable=collidable!==false;this._collidable=collidable;for(var _i135=0,len=this._children.length;_i135<len;_i135++){this._children[_i135].collidable=collidable;}}},{key:"pickable",get:/**
     * Gets if to this Node is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._pickable;}/**
     * Sets the RGB colorize color for this Node and all child Nodes and {@link Mesh}es}.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */,set:function set(pickable){pickable=pickable!==false;this._pickable=pickable;for(var _i136=0,len=this._children.length;_i136<len;_i136++){this._children[_i136].pickable=pickable;}}},{key:"colorize",get:/**
     * Gets the RGB colorize color for this Node.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Number[]}
     */function get(){return this._colorize.slice(0,3);}/**
     * Sets the opacity factor for this Node and all child Nodes and {@link Mesh}es.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(rgb){var colorize=this._colorize;if(!colorize){colorize=this._colorize=new Float32Array(4);colorize[3]=1.0;}if(rgb){colorize[0]=rgb[0];colorize[1]=rgb[1];colorize[2]=rgb[2];}else{colorize[0]=1;colorize[1]=1;colorize[2]=1;}for(var _i137=0,len=this._children.length;_i137<len;_i137++){this._children[_i137].colorize=colorize;}if(this._isObject){var colorized=!!rgb;this.scene._objectColorizeUpdated(this,colorized);}}},{key:"opacity",get:/**
     * Gets this Node's opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Number}
     */function get(){return this._colorize[3];}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es cast shadows.
     *
     * @type {Boolean}
     */,set:function set(opacity){var colorize=this._colorize;if(!colorize){colorize=this._colorize=new Float32Array(4);colorize[0]=1;colorize[1]=1;colorize[2]=1;}colorize[3]=opacity!==null&&opacity!==undefined?opacity:1.0;for(var _i138=0,len=this._children.length;_i138<len;_i138++){this._children[_i138].opacity=opacity;}if(this._isObject){var opacityUpdated=opacity!==null&&opacity!==undefined;this.scene._objectOpacityUpdated(this,opacityUpdated);}}},{key:"castsShadow",get:/**
     * Gets if this Node casts shadows.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._castsShadow;}/**
     * Sets if this Node and all child Nodes and {@link Mesh}es can have shadows cast upon them.
     *
     * @type {Boolean}
     */,set:function set(castsShadow){castsShadow=!!castsShadow;this._castsShadow=castsShadow;for(var _i139=0,len=this._children.length;_i139<len;_i139++){this._children[_i139].castsShadow=castsShadow;}}},{key:"receivesShadow",get:/**
     * Whether or not to this Node can have shadows cast upon it.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */function get(){return this._receivesShadow;}/**
     * Gets if this Node can have Scalable Ambient Obscurance (SAO) applied to it.
     *
     * SAO is configured by {@link SAO}.
     *
     * @type {Boolean}
     * @abstract
     */,set:function set(receivesShadow){receivesShadow=!!receivesShadow;this._receivesShadow=receivesShadow;for(var _i140=0,len=this._children.length;_i140<len;_i140++){this._children[_i140].receivesShadow=receivesShadow;}}},{key:"saoEnabled",get:function get(){return false;// TODO: Support SAO on Nodes
}/**
     * Sets the 3D World-space offset for this Node and all child Nodes and {@link Mesh}es}.
     *
     * The offset dynamically translates those components in World-space.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * Note that child Nodes and {@link Mesh}es may subsequently be given different values for this property.
     *
     * @type {Number[]}
     */},{key:"offset",get:/**
     * Gets the Node's 3D World-space offset.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Number[]}
     */function get(){return this._offset;}//------------------------------------------------------------------------------------------------------------------
// Node members
//------------------------------------------------------------------------------------------------------------------
/**
     * Returns true to indicate that this Component is a Node.
     * @type {Boolean}
     */,set:function set(offset){if(offset){this._offset[0]=offset[0];this._offset[1]=offset[1];this._offset[2]=offset[2];}else{this._offset[0]=0;this._offset[1]=0;this._offset[2]=0;}for(var _i141=0,len=this._children.length;_i141<len;_i141++){this._children[_i141].offset=this._offset;}if(this._isObject){this.scene._objectOffsetUpdated(this,offset);}}},{key:"isNode",get:function get(){return true;}},{key:"_setLocalMatrixDirty",value:function _setLocalMatrixDirty(){this._localMatrixDirty=true;this._setWorldMatrixDirty();}},{key:"_setWorldMatrixDirty",value:function _setWorldMatrixDirty(){this._worldMatrixDirty=true;for(var _i142=0,len=this._children.length;_i142<len;_i142++){this._children[_i142]._setWorldMatrixDirty();}}},{key:"_buildWorldMatrix",value:function _buildWorldMatrix(){var localMatrix=this.matrix;if(!this._parentNode){for(var _i143=0,len=localMatrix.length;_i143<len;_i143++){this._worldMatrix[_i143]=localMatrix[_i143];}}else{math.mulMat4(this._parentNode.worldMatrix,localMatrix,this._worldMatrix);}this._worldMatrixDirty=false;}},{key:"_setSubtreeAABBsDirty",value:function _setSubtreeAABBsDirty(node){node._aabbDirty=true;if(node._children){for(var _i144=0,len=node._children.length;_i144<len;_i144++){this._setSubtreeAABBsDirty(node._children[_i144]);}}}},{key:"_setAABBDirty",value:function _setAABBDirty(){this._setSubtreeAABBsDirty(this);if(this.collidable){for(var _node2=this;_node2;_node2=_node2._parentNode){_node2._aabbDirty=true;}}}},{key:"_updateAABB",value:function _updateAABB(){this.scene._aabbDirty=true;if(!this._aabb){this._aabb=math.AABB3();}if(this._buildAABB){this._buildAABB(this.worldMatrix,this._aabb);// Mesh or VBOSceneModel
}else{// Node | Node | Model
math.collapseAABB3(this._aabb);var _node3;for(var _i145=0,len=this._children.length;_i145<len;_i145++){_node3=this._children[_i145];if(!_node3.collidable){continue;}math.expandAABB3(this._aabb,_node3.aabb);}}this._aabbDirty=false;}/**
     * Adds a child Node or {@link Mesh}.
     *
     * The child must be a Node or {@link Mesh} in the same {@link Scene}.
     *
     * If the child already has a parent, will be removed from that parent first.
     *
     * Does nothing if already a child.
     *
     * @param {Node|Mesh|String} child Instance or ID of the child to add.
     * @param [inheritStates=false] Indicates if the child should inherit rendering states from this parent as it is added. Rendering state includes {@link Node#visible}, {@link Node#culled}, {@link Node#pickable}, {@link Node#clippable}, {@link Node#castsShadow}, {@link Node#receivesShadow}, {@link Node#selected}, {@link Node#highlighted}, {@link Node#colorize} and {@link Node#opacity}.
     * @returns {Node|Mesh} The child.
     */},{key:"addChild",value:function addChild(child,inheritStates){if(utils.isNumeric(child)||utils.isString(child)){var nodeId=child;child=this.scene.component[nodeId];if(!child){this.warn("Component not found: "+utils.inQuotes(nodeId));return;}if(!child.isNode&&!child.isMesh){this.error("Not a Node or Mesh: "+nodeId);return;}}else{if(!child.isNode&&!child.isMesh){this.error("Not a Node or Mesh: "+child.id);return;}if(child._parentNode){if(child._parentNode.id===this.id){this.warn("Already a child: "+child.id);return;}child._parentNode.removeChild(child);}}child.id;if(child.scene.id!==this.scene.id){this.error("Child not in same Scene: "+child.id);return;}this._children.push(child);child._parentNode=this;if(!!inheritStates){child.visible=this.visible;child.culled=this.culled;child.xrayed=this.xrayed;child.highlited=this.highlighted;child.selected=this.selected;child.edges=this.edges;child.clippable=this.clippable;child.pickable=this.pickable;child.collidable=this.collidable;child.castsShadow=this.castsShadow;child.receivesShadow=this.receivesShadow;child.colorize=this.colorize;child.opacity=this.opacity;child.offset=this.offset;}child._setWorldMatrixDirty();child._setAABBDirty();this._numTriangles+=child.numTriangles;return child;}/**
     * Removes the given child Node or {@link Mesh}.
     *
     * @param {Node|Mesh} child Child to remove.
     */},{key:"removeChild",value:function removeChild(child){for(var _i146=0,len=this._children.length;_i146<len;_i146++){if(this._children[_i146].id===child.id){child._parentNode=null;this._children=this._children.splice(_i146,1);child._setWorldMatrixDirty();child._setAABBDirty();this._setAABBDirty();this._numTriangles-=child.numTriangles;return;}}}/**
     * Removes all child Nodes and {@link Mesh}es.
     */},{key:"removeChildren",value:function removeChildren(){var child;for(var _i147=0,len=this._children.length;_i147<len;_i147++){child=this._children[_i147];child._parentNode=null;child._setWorldMatrixDirty();child._setAABBDirty();this._numTriangles-=child.numTriangles;}this._children=[];this._setAABBDirty();}/**
     * Number of child Nodes or {@link Mesh}es.
     *
     * @type {Number}
     */},{key:"numChildren",get:function get(){return this._children.length;}/**
     * Array of child Nodes or {@link Mesh}es.
     *
     * @type {Array}
     */},{key:"children",get:function get(){return this._children;}/**
     * The parent Node.
     *
     * The parent Node may also be set by passing the Node to the parent's {@link Node#addChild} method.
     *
     * @type {Node}
     */},{key:"parent",get:/**
     * The parent Node.
     *
     * @type {Node}
     */function get(){return this._parentNode;}/**
     * Sets the Node's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(node){if(utils.isNumeric(node)||utils.isString(node)){var nodeId=node;node=this.scene.components[nodeId];if(!node){this.warn("Node not found: "+utils.inQuotes(nodeId));return;}if(!node.isNode){this.error("Not a Node: "+node.id);return;}}if(node.scene.id!==this.scene.id){this.error("Node not in same Scene: "+node.id);return;}if(this._parentNode&&this._parentNode.id===node.id){this.warn("Already a child of Node: "+node.id);return;}node.addChild(this);}},{key:"position",get:/**
     * Gets the Node's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */function get(){return this._position;}/**
     * Sets the Node's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._position.set(value||[0,0,0]);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}},{key:"rotation",get:/**
     * Gets the Node's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */function get(){return this._rotation;}/**
     * Sets the Node's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._rotation.set(value||[0,0,0]);math.eulerToQuaternion(this._rotation,"XYZ",this._quaternion);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}},{key:"quaternion",get:/**
     * Gets the Node's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */function get(){return this._quaternion;}/**
     * Sets the Node's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._quaternion.set(value||[0,0,0,1]);math.quaternionToEuler(this._quaternion,"XYZ",this._rotation);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}},{key:"scale",get:/**
     * Gets the Node's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */function get(){return this._scale;}/**
     * Sets the Node's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._scale.set(value||[1,1,1]);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();}},{key:"matrix",get:/**
     * Gets the Node's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */function get(){if(this._localMatrixDirty){if(!this._localMatrix){this._localMatrix=math.identityMat4();}math.composeMat4(this._position,this._quaternion,this._scale,this._localMatrix);this._localMatrixDirty=false;}return this._localMatrix;}/**
     * Gets the Node's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */,set:function set(value){if(!this._localMatrix){this._localMatrix=math.identityMat4();}this._localMatrix.set(value||identityMat$1);math.decomposeMat4(this._localMatrix,this._position,this._quaternion,this._scale);this._localMatrixDirty=false;this._setWorldMatrixDirty();this._setAABBDirty();this.glRedraw();}},{key:"worldMatrix",get:function get(){if(this._worldMatrixDirty){this._buildWorldMatrix();}return this._worldMatrix;}/**
     * Rotates the Node about the given local axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotate",value:function rotate(axis,angle){angleAxis$1[0]=axis[0];angleAxis$1[1]=axis[1];angleAxis$1[2]=axis[2];angleAxis$1[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis$1,q1$1);math.mulQuaternions(this.quaternion,q1$1,q2$1);this.quaternion=q2$1;this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();return this;}/**
     * Rotates the Node about the given World-space axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateOnWorldAxis",value:function rotateOnWorldAxis(axis,angle){angleAxis$1[0]=axis[0];angleAxis$1[1]=axis[1];angleAxis$1[2]=axis[2];angleAxis$1[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis$1,q1$1);math.mulQuaternions(q1$1,this.quaternion,q1$1);//this.quaternion.premultiply(q1);
return this;}/**
     * Rotates the Node about the local X-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateX",value:function rotateX(angle){return this.rotate(xAxis$1,angle);}/**
     * Rotates the Node about the local Y-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateY",value:function rotateY(angle){return this.rotate(yAxis$1,angle);}/**
     * Rotates the Node about the local Z-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateZ",value:function rotateZ(angle){return this.rotate(zAxis$1,angle);}/**
     * Translates the Node along local space vector by the given increment.
     *
     * @param {Number[]} axis Normalized local space 3D vector along which to translate.
     * @param {Number} distance Distance to translate along  the vector.
     */},{key:"translate",value:function translate(axis,distance){math.vec3ApplyQuaternion(this.quaternion,axis,veca);math.mulVec3Scalar(veca,distance,vecb);math.addVec3(this.position,vecb,this.position);this._setLocalMatrixDirty();this._setAABBDirty();this.glRedraw();return this;}/**
     * Translates the Node along the local X-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the X-axis.
     */},{key:"translateX",value:function translateX(distance){return this.translate(xAxis$1,distance);}/**
     * Translates the Node along the local Y-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Y-axis.
     */},{key:"translateY",value:function translateY(distance){return this.translate(yAxis$1,distance);}/**
     * Translates the Node along the local Z-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Z-axis.
     */},{key:"translateZ",value:function translateZ(distance){return this.translate(zAxis$1,distance);}//------------------------------------------------------------------------------------------------------------------
// Component members
//------------------------------------------------------------------------------------------------------------------
/**
     @private
     */},{key:"type",get:function get(){return"Node";}/**
     * Destroys this Node.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Node$2.prototype),"destroy",this).call(this);if(this._parentNode){this._parentNode.removeChild(this);}if(this._isObject){this.scene._deregisterObject(this);if(this._visible){this.scene._objectVisibilityUpdated(this,false,false);}if(this._xrayed){this.scene._objectXRayedUpdated(this,false,false);}if(this._selected){this.scene._objectSelectedUpdated(this,false,false);}if(this._highlighted){this.scene._objectHighlightedUpdated(this,false,false);}this.scene._objectColorizeUpdated(this,false);this.scene._objectOpacityUpdated(this,false);if(this.offset.some(function(v){return v!==0;}))this.scene._objectOffsetUpdated(this,false);}if(this._isModel){this.scene._deregisterModel(this);}if(this._children.length){// Clone the _children before iterating, so our children don't mess us up when calling removeChild().
var tempChildList=this._children.splice();var child;for(var _i148=0,len=tempChildList.length;_i148<len;_i148++){child=tempChildList[_i148];child.destroy();}}this._children=[];this._setAABBDirty();this.scene._aabbDirty=true;}}]);return Node$2;}(Component);/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the non-realistic but GPU-efficient <a href="https://en.wikipedia.org/wiki/Lambertian_reflectance">Lambertian</a> flat shading model for calculating reflectance.
 *
 * * Useful for efficiently rendering non-realistic objects for high-detail CAD.
 * * Use  {@link PhongMaterial} when you need specular highlights.
 * * Use the physically-based {@link MetallicMaterial} or {@link SpecularMaterial} when you need more realism.
 * * For LambertMaterial, the illumination calculation is performed at each triangle vertex, and the resulting color is interpolated across the face of the triangle. For {@link PhongMaterial}, {@link MetallicMaterial} and
 * {@link SpecularMaterial}, vertex normals are interpolated across the surface of the triangle, and the illumination calculation is performed at each texel.
 *
 * ## Usage
 *
 * [[Run this example](/examples/#materials_LambertMaterial)]
 *
 * In the example below we'll create a {@link Mesh} with a shape defined by a {@link buildTorusGeometry} and normal rendering appearance configured with a LambertMaterial.
 *
 * ```` javascript
 * import {Viewer, Mesh, buildTorusGeometry, ReadableGeometry, LambertMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 12,
 *          tubeSegments: 8,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new LambertMaterial(viewer.scene, {
 *          ambient: [0.3, 0.3, 0.3],
 *          color: [0.5, 0.5, 0.0],
 *          alpha: 1.0, // Default
 *          lineWidth: 1,
 *          pointSize: 1,
 *          backfaces: false,
 *          frontFace: "ccw"
 *      })
 *  });
 * ````
 *
 * ## LambertMaterial Properties
 *
 * The following table summarizes LambertMaterial properties:
 *
 *  | Property | Type | Range | Default Value | Space | Description |
 *  |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 *  | {@link LambertMaterial#ambient} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |
 *  | {@link LambertMaterial#color} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |
 *  | {@link LambertMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |
 *  | {@link LambertMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 *  | {@link LambertMaterial#lineWidth} | Number | [0..100] | 1 |  | Line width in pixels. |
 *  | {@link LambertMaterial#pointSize} | Number | [0..100] | 1 |  | Point size in pixels. |
 *  | {@link LambertMaterial#backfaces} | Boolean |  | false |  | Whether to render {@link Geometry} backfaces. |
 *  | {@link LambertMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for {@link Geometry} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 *
 */var LambertMaterial=/*#__PURE__*/function(_Material6){_inherits(LambertMaterial,_Material6);var _super38=_createSuper(LambertMaterial);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The LambertMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {String:Object} [cfg.meta=null]  Metadata to attach to this LambertMaterial.
     * @param {Number[]} [cfg.ambient=[1.0, 1.0, 1.0 ]] LambertMaterial ambient color.
     * @param {Number[]} [cfg.color=[ 1.0, 1.0, 1.0 ]] LambertMaterial diffuse color.
     * @param {Number[]} [cfg.emissive=[ 0.0, 0.0, 0.0 ]] LambertMaterial emissive color.
     * @param {Number} [cfg.alpha=1]Scalar in range 0-1 that controls alpha, where 0 is completely transparent and 1 is completely opaque.
     * @param {Number} [cfg.reflectivity=1]Scalar in range 0-1 that controls how much {@link ReflectionMap} is reflected.
     * @param {Number} [cfg.lineWidth=1] Scalar that controls the width of {@link Geometry} lines.
     * @param {Number} [cfg.pointSize=1] Scalar that controls the size of points for {@link Geometry} with {@link Geometry#primitive} set to "points".
     * @param {Boolean} [cfg.backfaces=false] Whether to render {@link Geometry} backfaces.
     * @param {Boolean} [cfg.frontface="ccw"] The winding order for {@link Geometry} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.
     */function LambertMaterial(owner){var _this57;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,LambertMaterial);_this57=_super38.call(this,owner,cfg);_this57._state=new RenderState({type:"LambertMaterial",ambient:math.vec3([1.0,1.0,1.0]),color:math.vec3([1.0,1.0,1.0]),emissive:math.vec3([0.0,0.0,0.0]),alpha:null,alphaMode:0,// 2 ("blend") when transparent, so renderer knows when to add to transparency bin
lineWidth:null,pointSize:null,backfaces:null,frontface:null,// Boolean for speed; true == "ccw", false == "cw"
hash:"/lam;"});_this57.ambient=cfg.ambient;_this57.color=cfg.color;_this57.emissive=cfg.emissive;_this57.alpha=cfg.alpha;_this57.lineWidth=cfg.lineWidth;_this57.pointSize=cfg.pointSize;_this57.backfaces=cfg.backfaces;_this57.frontface=cfg.frontface;return _this57;}/**
     * Sets the LambertMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */_createClass(LambertMaterial,[{key:"type",get:/**
     @private
     */function get(){return"LambertMaterial";}},{key:"ambient",get:/**
     * Gets the LambertMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */function get(){return this._state.ambient;}/**
     * Sets the LambertMaterial's diffuse color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */,set:function set(value){var ambient=this._state.ambient;if(!ambient){ambient=this._state.ambient=new Float32Array(3);}else if(value&&ambient[0]===value[0]&&ambient[1]===value[1]&&ambient[2]===value[2]){return;}if(value){ambient[0]=value[0];ambient[1]=value[1];ambient[2]=value[2];}else{ambient[0]=.2;ambient[1]=.2;ambient[2]=.2;}this.glRedraw();}},{key:"color",get:/**
     * Gets the LambertMaterial's diffuse color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */function get(){return this._state.color;}/**
     * Sets the LambertMaterial's emissive color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */,set:function set(value){var color=this._state.color;if(!color){color=this._state.color=new Float32Array(3);}else if(value&&color[0]===value[0]&&color[1]===value[1]&&color[2]===value[2]){return;}if(value){color[0]=value[0];color[1]=value[1];color[2]=value[2];}else{color[0]=1;color[1]=1;color[2]=1;}this.glRedraw();}},{key:"emissive",get:/**
     * Gets the LambertMaterial's emissive color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */function get(){return this._state.emissive;}/**
     * Sets factor in the range ````[0..1]```` indicating how transparent the LambertMaterial is.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````
     *
     * @type {Number}
     */,set:function set(value){var emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3);}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return;}if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2];}else{emissive[0]=0;emissive[1]=0;emissive[2]=0;}this.glRedraw();}},{key:"alpha",get:/**
     * Gets factor in the range ````[0..1]```` indicating how transparent the LambertMaterial is.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````
     *
     * @type {Number}
     */function get(){return this._state.alpha;}/**
     * Sets the LambertMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.alpha===value){return;}this._state.alpha=value;this._state.alphaMode=value<1.0?2/* blend */:0;/* opaque */this.glRedraw();}},{key:"lineWidth",get:/**
     * Gets the LambertMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */function get(){return this._state.lineWidth;}/**
     * Sets the LambertMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){this._state.lineWidth=value||1.0;this.glRedraw();}},{key:"pointSize",get:/**
     * Gets the LambertMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */function get(){return this._state.pointSize;}/**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */,set:function set(value){this._state.pointSize=value||1.0;this.glRedraw();}},{key:"backfaces",get:/**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */function get(){return this._state.backfaces;}/**
     * Sets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */,set:function set(value){value=!!value;if(this._state.backfaces===value){return;}this._state.backfaces=value;this.glRedraw();}},{key:"frontface",get:/**
     * Gets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */function get(){return this._state.frontface?"ccw":"cw";},set:function set(value){value=value!=="cw";if(this._state.frontface===value){return;}this._state.frontface=value;this.glRedraw();}},{key:"_getState",value:function _getState(){return this._state;}/**
     * Destroys this LambertMaterial.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(LambertMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return LambertMaterial;}(Material);var modes={"opaque":0,"mask":1,"blend":2};var modeNames=["opaque","mask","blend"];/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the physically-accurate *metallic-roughness* shading model.
 *
 * * Useful for conductive materials, such as metal, but also appropriate for insulators.
 * * {@link SpecularMaterial} is best for insulators, such as wood, ceramics and plastic.
 * * {@link PhongMaterial} is appropriate for non-realistic objects.
 * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with {@link MetallicMaterial} and {@link ReadableGeometry} loaded from OBJ.
 *
 * Note that in this example we're providing separate {@link Texture} for the {@link MetallicMaterial#metallic} and {@link MetallicMaterial#roughness}
 * channels, which allows us a little creative flexibility. Then, in the next example further down, we'll combine those channels
 * within the same {@link Texture} for efficiency.
 *
 * [[Run this example](/examples/#materials_MetallicMaterial)]
 *
 * ````javascript
 * import {Viewer, Mesh, loadOBJGeometry, ReadableGeometry, MetallicMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0.57, 1.37, 1.14];
 * viewer.scene.camera.look = [0.04, 0.58, 0.00];
 * viewer.scene.camera.up = [-0.22, 0.84, -0.48];
 *
 * loadOBJGeometry(viewer.scene, {
 *      src: "models/obj/fireHydrant/FireHydrantMesh.obj"
 * })
 * .then(function (geometry) {
 *
 *      // Success
 *
 *      new Mesh(viewer.scene, {
 *
 *          geometry: new ReadableGeometry(viewer.scene, geometry),
 *
 *          material: new MetallicMaterial(viewer.scene, {
 *
 *              baseColor: [1, 1, 1],
 *              metallic: 1.0,
 *              roughness: 1.0,
 *
 *              baseColorMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *                  encoding: "sRGB"
 *              }),
 *              normalMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *              }),
 *              roughnessMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Roughness.png"
 *              }),
 *              metallicMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Metallic.png"
 *              }),
 *              occlusionMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *              }),
 *
 *              specularF0: 0.7
 *          })
 *      });
 * }, function () {
 *          // Error
 *      });
 * ````
 *
 * ## Background Theory
 *
 * For an introduction to physically-based rendering (PBR) concepts, try these articles:
 *
 * * Joe Wilson's [Basic Theory of Physically-Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * * Jeff Russel's [Physically-based Rendering, and you can too!](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 * * Sebastien Legarde's [Adapting a physically-based shading model](http://seblagarde.wordpress.com/tag/physically-based-rendering/)
 *
 * ## MetallicMaterial Properties
 *
 * The following table summarizes MetallicMaterial properties:
 *
 * | Property | Type | Range | Default Value | Space | Description |
 * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 * | {@link MetallicMaterial#baseColor} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the base color of the material. |
 * | {@link MetallicMaterial#metallic} | Number | [0, 1] | 1 | linear | The metallic-ness the material (1 for metals, 0 for non-metals). |
 * | {@link MetallicMaterial#roughness} | Number | [0, 1] | 1 | linear | The roughness of the material surface. |
 * | {@link MetallicMaterial#specularF0} | Number | [0, 1] | 1 | linear | The specular Fresnel of the material surface. |
 * | {@link MetallicMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the emissive color of the material. |
 * | {@link MetallicMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 * | {@link MetallicMaterial#baseColorMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link MetallicMaterial#baseColor}. If the fourth component (A) is present, it multiplies by {@link MetallicMaterial#alpha}. |
 * | {@link MetallicMaterial#metallicMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#metallic}. |
 * | {@link MetallicMaterial#roughnessMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#roughness}. |
 * | {@link MetallicMaterial#metallicRoughnessMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#metallic} and second component multiplying by {@link MetallicMaterial#roughness}. |
 * | {@link MetallicMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link MetallicMaterial#emissive}. |
 * | {@link MetallicMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#alpha}. |
 * | {@link MetallicMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by surface's reflected diffuse and specular light. |
 * | {@link MetallicMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |
 * | {@link MetallicMaterial#alphaMode} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 * | {@link MetallicMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 * | {@link MetallicMaterial#backfaces} | Boolean |  | false |  | Whether to render {@link ReadableGeometry} backfaces. |
 * | {@link MetallicMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for {@link ReadableGeometry} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 *
 *
 * ## Combining Channels Within the Same Textures
 *
 * In the previous example we provided separate {@link Texture} for the {@link MetallicMaterial#metallic} and
 * {@link MetallicMaterial#roughness} channels, but we can combine those channels into the same {@link Texture} to
 * reduce download time, memory footprint and rendering time (and also for glTF compatibility).
 *
 * Here's the {@link Mesh} again, with our MetallicMaterial with those channels combined in the {@link MetallicMaterial#metallicRoughnessMap}
 * {@link Texture}, where the *R* component multiplies by {@link MetallicMaterial#metallic} and *G* multiplies
 * by {@link MetallicMaterial#roughness}.
 *
 * ````javascript
 * new Mesh(viewer.scene, {
 *
 *     geometry: geometry,
 *
 *     material: new MetallicMaterial(viewer.scene, {
 *
 *         baseColor: [1, 1, 1],
 *         metallic: 1.0,
 *         roughness: 1.0,
 *
 *         baseColorMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *             encoding: "sRGB"
 *         }),
 *         normalMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *         }),
 *         metallicRoughnessMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"
 *         }),
 *         metallicRoughnessMap : new Texture(viewer.scene, {                  // <<----------- Added
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"  // R component multiplies by metallic
 *         }),                                                                   // G component multiplies by roughness
 *         occlusionMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *         }),
 *
 *         specularF0: 0.7
 *  })
 * ````
 *
 * Although not shown in this example, we can also texture {@link MetallicMaterial#alpha} with the *A* component of
 * {@link MetallicMaterial#baseColorMap}'s {@link Texture}, if required.
 *
 * ## Alpha Blending
 *
 * Let's make our {@link Mesh} transparent.
 *
 * We'll update the {@link MetallicMaterial#alpha} and {@link MetallicMaterial#alphaMode}, causing it to blend 50%
 * with the background:
 *
 * ````javascript
 * hydrant.material.alpha = 0.5;
 * hydrant.material.alphaMode = "blend";
 * ````
 *
 * ## Alpha Masking
 *
 * Let's apply an alpha mask to our {@link Mesh}.
 *
 * We'll configure an {@link MetallicMaterial#alphaMap} to multiply by {@link MetallicMaterial#alpha},
 * with {@link MetallicMaterial#alphaMode} and {@link MetallicMaterial#alphaCutoff} to treat it as an alpha mask:
 *
 * ````javascript
 * new Mesh(viewer.scene, {
 *
 *     geometry: geometry,
 *
 *     material: new MetallicMaterial(viewer.scene, {
 *
 *         baseColor: [1, 1, 1],
 *         metallic: 1.0,
 *         roughness: 1.0,
 *         alpha: 1.0,
 *         alphaMode : "mask",  // <<---------------- Added
 *         alphaCutoff : 0.2,   // <<---------------- Added
 *
 *         alphaMap : new Texture(viewer.scene{ // <<---------------- Added
 *              src: "textures/alphaMap.jpg"
 *         }),
 *         baseColorMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *             encoding: "sRGB"
 *         }),
 *         normalMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *         }),
 *         metallicRoughnessMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"
 *         }),
 *         metallicRoughnessMap : new Texture(viewer.scene, {                  // <<----------- Added
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"  // R component multiplies by metallic
 *         }),                                                                   // G component multiplies by roughness
 *         occlusionMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *         }),
 *
 *         specularF0: 0.7
 *  })
 * ````
 */var MetallicMaterial=/*#__PURE__*/function(_Material7){_inherits(MetallicMaterial,_Material7);var _super39=_createSuper(MetallicMaterial);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this MetallicMaterial as well.
     * @param {*} [cfg] The MetallicMaterial configuration.
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.baseColor=[1,1,1]] RGB diffuse color of this MetallicMaterial. Multiplies by the RGB components of {@link MetallicMaterial#baseColorMap}.
     * @param {Number} [cfg.metallic=1.0] Factor in the range ````[0..1]```` indicating how metallic this MetallicMaterial is.  ````1```` is metal, ````0```` is non-metal. Multiplies by the *R* component of {@link MetallicMaterial#metallicMap} and the *A* component of {@link MetallicMaterial#metallicRoughnessMap}.
     * @param {Number} [cfg.roughness=1.0] Factor in the range ````[0..1]```` indicating the roughness of this MetallicMaterial.  ````0```` is fully smooth, ````1```` is fully rough. Multiplies by the *R* component of {@link MetallicMaterial#roughnessMap}.
     * @param {Number} [cfg.specularF0=0.0] Factor in the range ````[0..1]```` indicating specular Fresnel.
     * @param {Number[]} [cfg.emissive=[0,0,0]]  RGB emissive color of this MetallicMaterial. Multiplies by the RGB components of {@link MetallicMaterial#emissiveMap}.
     * @param {Number} [cfg.alpha=1.0] Factor in the range ````[0..1]```` indicating the alpha of this MetallicMaterial.  Multiplies by the *R* component of {@link MetallicMaterial#alphaMap} and the *A* component,  if present, of {@link MetallicMaterial#baseColorMap}. The value of  {@link MetallicMaterial#alphaMode} indicates how alpha is interpreted when rendering.
     * @param {Texture} [cfg.baseColorMap=undefined] RGBA {@link Texture} containing the diffuse color of this MetallicMaterial, with optional *A* component for alpha. The RGB components multiply by the {@link MetallicMaterial#baseColor} property, while the *A* component, if present, multiplies by the {@link MetallicMaterial#alpha} property.
     * @param {Texture} [cfg.alphaMap=undefined] RGB {@link Texture} containing this MetallicMaterial's alpha in its *R* component. The *R* component multiplies by the {@link MetallicMaterial#alpha} property. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {Texture} [cfg.metallicMap=undefined] RGB {@link Texture} containing this MetallicMaterial's metallic factor in its *R* component. The *R* component multiplies by the {@link MetallicMaterial#metallic} property. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {Texture} [cfg.roughnessMap=undefined] RGB {@link Texture} containing this MetallicMaterial's roughness factor in its *R* component. The *R* component multiplies by the  {@link MetallicMaterial#roughness} property. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {Texture} [cfg.metallicRoughnessMap=undefined] RGB {@link Texture} containing this MetallicMaterial's metalness in its *R* component and roughness in its *G* component. Its *R* component multiplies by the {@link MetallicMaterial#metallic} property, while its *G* component multiplies by the {@link MetallicMaterial#roughness} property. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {Texture} [cfg.emissiveMap=undefined] RGB {@link Texture} containing the emissive color of this MetallicMaterial. Multiplies by the {@link MetallicMaterial#emissive} property. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {Texture} [cfg.occlusionMap=undefined] RGB ambient occlusion {@link Texture}. Within shaders, multiplies by the specular and diffuse light reflected by surfaces. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {Texture} [cfg.normalMap=undefined] RGB tangent-space normal {@link Texture}. Must be within the same {@link Scene} as this MetallicMaterial.
     * @param {String} [cfg.alphaMode="opaque"] The alpha blend mode, which specifies how alpha is to be interpreted. Accepted values are "opaque", "blend" and "mask". See the {@link MetallicMaterial#alphaMode} property for more info.
     * @param {Number} [cfg.alphaCutoff=0.5] The alpha cutoff value. See the {@link MetallicMaterial#alphaCutoff} property for more info.
     * @param {Boolean} [cfg.backfaces=false] Whether to render {@link ReadableGeometry} backfaces.
     * @param {Boolean} [cfg.frontface="ccw"] The winding order for {@link ReadableGeometry} front faces - ````"cw"```` for clockwise, or ````"ccw"```` for counter-clockwise.
     * @param {Number} [cfg.lineWidth=1] Scalar that controls the width of lines for {@link ReadableGeometry} with {@link ReadableGeometry#primitive} set to "lines".
     * @param {Number} [cfg.pointSize=1] Scalar that controls the size of points for {@link ReadableGeometry} with {@link ReadableGeometry#primitive} set to "points".
     */function MetallicMaterial(owner){var _this58;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,MetallicMaterial);_this58=_super39.call(this,owner,cfg);_this58._state=new RenderState({type:"MetallicMaterial",baseColor:math.vec4([1.0,1.0,1.0]),emissive:math.vec4([0.0,0.0,0.0]),metallic:null,roughness:null,specularF0:null,alpha:null,alphaMode:null,// "opaque"
alphaCutoff:null,lineWidth:null,pointSize:null,backfaces:null,frontface:null,// Boolean for speed; true == "ccw", false == "cw"
hash:null});_this58.baseColor=cfg.baseColor;_this58.metallic=cfg.metallic;_this58.roughness=cfg.roughness;_this58.specularF0=cfg.specularF0;_this58.emissive=cfg.emissive;_this58.alpha=cfg.alpha;if(cfg.baseColorMap){_this58._baseColorMap=_this58._checkComponent("Texture",cfg.baseColorMap);}if(cfg.metallicMap){_this58._metallicMap=_this58._checkComponent("Texture",cfg.metallicMap);}if(cfg.roughnessMap){_this58._roughnessMap=_this58._checkComponent("Texture",cfg.roughnessMap);}if(cfg.metallicRoughnessMap){_this58._metallicRoughnessMap=_this58._checkComponent("Texture",cfg.metallicRoughnessMap);}if(cfg.emissiveMap){_this58._emissiveMap=_this58._checkComponent("Texture",cfg.emissiveMap);}if(cfg.occlusionMap){_this58._occlusionMap=_this58._checkComponent("Texture",cfg.occlusionMap);}if(cfg.alphaMap){_this58._alphaMap=_this58._checkComponent("Texture",cfg.alphaMap);}if(cfg.normalMap){_this58._normalMap=_this58._checkComponent("Texture",cfg.normalMap);}_this58.alphaMode=cfg.alphaMode;_this58.alphaCutoff=cfg.alphaCutoff;_this58.backfaces=cfg.backfaces;_this58.frontface=cfg.frontface;_this58.lineWidth=cfg.lineWidth;_this58.pointSize=cfg.pointSize;_this58._makeHash();return _this58;}_createClass(MetallicMaterial,[{key:"type",get:/**
     @private
     */function get(){return"MetallicMaterial";}},{key:"_makeHash",value:function _makeHash(){var state=this._state;var hash=["/met"];if(this._baseColorMap){hash.push("/bm");if(this._baseColorMap._state.hasMatrix){hash.push("/mat");}hash.push("/"+this._baseColorMap._state.encoding);}if(this._metallicMap){hash.push("/mm");if(this._metallicMap._state.hasMatrix){hash.push("/mat");}}if(this._roughnessMap){hash.push("/rm");if(this._roughnessMap._state.hasMatrix){hash.push("/mat");}}if(this._metallicRoughnessMap){hash.push("/mrm");if(this._metallicRoughnessMap._state.hasMatrix){hash.push("/mat");}}if(this._emissiveMap){hash.push("/em");if(this._emissiveMap._state.hasMatrix){hash.push("/mat");}}if(this._occlusionMap){hash.push("/ocm");if(this._occlusionMap._state.hasMatrix){hash.push("/mat");}}if(this._alphaMap){hash.push("/am");if(this._alphaMap._state.hasMatrix){hash.push("/mat");}}if(this._normalMap){hash.push("/nm");if(this._normalMap._state.hasMatrix){hash.push("/mat");}}hash.push(";");state.hash=hash.join("");}/**
     * Sets the RGB diffuse color.
     *
     * Multiplies by the RGB components of {@link MetallicMaterial#baseColorMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */},{key:"baseColor",get:/**
     * Gets the RGB diffuse color.
     *
     * Multiplies by the RGB components of {@link MetallicMaterial#baseColorMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */function get(){return this._state.baseColor;}/**
     * Gets the RGB {@link Texture} containing the diffuse color of this MetallicMaterial, with optional *A* component for alpha.
     *
     * The RGB components multiply by {@link MetallicMaterial#baseColor}, while the *A* component, if present, multiplies by {@link MetallicMaterial#alpha}.
     *
     * @type {Texture}
     */,set:function set(value){var baseColor=this._state.baseColor;if(!baseColor){baseColor=this._state.baseColor=new Float32Array(3);}else if(value&&baseColor[0]===value[0]&&baseColor[1]===value[1]&&baseColor[2]===value[2]){return;}if(value){baseColor[0]=value[0];baseColor[1]=value[1];baseColor[2]=value[2];}else{baseColor[0]=1;baseColor[1]=1;baseColor[2]=1;}this.glRedraw();}},{key:"baseColorMap",get:function get(){return this._baseColorMap;}/**
     * Sets the metallic factor.
     *
     * This is in the range ````[0..1]```` and indicates how metallic this MetallicMaterial is.
     *
     * ````1```` is metal, ````0```` is non-metal.
     *
     * Multiplies by the *R* component of {@link MetallicMaterial#metallicMap} and the *A* component of {@link MetallicMaterial#metallicRoughnessMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */},{key:"metallic",get:/**
     * Gets the metallic factor.
     *
     * @type {Number}
     */function get(){return this._state.metallic;}/**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's metallic factor in its *R* component.
     *
     * The *R* component multiplies by {@link MetallicMaterial#metallic}.
     *
     * @type {Texture}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.metallic===value){return;}this._state.metallic=value;this.glRedraw();}},{key:"metallicMap",get:function get(){return this._attached.metallicMap;}/**
     *  Sets the roughness factor.
     *
     *  This factor is in the range ````[0..1]````, where ````0```` is fully smooth,````1```` is fully rough.
     *
     * Multiplies by the *R* component of {@link MetallicMaterial#roughnessMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */},{key:"roughness",get:/**
     * Gets the roughness factor.
     *
     * @type {Number}
     */function get(){return this._state.roughness;}/**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's roughness factor in its *R* component.
     *
     * The *R* component multiplies by {@link MetallicMaterial#roughness}.
     *
     * @type {Texture}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.roughness===value){return;}this._state.roughness=value;this.glRedraw();}},{key:"roughnessMap",get:function get(){return this._attached.roughnessMap;}/**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's metalness in its *R* component and roughness in its *G* component.
     *
     * Its *B* component multiplies by the {@link MetallicMaterial#metallic} property, while its *G* component multiplies by the {@link MetallicMaterial#roughness} property.
     *
     * @type {Texture}
     */},{key:"metallicRoughnessMap",get:function get(){return this._attached.metallicRoughnessMap;}/**
     * Sets the factor in the range [0..1] indicating specular Fresnel value.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */},{key:"specularF0",get:/**
     * Gets the factor in the range [0..1] indicating specular Fresnel value.
     *
     * @type {Number}
     */function get(){return this._state.specularF0;}/**
     * Sets the RGB emissive color.
     *
     * Multiplies by {@link MetallicMaterial#emissiveMap}.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */,set:function set(value){value=value!==undefined&&value!==null?value:0.0;if(this._state.specularF0===value){return;}this._state.specularF0=value;this.glRedraw();}},{key:"emissive",get:/**
     * Gets the RGB emissive color.
     *
     * @type {Number[]}
     */function get(){return this._state.emissive;}/**
     * Gets the RGB emissive map.
     *
     * Multiplies by {@link MetallicMaterial#emissive}.
     *
     * @type {Texture}
     */,set:function set(value){var emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3);}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return;}if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2];}else{emissive[0]=0;emissive[1]=0;emissive[2]=0;}this.glRedraw();}},{key:"emissiveMap",get:function get(){return this._attached.emissiveMap;}/**
     * Gets the RGB ambient occlusion map.
     *
     * Multiplies by the specular and diffuse light reflected by surfaces.
     *
     * @type {Texture}
     */},{key:"occlusionMap",get:function get(){return this._attached.occlusionMap;}/**
     * Sets factor in the range ````[0..1]```` that indicates the alpha value.
     *
     * Multiplies by the *R* component of {@link MetallicMaterial#alphaMap} and the *A* component, if present, of {@link MetallicMaterial#baseColorMap}.
     *
     * The value of {@link MetallicMaterial#alphaMode} indicates how alpha is interpreted when rendering.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */},{key:"alpha",get:/**
     * Gets factor in the range ````[0..1]```` that indicates the alpha value.
     *
     * @type {Number}
     */function get(){return this._state.alpha;}/**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's alpha in its *R* component.
     *
     * The *R* component multiplies by the {@link MetallicMaterial#alpha} property.
     *
     * @type {Texture}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.alpha===value){return;}this._state.alpha=value;this.glRedraw();}},{key:"alphaMap",get:function get(){return this._attached.alphaMap;}/**
     * Gets the RGB tangent-space normal map {@link Texture}.
     *
     * @type {Texture}
     */},{key:"normalMap",get:function get(){return this._attached.normalMap;}/**
     * Sets the alpha rendering mode.
     *
     * This specifies how alpha is interpreted. Alpha is the combined result of the {@link MetallicMaterial#alpha} and {@link MetallicMaterial#alphaMap} properties.
     *
     * Accepted values are:
     *
     * * "opaque" - The alpha value is ignored and the rendered output is fully opaque (default).
     * * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha and {@link MetallicMaterial#alphaCutoff}.
     * * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).
     *
     * @type {String}
     */},{key:"alphaMode",get:/**
     * Gets the alpha rendering mode.
     *
     * @type {String}
     */function get(){return modeNames[this._state.alphaMode];}/**
     * Sets the alpha cutoff value.
     *
     * Specifies the cutoff threshold when {@link MetallicMaterial#alphaMode} equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire
     * material as fully transparent. This value is ignored for other modes.
     *
     * Alpha is the combined result of the {@link MetallicMaterial#alpha} and {@link MetallicMaterial#alphaMap} properties.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */,set:function set(alphaMode){alphaMode=alphaMode||"opaque";var value=modes[alphaMode];if(value===undefined){this.error("Unsupported value for 'alphaMode': "+alphaMode+" defaulting to 'opaque'");value="opaque";}if(this._state.alphaMode===value){return;}this._state.alphaMode=value;this.glRedraw();}},{key:"alphaCutoff",get:/**
     * Gets the alpha cutoff value.
     *
     * @type {Number}
     */function get(){return this._state.alphaCutoff;}/**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * The backfaces will belong to {@link ReadableGeometry} compoents that are also attached to the {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */,set:function set(alphaCutoff){if(alphaCutoff===null||alphaCutoff===undefined){alphaCutoff=0.5;}if(this._state.alphaCutoff===alphaCutoff){return;}this._state.alphaCutoff=alphaCutoff;}},{key:"backfaces",get:/**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */function get(){return this._state.backfaces;}/**
     * Sets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */,set:function set(value){value=!!value;if(this._state.backfaces===value){return;}this._state.backfaces=value;this.glRedraw();}},{key:"frontface",get:/**
     * Gets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
*
     * @type {String}
     */function get(){return this._state.frontface?"ccw":"cw";}/**
     * Sets the MetallicMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){value=value!=="cw";if(this._state.frontface===value){return;}this._state.frontface=value;this.glRedraw();}},{key:"lineWidth",get:/**
     * Gets the MetallicMaterial's line width.
     *
     * @type {Number}
     */function get(){return this._state.lineWidth;}/**
     * Sets the MetallicMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){this._state.lineWidth=value||1.0;this.glRedraw();}},{key:"pointSize",get:/**
     * Gets the MetallicMaterial's point size.
     *
     * @type {Number}
     */function get(){return this._state.pointSize;}/**
     * Destroys this MetallicMaterial.
     */,set:function set(value){this._state.pointSize=value||1.0;this.glRedraw();}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(MetallicMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return MetallicMaterial;}(Material);var alphaModes={"opaque":0,"mask":1,"blend":2};var alphaModeNames=["opaque","mask","blend"];/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the physically-accurate *specular-glossiness* shading model.
 *
 * * Useful for insulators, such as wood, ceramics and plastic.
 * * {@link MetallicMaterial} is best for conductive materials, such as metal.
 * * {@link PhongMaterial} is appropriate for non-realistic objects.
 * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a {@link buildTorusGeometry} and a SpecularMaterial.
 *
 * Note that in this example we're providing separate {@link Texture} for the {@link SpecularMaterial#specular} and {@link SpecularMaterial#glossiness}
 * channels, which allows us a little creative flexibility. Then, in the next example further down, we'll combine those channels
 * within the same {@link Texture} for efficiency.
 *
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry, SpecularMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({ canvasId: "myCanvas" });
 *
 * const myMesh = new Mesh(viewer.scene,{
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry()),
 *
 *      material: new SpecularMaterial(viewer.scene,{
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 1.0,
 *
 *          // Textures to multiply some of the channels
 *
 *          diffuseMap: new Texture(viewer.scene, { // RGB components multiply by diffuse
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularMap: new Texture(viewer.scene, { // RGB component multiplies by specular
 *              src: "textures/specular.jpg"
 *          }),
 *          glossinessMap: new Texture(viewer.scene, { // R component multiplies by glossiness
 *              src: "textures/glossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * ## Combining Channels Within the Same Textures
 *
 *  In the previous example we provided separate {@link Texture} for the {@link SpecularMaterial#specular} and
 * {@link SpecularMaterial#glossiness} channels, but we can combine those channels into the same {@link Texture} to reduce
 * download time, memory footprint and rendering time (and also for glTF compatibility).
 *
 * Here's our SpecularMaterial again with those channels combined in the {@link SpecularMaterial#specularGlossinessMap}
 * {@link Texture}, where the *RGB* component multiplies by {@link SpecularMaterial#specular} and *A* multiplies by {@link SpecularMaterial#glossiness}.
 *
 * ````javascript
 * const myMesh = new Mesh(viewer.scene,{
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry()),
 *
 *      material: new SpecularMaterial(viewer.scene,{
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 1.0,
 *
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularGlossinessMap: new Texture(viewer.scene, { // RGB multiplies by specular, A by glossiness
 *              src: "textures/specularGlossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * Although not shown in this example, we can also texture {@link SpecularMaterial#alpha} with
 * the *A* component of {@link SpecularMaterial#diffuseMap}'s {@link Texture}, if required.
 *
 * ## Alpha Blending
 *
 * Let's make our {@link Mesh} transparent. We'll redefine {@link SpecularMaterial#alpha}
 * and {@link SpecularMaterial#alphaMode}, causing it to blend 50% with the background:
 *
 * ````javascript
 * const myMesh = new Mesh(viewer.scene,{
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry()),
 *
 *      material: new SpecularMaterial(viewer.scene,{
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 0.5,         // <<----------- Changed
 *          alphaMode: "blend", // <<----------- Added
 *
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularGlossinessMap: new Texture(viewer.scene, { // RGB multiplies by specular, A by glossiness
 *              src: "textures/specularGlossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * ## Alpha Masking
 *
 * Now let's make holes in our {@link Mesh}. We'll give its SpecularMaterial an {@link SpecularMaterial#alphaMap}
 * and configure {@link SpecularMaterial#alpha}, {@link SpecularMaterial#alphaMode},
 * and {@link SpecularMaterial#alphaCutoff} to treat it as an alpha mask:
 *
 * ````javascript
 * const myMesh = new Mesh(viewer.scene,{
 *
 *     geometry: buildTorusGeometry(viewer.scene, ReadableGeometry, {}),
 *
 *      material: new SpecularMaterial(viewer.scene, {
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 1.0,         // <<----------- Changed
 *          alphaMode: "mask",  // <<----------- Changed
 *          alphaCutoff: 0.2,   // <<----------- Added
 *
 *          alphaMap: new Texture(viewer.scene, { // <<---------- Added
 *              src: "textures/diffuse/crossGridColorMap.jpg"
 *          }),
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularGlossinessMap: new Texture(viewer.scene, { // RGB multiplies by specular, A by glossiness
 *              src: "textures/specularGlossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * ## Background Theory
 *
 * For an introduction to physically-based rendering (PBR) concepts, try these articles:
 *
 * * Joe Wilson's [Basic Theory of Physically-Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * * Jeff Russel's [Physically-based Rendering, and you can too!](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 * * Sebastien Legarde's [Adapting a physically-based shading model](http://seblagarde.wordpress.com/tag/physically-based-rendering/)
 *
 * ## SpecularMaterial Properties
 *
 * The following table summarizes SpecularMaterial properties:
 *
 * | Property | Type | Range | Default Value | Space | Description |
 * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 * | {@link SpecularMaterial#diffuse} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse color of the material. |
 * | {@link SpecularMaterial#specular} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular color of the material. |
 * | {@link SpecularMaterial#glossiness} | Number | [0, 1] | 1 | linear | The glossiness the material. |
 * | {@link SpecularMaterial#specularF0} | Number | [0, 1] | 1 | linear | The specularF0 of the material surface. |
 * | {@link SpecularMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the emissive color of the material. |
 * | {@link SpecularMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 * | {@link SpecularMaterial#diffuseMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link SpecularMaterial#diffuse}. If the fourth component (A) is present, it multiplies by {@link SpecularMaterial#alpha}. |
 * | {@link SpecularMaterial#specularMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link SpecularMaterial#specular}. If the fourth component (A) is present, it multiplies by {@link SpecularMaterial#alpha}. |
 * | {@link SpecularMaterial#glossinessMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link SpecularMaterial#glossiness}. |
 * | {@link SpecularMaterial#specularGlossinessMap} | {@link Texture} |  | null | linear | Texture with first three components multiplying by {@link SpecularMaterial#specular} and fourth component multiplying by {@link SpecularMaterial#glossiness}. |
 * | {@link SpecularMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link SpecularMaterial#emissive}. |
 * | {@link SpecularMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link SpecularMaterial#alpha}. |
 * | {@link SpecularMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by surface's reflected diffuse and specular light. |
 * | {@link SpecularMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |
 * | {@link SpecularMaterial#alphaMode} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 * | {@link SpecularMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 * | {@link SpecularMaterial#backfaces} | Boolean |  | false |  | Whether to render {@link Geometry} backfaces. |
 * | {@link SpecularMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for {@link Geometry} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 *
 */var SpecularMaterial=/*#__PURE__*/function(_Material8){_inherits(SpecularMaterial,_Material8);var _super40=_createSuper(SpecularMaterial);/**
     *
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] The SpecularMaterial configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.diffuse=[1,1,1]] RGB diffuse color of this SpecularMaterial. Multiplies by the RGB components of {@link SpecularMaterial#diffuseMap}.
     * @param {Texture} [cfg.diffuseMap=undefined] RGBA {@link Texture} containing the diffuse color of this SpecularMaterial, with optional *A* component for alpha. The RGB components multiply by {@link SpecularMaterial#diffuse}, while the *A* component, if present, multiplies by {@link SpecularMaterial#alpha}.
     * @param {Number} [cfg.specular=[1,1,1]] RGB specular color of this SpecularMaterial. Multiplies by the {@link SpecularMaterial#specularMap} and the *RGB* components of {@link SpecularMaterial#specularGlossinessMap}.
     * @param {Texture} [cfg.specularMap=undefined] RGB texture containing the specular color of this SpecularMaterial. Multiplies by the {@link SpecularMaterial#specular} property. Must be within the same {@link Scene} as this SpecularMaterial.
     * @param {Number} [cfg.glossiness=1.0] Factor in the range [0..1] indicating how glossy this SpecularMaterial is. 0 is no glossiness, 1 is full glossiness. Multiplies by the *R* component of {@link SpecularMaterial#glossinessMap} and the *A* component of {@link SpecularMaterial#specularGlossinessMap}.
     * @param {Texture} [cfg.specularGlossinessMap=undefined] RGBA {@link Texture} containing this SpecularMaterial's specular color in its *RGB* component and glossiness in its *A* component. Its *RGB* components multiply by {@link SpecularMaterial#specular}, while its *A* component multiplies by {@link SpecularMaterial#glossiness}. Must be within the same {@link Scene} as this SpecularMaterial.
     * @param {Number} [cfg.specularF0=0.0] Factor in the range 0..1 indicating how reflective this SpecularMaterial is.
     * @param {Number[]} [cfg.emissive=[0,0,0]]  RGB emissive color of this SpecularMaterial. Multiplies by the RGB components of {@link SpecularMaterial#emissiveMap}.
     * @param {Texture} [cfg.emissiveMap=undefined] RGB {@link Texture} containing the emissive color of this SpecularMaterial. Multiplies by the {@link SpecularMaterial#emissive} property. Must be within the same {@link Scene} as this SpecularMaterial.
     * @param {Texture} [cfg.occlusionMap=undefined] RGB ambient occlusion {@link Texture}. Within shaders, multiplies by the specular and diffuse light reflected by surfaces. Must be within the same {@link Scene} as this SpecularMaterial.
     * @param {Texture} [cfg.normalMap=undefined] {Texture} RGB tangent-space normal {@link Texture}. Must be within the same {@link Scene} as this SpecularMaterial.
     * @param {Number} [cfg.alpha=1.0] Factor in the range 0..1 indicating how transparent this SpecularMaterial is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. Multiplies by the *R* component of {@link SpecularMaterial#alphaMap} and the *A* component, if present, of {@link SpecularMaterial#diffuseMap}.
     * @param {Texture} [cfg.alphaMap=undefined] RGB {@link Texture} containing this SpecularMaterial's alpha in its *R* component. The *R* component multiplies by the {@link SpecularMaterial#alpha} property. Must be within the same {@link Scene} as this SpecularMaterial.
     * @param {String} [cfg.alphaMode="opaque"] The alpha blend mode - accepted values are "opaque", "blend" and "mask". See the {@link SpecularMaterial#alphaMode} property for more info.
     * @param {Number} [cfg.alphaCutoff=0.5] The alpha cutoff value. See the {@link SpecularMaterial#alphaCutoff} property for more info.
     * @param {Boolean} [cfg.backfaces=false] Whether to render {@link Geometry} backfaces.
     * @param {Boolean} [cfg.frontface="ccw"] The winding order for {@link Geometry} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.
     * @param {Number} [cfg.lineWidth=1] Scalar that controls the width of {@link Geometry lines.
     * @param {Number} [cfg.pointSize=1] Scalar that controls the size of {@link Geometry} points.
     */function SpecularMaterial(owner){var _this59;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SpecularMaterial);_this59=_super40.call(this,owner,cfg);_this59._state=new RenderState({type:"SpecularMaterial",diffuse:math.vec3([1.0,1.0,1.0]),emissive:math.vec3([0.0,0.0,0.0]),specular:math.vec3([1.0,1.0,1.0]),glossiness:null,specularF0:null,alpha:null,alphaMode:null,alphaCutoff:null,lineWidth:null,pointSize:null,backfaces:null,frontface:null,// Boolean for speed; true == "ccw", false == "cw"
hash:null});_this59.diffuse=cfg.diffuse;_this59.specular=cfg.specular;_this59.glossiness=cfg.glossiness;_this59.specularF0=cfg.specularF0;_this59.emissive=cfg.emissive;_this59.alpha=cfg.alpha;if(cfg.diffuseMap){_this59._diffuseMap=_this59._checkComponent("Texture",cfg.diffuseMap);}if(cfg.emissiveMap){_this59._emissiveMap=_this59._checkComponent("Texture",cfg.emissiveMap);}if(cfg.specularMap){_this59._specularMap=_this59._checkComponent("Texture",cfg.specularMap);}if(cfg.glossinessMap){_this59._glossinessMap=_this59._checkComponent("Texture",cfg.glossinessMap);}if(cfg.specularGlossinessMap){_this59._specularGlossinessMap=_this59._checkComponent("Texture",cfg.specularGlossinessMap);}if(cfg.occlusionMap){_this59._occlusionMap=_this59._checkComponent("Texture",cfg.occlusionMap);}if(cfg.alphaMap){_this59._alphaMap=_this59._checkComponent("Texture",cfg.alphaMap);}if(cfg.normalMap){_this59._normalMap=_this59._checkComponent("Texture",cfg.normalMap);}_this59.alphaMode=cfg.alphaMode;_this59.alphaCutoff=cfg.alphaCutoff;_this59.backfaces=cfg.backfaces;_this59.frontface=cfg.frontface;_this59.lineWidth=cfg.lineWidth;_this59.pointSize=cfg.pointSize;_this59._makeHash();return _this59;}_createClass(SpecularMaterial,[{key:"type",get:/**
     @private
     */function get(){return"SpecularMaterial";}},{key:"_makeHash",value:function _makeHash(){var state=this._state;var hash=["/spe"];if(this._diffuseMap){hash.push("/dm");if(this._diffuseMap.hasMatrix){hash.push("/mat");}hash.push("/"+this._diffuseMap.encoding);}if(this._emissiveMap){hash.push("/em");if(this._emissiveMap.hasMatrix){hash.push("/mat");}}if(this._glossinessMap){hash.push("/gm");if(this._glossinessMap.hasMatrix){hash.push("/mat");}}if(this._specularMap){hash.push("/sm");if(this._specularMap.hasMatrix){hash.push("/mat");}}if(this._specularGlossinessMap){hash.push("/sgm");if(this._specularGlossinessMap.hasMatrix){hash.push("/mat");}}if(this._occlusionMap){hash.push("/ocm");if(this._occlusionMap.hasMatrix){hash.push("/mat");}}if(this._normalMap){hash.push("/nm");if(this._normalMap.hasMatrix){hash.push("/mat");}}if(this._alphaMap){hash.push("/opm");if(this._alphaMap.hasMatrix){hash.push("/mat");}}hash.push(";");state.hash=hash.join("");}/**
     * Sets the RGB diffuse color of this SpecularMaterial.
     *
     * Multiplies by the *RGB* components of {@link SpecularMaterial#diffuseMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */},{key:"diffuse",get:/**
     * Gets the RGB diffuse color of this SpecularMaterial.
     *
     * @type {Number[]}
     */function get(){return this._state.diffuse;}/**
     * Gets the RGB {@link Texture} containing the diffuse color of this SpecularMaterial, with optional *A* component for alpha.
     *
     * The *RGB* components multipliues by the {@link SpecularMaterial#diffuse} property, while the *A* component, if present, multiplies by the {@link SpecularMaterial#alpha} property.
     *
     * @type {Texture}
     */,set:function set(value){var diffuse=this._state.diffuse;if(!diffuse){diffuse=this._state.diffuse=new Float32Array(3);}else if(value&&diffuse[0]===value[0]&&diffuse[1]===value[1]&&diffuse[2]===value[2]){return;}if(value){diffuse[0]=value[0];diffuse[1]=value[1];diffuse[2]=value[2];}else{diffuse[0]=1;diffuse[1]=1;diffuse[2]=1;}this.glRedraw();}},{key:"diffuseMap",get:function get(){return this._diffuseMap;}/**
     * Sets the RGB specular color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#specularMap} and the *A* component of {@link SpecularMaterial#specularGlossinessMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */},{key:"specular",get:/**
     * Gets the RGB specular color of this SpecularMaterial.
     *
     * @type {Number[]}
     */function get(){return this._state.specular;}/**
     * Gets the RGB texture containing the specular color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#specular}.
     *
     * @type {Texture}
     */,set:function set(value){var specular=this._state.specular;if(!specular){specular=this._state.specular=new Float32Array(3);}else if(value&&specular[0]===value[0]&&specular[1]===value[1]&&specular[2]===value[2]){return;}if(value){specular[0]=value[0];specular[1]=value[1];specular[2]=value[2];}else{specular[0]=1;specular[1]=1;specular[2]=1;}this.glRedraw();}},{key:"specularMap",get:function get(){return this._specularMap;}/**
     * Gets the RGBA texture containing this SpecularMaterial's specular color in its *RGB* components and glossiness in its *A* component.
     *
     * The *RGB* components multiplies {@link SpecularMaterial#specular}, while the *A* component multiplies by {@link SpecularMaterial#glossiness}.
     *
     * @type {Texture}
     */},{key:"specularGlossinessMap",get:function get(){return this._specularGlossinessMap;}/**
     * Sets the Factor in the range [0..1] indicating how glossy this SpecularMaterial is.
     *
     * ````0```` is no glossiness, ````1```` is full glossiness.
     *
     * Multiplies by the *R* component of {@link SpecularMaterial#glossinessMap} and the *A* component of {@link SpecularMaterial#specularGlossinessMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */},{key:"glossiness",get:/**
     * Gets the Factor in the range ````[0..1]```` indicating how glossy this SpecularMaterial is.

     * @type {Number}
     */function get(){return this._state.glossiness;}/**
     * Gets the RGB texture containing this SpecularMaterial's glossiness in its *R* component.
     *
     * The *R* component multiplies by {@link SpecularMaterial#glossiness}.
     ** @type {Texture}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.glossiness===value){return;}this._state.glossiness=value;this.glRedraw();}},{key:"glossinessMap",get:function get(){return this._glossinessMap;}/**
     * Sets the factor in the range ````[0..1]```` indicating amount of specular Fresnel.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */},{key:"specularF0",get:/**
     * Gets the factor in the range ````[0..1]```` indicating amount of specular Fresnel.
     *
     * @type {Number}
     */function get(){return this._state.specularF0;}/**
     * Sets the RGB emissive color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#emissiveMap}.

     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */,set:function set(value){value=value!==undefined&&value!==null?value:0.0;if(this._state.specularF0===value){return;}this._state.specularF0=value;this.glRedraw();}},{key:"emissive",get:/**
     * Gets the RGB emissive color of this SpecularMaterial.
     *
     * @type {Number[]}
     */function get(){return this._state.emissive;}/**
     * Gets the RGB texture containing the emissive color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#emissive}.
     *
     * @type {Texture}
     */,set:function set(value){var emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3);}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return;}if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2];}else{emissive[0]=0;emissive[1]=0;emissive[2]=0;}this.glRedraw();}},{key:"emissiveMap",get:function get(){return this._emissiveMap;}/**
     * Sets the factor in the range [0..1] indicating how transparent this SpecularMaterial is.
     *
     * A value of ````0.0```` is fully transparent, while ````1.0```` is fully opaque.
     *
     * Multiplies by the *R* component of {@link SpecularMaterial#alphaMap} and the *A* component, if present, of {@link SpecularMaterial#diffuseMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */},{key:"alpha",get:/**
     * Gets the factor in the range [0..1] indicating how transparent this SpecularMaterial is.
     *
     * @type {Number}
     */function get(){return this._state.alpha;}/**
     * Gets the RGB {@link Texture} with alpha in its *R* component.
     *
     * The *R* component multiplies by the {@link SpecularMaterial#alpha} property.
     *
     * @type {Texture}
     */,set:function set(value){value=value!==undefined&&value!==null?value:1.0;if(this._state.alpha===value){return;}this._state.alpha=value;this.glRedraw();}},{key:"alphaMap",get:function get(){return this._alphaMap;}/**
     * Gets the RGB tangent-space normal {@link Texture} attached to this SpecularMaterial.
     *
     * @type {Texture}
     */},{key:"normalMap",get:function get(){return this._normalMap;}/**
     * Gets the RGB ambient occlusion {@link Texture} attached to this SpecularMaterial.
     *
     * Multiplies by the specular and diffuse light reflected by surfaces.
     *
     * @type {Texture}
     */},{key:"occlusionMap",get:function get(){return this._occlusionMap;}/**
     * Sets the alpha rendering mode.
     *
     * This governs how alpha is treated. Alpha is the combined result of the {@link SpecularMaterial#alpha} and {@link SpecularMaterial#alphaMap} properties.
     *
     * Accepted values are:
     *
     * * "opaque" - The alpha value is ignored and the rendered output is fully opaque (default).
     * * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.
     * * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)
     *
     * @type {String}
     */},{key:"alphaMode",get:function get(){return alphaModeNames[this._state.alphaMode];}/**
     * Sets the alpha cutoff value.
     *
     * Specifies the cutoff threshold when {@link SpecularMaterial#alphaMode} equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes.
     *
     * Alpha is the combined result of the {@link SpecularMaterial#alpha} and {@link SpecularMaterial#alphaMap} properties.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */,set:function set(alphaMode){alphaMode=alphaMode||"opaque";var value=alphaModes[alphaMode];if(value===undefined){this.error("Unsupported value for 'alphaMode': "+alphaMode+" defaulting to 'opaque'");value="opaque";}if(this._state.alphaMode===value){return;}this._state.alphaMode=value;this.glRedraw();}},{key:"alphaCutoff",get:/**
     * Gets the alpha cutoff value.

     * @type {Number}
     */function get(){return this._state.alphaCutoff;}/**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * The backfaces will belong to {@link ReadableGeometry} compoents that are also attached to the {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */,set:function set(alphaCutoff){if(alphaCutoff===null||alphaCutoff===undefined){alphaCutoff=0.5;}if(this._state.alphaCutoff===alphaCutoff){return;}this._state.alphaCutoff=alphaCutoff;}},{key:"backfaces",get:/**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */function get(){return this._state.backfaces;}/**
     * Sets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */,set:function set(value){value=!!value;if(this._state.backfaces===value){return;}this._state.backfaces=value;this.glRedraw();}},{key:"frontface",get:/**
     * Gets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * @type {String}
     */function get(){return this._state.frontface?"ccw":"cw";}/**
     * Sets the SpecularMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){value=value!=="cw";if(this._state.frontface===value){return;}this._state.frontface=value;this.glRedraw();}},{key:"lineWidth",get:/**
     * Gets the SpecularMaterial's line width.
     *
     * @type {Number}
     */function get(){return this._state.lineWidth;}/**
     * Sets the SpecularMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */,set:function set(value){this._state.lineWidth=value||1.0;this.glRedraw();}},{key:"pointSize",get:/**
     * Sets the SpecularMaterial's point size.
     *
     * @type {Number}
     */function get(){return this._state.pointSize;}/**
     * Destroys this SpecularMaterial.
     */,set:function set(value){this._state.pointSize=value||1;this.glRedraw();}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(SpecularMaterial.prototype),"destroy",this).call(this);this._state.destroy();}}]);return SpecularMaterial;}(Material);/**
 * @private
 */function convertConstant(gl,constantVal){var encoding=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var extension;var p=constantVal;if(p===UnsignedByteType)return gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return gl.UNSIGNED_SHORT_5_5_5_1;if(p===ByteType)return gl.BYTE;if(p===ShortType)return gl.SHORT;if(p===UnsignedShortType)return gl.UNSIGNED_SHORT;if(p===IntType)return gl.INT;if(p===UnsignedIntType)return gl.UNSIGNED_INT;if(p===FloatType)return gl.FLOAT;if(p===HalfFloatType){return gl.HALF_FLOAT;}if(p===AlphaFormat)return gl.ALPHA;if(p===RGBAFormat)return gl.RGBA;if(p===LuminanceFormat)return gl.LUMINANCE;if(p===LuminanceAlphaFormat)return gl.LUMINANCE_ALPHA;if(p===DepthFormat)return gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return gl.DEPTH_STENCIL;if(p===RedFormat)return gl.RED;if(p===RGBFormat){return gl.RGBA;}// WebGL2 formats.
if(p===RedIntegerFormat)return gl.RED_INTEGER;if(p===RGFormat)return gl.RG;if(p===RGIntegerFormat)return gl.RG_INTEGER;if(p===RGBAIntegerFormat)return gl.RGBA_INTEGER;// S3TC
if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){if(encoding===sRGBEncoding){var _extension=getExtension(gl,'WEBGL_compressed_texture_s3tc_srgb');if(_extension!==null){if(p===RGB_S3TC_DXT1_Format)return _extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return _extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return _extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return _extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;}else{return null;}}else{extension=getExtension(gl,'WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else{return null;}}}// PVRTC
if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){var _extension2=getExtension(gl,'WEBGL_compressed_texture_pvrtc');if(_extension2!==null){if(p===RGB_PVRTC_4BPPV1_Format)return _extension2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return _extension2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return _extension2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return _extension2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else{return null;}}// ETC1
if(p===RGB_ETC1_Format){var _extension3=getExtension(gl,'WEBGL_compressed_texture_etc1');if(_extension3!==null){return _extension3.COMPRESSED_RGB_ETC1_WEBGL;}else{return null;}}// ETC2
if(p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){var _extension4=getExtension(gl,'WEBGL_compressed_texture_etc');if(_extension4!==null){if(p===RGB_ETC2_Format)return encoding===sRGBEncoding?_extension4.COMPRESSED_SRGB8_ETC2:_extension4.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return encoding===sRGBEncoding?_extension4.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:_extension4.COMPRESSED_RGBA8_ETC2_EAC;}else{return null;}}// ASTC
if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format){var _extension5=getExtension(gl,'WEBGL_compressed_texture_astc');if(_extension5!==null){if(p===RGBA_ASTC_4x4_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:_extension5.COMPRESSED_RGBA_ASTC_4x4_KHR;if(p===RGBA_ASTC_5x4_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:_extension5.COMPRESSED_RGBA_ASTC_5x4_KHR;if(p===RGBA_ASTC_5x5_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:_extension5.COMPRESSED_RGBA_ASTC_5x5_KHR;if(p===RGBA_ASTC_6x5_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:_extension5.COMPRESSED_RGBA_ASTC_6x5_KHR;if(p===RGBA_ASTC_6x6_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:_extension5.COMPRESSED_RGBA_ASTC_6x6_KHR;if(p===RGBA_ASTC_8x5_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:_extension5.COMPRESSED_RGBA_ASTC_8x5_KHR;if(p===RGBA_ASTC_8x6_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:_extension5.COMPRESSED_RGBA_ASTC_8x6_KHR;if(p===RGBA_ASTC_8x8_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:_extension5.COMPRESSED_RGBA_ASTC_8x8_KHR;if(p===RGBA_ASTC_10x5_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:_extension5.COMPRESSED_RGBA_ASTC_10x5_KHR;if(p===RGBA_ASTC_10x6_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:_extension5.COMPRESSED_RGBA_ASTC_10x6_KHR;if(p===RGBA_ASTC_10x8_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:_extension5.COMPRESSED_RGBA_ASTC_10x8_KHR;if(p===RGBA_ASTC_10x10_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:_extension5.COMPRESSED_RGBA_ASTC_10x10_KHR;if(p===RGBA_ASTC_12x10_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:_extension5.COMPRESSED_RGBA_ASTC_12x10_KHR;if(p===RGBA_ASTC_12x12_Format)return encoding===sRGBEncoding?_extension5.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:_extension5.COMPRESSED_RGBA_ASTC_12x12_KHR;}else{return null;}}// BPTC
if(p===RGBA_BPTC_Format){var _extension6=getExtension(gl,'EXT_texture_compression_bptc');if(_extension6!==null){if(p===RGBA_BPTC_Format){return encoding===sRGBEncoding?_extension6.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:_extension6.COMPRESSED_RGBA_BPTC_UNORM_EXT;}}else{return null;}}//
if(p===UnsignedInt248Type){return gl.UNSIGNED_INT_24_8;}if(p===RepeatWrapping){return gl.REPEAT;}if(p===ClampToEdgeWrapping){return gl.CLAMP_TO_EDGE;}if(p===NearestMipMapNearestFilter){return gl.NEAREST_MIPMAP_LINEAR;}if(p===NearestMipMapLinearFilter){return gl.NEAREST_MIPMAP_LINEAR;}if(p===LinearMipMapNearestFilter){return gl.LINEAR_MIPMAP_NEAREST;}if(p===LinearMipMapLinearFilter){return gl.LINEAR_MIPMAP_LINEAR;}if(p===NearestFilter){return gl.NEAREST;}if(p===LinearFilter){return gl.LINEAR;}return null;}var color$4=new Uint8Array([0,0,0,1]);/**
 * @desc A low-level component that represents a 2D WebGL texture.
 *
 * @private
 */var Texture2D=/*#__PURE__*/function(){function Texture2D(_ref4){var gl=_ref4.gl,target=_ref4.target,format=_ref4.format,type=_ref4.type,wrapS=_ref4.wrapS,wrapT=_ref4.wrapT,wrapR=_ref4.wrapR,encoding=_ref4.encoding,preloadColor=_ref4.preloadColor,premultiplyAlpha=_ref4.premultiplyAlpha,flipY=_ref4.flipY;_classCallCheck(this,Texture2D);this.gl=gl;this.target=target||gl.TEXTURE_2D;this.format=format||RGBAFormat;this.type=type||UnsignedByteType;this.internalFormat=null;this.premultiplyAlpha=!!premultiplyAlpha;this.flipY=!!flipY;this.unpackAlignment=4;this.wrapS=wrapS||RepeatWrapping;this.wrapT=wrapT||RepeatWrapping;this.wrapR=wrapR||RepeatWrapping;this.encoding=encoding||sRGBEncoding;this.texture=gl.createTexture();if(preloadColor){this.setPreloadColor(preloadColor);// Prevents "there is no texture bound to the unit 0" error
}this.allocated=true;}_createClass(Texture2D,[{key:"setPreloadColor",value:function setPreloadColor(value){if(!value){color$4[0]=0;color$4[1]=0;color$4[2]=0;color$4[3]=255;}else{color$4[0]=Math.floor(value[0]*255);color$4[1]=Math.floor(value[1]*255);color$4[2]=Math.floor(value[2]*255);color$4[3]=Math.floor((value[3]!==undefined?value[3]:1)*255);}var gl=this.gl;gl.bindTexture(this.target,this.texture);if(this.target===gl.TEXTURE_CUBE_MAP){var faces=[gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(var _i149=0,len=faces.length;_i149<len;_i149++){gl.texImage2D(faces[_i149],0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,color$4);}}else{gl.texImage2D(this.target,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,color$4);}gl.bindTexture(this.target,null);}},{key:"setTarget",value:function setTarget(target){this.target=target||this.gl.TEXTURE_2D;}},{key:"setImage",value:function setImage(image){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var gl=this.gl;if(props.format!==undefined){this.format=props.format;}if(props.internalFormat!==undefined){this.internalFormat=props.internalFormat;}if(props.encoding!==undefined){this.encoding=props.encoding;}if(props.type!==undefined){this.type=props.type;}if(props.flipY!==undefined){this.flipY=props.flipY;}if(props.premultiplyAlpha!==undefined){this.premultiplyAlpha=props.premultiplyAlpha;}if(props.unpackAlignment!==undefined){this.unpackAlignment=props.unpackAlignment;}if(props.minFilter!==undefined){this.minFilter=props.minFilter;}if(props.magFilter!==undefined){this.magFilter=props.magFilter;}if(props.wrapS!==undefined){this.wrapS=props.wrapS;}if(props.wrapT!==undefined){this.wrapT=props.wrapT;}if(props.wrapR!==undefined){this.wrapR=props.wrapR;}var generateMipMap=false;gl.bindTexture(this.target,this.texture);var bak1=gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.flipY);var bak2=gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);var bak3=gl.getParameter(gl.UNPACK_ALIGNMENT);gl.pixelStorei(gl.UNPACK_ALIGNMENT,this.unpackAlignment);var bak4=gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,gl.NONE);var minFilter=convertConstant(gl,this.minFilter);gl.texParameteri(this.target,gl.TEXTURE_MIN_FILTER,minFilter);if(minFilter===gl.NEAREST_MIPMAP_NEAREST||minFilter===gl.LINEAR_MIPMAP_NEAREST||minFilter===gl.NEAREST_MIPMAP_LINEAR||minFilter===gl.LINEAR_MIPMAP_LINEAR){generateMipMap=true;}var magFilter=convertConstant(gl,this.magFilter);if(magFilter){gl.texParameteri(this.target,gl.TEXTURE_MAG_FILTER,magFilter);}var wrapS=convertConstant(gl,this.wrapS);if(wrapS){gl.texParameteri(this.target,gl.TEXTURE_WRAP_S,wrapS);}var wrapT=convertConstant(gl,this.wrapT);if(wrapT){gl.texParameteri(this.target,gl.TEXTURE_WRAP_T,wrapT);}var glFormat=convertConstant(gl,this.format,this.encoding);var glType=convertConstant(gl,this.type);var glInternalFormat=getInternalFormat(gl,this.internalFormat,glFormat,glType,this.encoding,false);if(this.target===gl.TEXTURE_CUBE_MAP){if(utils.isArray(image)){var images=image;var faces=[gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(var _i150=0,len=faces.length;_i150<len;_i150++){gl.texImage2D(faces[_i150],0,glInternalFormat,glFormat,glType,images[_i150]);}}}else{gl.texImage2D(gl.TEXTURE_2D,0,glInternalFormat,glFormat,glType,image);}if(generateMipMap){gl.generateMipmap(this.target);}gl.bindTexture(this.target,null);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,bak1);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,bak2);gl.pixelStorei(gl.UNPACK_ALIGNMENT,bak3);gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,bak4);}},{key:"setCompressedData",value:function setCompressedData(_ref5){var mipmaps=_ref5.mipmaps,_ref5$props=_ref5.props,props=_ref5$props===void 0?{}:_ref5$props;var gl=this.gl;var levels=mipmaps.length;// Cache props
if(props.format!==undefined){this.format=props.format;}if(props.internalFormat!==undefined){this.internalFormat=props.internalFormat;}if(props.encoding!==undefined){this.encoding=props.encoding;}if(props.type!==undefined){this.type=props.type;}if(props.flipY!==undefined){this.flipY=props.flipY;}if(props.premultiplyAlpha!==undefined){this.premultiplyAlpha=props.premultiplyAlpha;}if(props.unpackAlignment!==undefined){this.unpackAlignment=props.unpackAlignment;}if(props.minFilter!==undefined){this.minFilter=props.minFilter;}if(props.magFilter!==undefined){this.magFilter=props.magFilter;}if(props.wrapS!==undefined){this.wrapS=props.wrapS;}if(props.wrapT!==undefined){this.wrapT=props.wrapT;}if(props.wrapR!==undefined){this.wrapR=props.wrapR;}gl.activeTexture(gl.TEXTURE0+0);gl.bindTexture(this.target,this.texture);var supportsMips=mipmaps.length>1;gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.flipY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);gl.pixelStorei(gl.UNPACK_ALIGNMENT,this.unpackAlignment);gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,gl.NONE);var wrapS=convertConstant(gl,this.wrapS);if(wrapS){gl.texParameteri(this.target,gl.TEXTURE_WRAP_S,wrapS);}var wrapT=convertConstant(gl,this.wrapT);if(wrapT){gl.texParameteri(this.target,gl.TEXTURE_WRAP_T,wrapT);}if(this.type===gl.TEXTURE_3D||this.type===gl.TEXTURE_2D_ARRAY){var wrapR=convertConstant(gl,this.wrapR);if(wrapR){gl.texParameteri(this.target,gl.TEXTURE_WRAP_R,wrapR);}gl.texParameteri(this.type,gl.TEXTURE_WRAP_R,wrapR);}if(supportsMips){gl.texParameteri(this.target,gl.TEXTURE_MIN_FILTER,filterFallback(gl,this.minFilter));gl.texParameteri(this.target,gl.TEXTURE_MAG_FILTER,filterFallback(gl,this.magFilter));}else{gl.texParameteri(this.target,gl.TEXTURE_MIN_FILTER,convertConstant(gl,this.minFilter));gl.texParameteri(this.target,gl.TEXTURE_MAG_FILTER,convertConstant(gl,this.magFilter));}var glFormat=convertConstant(gl,this.format,this.encoding);var glType=convertConstant(gl,this.type);var glInternalFormat=getInternalFormat(gl,this.internalFormat,glFormat,glType,this.encoding,false);gl.texStorage2D(gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(var _i151=0,len=mipmaps.length;_i151<len;_i151++){var mipmap=mipmaps[_i151];if(this.format!==RGBAFormat){if(glFormat!==null){gl.compressedTexSubImage2D(gl.TEXTURE_2D,_i151,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}else{console.warn('Attempt to load unsupported compressed texture format in .setCompressedData()');}}else{gl.texSubImage2D(gl.TEXTURE_2D,_i151,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}//    if (generateMipMap) {
// //       gl.generateMipmap(this.target); // Only for roughness textures?
//    }
gl.bindTexture(this.target,null);}},{key:"setProps",value:function setProps(props){var gl=this.gl;gl.bindTexture(this.target,this.texture);this._uploadProps(props);gl.bindTexture(this.target,null);}},{key:"_uploadProps",value:function _uploadProps(props){var gl=this.gl;if(props.format!==undefined){this.format=props.format;}if(props.internalFormat!==undefined){this.internalFormat=props.internalFormat;}if(props.encoding!==undefined){this.encoding=props.encoding;}if(props.type!==undefined){this.type=props.type;}if(props.minFilter!==undefined){var minFilter=convertConstant(gl,props.minFilter);if(minFilter){this.minFilter=props.minFilter;gl.texParameteri(this.target,gl.TEXTURE_MIN_FILTER,minFilter);if(minFilter===gl.NEAREST_MIPMAP_NEAREST||minFilter===gl.LINEAR_MIPMAP_NEAREST||minFilter===gl.NEAREST_MIPMAP_LINEAR||minFilter===gl.LINEAR_MIPMAP_LINEAR){gl.generateMipmap(this.target);}}}if(props.magFilter!==undefined){var magFilter=convertConstant(gl,props.magFilter);if(magFilter){this.magFilter=props.magFilter;gl.texParameteri(this.target,gl.TEXTURE_MAG_FILTER,magFilter);}}if(props.wrapS!==undefined){var wrapS=convertConstant(gl,props.wrapS);if(wrapS){this.wrapS=props.wrapS;gl.texParameteri(this.target,gl.TEXTURE_WRAP_S,wrapS);}}if(props.wrapT!==undefined){var wrapT=convertConstant(gl,props.wrapT);if(wrapT){this.wrapT=props.wrapT;gl.texParameteri(this.target,gl.TEXTURE_WRAP_T,wrapT);}}}},{key:"bind",value:function bind(unit){if(!this.allocated){return;}if(this.texture){var _gl2=this.gl;_gl2.activeTexture(_gl2["TEXTURE"+unit]);_gl2.bindTexture(this.target,this.texture);return true;}return false;}},{key:"unbind",value:function unbind(unit){if(!this.allocated){return;}if(this.texture){var _gl3=this.gl;_gl3.activeTexture(_gl3["TEXTURE"+unit]);_gl3.bindTexture(this.target,null);}}},{key:"destroy",value:function destroy(){if(!this.allocated){return;}if(this.texture){this.gl.deleteTexture(this.texture);this.texture=null;}}}]);return Texture2D;}();function getInternalFormat(gl,internalFormatName,glFormat,glType,encoding){var isVideoTexture=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;if(internalFormatName!==null){if(gl[internalFormatName]!==undefined){return gl[internalFormatName];}console.warn('Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}var internalFormat=glFormat;if(glFormat===gl.RED){if(glType===gl.FLOAT)internalFormat=gl.R32F;if(glType===gl.HALF_FLOAT)internalFormat=gl.R16F;if(glType===gl.UNSIGNED_BYTE)internalFormat=gl.R8;}if(glFormat===gl.RG){if(glType===gl.FLOAT)internalFormat=gl.RG32F;if(glType===gl.HALF_FLOAT)internalFormat=gl.RG16F;if(glType===gl.UNSIGNED_BYTE)internalFormat=gl.RG8;}if(glFormat===gl.RGBA){if(glType===gl.FLOAT)internalFormat=gl.RGBA32F;if(glType===gl.HALF_FLOAT)internalFormat=gl.RGBA16F;if(glType===gl.UNSIGNED_BYTE)internalFormat=encoding===sRGBEncoding&&isVideoTexture===false?gl.SRGB8_ALPHA8:gl.RGBA8;if(glType===gl.UNSIGNED_SHORT_4_4_4_4)internalFormat=gl.RGBA4;if(glType===gl.UNSIGNED_SHORT_5_5_5_1)internalFormat=gl.RGB5_A1;}if(internalFormat===gl.R16F||internalFormat===gl.R32F||internalFormat===gl.RG16F||internalFormat===gl.RG32F||internalFormat===gl.RGBA16F||internalFormat===gl.RGBA32F){getExtension(gl,'EXT_color_buffer_float');}return internalFormat;}function filterFallback(gl,f){if(f===NearestFilter||f===NearestMipmapNearestFilter||f===NearestMipmapLinearFilter){return gl.NEAREST;}return gl.LINEAR;}function ensureImageSizePowerOfTwo$1(image){if(!isPowerOfTwo$1(image.width)||!isPowerOfTwo$1(image.height)){var _canvas3=document.createElement("canvas");_canvas3.width=nextHighestPowerOfTwo$1(image.width);_canvas3.height=nextHighestPowerOfTwo$1(image.height);var ctx=_canvas3.getContext("2d");ctx.drawImage(image,0,0,image.width,image.height,0,0,_canvas3.width,_canvas3.height);image=_canvas3;}return image;}function isPowerOfTwo$1(x){return(x&x-1)===0;}function nextHighestPowerOfTwo$1(x){--x;for(var _i152=1;_i152<32;_i152<<=1){x=x|x>>_i152;}return x+1;}/**
 * @desc A 2D texture map.
 *
 * * Textures are attached to {@link Material}s, which are attached to {@link Mesh}es.
 * * To create a Texture from an image file, set {@link Texture#src} to the image file path.
 * * To create a Texture from an HTMLImageElement, set the Texture's {@link Texture#image} to the HTMLImageElement.
 *
 * ## Usage
 *
 * In this example we have a Mesh with a {@link PhongMaterial} which applies diffuse {@link Texture}, and a {@link buildTorusGeometry} which builds a {@link ReadableGeometry}.
 *
 * Note that xeokit will ignore {@link PhongMaterial#diffuse} and {@link PhongMaterial#specular}, since we override those
 * with {@link PhongMaterial#diffuseMap} and {@link PhongMaterial#specularMap}. The {@link Texture} pixel colors directly
 * provide the diffuse and specular components for each fragment across the {@link ReadableGeometry} surface.
 *
 * [[Run this example](/examples/#materials_Texture)]
 *
 * ```` javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 *      ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 * });
 *````
 */var Texture=/*#__PURE__*/function(_Component24){_inherits(Texture,_Component24);var _super41=_createSuper(Texture);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this Texture as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID for this Texture, unique among all components in the parent scene, generated automatically when omitted.
     * @param {String} [cfg.src=null] Path to image file to load into this Texture. See the {@link Texture#src} property for more info.
     * @param {HTMLImageElement} [cfg.image=null] HTML Image object to load into this Texture. See the {@link Texture#image} property for more info.
     * @param {Number} [cfg.minFilter=LinearMipmapLinearFilter] How the texture is sampled when a texel covers less than one pixel.
     * Supported values are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter}, {@link NearestMipMapNearestFilter}, {@link NearestMipMapLinearFilter} and {@link LinearMipMapLinearFilter}.
     * @param {Number} [cfg.magFilter=LinearFilter] How the texture is sampled when a texel covers more than one pixel. Supported values are {@link LinearFilter} and {@link NearestFilter}.
     * @param {Number} [cfg.wrapS=RepeatWrapping] Wrap parameter for texture coordinate *S*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.
     * @param {Number} [cfg.wrapT=RepeatWrapping] Wrap parameter for texture coordinate *T*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}..
     * @param {Boolean} [cfg.flipY=false] Flips this Texture's source data along its vertical axis when ````true````.
     * @param  {Number} [cfg.encoding=LinearEncoding] Encoding format. Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.
     * @param {Number[]} [cfg.translate=[0,0]] 2D translation vector that will be added to texture's *S* and *T* coordinates.
     * @param {Number[]} [cfg.scale=[1,1]] 2D scaling vector that will be applied to texture's *S* and *T* coordinates.
     * @param {Number} [cfg.rotate=0] Rotation, in degrees, that will be applied to texture's *S* and *T* coordinates.
     */function Texture(owner){var _this60;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Texture);_this60=_super41.call(this,owner,cfg);_this60._state=new RenderState({texture:new Texture2D({gl:_this60.scene.canvas.gl}),matrix:math.identityMat4(),hasMatrix:cfg.translate&&(cfg.translate[0]!==0||cfg.translate[1]!==0)||!!cfg.rotate||cfg.scale&&(cfg.scale[0]!==0||cfg.scale[1]!==0),minFilter:_this60._checkMinFilter(cfg.minFilter),magFilter:_this60._checkMagFilter(cfg.magFilter),wrapS:_this60._checkWrapS(cfg.wrapS),wrapT:_this60._checkWrapT(cfg.wrapT),flipY:_this60._checkFlipY(cfg.flipY),encoding:_this60._checkEncoding(cfg.encoding)});// Data source
_this60._src=null;_this60._image=null;// Transformation
_this60._translate=math.vec2([0,0]);_this60._scale=math.vec2([1,1]);_this60._rotate=math.vec2([0,0]);_this60._matrixDirty=false;// Transform
_this60.translate=cfg.translate;_this60.scale=cfg.scale;_this60.rotate=cfg.rotate;// Data source
if(cfg.src){_this60.src=cfg.src;// Image file
}else if(cfg.image){_this60.image=cfg.image;// Image object
}stats.memory.textures++;return _this60;}_createClass(Texture,[{key:"type",get:/**
     @private
     */function get(){return"Texture";}},{key:"_checkMinFilter",value:function _checkMinFilter(value){value=value||LinearMipMapLinearFilter;if(value!==LinearFilter&&value!==LinearMipMapNearestFilter&&value!==LinearMipMapLinearFilter&&value!==NearestMipMapLinearFilter&&value!==NearestMipMapNearestFilter){this.error("Unsupported value for 'minFilter' - supported values are LinearFilter, LinearMipMapNearestFilter, NearestMipMapNearestFilter, "+"NearestMipMapLinearFilter and LinearMipMapLinearFilter. Defaulting to LinearMipMapLinearFilter.");value=LinearMipMapLinearFilter;}return value;}},{key:"_checkMagFilter",value:function _checkMagFilter(value){value=value||LinearFilter;if(value!==LinearFilter&&value!==NearestFilter){this.error("Unsupported value for 'magFilter' - supported values are LinearFilter and NearestFilter. Defaulting to LinearFilter.");value=LinearFilter;}return value;}},{key:"_checkWrapS",value:function _checkWrapS(value){value=value||RepeatWrapping;if(value!==ClampToEdgeWrapping&&value!==MirroredRepeatWrapping&&value!==RepeatWrapping){this.error("Unsupported value for 'wrapS' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.");value=RepeatWrapping;}return value;}},{key:"_checkWrapT",value:function _checkWrapT(value){value=value||RepeatWrapping;if(value!==ClampToEdgeWrapping&&value!==MirroredRepeatWrapping&&value!==RepeatWrapping){this.error("Unsupported value for 'wrapT' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.");value=RepeatWrapping;}return value;}},{key:"_checkFlipY",value:function _checkFlipY(value){return!!value;}},{key:"_checkEncoding",value:function _checkEncoding(value){value=value||LinearEncoding;if(value!==LinearEncoding&&value!==sRGBEncoding){this.error("Unsupported value for 'encoding' - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding.");value=LinearEncoding;}return value;}},{key:"_webglContextRestored",value:function _webglContextRestored(){this._state.texture=new Texture2D({gl:this.scene.canvas.gl});if(this._image){this.image=this._image;}else if(this._src){this.src=this._src;}}},{key:"_update",value:function _update(){var state=this._state;if(this._matrixDirty){var _matrix;var t;if(this._translate[0]!==0||this._translate[1]!==0){_matrix=math.translationMat4v([this._translate[0],this._translate[1],0],this._state.matrix);}if(this._scale[0]!==1||this._scale[1]!==1){t=math.scalingMat4v([this._scale[0],this._scale[1],1]);_matrix=_matrix?math.mulMat4(_matrix,t):t;}if(this._rotate!==0){t=math.rotationMat4v(this._rotate*0.0174532925,[0,0,1]);_matrix=_matrix?math.mulMat4(_matrix,t):t;}if(_matrix){state.matrix=_matrix;}this._matrixDirty=false;}this.glRedraw();}/**
     * Sets an HTML DOM Image object to source this Texture from.
     *
     * Sets {@link Texture#src} null.
     *
     * @type {HTMLImageElement}
     */},{key:"image",get:/**
     * Gets HTML DOM Image object this Texture is sourced from, if any.
     *
     * Returns null if not set.
     *
     * @type {HTMLImageElement}
     */function get(){return this._image;}/**
     * Sets path to an image file to source this Texture from.
     *
     * Sets {@link Texture#image} null.
     *
     * @type {String}
     */,set:function set(value){this._image=ensureImageSizePowerOfTwo$1(value);this._image.crossOrigin="Anonymous";this._state.texture.setImage(this._image,this._state);this._src=null;this.glRedraw();}},{key:"src",get:/**
     * Gets path to the image file this Texture from, if any.
     *
     * Returns null if not set.
     *
     * @type {String}
     */function get(){return this._src;}/**
     * Sets the 2D translation vector added to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[0, 0]````.
     *
     * @type {Number[]}
     */,set:function set(src){this.scene.loading++;this.scene.canvas.spinner.processes++;var self=this;var image=new Image();image.onload=function(){image=ensureImageSizePowerOfTwo$1(image);self._state.texture.setImage(image,self._state);self.scene.loading--;self.glRedraw();self.scene.canvas.spinner.processes--;};image.src=src;this._src=src;this._image=null;}},{key:"translate",get:/**
     * Gets the 2D translation vector added to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[0, 0]````.
     *
     * @type {Number[]}
     */function get(){return this._translate;}/**
     * Sets the 2D scaling vector that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[1, 1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._translate.set(value||[0,0]);this._matrixDirty=true;this._needUpdate();}},{key:"scale",get:/**
     * Gets the 2D scaling vector that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[1, 1]````.
     *
     * @type {Number[]}
     */function get(){return this._scale;}/**
     * Sets the rotation angles, in degrees, that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */,set:function set(value){this._scale.set(value||[1,1]);this._matrixDirty=true;this._needUpdate();}},{key:"rotate",get:/**
     * Gets the rotation angles, in degrees, that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */function get(){return this._rotate;}/**
     * Gets how this Texture is sampled when a texel covers less than one pixel.
     *
     * Options are:
     *
     * * NearestFilter - Uses the value of the texture element that is nearest
     * (in Manhattan distance) to the center of the pixel being textured.
     *
     * * LinearFilter - Uses the weighted average of the four texture elements that are
     * closest to the center of the pixel being textured.
     *
     * * NearestMipMapNearestFilter - Chooses the mipmap that most closely matches the
     * size of the pixel being textured and uses the "nearest" criterion (the texture
     * element nearest to the center of the pixel) to produce a texture value.
     *
     * * LinearMipMapNearestFilter - Chooses the mipmap that most closely matches the size of
     * the pixel being textured and uses the "linear" criterion (a weighted average of the
     * four texture elements that are closest to the center of the pixel) to produce a
     * texture value.
     *
     * * NearestMipMapLinearFilter - Chooses the two mipmaps that most closely
     * match the size of the pixel being textured and uses the "nearest" criterion
     * (the texture element nearest to the center of the pixel) to produce a texture
     * value from each mipmap. The final texture value is a weighted average of those two
     * values.
     *
     * * LinearMipMapLinearFilter - (default) - Chooses the two mipmaps that most closely match the size
     * of the pixel being textured and uses the "linear" criterion (a weighted average
     * of the four texture elements that are closest to the center of the pixel) to
     * produce a texture value from each mipmap. The final texture value is a weighted
     * average of those two values.
     *
     * Default value is LinearMipMapLinearFilter.
     *
     *  @type {Number}
     */,set:function set(value){value=value||0;if(this._rotate===value){return;}this._rotate=value;this._matrixDirty=true;this._needUpdate();}},{key:"minFilter",get:function get(){return this._state.minFilter;}/**
     * Gets how this Texture is sampled when a texel covers more than one pixel.
     *
     * * NearestFilter - Uses the value of the texture element that is nearest
     * (in Manhattan distance) to the center of the pixel being textured.
     * * LinearFilter - (default) - Uses the weighted average of the four texture elements that are
     * closest to the center of the pixel being textured.
     *
     * Default value is LinearMipMapLinearFilter.
     *
     * @type {Number}
     */},{key:"magFilter",get:function get(){return this._state.magFilter;}/**
     * Gets the wrap parameter for this Texture's *S* coordinate.
     *
     * Values can be:
     *
     * * ClampToEdgeWrapping -  causes *S* coordinates to be clamped to the size of the texture.
     * * MirroredRepeatWrapping - causes the *S* coordinate to be set to the fractional part of the texture coordinate
     * if the integer part of *S* is even; if the integer part of *S* is odd, then the *S* texture coordinate is
     * set to *1 - frac  S* , where *frac  S* represents the fractional part of *S*.
     * * RepeatWrapping - (default) - causes the integer part of the *S* coordinate to be ignored; xeokit uses only the
     * fractional part, thereby creating a repeating pattern.
     *
     * Default value is RepeatWrapping.
     *
     * @type {Number}
     */},{key:"wrapS",get:function get(){return this._state.wrapS;}/**
     * Gets the wrap parameter for this Texture's *T* coordinate.
     *
     * Values can be:
     *
     * * ClampToEdgeWrapping -  causes *S* coordinates to be clamped to the size of the texture.
     *  * MirroredRepeatWrapping - causes the *S* coordinate to be set to the fractional part of the texture coordinate
     * if the integer part of *S* is even; if the integer part of *S* is odd, then the *S* texture coordinate is
     * set to *1 - frac  S* , where *frac  S* represents the fractional part of *S*.
     * * RepeatWrapping - (default) - causes the integer part of the *S* coordinate to be ignored; xeokit uses only the
     * fractional part, thereby creating a repeating pattern.
     *
     * Default value is RepeatWrapping.
     *
     * @type {Number}
     */},{key:"wrapT",get:function get(){return this._state.wrapT;}/**
     * Gets if this Texture's source data is flipped along its vertical axis.
     *
     * @type {Number}
     */},{key:"flipY",get:function get(){return this._state.flipY;}/**
     * Gets the Texture's encoding format.
     *
     * @type {Number}
     */},{key:"encoding",get:function get(){return this._state.encoding;}/**
     * Destroys this Texture
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Texture.prototype),"destroy",this).call(this);if(this._state.texture){this._state.texture.destroy();}this._state.destroy();stats.memory.textures--;}}]);return Texture;}(Component);/**
 * @desc Configures Fresnel effects for {@link PhongMaterial}s.
 *
 * Fresnels are attached to {@link PhongMaterial}s, which are attached to {@link Mesh}es.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a {@link PhongMaterial} that applies a Fresnel to its alpha channel to give a glasss-like effect.
 *
 * [[Run this example](/examples/#materials_Fresnel)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 *      ReadableGeometry, PhongMaterial, Texture, Fresnel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *       canvasId: "myCanvas",
 *       transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          alpha: 0.9,
 *          alphaMode: "blend",
 *          ambient: [0.0, 0.0, 0.0],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          alphaFresnel: new Fresnel(viewer.scene, {
v               edgeBias: 0.2,
 *              centerBias: 0.8,
 *              edgeColor: [1.0, 1.0, 1.0],
 *              centerColor: [0.0, 0.0, 0.0],
 *              power: 2
 *          })
 *      })
 * });
 * ````
 */var Fresnel=/*#__PURE__*/function(_Component25){_inherits(Fresnel,_Component25);var _super42=_createSuper(Fresnel);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this Fresnel as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent scene, generated automatically when omitted.
     * @param {Number[]} [cfg.edgeColor=[ 0.0, 0.0, 0.0 ]]  Color used on edges.
     * @param {Number[]} [cfg.centerColor=[ 1.0, 1.0, 1.0 ]]  Color used on center.
     * @param {Number} [cfg.edgeBias=0]  Bias at the edge.
     * @param {Number} [cfg.centerBias=1]  Bias at the center.
     * @param {Number} [cfg.power=0]  The power.
     */function Fresnel(owner){var _this61;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Fresnel);_this61=_super42.call(this,owner,cfg);_this61._state=new RenderState({edgeColor:math.vec3([0,0,0]),centerColor:math.vec3([1,1,1]),edgeBias:0,centerBias:1,power:1});_this61.edgeColor=cfg.edgeColor;_this61.centerColor=cfg.centerColor;_this61.edgeBias=cfg.edgeBias;_this61.centerBias=cfg.centerBias;_this61.power=cfg.power;return _this61;}/**
     * Sets the Fresnel's edge color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */_createClass(Fresnel,[{key:"type",get:/**
     * JavaScript class name for this Component.
     *
     * @type {String}
     */function get(){return"Fresnel";}},{key:"edgeColor",get:/**
     * Gets the Fresnel's edge color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */function get(){return this._state.edgeColor;}/**
     * Sets the Fresnel's center color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._state.edgeColor.set(value||[0.0,0.0,0.0]);this.glRedraw();}},{key:"centerColor",get:/**
     * Gets the Fresnel's center color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */function get(){return this._state.centerColor;}/**
     * Sets the Fresnel's edge bias.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */,set:function set(value){this._state.centerColor.set(value||[1.0,1.0,1.0]);this.glRedraw();}},{key:"edgeBias",get:/**
     * Gets the Fresnel's edge bias.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */function get(){return this._state.edgeBias;}/**
     * Sets the Fresnel's center bias.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */,set:function set(value){this._state.edgeBias=value||0;this.glRedraw();}},{key:"centerBias",get:/**
     * Gets the Fresnel's center bias.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */function get(){return this._state.centerBias;}/**
     * Sets the Fresnel's power.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */,set:function set(value){this._state.centerBias=value!==undefined&&value!==null?value:1;this.glRedraw();}},{key:"power",get:/**
     * Gets the Fresnel's power.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */function get(){return this._state.power;}/**
     * Destroys this Fresnel.
     */,set:function set(value){this._state.power=value!==undefined&&value!==null?value:1;this.glRedraw();}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Fresnel.prototype),"destroy",this).call(this);this._state.destroy();}}]);return Fresnel;}(Component);var memoryStats=stats.memory;var tempAABB$2=math.AABB3();/**
 * @desc A {@link Geometry} that keeps its geometry data solely in GPU memory, without retaining it in browser memory.
 *
 * VBOGeometry uses less memory than {@link ReadableGeometry}, which keeps its geometry data in both browser and GPU memory.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a VBOGeometry that defines a single triangle, plus a {@link PhongMaterial} with diffuse {@link Texture}:
 *
 * [[Run this example](/examples/#geometry_VBOGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, VBOGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 *     });
 *
 * new Mesh(viewer.scene, {
 *         geometry: new VBOGeometry(viewer.scene, {
 *             primitive: "triangles",
 *             positions: [0.0, 3, 0.0, -3, -3, 0.0, 3, -3, 0.0],
 *             normals: [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0],
 *             uv: [0.0, 0.0, 0.5, 1.0, 1.0, 0.0],
 *             indices: [0, 1, 2]
 *         }),
 *         material: new PhongMaterial(viewer.scene, {
 *             diffuseMap: new Texture(viewer.scene, {
 *                 src: "textures/diffuse/uvGrid2.jpg"
 *             }),
 *             backfaces: true
 *         })
 *     });
 * ````
 */var VBOGeometry=/*#__PURE__*/function(_Geometry2){_inherits(VBOGeometry,_Geometry2);var _super43=_createSuper(VBOGeometry);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {String} [cfg.primitive="triangles"]  The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
     * @param {Number[]} [cfg.positions]  Positions array.
     * @param {Number[]} [cfg.normals]  Vertex normal vectors array.
     * @param {Number[]} [cfg.uv]  UVs array.
     * @param {Number[]} [cfg.colors]  Vertex colors.
     * @param {Number[]} [cfg.indices]  Indices array.
     * @param {Number} [cfg.edgeThreshold=10]  When autogenerating edges for supporting {@link Drawable#edges}, this indicates the threshold angle (in degrees) between the face normals of adjacent triangles below which the edge is discarded.
     */function VBOGeometry(owner){var _this62;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,VBOGeometry);_this62=_super43.call(this,owner,cfg);_this62._state=new RenderState({// Arrays for emphasis effects are got from xeokit.GeometryLite friend methods
compressGeometry:true,primitive:null,// WebGL enum
primitiveName:null,// String
positionsDecodeMatrix:null,// Set when compressGeometry == true
uvDecodeMatrix:null,// Set when compressGeometry == true
positionsBuf:null,normalsBuf:null,colorsbuf:null,uvBuf:null,indicesBuf:null,hash:""});_this62._numTriangles=0;_this62._edgeThreshold=cfg.edgeThreshold||10.0;_this62._aabb=null;_this62._obb=math.OBB3();var state=_this62._state;var gl=_this62.scene.canvas.gl;cfg.primitive=cfg.primitive||"triangles";switch(cfg.primitive){case"points":state.primitive=gl.POINTS;state.primitiveName=cfg.primitive;break;case"lines":state.primitive=gl.LINES;state.primitiveName=cfg.primitive;break;case"line-loop":state.primitive=gl.LINE_LOOP;state.primitiveName=cfg.primitive;break;case"line-strip":state.primitive=gl.LINE_STRIP;state.primitiveName=cfg.primitive;break;case"triangles":state.primitive=gl.TRIANGLES;state.primitiveName=cfg.primitive;break;case"triangle-strip":state.primitive=gl.TRIANGLE_STRIP;state.primitiveName=cfg.primitive;break;case"triangle-fan":state.primitive=gl.TRIANGLE_FAN;state.primitiveName=cfg.primitive;break;default:_this62.error("Unsupported value for 'primitive': '"+cfg.primitive+"' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', "+"'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");state.primitive=gl.TRIANGLES;state.primitiveName=cfg.primitive;}if(!cfg.positions){_this62.error("Config expected: positions");return _possibleConstructorReturn(_this62);// TODO: Recover?
}if(!cfg.indices){_this62.error("Config expected: indices");return _possibleConstructorReturn(_this62);// TODO: Recover?
}var positions;{var positionsDecodeMatrix=cfg.positionsDecodeMatrix;if(positionsDecodeMatrix);else{// Uncompressed positions
var bounds=geometryCompressionUtils.getPositionsBounds(cfg.positions);var result=geometryCompressionUtils.compressPositions(cfg.positions,bounds.min,bounds.max);positions=result.quantized;state.positionsDecodeMatrix=result.decodeMatrix;state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,positions,positions.length,3,gl.STATIC_DRAW);memoryStats.positions+=state.positionsBuf.numItems;math.positions3ToAABB3(cfg.positions,_this62._aabb);math.positions3ToAABB3(positions,tempAABB$2,state.positionsDecodeMatrix);math.AABB3ToOBB3(tempAABB$2,_this62._obb);}}if(cfg.colors){var colors=cfg.colors.constructor===Float32Array?cfg.colors:new Float32Array(cfg.colors);state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colors,colors.length,4,gl.STATIC_DRAW);memoryStats.colors+=state.colorsBuf.numItems;}if(cfg.uv){var _bounds2=geometryCompressionUtils.getUVBounds(cfg.uv);var _result2=geometryCompressionUtils.compressUVs(cfg.uv,_bounds2.min,_bounds2.max);var uv=_result2.quantized;state.uvDecodeMatrix=_result2.decodeMatrix;state.uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,uv,uv.length,2,gl.STATIC_DRAW);memoryStats.uvs+=state.uvBuf.numItems;}if(cfg.normals){var normals=geometryCompressionUtils.compressNormals(cfg.normals);var normalized=state.compressGeometry;state.normalsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,normals,normals.length,3,gl.STATIC_DRAW,normalized);memoryStats.normals+=state.normalsBuf.numItems;}{var indices=cfg.indices.constructor===Uint32Array||cfg.indices.constructor===Uint16Array?cfg.indices:new Uint32Array(cfg.indices);state.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,indices,indices.length,1,gl.STATIC_DRAW);memoryStats.indices+=state.indicesBuf.numItems;var edgeIndices=buildEdgeIndices(positions,indices,state.positionsDecodeMatrix,_this62._edgeThreshold);_this62._edgeIndicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,edgeIndices,edgeIndices.length,1,gl.STATIC_DRAW);if(_this62._state.primitiveName==="triangles"){_this62._numTriangles=cfg.indices.length/3;}}_this62._buildHash();memoryStats.meshes++;return _this62;}_createClass(VBOGeometry,[{key:"type",get:/**
     @private
     */function get(){return"VBOGeometry";}/**
     * @private
     * @returns {Boolean}
     */},{key:"isVBOGeometry",get:function get(){return true;}},{key:"_buildHash",value:function _buildHash(){var state=this._state;var hash=["/g"];hash.push("/"+state.primitive+";");if(state.positionsBuf){hash.push("p");}if(state.colorsBuf){hash.push("c");}if(state.normalsBuf||state.autoVertexNormals){hash.push("n");}if(state.uvBuf){hash.push("u");}hash.push("cp");// Always compressed
hash.push(";");state.hash=hash.join("");}},{key:"_getEdgeIndices",value:function _getEdgeIndices(){return this._edgeIndicesBuf;}/**
     * Gets the primitive type.
     *
     * Possible types are: 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
     *
     * @type {String}
     */},{key:"primitive",get:function get(){return this._state.primitiveName;}/**
     * Gets the local-space axis-aligned 3D boundary (AABB).
     *
     * The AABB is represented by a six-element Float64Array containing the min/max extents of the axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */},{key:"aabb",get:function get(){return this._aabb;}/**
     * Gets the local-space oriented 3D boundary (OBB).
     *
     * The OBB is represented by a 32-element Float64Array containing the eight vertices of the box, where each vertex is a homogeneous coordinate having [x,y,z,w] elements.
     *
     * @type {Number[]}
     */},{key:"obb",get:function get(){return this._obb;}/**
     * Approximate number of triangles in this VBOGeometry.
     *
     * Will be zero if {@link VBOGeometry#primitive} is not 'triangles', 'triangle-strip' or 'triangle-fan'.
     *
     * @type {Number}
     */},{key:"numTriangles",get:function get(){return this._numTriangles;}/** @private */},{key:"_getState",value:function _getState(){return this._state;}/**
     * Destroys this component.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(VBOGeometry.prototype),"destroy",this).call(this);var state=this._state;if(state.indicesBuf){state.indicesBuf.destroy();}if(state.positionsBuf){state.positionsBuf.destroy();}if(state.normalsBuf){state.normalsBuf.destroy();}if(state.uvBuf){state.uvBuf.destroy();}if(state.colorsBuf){state.colorsBuf.destroy();}if(this._edgeIndicesBuf){this._edgeIndicesBuf.destroy();}state.destroy();memoryStats.meshes--;}}]);return VBOGeometry;}(Geometry);/**
 * @private
 */var K3D={};K3D.load=function(path,resp){var request=new XMLHttpRequest();request.open("GET",path,true);request.responseType="arraybuffer";request.onload=function(e){resp(e.target.response);};request.send();};K3D.save=function(buff,path){var dataURI="data:application/octet-stream;base64,"+btoa(K3D.parse._buffToStr(buff));window.location.href=dataURI;};K3D.clone=function(o){return JSON.parse(JSON.stringify(o));};K3D.bin={};K3D.bin.f=new Float32Array(1);K3D.bin.fb=new Uint8Array(K3D.bin.f.buffer);K3D.bin.rf=function(buff,off){var f=K3D.bin.f,fb=K3D.bin.fb;for(var i=0;i<4;i++){fb[i]=buff[off+i];}return f[0];};K3D.bin.rsl=function(buff,off){return buff[off]|buff[off+1]<<8;};K3D.bin.ril=function(buff,off){return buff[off]|buff[off+1]<<8|buff[off+2]<<16|buff[off+3]<<24;};K3D.bin.rASCII0=function(buff,off){var s="";while(buff[off]!=0){s+=String.fromCharCode(buff[off++]);}return s;};K3D.bin.wf=function(buff,off,v){var f=new Float32Array(buff.buffer,off,1);f[0]=v;};K3D.bin.wsl=function(buff,off,v){buff[off]=v;buff[off+1]=v>>8;};K3D.bin.wil=function(buff,off,v){buff[off]=v;buff[off+1]=v>>8;buff[off+2]=v>>16;buff[off+3]>>24;};K3D.parse={};K3D.parse._buffToStr=function(buff){var a=new Uint8Array(buff);var s="";for(var i=0;i<a.length;i++){s=s.concat(String.fromCharCode(a[i]));}return s;};K3D.parse._strToBuff=function(str){var buf=new ArrayBuffer(str.length);var bufView=new Uint8Array(buf);for(var i=0;i<str.length;i++){bufView[i]=str.charCodeAt(i);}return buf;};K3D.parse._readLine=function(a,off)// Uint8Array, offset
{var s="";while(a[off]!=10){s+=String.fromCharCode(a[off++]);}return s;};K3D.parse.fromJSON=function(buff){var json=JSON.parse(K3D.parse._buffToStr(buff));return json;};K3D.parse.toJSON=function(object){var str=JSON.stringify(object);return K3D.parse._strToBuff(str);};K3D.parse.fromOBJ=function(buff){var res={};res.groups={};res.c_verts=[];res.c_uvt=[];res.c_norms=[];res.i_verts=[];res.i_uvt=[];res.i_norms=[];var cg={from:0,to:0};// current group
var off=0;var a=new Uint8Array(buff);while(off<a.length){var line=K3D.parse._readLine(a,off);off+=line.length+1;line=line.replace(/ +(?= )/g,'');line=line.replace(/(^\s+|\s+$)/g,'');var cds=line.split(" ");if(cds[0]=="g"){cg.to=res.i_verts.length;if(res.groups[cds[1]]==null)res.groups[cds[1]]={from:res.i_verts.length,to:0};cg=res.groups[cds[1]];}if(cds[0]=="v"){var x=parseFloat(cds[1]);var y=parseFloat(cds[2]);var z=parseFloat(cds[3]);res.c_verts.push(x,y,z);}if(cds[0]=="vt"){var x=parseFloat(cds[1]);var y=1-parseFloat(cds[2]);res.c_uvt.push(x,y);}if(cds[0]=="vn"){var x=parseFloat(cds[1]);var y=parseFloat(cds[2]);var z=parseFloat(cds[3]);res.c_norms.push(x,y,z);}if(cds[0]=="f"){var v0a=cds[1].split("/"),v1a=cds[2].split("/"),v2a=cds[3].split("/");var vi0=parseInt(v0a[0])-1,vi1=parseInt(v1a[0])-1,vi2=parseInt(v2a[0])-1;var ui0=parseInt(v0a[1])-1,ui1=parseInt(v1a[1])-1,ui2=parseInt(v2a[1])-1;var ni0=parseInt(v0a[2])-1,ni1=parseInt(v1a[2])-1,ni2=parseInt(v2a[2])-1;var vlen=res.c_verts.length/3,ulen=res.c_uvt.length/2,nlen=res.c_norms.length/3;if(vi0<0)vi0=vlen+vi0+1;if(vi1<0)vi1=vlen+vi1+1;if(vi2<0)vi2=vlen+vi2+1;if(ui0<0)ui0=ulen+ui0+1;if(ui1<0)ui1=ulen+ui1+1;if(ui2<0)ui2=ulen+ui2+1;if(ni0<0)ni0=nlen+ni0+1;if(ni1<0)ni1=nlen+ni1+1;if(ni2<0)ni2=nlen+ni2+1;res.i_verts.push(vi0,vi1,vi2);//cg.i_verts.push(vi0, vi1, vi2)
res.i_uvt.push(ui0,ui1,ui2);//cg.i_uvt  .push(ui0, ui1, ui2);
res.i_norms.push(ni0,ni1,ni2);//cg.i_norms.push(ni0, ni1, ni2);
if(cds.length==5){var v3a=cds[4].split("/");var vi3=parseInt(v3a[0])-1,ui3=parseInt(v3a[1])-1,ni3=parseInt(v3a[2])-1;if(vi3<0)vi3=vlen+vi3+1;if(ui3<0)ui3=ulen+ui3+1;if(ni3<0)ni3=nlen+ni3+1;res.i_verts.push(vi0,vi2,vi3);//cg.i_verts.push(vi0, vi2, vi3);
res.i_uvt.push(ui0,ui2,ui3);//cg.i_uvt  .push(ui0, ui2, ui3);
res.i_norms.push(ni0,ni2,ni3);//cg.i_norms.push(ni0, ni2, ni3);
}}}cg.to=res.i_verts.length;return res;};K3D.parse.fromMD2=function(buff){buff=new Uint8Array(buff);var res={};var head={};//res.head = head;
head.ident=K3D.bin.ril(buff,0);/* magic number: "IDP2" */head.version=K3D.bin.ril(buff,4);/* version: must be 8 */head.skinwidth=K3D.bin.ril(buff,8);/* texture width */head.skinheight=K3D.bin.ril(buff,12);/* texture height */head.framesize=K3D.bin.ril(buff,16);/* size in bytes of a frame */head.num_skins=K3D.bin.ril(buff,20);/* number of skins */head.num_vertices=K3D.bin.ril(buff,24);/* number of vertices per frame */head.num_st=K3D.bin.ril(buff,28);/* number of texture coordinates */head.num_tris=K3D.bin.ril(buff,32);/* number of triangles */head.num_glcmds=K3D.bin.ril(buff,36);/* number of opengl commands */head.num_frames=K3D.bin.ril(buff,40);/* number of frames */head.offset_skins=K3D.bin.ril(buff,44);/* offset skin data */head.offset_st=K3D.bin.ril(buff,48);/* offset texture coordinate data */head.offset_tris=K3D.bin.ril(buff,52);/* offset triangle data */head.offset_frames=K3D.bin.ril(buff,56);/* offset frame data */head.offset_glcmds=K3D.bin.ril(buff,60);/* offset OpenGL command data */head.offset_end=K3D.bin.ril(buff,64);/* offset end of file */var off=head.offset_st;res.c_uvt=[];for(var i=0;i<head.num_st;i++){var x=K3D.bin.rsl(buff,off)/head.skinwidth;var y=K3D.bin.rsl(buff,off+2)/head.skinheight;res.c_uvt.push(x,y);off+=4;}var off=head.offset_tris;var vi=[],ti=[];res.i_verts=vi;res.i_uvt=ti;//res.tris = {i_verts : vi, i_uvt : ti};
for(var i=0;i<head.num_tris;i++){vi.push(K3D.bin.rsl(buff,off),K3D.bin.rsl(buff,off+2),K3D.bin.rsl(buff,off+4));ti.push(K3D.bin.rsl(buff,off+6),K3D.bin.rsl(buff,off+8),K3D.bin.rsl(buff,off+10));off+=12;}var off=head.offset_skins;res.skins=[];for(var i=0;i<head.num_skins;i++){res.skins.push(K3D.bin.rASCII0(buff,off));off+=64;}var off=head.offset_frames;res.frames=[];var nms=K3D.parse.fromMD2._normals;for(var i=0;i<head.num_frames;i++){var fr={};var sx=K3D.bin.rf(buff,off),sy=K3D.bin.rf(buff,off+4),sz=K3D.bin.rf(buff,off+8);off+=12;var tx=K3D.bin.rf(buff,off),ty=K3D.bin.rf(buff,off+4),tz=K3D.bin.rf(buff,off+8);off+=12;fr.name=K3D.bin.rASCII0(buff,off);off+=16;fr.verts=[];fr.norms=[];for(var j=0;j<head.num_vertices;j++){fr.verts.push(buff[off]*sx+tx,buff[off+1]*sy+ty,buff[off+2]*sz+tz);fr.norms.push(nms[3*buff[off+3]],nms[3*buff[off+3]+1],nms[3*buff[off+3]+2]);off+=4;}res.frames.push(fr);}return res;};/*
 static MD2 normals
 */K3D.parse.fromMD2._normals=[-0.525731,0.000000,0.850651,-0.442863,0.238856,0.864188,-0.295242,0.000000,0.955423,-0.309017,0.500000,0.809017,-0.162460,0.262866,0.951056,0.000000,0.000000,1.000000,0.000000,0.850651,0.525731,-0.147621,0.716567,0.681718,0.147621,0.716567,0.681718,0.000000,0.525731,0.850651,0.309017,0.500000,0.809017,0.525731,0.000000,0.850651,0.295242,0.000000,0.955423,0.442863,0.238856,0.864188,0.162460,0.262866,0.951056,-0.681718,0.147621,0.716567,-0.809017,0.309017,0.500000,-0.587785,0.425325,0.688191,-0.850651,0.525731,0.000000,-0.864188,0.442863,0.238856,-0.716567,0.681718,0.147621,-0.688191,0.587785,0.425325,-0.500000,0.809017,0.309017,-0.238856,0.864188,0.442863,-0.425325,0.688191,0.587785,-0.716567,0.681718,-0.147621,-0.500000,0.809017,-0.309017,-0.525731,0.850651,0.000000,0.000000,0.850651,-0.525731,-0.238856,0.864188,-0.442863,0.000000,0.955423,-0.295242,-0.262866,0.951056,-0.162460,0.000000,1.000000,0.000000,0.000000,0.955423,0.295242,-0.262866,0.951056,0.162460,0.238856,0.864188,0.442863,0.262866,0.951056,0.162460,0.500000,0.809017,0.309017,0.238856,0.864188,-0.442863,0.262866,0.951056,-0.162460,0.500000,0.809017,-0.309017,0.850651,0.525731,0.000000,0.716567,0.681718,0.147621,0.716567,0.681718,-0.147621,0.525731,0.850651,0.000000,0.425325,0.688191,0.587785,0.864188,0.442863,0.238856,0.688191,0.587785,0.425325,0.809017,0.309017,0.500000,0.681718,0.147621,0.716567,0.587785,0.425325,0.688191,0.955423,0.295242,0.000000,1.000000,0.000000,0.000000,0.951056,0.162460,0.262866,0.850651,-0.525731,0.000000,0.955423,-0.295242,0.000000,0.864188,-0.442863,0.238856,0.951056,-0.162460,0.262866,0.809017,-0.309017,0.500000,0.681718,-0.147621,0.716567,0.850651,0.000000,0.525731,0.864188,0.442863,-0.238856,0.809017,0.309017,-0.500000,0.951056,0.162460,-0.262866,0.525731,0.000000,-0.850651,0.681718,0.147621,-0.716567,0.681718,-0.147621,-0.716567,0.850651,0.000000,-0.525731,0.809017,-0.309017,-0.500000,0.864188,-0.442863,-0.238856,0.951056,-0.162460,-0.262866,0.147621,0.716567,-0.681718,0.309017,0.500000,-0.809017,0.425325,0.688191,-0.587785,0.442863,0.238856,-0.864188,0.587785,0.425325,-0.688191,0.688191,0.587785,-0.425325,-0.147621,0.716567,-0.681718,-0.309017,0.500000,-0.809017,0.000000,0.525731,-0.850651,-0.525731,0.000000,-0.850651,-0.442863,0.238856,-0.864188,-0.295242,0.000000,-0.955423,-0.162460,0.262866,-0.951056,0.000000,0.000000,-1.000000,0.295242,0.000000,-0.955423,0.162460,0.262866,-0.951056,-0.442863,-0.238856,-0.864188,-0.309017,-0.500000,-0.809017,-0.162460,-0.262866,-0.951056,0.000000,-0.850651,-0.525731,-0.147621,-0.716567,-0.681718,0.147621,-0.716567,-0.681718,0.000000,-0.525731,-0.850651,0.309017,-0.500000,-0.809017,0.442863,-0.238856,-0.864188,0.162460,-0.262866,-0.951056,0.238856,-0.864188,-0.442863,0.500000,-0.809017,-0.309017,0.425325,-0.688191,-0.587785,0.716567,-0.681718,-0.147621,0.688191,-0.587785,-0.425325,0.587785,-0.425325,-0.688191,0.000000,-0.955423,-0.295242,0.000000,-1.000000,0.000000,0.262866,-0.951056,-0.162460,0.000000,-0.850651,0.525731,0.000000,-0.955423,0.295242,0.238856,-0.864188,0.442863,0.262866,-0.951056,0.162460,0.500000,-0.809017,0.309017,0.716567,-0.681718,0.147621,0.525731,-0.850651,0.000000,-0.238856,-0.864188,-0.442863,-0.500000,-0.809017,-0.309017,-0.262866,-0.951056,-0.162460,-0.850651,-0.525731,0.000000,-0.716567,-0.681718,-0.147621,-0.716567,-0.681718,0.147621,-0.525731,-0.850651,0.000000,-0.500000,-0.809017,0.309017,-0.238856,-0.864188,0.442863,-0.262866,-0.951056,0.162460,-0.864188,-0.442863,0.238856,-0.809017,-0.309017,0.500000,-0.688191,-0.587785,0.425325,-0.681718,-0.147621,0.716567,-0.442863,-0.238856,0.864188,-0.587785,-0.425325,0.688191,-0.309017,-0.500000,0.809017,-0.147621,-0.716567,0.681718,-0.425325,-0.688191,0.587785,-0.162460,-0.262866,0.951056,0.442863,-0.238856,0.864188,0.162460,-0.262866,0.951056,0.309017,-0.500000,0.809017,0.147621,-0.716567,0.681718,0.000000,-0.525731,0.850651,0.425325,-0.688191,0.587785,0.587785,-0.425325,0.688191,0.688191,-0.587785,0.425325,-0.955423,0.295242,0.000000,-0.951056,0.162460,0.262866,-1.000000,0.000000,0.000000,-0.850651,0.000000,0.525731,-0.955423,-0.295242,0.000000,-0.951056,-0.162460,0.262866,-0.864188,0.442863,-0.238856,-0.951056,0.162460,-0.262866,-0.809017,0.309017,-0.500000,-0.864188,-0.442863,-0.238856,-0.951056,-0.162460,-0.262866,-0.809017,-0.309017,-0.500000,-0.681718,0.147621,-0.716567,-0.681718,-0.147621,-0.716567,-0.850651,0.000000,-0.525731,-0.688191,0.587785,-0.425325,-0.587785,0.425325,-0.688191,-0.425325,0.688191,-0.587785,-0.425325,-0.688191,-0.587785,-0.587785,-0.425325,-0.688191,-0.688191,-0.587785,-0.425325];K3D.parse.fromCollada=function(buff){var str=K3D.parse._buffToStr(buff);var xml=new DOMParser().parseFromString(str,"text/xml");xml=xml.childNodes[0];var resp={};//console.log(xml);
var ass=xml.getElementsByTagName("asset")[0];var geo=xml.getElementsByTagName("library_geometries")[0];var ima=xml.getElementsByTagName("library_images")[0];var mat=xml.getElementsByTagName("library_materials")[0];var eff=xml.getElementsByTagName("library_effects")[0];//console.log(xml);
if(ass)resp.asset=K3D.parse.fromCollada._asset(ass);if(geo)resp.geometries=K3D.parse.fromCollada._libGeometries(geo);if(ima)resp.images=K3D.parse.fromCollada._libImages(ima);if(mat)resp.materials=K3D.parse.fromCollada._libMaterials(mat);if(eff)resp.effects=K3D.parse.fromCollada._libEffects(eff);return resp;};K3D.parse.fromCollada._asset=function(xml){//console.log(xml);
return{created:xml.getElementsByTagName("created")[0].textContent,modified:xml.getElementsByTagName("modified")[0].textContent,up_axis:xml.getElementsByTagName("up_axis")[0].textContent};};K3D.parse.fromCollada._libGeometries=function(xml){xml=xml.getElementsByTagName("geometry");var res=[];for(var i=0;i<xml.length;i++){var g=xml[i];var o=K3D.parse.fromCollada._getMesh(g.getElementsByTagName("mesh")[0]);res.push(o);}return res;};K3D.parse.fromCollada._getMesh=function(mesh){//console.log(mesh);
var res={};var ss=mesh.getElementsByTagName("source");var sources=res.sources={};for(var i=0;i<ss.length;i++){var farr=ss[i].getElementsByTagName("float_array")[0].textContent.split(" ");var fl=farr.length-(farr[farr.length-1]==""?1:0);var arr=new Array(fl);for(var j=0;j<fl;j++){arr[j]=parseFloat(farr[j]);}sources[ss[i].getAttribute("id")]=arr;}res.triangles=[];var tgs=mesh.getElementsByTagName("triangles");if(tgs==null)return res;for(var i=0;i<tgs.length;i++){var t={};var tnode=tgs[i];t.material=tnode.getAttribute("material");var inputs=tnode.getElementsByTagName("input");var inds=[];for(var j=0;j<inputs.length;j++){var inp=inputs[j],arr=[];inds[parseInt(inp.getAttribute("offset"))]=arr;var par=inp.getAttribute("semantic");t["s_"+par]=par=="VERTEX"?mesh.getElementsByTagName("vertices")[0].getElementsByTagName("input")[0].getAttribute("source").substring(1):inp.getAttribute("source").substring(1);t["i_"+par]=arr;sources[t["s_"+par]];}var indices=tnode.getElementsByTagName("p")[0].textContent.split(" ");var inum=3*Math.floor(indices.length/3);for(var j=0;j<inum;j++){inds[j%inputs.length].push(parseInt(indices[j]));}/*
         if(t.s_VERTEX  ) t.u_VERTEX   = K3D.edit.unwrap(t.i_VERTEX  , sources[t.s_VERTEX  ], 3);
         if(t.s_TEXCOORD) t.u_TEXCOORD = K3D.edit.unwrap(t.i_TEXCOORD, sources[t.s_TEXCOORD], 2);
         if(t.s_NORMAL  ) t.u_NORMAL   = K3D.edit.unwrap(t.i_NORMAL  , sources[t.s_NORMAL  ], 3);
         //*/ //if(t.s_TEXCOORD) for(var j=1; j<t.u_TEXCOORD.length; j+=2) t.u_TEXCOORD[j] = 1 - t.u_TEXCOORD[j];
/*
         t.u_INDEX = new Array(t.i_VERTEX.length);
         for(var j=0; j<t.i_VERTEX.length; j++) t.u_INDEX[j] = j;
         */res.triangles.push(t);}return res;};K3D.parse.fromCollada._libImages=function(xml){xml=xml.getElementsByTagName("image");var res={};for(var i=0;i<xml.length;i++){res[xml[i].getAttribute("id")]=xml[i].getElementsByTagName("init_from")[0].textContent;}return res;};K3D.parse.fromCollada._libMaterials=function(xml){xml=xml.getElementsByTagName("material");var res={};for(var i=0;i<xml.length;i++){res[xml[i].getAttribute("name")]=xml[i].getElementsByTagName("instance_effect")[0].getAttribute("url").substring(1);}return res;};K3D.parse.fromCollada._libEffects=function(xml){xml=xml.getElementsByTagName("effect");var res={};for(var i=0;i<xml.length;i++){var eff={};var params=xml[i].getElementsByTagName("newparam");for(var j=0;j<params.length;j++){var srf=params[j].getElementsByTagName("surface")[0];if(srf)eff.surface=srf.getElementsByTagName("init_from")[0].textContent;}res[xml[i].getAttribute("id")]=eff;}return res;};K3D.parse.from3DS=function(buff){buff=new Uint8Array(buff);var res={};if(K3D.bin.rsl(buff,0)!=0x4d4d)return null;var lim=K3D.bin.ril(buff,2);var off=6;while(off<lim){var cid=K3D.bin.rsl(buff,off);var lng=K3D.bin.ril(buff,off+2);//console.log(cid.toString(16), lng);
if(cid==0x3d3d)res.edit=K3D.parse.from3DS._edit3ds(buff,off,lng);if(cid==0xb000)res.keyf=K3D.parse.from3DS._keyf3ds(buff,off,lng);off+=lng;}return res;};K3D.parse.from3DS._edit3ds=function(buff,coff,clng)// buffer, chunk offset, length
{var res={};var off=coff+6;while(off<coff+clng){var cid=K3D.bin.rsl(buff,off);var lng=K3D.bin.ril(buff,off+2);//console.log("\t", cid.toString(16), lng);
if(cid==0x4000){if(res.objects==null)res.objects=[];res.objects.push(K3D.parse.from3DS._edit_object(buff,off,lng));}//if(cid == 0xb000) res.KEYF3DS = K3D.parse.from3DS._keyf3ds(buff, off, lng);
off+=lng;}return res;};K3D.parse.from3DS._keyf3ds=function(buff,coff,clng){var res={};var off=coff+6;while(off<coff+clng){var cid=K3D.bin.rsl(buff,off);var lng=K3D.bin.ril(buff,off+2);//console.log("\t\t", cid.toString(16), lng);
//if(cid == 0x4000) { res.objects.push(K3D.parse.from3DS._edit_object(buff, off, lng)); }
if(cid==0xb002){if(res.desc==null)res.desc=[];res.desc.push(K3D.parse.from3DS._keyf_objdes(buff,off,lng));}off+=lng;}return res;};K3D.parse.from3DS._keyf_objdes=function(buff,coff,clng){var res={};var off=coff+6;while(off<coff+clng){var cid=K3D.bin.rsl(buff,off);var lng=K3D.bin.ril(buff,off+2);//console.log("\t\t\t", cid.toString(16), lng);
if(cid==0xb010)res.hierarchy=K3D.parse.from3DS._keyf_objhierarch(buff,off,lng);if(cid==0xb011)res.dummy_name=K3D.bin.rASCII0(buff,off+6);off+=lng;}return res;};K3D.parse.from3DS._keyf_objhierarch=function(buff,coff,clng){var res={};var off=coff+6;res.name=K3D.bin.rASCII0(buff,off);off+=res.name.length+1;res.hierarchy=K3D.bin.rsl(buff,off+4);return res;};K3D.parse.from3DS._edit_object=function(buff,coff,clng)// buffer, chunk offset, length
{var res={};var off=coff+6;res.name=K3D.bin.rASCII0(buff,off);off+=res.name.length+1;//console.log(res.name);
while(off<coff+clng){var cid=K3D.bin.rsl(buff,off);var lng=K3D.bin.ril(buff,off+2);//console.log("\t\t", cid.toString(16), lng);
if(cid==0x4100)res.mesh=K3D.parse.from3DS._obj_trimesh(buff,off,lng);//if(cid == 0xb000) res.KEYF3DS = K3D.parse.from3DS._keyf3ds(buff, off, lng);
off+=lng;}return res;};K3D.parse.from3DS._obj_trimesh=function(buff,coff,clng)// buffer, chunk offset, length
{var res={};var off=coff+6;while(off<coff+clng){var cid=K3D.bin.rsl(buff,off);var lng=K3D.bin.ril(buff,off+2);//console.log("\t\t\t", cid.toString(16), lng);
if(cid==0x4110)res.vertices=K3D.parse.from3DS._tri_vertexl(buff,off,lng);if(cid==0x4120)res.indices=K3D.parse.from3DS._tri_facel1(buff,off,lng);if(cid==0x4140)res.uvt=K3D.parse.from3DS._tri_mappingcoors(buff,off,lng);if(cid==0x4160)res.local=K3D.parse.from3DS._tri_local(buff,off,lng);off+=lng;}return res;};K3D.parse.from3DS._tri_vertexl=function(buff,coff,clng)// buffer, chunk offset, length
{var res=[];var off=coff+6;var n=K3D.bin.rsl(buff,off);off+=2;for(var i=0;i<n;i++){res.push(K3D.bin.rf(buff,off));res.push(K3D.bin.rf(buff,off+4));res.push(K3D.bin.rf(buff,off+8));off+=12;}return res;};K3D.parse.from3DS._tri_facel1=function(buff,coff,clng)// buffer, chunk offset, length
{var res=[];var off=coff+6;var n=K3D.bin.rsl(buff,off);off+=2;for(var i=0;i<n;i++){res.push(K3D.bin.rsl(buff,off));res.push(K3D.bin.rsl(buff,off+2));res.push(K3D.bin.rsl(buff,off+4));off+=8;}return res;};K3D.parse.from3DS._tri_mappingcoors=function(buff,coff,clng)// buffer, chunk offset, length
{var res=[];var off=coff+6;var n=K3D.bin.rsl(buff,off);off+=2;for(var i=0;i<n;i++){res.push(K3D.bin.rf(buff,off));res.push(1-K3D.bin.rf(buff,off+4));off+=8;}return res;};K3D.parse.from3DS._tri_local=function(buff,coff,clng)// buffer, chunk offset, length
{var res={};var off=coff+6;res.X=[K3D.bin.rf(buff,off),K3D.bin.rf(buff,off+4),K3D.bin.rf(buff,off+8)];off+=12;res.Y=[K3D.bin.rf(buff,off),K3D.bin.rf(buff,off+4),K3D.bin.rf(buff,off+8)];off+=12;res.Z=[K3D.bin.rf(buff,off),K3D.bin.rf(buff,off+4),K3D.bin.rf(buff,off+8)];off+=12;res.C=[K3D.bin.rf(buff,off),K3D.bin.rf(buff,off+4),K3D.bin.rf(buff,off+8)];off+=12;return res;};K3D.parse.fromBIV=function(buff){buff=new Uint8Array(buff);var res={};var head={};head.id=K3D.bin.ril(buff,0);head.verS=K3D.bin.ril(buff,4);head.texS=K3D.bin.ril(buff,8);head.indS=K3D.bin.ril(buff,12);head.verO=K3D.bin.ril(buff,16);head.verL=K3D.bin.ril(buff,20);head.texO=K3D.bin.ril(buff,24);head.texL=K3D.bin.ril(buff,28);head.indO=K3D.bin.ril(buff,32);head.indL=K3D.bin.ril(buff,36);if(head.verO!=0)res.vertices=K3D.parse.fromBIV._readFloats(buff,head.verO,head.verL);if(head.texO!=0)res.uvt=K3D.parse.fromBIV._readFloats(buff,head.texO,head.texL);if(head.indO!=0)res.indices=K3D.parse.fromBIV._readInts(buff,head.indO,head.indL,head.indS);return res;};K3D.parse.toBIV=function(obj){var maxi=0;for(var i=0;i<obj.indices.length;i++){maxi=Math.max(maxi,obj.indices[i]);}var indS=32;if(maxi<=0xffff)indS=16;var len=40;if(obj.vertices)len+=obj.vertices.length*4;if(obj.uvt)len+=obj.uvt.length*4;if(obj.indices)len+=obj.indices.length*indS/8;var buff=new Uint8Array(len);K3D.bin.wil(buff,0,0x6976616e);K3D.bin.wil(buff,4,32);K3D.bin.wil(buff,8,32);K3D.bin.wil(buff,12,indS);var off=40;if(obj.vertices){K3D.bin.wil(buff,16,off);K3D.bin.wil(buff,20,4*obj.vertices.length);K3D.parse.fromBIV._writeFloats(buff,off,obj.vertices);off+=4*obj.vertices.length;}if(obj.uvt){K3D.bin.wil(buff,24,off);K3D.bin.wil(buff,28,4*obj.uvt.length);K3D.parse.fromBIV._writeFloats(buff,off,obj.uvt);off+=4*obj.uvt.length;}if(obj.indices){K3D.bin.wil(buff,32,off);K3D.bin.wil(buff,36,4*obj.indices.length);K3D.parse.fromBIV._writeInts(buff,off,obj.indices,indS);}return buff.buffer;};K3D.parse.fromBIV._readFloats=function(buff,off,len){var arr=[];for(var i=0;i<len/4;i++){arr.push(K3D.bin.rf(buff,off+4*i));}return arr;};K3D.parse.fromBIV._writeFloats=function(buff,off,arr){for(var i=0;i<arr.length;i++){K3D.bin.wf(buff,off+4*i,arr[i]);}};K3D.parse.fromBIV._readInts=function(buff,off,len,cs){var arr=[];for(var i=0;i<len/4;i++){if(cs==16)arr.push(K3D.bin.rsl(buff,off+2*i));if(cs==32)arr.push(K3D.bin.ril(buff,off+4*i));}return arr;};K3D.parse.fromBIV._writeInts=function(buff,off,arr,cs){for(var i=0;i<arr.length;i++){if(cs==16)K3D.bin.wsl(buff,off+2*i,arr[i]);if(cs==32)K3D.bin.wil(buff,off+4*i,arr[i]);}};K3D.gen={};K3D.gen.Plane=function(sw,sh,tsw,tsh){if(!tsw)tsw=1;if(!tsh)tsh=1;var r={verts:[],inds:[],uvt:[]};var ssw=sw+1,ssh=sh+1;for(var i=0;i<ssh;i++){for(var j=0;j<ssw;j++){var x=-1+j*(2/sw);var y=-1+i*(2/sh);r.verts.push(x,y,0);r.uvt.push(tsw*j/sw,tsh*i/sh);if(i<sh&&j<sw)r.inds.push(i*ssw+j,i*ssw+j+1,(i+1)*ssw+j,i*ssw+j+1,(i+1)*ssw+j,(i+1)*ssw+j+1);}}return r;};K3D.gen.Cube=function(){var r={verts:[-1,1,-1,1,1,-1,-1,-1,-1,1,-1,-1,// front
-1,1,1,1,1,1,-1,-1,1,1,-1,1,// back
-1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,// left
1,1,1,1,1,-1,1,-1,1,1,-1,-1,// right
-1,1,-1,1,1,-1,-1,1,1,1,1,1,// top
-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1// bottom
],inds:[0,1,2,1,2,3,4,5,6,5,6,7,8,9,10,9,10,11,12,13,14,13,14,15,16,17,18,17,18,19,20,21,22,21,22,23],uvt:[1/4,1/4,2/4,1/4,1/4,2/4,2/4,2/4,// front
4/4,1/4,3/4,1/4,4/4,2/4,3/4,2/4,// back
0/4,1/4,1/4,1/4,0/4,2/4,1/4,2/4,// left
3/4,1/4,2/4,1/4,3/4,2/4,2/4,2/4,// right
1/4,1/4,2/4,1/4,1/4,0/4,2/4,0/4,// top
1/4,2/4,2/4,2/4,1/4,3/4,2/4,3/4// bottom
]};return r;};K3D.gen.Sphere=function(sx,sy){var r={verts:[],inds:[],uvt:[]};var nx=sx+1,ny=sy+1;for(var i=0;i<ny;i++)// rows
{for(var j=0;j<nx;j++)// cols
{var lat=-Math.PI/2+i*Math.PI/sy;var lon=j*2*Math.PI/sx;var x=Math.cos(lat)*Math.cos(lon);var y=Math.sin(lat);var z=Math.cos(lat)*Math.sin(lon);r.verts.push(x,y,z);r.uvt.push(j/sx,i/sy);if(i<sy&&j<sx)// 6 indices for 2 triangles
r.inds.push(nx*i+j,nx*i+j+1,nx*(i+1)+j,nx*i+j+1,nx*(i+1)+j,nx*(i+1)+j+1);}}return r;};K3D.mat={};K3D.mat.scale=function(x,y,z){return[x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1];};K3D.mat.translate=function(x,y,z){return[1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1];};K3D.mat.rotateDeg=function(x,y,z){var r=Math.PI/180;return K3D.mat.rotate(x*r,y*r,z*r);};K3D.mat.rotate=function(x,y,z){var m=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var a=x;// alpha
var b=y;// beta
var g=z;// gama
var ca=Math.cos(a),cb=Math.cos(b),cg=Math.cos(g);var sa=Math.sin(a),sb=Math.sin(b),sg=Math.sin(g);m[0]=cb*cg;m[1]=-cb*sg;m[2]=sb;m[4]=ca*sg+sa*sb*cg;m[5]=ca*cg-sa*sb*sg;m[6]=-sa*cb;m[8]=sa*sg-ca*sb*cg;m[9]=sa*cg+ca*sb*sg;m[10]=ca*cb;return m;};K3D.edit={};K3D.edit.interpolate=function(a,b,d,t){for(var i=0;i<a.length;i++){d[i]=a[i]+t*(b[i]-a[i]);}};K3D.edit.transform=function(a,m){for(var i=0;i<a.length;i+=3){var x=a[i],y=a[i+1],z=a[i+2];a[i+0]=m[0]*x+m[4]*y+m[8]*z+m[12];a[i+1]=m[1]*x+m[5]*y+m[9]*z+m[13];a[i+2]=m[2]*x+m[6]*y+m[10]*z+m[14];}};// starting indices, starting coordinates, coordinates per index
K3D.edit.unwrap=function(ind,crd,cpi){var ncrd=new Array(Math.floor(ind.length/3)*cpi);for(var i=0;i<ind.length;i++){for(var j=0;j<cpi;j++){ncrd[i*cpi+j]=crd[ind[i]*cpi+j];}}return ncrd;};// current indices, new indices, current array, coordinates per vertex
K3D.edit.remap=function(ind,nind,arr,cpi){var ncrd=new Array(arr.length);for(var i=0;i<ind.length;i++){for(var j=0;j<cpi;j++){ncrd[nind[i]*cpi+j]=arr[ind[i]*cpi+j];}}return ncrd;};K3D.utils={};K3D.utils.getAABB=function(vts){var minx,miny,minz,maxx,maxy,maxz;minx=miny=minz=999999999;maxx=maxy=maxz=-minx;for(var i=0;i<vts.length;i+=3){var vx=vts[i+0];var vy=vts[i+1];var vz=vts[i+2];if(vx<minx)minx=vx;if(vx>maxx)maxx=vx;if(vy<miny)miny=vy;if(vy>maxy)maxy=vy;if(vz<minz)minz=vz;if(vy>maxz)maxz=vz;}return{min:{x:minx,y:miny,z:minz},max:{x:maxx,y:maxy,z:maxz}};};/**
 * @desc Loads {@link Geometry} from 3DS.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with {@link PhongMaterial}, {@link Texture} and a {@link ReadableGeometry} loaded from 3DS.
 *
 * [[Run this example](/examples/#geometry_loaders_3DS)]
 *
 * ````javascript
 * import {Viewer, Mesh, load3DSGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [40.04, 23.46, 79.06];
 * viewer.scene.camera.look = [-6.48, 13.92, -0.56];
 * viewer.scene.camera.up = [-0.04, 0.98, -0.08];
 *
 * load3DSGeometry(viewer.scene, {
 *      src: "models/3ds/lexus.3ds",
 *      compressGeometry: false
 *
 *  }).then(function (geometryCfg) {
 *
 *      // Success
 *
 *      new Mesh(viewer.scene, {
 *
 *          geometry: new ReadableGeometry(viewer.scene, geometryCfg),
 *
 *          material: new PhongMaterial(viewer.scene, {
 *
 *              emissive: [1, 1, 1],
 *              emissiveMap: new Texture({  // .3DS has no normals so relies on emissive illumination
 *                  src: "models/3ds/lexus.jpg"
 *              })
 *          }),
 *
 *          rotation: [-90, 0, 0] // +Z is up for this particular 3DS
 *      });
 *  }, function () {
 *      // Error
 *  });
 * ````
 *
 * @function load3DSGeometry
 * @param {Scene} scene Scene we're loading the geometry for.
 * @param {*} cfg Configs, also added to the result object.
 * @param {String} [cfg.src]  Path to 3DS file.
 * @returns {Object} Configuration to pass into a {@link Geometry} constructor, containing geometry arrays loaded from the OBJ file.
 */function load3DSGeometry(scene){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return new Promise(function(resolve,reject){if(!cfg.src){console.error("load3DSGeometry: Parameter expected: src");reject();}var spinner=scene.canvas.spinner;spinner.processes++;utils.loadArraybuffer(cfg.src,function(data){if(!data.byteLength){console.error("load3DSGeometry: no data loaded");spinner.processes--;reject();}var m=K3D.parse.from3DS(data);// done !
var mesh=m.edit.objects[0].mesh;var positions=mesh.vertices;var uv=mesh.uvt;var indices=mesh.indices;spinner.processes--;resolve(utils.apply(cfg,{primitive:"triangles",positions:positions,normals:null,uv:uv,indices:indices}));},function(msg){console.error("load3DSGeometry: "+msg);spinner.processes--;reject();});});}/**
 * @desc Loads {@link Geometry} from OBJ.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with {@link MetallicMaterial} and {@link ReadableGeometry} loaded from OBJ.
 *
 * [[Run this example](/examples/#geometry_loaders_OBJ)]
 *
 * ````javascript
 * import {Viewer, Mesh, loadOBJGeometry, ReadableGeometry,
 *      MetallicMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0.57, 1.37, 1.14];
 * viewer.scene.camera.look = [0.04, 0.58, 0.00];
 * viewer.scene.camera.up = [-0.22, 0.84, -0.48];
 *
 * loadOBJGeometry(viewer.scene, {
 *
 *      src: "models/obj/fireHydrant/FireHydrantMesh.obj",
 *      compressGeometry: false
 *
 *  }).then(function (geometryCfg) {
 *
 *      // Success
 *
 *      new Mesh(viewer.scene, {
 *
 *          geometry: new ReadableGeometry(viewer.scene, geometryCfg),
 *
 *          material: new MetallicMaterial(viewer.scene, {
 *
 *              baseColor: [1, 1, 1],
 *              metallic: 1.0,
 *              roughness: 1.0,
 * 
 *              baseColorMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *                  encoding: "sRGB"
 *              }),
 *              normalMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *              }),
 *              roughnessMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Roughness.png"
 *              }),
 *              metallicMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Metallic.png"
 *              }),
 *              occlusionMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *              }),
 * 
 *              specularF0: 0.7
 *          })
 *      });
 *  }, function () {
 *      // Error
 *  });
 * ````
 *
 * @function loadOBJGeometry
 * @param {Scene} scene Scene we're loading the geometry for.
 * @param {*} [cfg] Configs, also added to the result object.
 * @param {String} [cfg.src]  Path to OBJ file.
 * @returns {Object} Configuration to pass into a {@link Geometry} constructor, containing geometry arrays loaded from the OBJ file.
 */function loadOBJGeometry(scene){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return new Promise(function(resolve,reject){if(!cfg.src){console.error("loadOBJGeometry: Parameter expected: src");reject();}var spinner=scene.canvas.spinner;spinner.processes++;utils.loadArraybuffer(cfg.src,function(data){if(!data.byteLength){console.error("loadOBJGeometry: no data loaded");spinner.processes--;reject();}var m=K3D.parse.fromOBJ(data);// done !
// unwrap simply duplicates some values, so they can be indexed with indices [0,1,2,3 ... ]
// In some rendering engines, you can have only one index value for vertices, UVs, normals ...,
// so "unwrapping" is a simple solution.
var positions=K3D.edit.unwrap(m.i_verts,m.c_verts,3);var normals=K3D.edit.unwrap(m.i_norms,m.c_norms,3);var uv=K3D.edit.unwrap(m.i_uvt,m.c_uvt,2);var indices=new Int32Array(m.i_verts.length);for(var i=0;i<m.i_verts.length;i++){indices[i]=i;}spinner.processes--;resolve(utils.apply(cfg,{primitive:"triangles",positions:positions,normals:normals.length>0?normals:null,autoNormals:normals.length===0,uv:uv,indices:indices}));},function(msg){console.error("loadOBJGeometry: "+msg);spinner.processes--;reject();});});}/**
 * @desc Creates a box-shaped lines {@link Geometry}.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a box-shaped {@link ReadableGeometry} that has lines primitives.
 *
 * [[Run this example](/examples/#geometry_builders_buildBoxLinesGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildBoxLinesGeometry, ReadableGeometry, PhongMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildBoxLinesGeometry({
 *         center: [0,0,0],
 *         xSize: 1,  // Half-size on each axis
 *         ySize: 1,
 *         zSize: 1
 *      })),
 *      material: new PhongMaterial(viewer.scene, {
 *         emissive: [0,1,0]
 *      })
 * });
 * ````
 *
 * @function buildBoxLinesGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.
 * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.
 * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildBoxLinesGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var xSize=cfg.xSize||1;if(xSize<0){console.error("negative xSize not allowed - will invert");xSize*=-1;}var ySize=cfg.ySize||1;if(ySize<0){console.error("negative ySize not allowed - will invert");ySize*=-1;}var zSize=cfg.zSize||1;if(zSize<0){console.error("negative zSize not allowed - will invert");zSize*=-1;}var center=cfg.center;var centerX=center?center[0]:0;var centerY=center?center[1]:0;var centerZ=center?center[2]:0;var xmin=-xSize+centerX;var ymin=-ySize+centerY;var zmin=-zSize+centerZ;var xmax=xSize+centerX;var ymax=ySize+centerY;var zmax=zSize+centerZ;return utils.apply(cfg,{primitive:"lines",positions:[xmin,ymin,zmin,xmin,ymin,zmax,xmin,ymax,zmin,xmin,ymax,zmax,xmax,ymin,zmin,xmax,ymin,zmax,xmax,ymax,zmin,xmax,ymax,zmax],indices:[0,1,1,3,3,2,2,0,4,5,5,7,7,6,6,4,0,4,1,5,2,6,3,7]});}/**
 * @desc Creates a box-shaped lines {@link Geometry} from AABB.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a box-shaped {@link ReadableGeometry} that has lines primitives.
 * This box will be created from AABB of a model.
 *
 * [[Run this example](/examples/#geometry_builders_buildBoxLinesGeometryFromAABB)]
 *
 * ````javascript
 *     import {Viewer, Mesh, Node, buildBoxGeometry, buildBoxLinesGeometryFromAABB, ReadableGeometry, PhongMaterial} from "../../dist/xeokit-sdk.min.es.js";
 *
 *     const viewer = new Viewer({
 *         canvasId: "myCanvas"
 *     });
 *
 *     viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 *     viewer.scene.camera.look = [0, -5.75, 0];
 *     viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 *     const boxGeometry = new ReadableGeometry(viewer.scene, buildBoxGeometry({
 *         xSize: 1,
 *         ySize: 1,
 *         zSize: 1
 *     }));
 *
 *     new Node(viewer.scene, {
 *         id: "table",
 *         isModel: true, // <--------------------- Node represents a model
 *         rotation: [0, 50, 0],
 *         position: [0, 0, 0],
 *         scale: [1, 1, 1],
 *
 *         children: [
 *
 *             new Mesh(viewer.scene, { // Red table leg
 *                 id: "redLeg",
 *                 isObject: true, // <---------- Node represents an object
 *                 position: [-4, -6, -4],
 *                 scale: [1, 3, 1],
 *                 rotation: [0, 0, 0],
 *                 geometry: boxGeometry,
 *                 material: new PhongMaterial(viewer.scene, {
 *                     diffuse: [1, 0.3, 0.3]
 *                 })
 *             }),
 *
 *             new Mesh(viewer.scene, { // Green table leg
 *                 id: "greenLeg",
 *                 isObject: true, // <---------- Node represents an object
 *                 position: [4, -6, -4],
 *                 scale: [1, 3, 1],
 *                 rotation: [0, 0, 0],
 *                 geometry: boxGeometry,
 *                 material: new PhongMaterial(viewer.scene, {
 *                     diffuse: [0.3, 1.0, 0.3]
 *                 })
 *             }),
 *
 *             new Mesh(viewer.scene, {// Blue table leg
 *                 id: "blueLeg",
 *                 isObject: true, // <---------- Node represents an object
 *                 position: [4, -6, 4],
 *                 scale: [1, 3, 1],
 *                 rotation: [0, 0, 0],
 *                 geometry: boxGeometry,
 *                 material: new PhongMaterial(viewer.scene, {
 *                     diffuse: [0.3, 0.3, 1.0]
 *                 })
 *             }),
 *
 *             new Mesh(viewer.scene, {  // Yellow table leg
 *                 id: "yellowLeg",
 *                 isObject: true, // <---------- Node represents an object
 *                 position: [-4, -6, 4],
 *                 scale: [1, 3, 1],
 *                 rotation: [0, 0, 0],
 *                 geometry: boxGeometry,
 *                 material: new PhongMaterial(viewer.scene, {
 *                     diffuse: [1.0, 1.0, 0.0]
 *                 })
 *             }),
 *
 *             new Mesh(viewer.scene, { // Purple table top
 *                 id: "tableTop",
 *                 isObject: true, // <---------- Node represents an object
 *                 position: [0, -3, 0],
 *                 scale: [6, 0.5, 6],
 *                 rotation: [0, 0, 0],
 *                 geometry: boxGeometry,
 *                 material: new PhongMaterial(viewer.scene, {
 *                     diffuse: [1.0, 0.3, 1.0]
 *                 })
 *             })
 *         ]
 *     });
 *
 *     let aabb = viewer.scene.aabb;
 *     console.log(aabb);
 *
 *     new Mesh(viewer.scene, {
 *         geometry: new ReadableGeometry(viewer.scene, buildBoxLinesGeometryFromAABB({
 *             id: "aabb",
 *             aabb: aabb,
 *         })),
 *         material: new PhongMaterial(viewer.scene, {
 *             emissive: [0, 1,]
 *         })
 *     });
 * ````
 *
 * @function buildBoxLinesGeometryFromAABB
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.aabb]  AABB for which box will be created.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildBoxLinesGeometryFromAABB(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return buildBoxLinesGeometry({id:cfg.id,center:[(cfg.aabb[0]+cfg.aabb[3])/2.0,(cfg.aabb[1]+cfg.aabb[4])/2.0,(cfg.aabb[2]+cfg.aabb[5])/2.0],xSize:Math.abs(cfg.aabb[3]-cfg.aabb[0])/2.0,ySize:Math.abs(cfg.aabb[4]-cfg.aabb[1])/2.0,zSize:Math.abs(cfg.aabb[5]-cfg.aabb[2])/2.0});}/**
 * @desc Creates a grid-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a GridGeometry and a {@link PhongMaterial}:
 *
 * [[Run this example](/examples/#geometry_builders_buildGridGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildGridGeometry, VBOGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new VBOGeometry(viewer.scene, buildGridGeometry({
 *          size: 1000,
 *          divisions: 500
 *      })),
 *      material: new PhongMaterial(viewer.scene, {
 *          color: [0.0, 0.0, 0.0],
 *          emissive: [0.4, 0.4, 0.4]
 *      }),
 *      position: [0, -1.6, 0]
 * });
 * ````
 *
 * @function buildGridGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number} [cfg.size=1] Dimension on the X and Z-axis.
 * @param {Number} [cfg.divisions=1] Number of divisions on X and Z axis..
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildGridGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var size=cfg.size||1;if(size<0){console.error("negative size not allowed - will invert");size*=-1;}var divisions=cfg.divisions||1;if(divisions<0){console.error("negative divisions not allowed - will invert");divisions*=-1;}if(divisions<1){divisions=1;}size=size||10;divisions=divisions||10;var step=size/divisions;var halfSize=size/2;var positions=[];var indices=[];var l=0;for(var _i153=0,k=-halfSize;_i153<=divisions;_i153++,k+=step){positions.push(-halfSize);positions.push(0);positions.push(k);positions.push(halfSize);positions.push(0);positions.push(k);positions.push(k);positions.push(0);positions.push(-halfSize);positions.push(k);positions.push(0);positions.push(halfSize);indices.push(l++);indices.push(l++);indices.push(l++);indices.push(l++);}return utils.apply(cfg,{primitive:"lines",positions:positions,indices:indices});}/**
 * @desc Creates a plane-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a PlaneGeometry and a {@link PhongMaterial} with diffuse {@link Texture}:
 *
 * [[Run this example](/examples/#geometry_builders_buildPlaneGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildPlaneGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];

 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildPlaneGeometry({
 *          center: [0,0,0],
 *          xSize: 2,
 *          zSize: 2,
 *          xSegments: 10,
 *          zSegments: 10
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 *  });
 * ````
 *
 * @function buildPlaneGeometry
 * @param {*} [cfg] Configs
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number} [cfg.xSize=1] Dimension on the X-axis.
 * @param {Number} [cfg.zSize=1] Dimension on the Z-axis.
 * @param {Number} [cfg.xSegments=1] Number of segments on the X-axis.
 * @param {Number} [cfg.zSegments=1] Number of segments on the Z-axis.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildPlaneGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var xSize=cfg.xSize||1;if(xSize<0){console.error("negative xSize not allowed - will invert");xSize*=-1;}var zSize=cfg.zSize||1;if(zSize<0){console.error("negative zSize not allowed - will invert");zSize*=-1;}var xSegments=cfg.xSegments||1;if(xSegments<0){console.error("negative xSegments not allowed - will invert");xSegments*=-1;}if(xSegments<1){xSegments=1;}var zSegments=cfg.xSegments||1;if(zSegments<0){console.error("negative zSegments not allowed - will invert");zSegments*=-1;}if(zSegments<1){zSegments=1;}var center=cfg.center;var centerX=center?center[0]:0;var centerY=center?center[1]:0;var centerZ=center?center[2]:0;var halfWidth=xSize/2;var halfHeight=zSize/2;var planeX=Math.floor(xSegments)||1;var planeZ=Math.floor(zSegments)||1;var planeX1=planeX+1;var planeZ1=planeZ+1;var segmentWidth=xSize/planeX;var segmentHeight=zSize/planeZ;var positions=new Float32Array(planeX1*planeZ1*3);var normals=new Float32Array(planeX1*planeZ1*3);var uvs=new Float32Array(planeX1*planeZ1*2);var offset=0;var offset2=0;var iz;var ix;var x;var a;var b;var c;var d;for(iz=0;iz<planeZ1;iz++){var _z3=iz*segmentHeight-halfHeight;for(ix=0;ix<planeX1;ix++){x=ix*segmentWidth-halfWidth;positions[offset]=x+centerX;positions[offset+1]=centerY;positions[offset+2]=-_z3+centerZ;normals[offset+2]=-1;uvs[offset2]=ix/planeX;uvs[offset2+1]=(planeZ-iz)/planeZ;offset+=3;offset2+=2;}}offset=0;var indices=new(positions.length/3>65535?Uint32Array:Uint16Array)(planeX*planeZ*6);for(iz=0;iz<planeZ;iz++){for(ix=0;ix<planeX;ix++){a=ix+planeX1*iz;b=ix+planeX1*(iz+1);c=ix+1+planeX1*(iz+1);d=ix+1+planeX1*iz;indices[offset]=d;indices[offset+1]=b;indices[offset+2]=a;indices[offset+3]=d;indices[offset+4]=c;indices[offset+5]=b;offset+=6;}}return utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices});}/**
 * @desc Creates a torus-shaped {@link Geometry}.
 *
 * ## Usage
 * Creating a {@link Mesh} with a torus-shaped {@link ReadableGeometry} :
 *
 * [[Run this example](/examples/#geometry_builders_buildTorusGeometry)]
 * 
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0,0,0],
 *          radius: 1.0,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildTorusGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center] 3D point indicating the center position.
 * @param {Number} [cfg.radius=1] The overall radius.
 * @param {Number} [cfg.tube=0.3] The tube radius.
 * @param {Number} [cfg.radialSegments=32] The number of radial segments.
 * @param {Number} [cfg.tubeSegments=24] The number of tubular segments.
 * @param {Number} [cfg.arc=Math.PI*0.5] The length of the arc in radians, where Math.PI*2 is a closed torus.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildTorusGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var radius=cfg.radius||1;if(radius<0){console.error("negative radius not allowed - will invert");radius*=-1;}radius*=0.5;var tube=cfg.tube||0.3;if(tube<0){console.error("negative tube not allowed - will invert");tube*=-1;}var radialSegments=cfg.radialSegments||32;if(radialSegments<0){console.error("negative radialSegments not allowed - will invert");radialSegments*=-1;}if(radialSegments<4){radialSegments=4;}var tubeSegments=cfg.tubeSegments||24;if(tubeSegments<0){console.error("negative tubeSegments not allowed - will invert");tubeSegments*=-1;}if(tubeSegments<4){tubeSegments=4;}var arc=cfg.arc||Math.PI*2;if(arc<0){console.warn("negative arc not allowed - will invert");arc*=-1;}if(arc>360){arc=360;}var center=cfg.center;var centerX=center?center[0]:0;var centerY=center?center[1]:0;var centerZ=center?center[2]:0;var positions=[];var normals=[];var uvs=[];var indices=[];var u;var v;var x;var y;var z;var vec;var i;var j;for(j=0;j<=tubeSegments;j++){for(i=0;i<=radialSegments;i++){u=i/radialSegments*arc;v=0.785398+j/tubeSegments*Math.PI*2;centerX=radius*Math.cos(u);centerY=radius*Math.sin(u);x=(radius+tube*Math.cos(v))*Math.cos(u);y=(radius+tube*Math.cos(v))*Math.sin(u);z=tube*Math.sin(v);positions.push(x+centerX);positions.push(y+centerY);positions.push(z+centerZ);uvs.push(1-i/radialSegments);uvs.push(j/tubeSegments);vec=math.normalizeVec3(math.subVec3([x,y,z],[centerX,centerY,centerZ],[]),[]);normals.push(vec[0]);normals.push(vec[1]);normals.push(vec[2]);}}var a;var b;var c;var d;for(j=1;j<=tubeSegments;j++){for(i=1;i<=radialSegments;i++){a=(radialSegments+1)*j+i-1;b=(radialSegments+1)*(j-1)+i-1;c=(radialSegments+1)*(j-1)+i;d=(radialSegments+1)*j+i;indices.push(a);indices.push(b);indices.push(c);indices.push(c);indices.push(d);indices.push(a);}}return utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices});}/**
 * @desc Creates a 3D polyline {@link Geometry}.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a polyline {@link ReadableGeometry} that has lines primitives.
 *
 * [[Run this example](/examples/#geometry_builders_buildPolylineGeometry)]
 *
 * ````javascript
 * //------------------------------------------------------------------------------------------------------------------
 * // Import the modules we need for this example
 * //------------------------------------------------------------------------------------------------------------------
 *
 * import {buildPolylineGeometry, Viewer, Mesh, ReadableGeometry, PhongMaterial} from "../../dist/xeokit-sdk.min.es.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // Create a Viewer and arrange the camera
 * //------------------------------------------------------------------------------------------------------------------
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 8];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // Create a mesh with polyline shape
 * //------------------------------------------------------------------------------------------------------------------
 *
 * new Mesh(viewer.scene, {
 *     geometry: new ReadableGeometry(viewer.scene, buildPolylineGeometry({
 *         points: [
 *             0, 2.83654, 0,
 *             -0.665144, 1.152063, 0,
 *             -2.456516, 1.41827, 0,
 *             -1.330288, 0, 0,
 *             -2.456516, -1.41827, 0,
 *             -0.665144, -1.152063, 0,
 *             0, -2.83654, 0,
 *             0.665144, -1.152063, 0,
 *             2.456516, -1.41827, 0,
 *             1.330288, 0, 0,
 *             2.456516, 1.41827, 0,
 *             0.665144, 1.152063, 0,
 *             0, 2.83654, 0,
 *         ]
 *     })),
 *     material: new PhongMaterial(viewer.scene, {
 *         emissive: [0, 1,]
 *     })
 * });
 * ````
 *
 * @function buildPolylineGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.points]  3D points indicating vertices position.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildPolylineGeometry(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(cfg.points.length%3!==0){throw"Size of points array for given polyline should be divisible by 3";}var numberOfPoints=cfg.points.length/3;if(numberOfPoints<2){throw"There should be at least 2 points to create a polyline";}var indices=[];for(var _i154=0;_i154<numberOfPoints-1;_i154++){indices.push(_i154);indices.push(_i154+1);}return utils.apply(cfg,{primitive:"lines",positions:cfg.points,indices:indices});}/**
 * @desc Creates a 3D polyline from curve {@link Geometry}.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a polyline {@link ReadableGeometry} created from curves.
 *
 * [[Run this example](/examples/#geometry_builders_buildPolylineGeometryFromCurve)]
 *
 * ````javascript
 * //------------------------------------------------------------------------------------------------------------------
 * // Import the modules we need for this example
 * //------------------------------------------------------------------------------------------------------------------
 *
 * import {buildPolylineGeometryFromCurve, Viewer, Mesh, PhongMaterial, NavCubePlugin, CubicBezierCurve, SplineCurve, QuadraticBezierCurve, ReadableGeometry} from "../../dist/xeokit-sdk.min.es.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // Create a Viewer and arrange the camera
 * //------------------------------------------------------------------------------------------------------------------
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * new NavCubePlugin(viewer, {
 *     canvasId: "myNavCubeCanvas",
 *     visible: true,
 *     size: 250,
 *     alignment: "bottomRight",
 *     bottomMargin: 100,
 *     rightMargin: 10
 * });
 *
 * viewer.camera.eye = [0, -250, 1];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // Create a mesh with polyline shape from Spline
 * //------------------------------------------------------------------------------------------------------------------
 *
 * new Mesh(viewer.scene, {
 *     geometry: new ReadableGeometry(viewer.scene, buildPolylineGeometryFromCurve({
 *         id: "SplineCurve",
 *         curve: new SplineCurve(viewer.scene, {
 *             points: [
 *                 [-65.77614, 0, -88.881992],
 *                 [90.020852, 0, -61.589088],
 *                 [-67.766247, 0, -22.071238],
 *                 [93.148164, 0, -13.826507],
 *                 [-14.033343, 0, 3.231558],
 *                 [32.592034, 0, 9.20188],
 *                 [3.309023, 0, 22.848332],
 *                 [23.210098, 0, 28.818655],
 *             ],
 *         }),
 *         divisions: 100,
 *     })),
 *     material: new PhongMaterial(viewer.scene, {
 *         emissive: [1, 0, 0]
 *     })
 * });
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // Create a mesh with polyline shape from CubicBezier
 * //------------------------------------------------------------------------------------------------------------------
 *
 * new Mesh(viewer.scene, {
 *     geometry: new ReadableGeometry(viewer.scene, buildPolylineGeometryFromCurve({
 *         id: "CubicBezierCurve",
 *         curve: new CubicBezierCurve(viewer.scene, {
 *             v0: [120, 0, 100],
 *             v1: [120, 0, 0],
 *             v2: [80, 0, 100],
 *             v3: [80, 0, 0],
 *         }),
 *         divisions: 50,
 *     })),
 *     material: new PhongMaterial(viewer.scene, {
 *         emissive: [0, 1, 0]
 *     })
 * });
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // Create a mesh with polyline shape from QuadraticBezier
 * //------------------------------------------------------------------------------------------------------------------
 *
 * new Mesh(viewer.scene, {
 *     geometry: new ReadableGeometry(viewer.scene, buildPolylineGeometryFromCurve({
 *         id: "QuadraticBezierCurve",
 *         curve: new QuadraticBezierCurve(viewer.scene, {
 *             v0: [-100, 0, 100],
 *             v1: [-50, 0, 150],
 *             v2: [-50, 0, 0],
 *         }),
 *         divisions: 20,
 *     })),
 *     material: new PhongMaterial(viewer.scene, {
 *         emissive: [0, 0, 1]
 *     })
 * });
 * ````
 *
 * @function buildPolylineGeometryFromCurve
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Object} [cfg.curve]  Curve for which polyline will be created.
 * @param {Number} [cfg.divisions]  The number of divisions.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */function buildPolylineGeometryFromCurve(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var polylinePoints=cfg.curve.getPoints(cfg.divisions).map(function(a){return _toConsumableArray(a);}).flat();return buildPolylineGeometry({id:cfg.id,points:polylinePoints});}/**
 *  A plane-shaped 3D object containing a bitmap image.
 *
 * * Creates a 3D quad containing our bitmap, located and oriented using ````pos````, ````normal```` and ````up```` vectors.
 * * Registered by {@link Bitmap#id} in {@link Scene#bitmaps}.
 * * {@link BCFViewpointsPlugin} will save and load Bitmaps in BCF viewpoints.
 *
 * ## Usage
 *
 * In the example below, we'll load the Schependomlaan model, then use
 * an ````Bitmap```` to show a storey plan next to the model.
 *
 * [<img src="http://xeokit.github.io/xeokit-sdk/assets/images/Bitmap_storeyPlan.png">](/examples/#Bitmap_storeyPlan)
 *
 * [[Run this example](/examples/#Bitmap_grid)]
 *
 * ````javascript
 * import {Viewer, Bitmap, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 *  });
 *
 * viewer.camera.eye = [-24.65, 21.69, 8.16];
 * viewer.camera.look = [-14.62, 2.16, -1.38];
 * viewer.camera.up = [0.59, 0.57, -0.56];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true
 *  });
 *
 * new Bitmap(viewer.scene, {
 *      src: "./images/schependomlaanPlanView.png",
 *      visible: true,                             // Show the Bitmap
 *      height: 24.0,                              // Height of Bitmap
 *      pos: [-15, 0, -10],                        // World-space position of Bitmap's center
 *      normal: [0, -1, 0],                        // Vector perpendicular to Bitmap
 *      up: [0, 0, 1],                             // Direction of Bitmap "up"
 *      collidable: false,                         // Bitmap does not contribute to Scene boundary
 *      clippable: true,                           // Bitmap can be clipped by SectionPlanes
 *      pickable: true                             // Allow the ground plane to be picked
 * });
 * ````
 */var Bitmap=/*#__PURE__*/function(_Component26){_inherits(Bitmap,_Component26);var _super44=_createSuper(Bitmap);/**
     * Creates a new Bitmap.
     *
     * Registers the Bitmap in {@link Scene#bitmaps}; causes Scene to fire a "bitmapCreated" event.
     *
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this ````Bitmap```` as well.
     * @param {*} [cfg]  ````Bitmap```` configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Boolean} [cfg.visible=true] Indicates whether or not this ````Bitmap```` is visible.
     * @param {Number[]} [cfg.pos=[0,0,0]] World-space position of the ````Bitmap````.
     * @param {Number[]} [cfg.normal=[0,0,1]] Normal vector indicating the direction the ````Bitmap```` faces.
     * @param {Number[]} [cfg.up=[0,1,0]] Direction of "up" for the ````Bitmap````.
     * @param {Number[]} [cfg.height=1] World-space height of the ````Bitmap````.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Modelling transform matrix for the ````Bitmap````. Overrides the ````position````, ````height```, ````rotation```` and ````normal```` parameters.
     * @param {Boolean} [cfg.collidable=true] Indicates if the ````Bitmap```` is initially included in boundary calculations.
     * @param {Boolean} [cfg.clippable=true] Indicates if the ````Bitmap```` is initially clippable.
     * @param {Boolean} [cfg.pickable=true] Indicates if the ````Bitmap```` is initially pickable.
     * @param {Number} [cfg.opacity=1.0] ````Bitmap````'s initial opacity factor, multiplies by the rendered fragment alpha.
     * @param {String} [cfg.src] URL of image. Accepted file types are PNG and JPEG.
     * @param {HTMLImageElement} [cfg.image] An ````HTMLImageElement```` to source the image from. Overrides ````src````.
     * @param {String} [cfg.imageData]    Image data as a base64 encoded string.
     * @param {String} [cfg.type="jpg"] Image MIME type. Accepted values are "jpg" and "png". Default is "jpg". Normally only needed with ````image```` or ````imageData````. Automatically inferred from file extension of ````src````, if the file has a recognized extension.
     */function Bitmap(owner){var _this63;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Bitmap);_this63=_super44.call(this,owner,cfg);_this63._type=cfg.type||(cfg.src?cfg.src.split('.').pop():null)||"jpg";_this63._pos=math.vec3(cfg.pos||[0,0,0]);_this63._up=math.vec3(cfg.up||[0,1,0]);_this63._normal=math.vec3(cfg.normal||[0,0,1]);_this63._height=cfg.height||1.0;_this63._origin=math.vec3();_this63._rtcPos=math.vec3();_this63._imageSize=math.vec2();_this63._texture=new Texture(_assertThisInitialized(_this63),{flipY:true});_this63._image=new Image();if(_this63._type!=="jpg"&&_this63._type!=="png"){_this63.error("Unsupported type - defaulting to \"jpg\"");_this63._type="jpg";}_this63._node=new Node$2(_assertThisInitialized(_this63),{matrix:math.inverseMat4(math.lookAtMat4v(_this63._pos,math.subVec3(_this63._pos,_this63._normal,math.mat4()),_this63._up,math.mat4())),children:[_this63._bitmapMesh=new Mesh(_assertThisInitialized(_this63),{scale:[1,1,1],rotation:[-90,0,0],collidable:cfg.collidable,pickable:cfg.pickable,opacity:cfg.opacity,clippable:cfg.clippable,geometry:new ReadableGeometry(_assertThisInitialized(_this63),buildPlaneGeometry({center:[0,0,0],xSize:1,zSize:1,xSegments:2,zSegments:2})),material:new PhongMaterial(_assertThisInitialized(_this63),{diffuse:[0,0,0],ambient:[0,0,0],specular:[0,0,0],diffuseMap:_this63._texture,emissiveMap:_this63._texture,backfaces:true})})]});if(cfg.image){_this63.image=cfg.image;}else if(cfg.src){_this63.src=cfg.src;}else if(cfg.imageData){_this63.imageData=cfg.imageData;}_this63.scene._bitmapCreated(_assertThisInitialized(_this63));return _this63;}/**
     * Sets if this ````Bitmap```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} visible Set ````true```` to make this ````Bitmap```` visible.
     */_createClass(Bitmap,[{key:"visible",get:/**
     * Gets if this ````Bitmap```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */function get(){return this._bitmapMesh.visible;}/**
     * Sets an ````HTMLImageElement```` to source the image from.
     *
     * Sets {@link Texture#src} null.
     *
     * You may also need to set {@link Bitmap#type}, if you want to read the image data with {@link Bitmap#imageData}.
     *
     * @type {HTMLImageElement}
     */,set:function set(visible){this._bitmapMesh.visible=visible;}},{key:"image",get:/**
     * Gets the ````HTMLImageElement```` the ````Bitmap````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {HTMLImageElement}
     */function get(){return this._image;}/**
     * Sets an image file path that the ````Bitmap````'s image is sourced from.
     *
     * If the file extension is a recognized MIME type, also sets {@link Bitmap#type} to that MIME type.
     *
     * Accepted file types are PNG and JPEG.
     *
     * @type {String}
     */,set:function set(image){this._image=image;if(this._image){this._texture.image=this._image;this._imageSize[0]=this._image.width;this._imageSize[1]=this._image.height;this._updateBitmapMeshScale();}}},{key:"src",get:/**
     * Gets the image file path that the ````Bitmap````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {String}
     */function get(){return this._image.src;}/**
     * Sets an image file path that the ````Bitmap````'s image is sourced from.
     *
     * Accepted file types are PNG and JPEG.
     *
     * Sets {@link Texture#image} null.
     *
     * You may also need to set {@link Bitmap#type}, if you want to read the image data with {@link Bitmap#imageData}.
     *
     * @type {String}
     */,set:function set(src){var _this64=this;if(src){this._image.onload=function(){_this64._texture.image=_this64._image;_this64._imageSize[0]=_this64._image.width;_this64._imageSize[1]=_this64._image.height;_this64._updateBitmapMeshScale();};this._image.src=src;var ext=src.split('.').pop();switch(ext){case"jpeg":case"jpg":this._type="jpg";break;case"png":this._type="png";}}}},{key:"imageData",get:/**
     * Gets the image file path that the ````Bitmap````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {String}
     */function get(){var canvas=document.createElement('canvas');var context=canvas.getContext('2d');canvas.width=this._image.width;canvas.height=this._image.height;context.drawImage(this._image,0,0);return canvas.toDataURL(this._type==="jpg"?'image/jpeg':'image/png');}/**
     * Sets the MIME type of this Bitmap.
     *
     * This is used by ````Bitmap```` when getting image data with {@link Bitmap#imageData}.
     *
     * Supported values are "jpg" and "png",
     *
     * Default is "jpg".
     *
     * @type {String}
     */,set:function set(imageData){var _this65=this;this._image.onload=function(){_this65._texture.image=image;_this65._imageSize[0]=image.width;_this65._imageSize[1]=image.height;_this65._updateBitmapMeshScale();};this._image.src=imageData;}},{key:"type",get:/**
     * Gets the MIME type of this Bitmap.
     *
     * @type {String}
     */function get(){return this._type;}/**
     * Gets the World-space position of this ````Bitmap````.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @returns {Number[]} Current position.
     */,set:function set(type){type=type||"jpg";if(type!=="png"||type!=="jpg"){this.error("Unsupported value for `type` - supported types are `jpg` and `png` - defaulting to `jpg`");type="jpg";}this._type=type;}},{key:"pos",get:function get(){return this._pos;}/**
     * Gets the direction of the normal vector that is perpendicular to this ````Bitmap````.
     *
     * @returns {Number[]} value Current normal direction.
     */},{key:"normal",get:function get(){return this._normal;}/**
     * Gets the "up" direction of this ````Bitmap````.
     *
     * @returns {Number[]} value Current "up" direction.
     */},{key:"up",get:function get(){return this._up;}/**
     * Sets the World-space height of the ````Bitmap````.
     *
     * Default value is ````1.0````.
     *
     * @param {Number} height New World-space height of the ````Bitmap````.
     */},{key:"height",get:/**
     * Gets the World-space height of the ````Bitmap````.
     *
     * Returns {Number} World-space height of the ````Bitmap````.
     */function get(){return this._height;}/**
     * Sets if this ````Bitmap```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(height){this._height=height===undefined||height===null?1.0:height;if(this._image){this._updateBitmapMeshScale();}}},{key:"collidable",get:/**
     * Gets if this ````Bitmap```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._bitmapMesh.collidable;}/**
     * Sets if this ````Bitmap```` is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){this._bitmapMesh.collidable=value!==false;}},{key:"clippable",get:/**
     * Gets if this ````Bitmap````  is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._bitmapMesh.clippable;}/**
     * Sets if this ````Bitmap```` is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){this._bitmapMesh.clippable=value!==false;}},{key:"pickable",get:/**
     * Gets if this ````Bitmap````  is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._bitmapMesh.pickable;}/**
     * Sets the opacity factor for this ````Bitmap````.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(value){this._bitmapMesh.pickable=value!==false;}},{key:"opacity",get:/**
     * Gets this ````Bitmap````'s opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */function get(){return this._bitmapMesh.opacity;}/**
     * Destroys this ````Bitmap````.
     *
     * Removes the ```Bitmap```` from {@link Scene#bitmaps}; causes Scene to fire a "bitmapDestroyed" event.
     */,set:function set(opacity){this._bitmapMesh.opacity=opacity;}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Bitmap.prototype),"destroy",this).call(this);this.scene._bitmapDestroyed(this);}},{key:"_updateBitmapMeshScale",value:function _updateBitmapMeshScale(){var aspect=this._imageSize[1]/this._imageSize[0];this._bitmapMesh.scale=[this._height/aspect,1.0,this._height];}}]);return Bitmap;}(Component);var tempOBB3$1=math.OBB3();var tempOBB3b=math.OBB3();var tempOBB3c=math.OBB3();/**
 * A mesh within a {@link SceneModel}.
 *
 * * Created with {@link SceneModel#createMesh}
 * * Belongs to exactly one {@link SceneModelEntity}
 * * Stored by ID in {@link SceneModel#meshes}
 * * Referenced by {@link SceneModelEntity#meshes}
 * * Can have a {@link SceneModelTransform} to dynamically scale, rotate and translate it.
 */var SceneModelMesh=/*#__PURE__*/function(){/**
     * @private
     */function SceneModelMesh(model,id,color,opacity,transform,textureSet){var layer=arguments.length>6&&arguments[6]!==undefined?arguments[6]:null;var portionId=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;_classCallCheck(this,SceneModelMesh);/**
         * The {@link SceneModel} that owns this SceneModelMesh.
         *
         * @type {SceneModel}
         */this.model=model;/**
         * The {@link SceneModelEntity} that owns this SceneModelMesh.
         *
         * @type {SceneModelEntity}
         */this.object=null;/**
         * @private
         */this.parent=null;/**
         * The {@link SceneModelTransform} that transforms this SceneModelMesh.
         *
         * * This only exists when the SceneModelMesh is instancing its geometry.
         * * These are created with {@link SceneModel#createTransform}
         * * Each of these is also registered in {@link SceneModel#transforms}.
         *
         * @type {SceneModelTransform}
         */this.transform=transform;/**
         * The {@link SceneModelTextureSet} that optionally textures this SceneModelMesh.
         *
         * * This only exists when the SceneModelMesh has texture.
         * * These are created with {@link SceneModel#createTextureSet}
         * * Each of these is also registered in {@link SceneModel#textureSets}.
         *
         * @type {SceneModelTextureSet}
         */this.textureSet=textureSet;this._matrixDirty=false;this._matrixUpdateScheduled=false;/**
         * Unique ID of this SceneModelMesh.
         *
         * The SceneModelMesh is registered against this ID in {@link SceneModel#meshes}.
         */this.id=id;/**
         * @private
         */this.obb=null;this._aabbLocal=null;this._aabbWorld=math.AABB3();this._aabbWorldDirty=false;/**
         * @private
         */this.layer=layer;/**
         * @private
         */this.portionId=portionId;this._color=new Uint8Array([color[0],color[1],color[2],opacity]);// [0..255]
this._colorize=new Uint8Array([color[0],color[1],color[2],opacity]);// [0..255]
this._colorizing=false;this._transparent=opacity<255;/**
         * @private
         */this.numTriangles=0;/**
         * @private
         * @type {null}
         */this.origin=null;// Set By SceneModel
/**
         * The {@link SceneModelEntity} that owns this SceneModelMesh.
         *
         * @type {SceneModelEntity}
         */this.entity=null;if(transform){transform._addMesh(this);}}_createClass(SceneModelMesh,[{key:"_sceneModelDirty",value:function _sceneModelDirty(){this._aabbWorldDirty=true;this.layer.aabbDirty=true;}},{key:"_transformDirty",value:function _transformDirty(){if(!this._matrixDirty&&!this._matrixUpdateScheduled){this.model._meshMatrixDirty(this);this._matrixDirty=true;this._matrixUpdateScheduled=true;}this._aabbWorldDirty=true;this.layer.aabbDirty=true;if(this.entity){this.entity._transformDirty();}}},{key:"_updateMatrix",value:function _updateMatrix(){if(this.transform&&this._matrixDirty){this.layer.setMatrix(this.portionId,this.transform.worldMatrix);}this._matrixDirty=false;this._matrixUpdateScheduled=false;}},{key:"_finalize",value:function _finalize(entityFlags){this.layer.initFlags(this.portionId,entityFlags,this._transparent);}},{key:"_finalize2",value:function _finalize2(){if(this.layer.flushInitFlags){this.layer.flushInitFlags();}}},{key:"_setVisible",value:function _setVisible(entityFlags){this.layer.setVisible(this.portionId,entityFlags,this._transparent);}},{key:"_setColor",value:function _setColor(color){this._color[0]=color[0];this._color[1]=color[1];this._color[2]=color[2];if(!this._colorizing){this.layer.setColor(this.portionId,this._color,false);}}},{key:"_setColorize",value:function _setColorize(colorize){var setOpacity=false;if(colorize){this._colorize[0]=colorize[0];this._colorize[1]=colorize[1];this._colorize[2]=colorize[2];this.layer.setColor(this.portionId,this._colorize,setOpacity);this._colorizing=true;}else{this.layer.setColor(this.portionId,this._color,setOpacity);this._colorizing=false;}}},{key:"_setOpacity",value:function _setOpacity(opacity,entityFlags){var newTransparent=opacity<255;var lastTransparent=this._transparent;var changingTransparency=lastTransparent!==newTransparent;this._color[3]=opacity;this._colorize[3]=opacity;this._transparent=newTransparent;if(this._colorizing){this.layer.setColor(this.portionId,this._colorize);}else{this.layer.setColor(this.portionId,this._color);}if(changingTransparency){this.layer.setTransparent(this.portionId,entityFlags,newTransparent);}}},{key:"_setOffset",value:function _setOffset(offset){this.layer.setOffset(this.portionId,offset);}},{key:"_setHighlighted",value:function _setHighlighted(entityFlags){this.layer.setHighlighted(this.portionId,entityFlags,this._transparent);}},{key:"_setXRayed",value:function _setXRayed(entityFlags){this.layer.setXRayed(this.portionId,entityFlags,this._transparent);}},{key:"_setSelected",value:function _setSelected(entityFlags){this.layer.setSelected(this.portionId,entityFlags,this._transparent);}},{key:"_setEdges",value:function _setEdges(entityFlags){this.layer.setEdges(this.portionId,entityFlags,this._transparent);}},{key:"_setClippable",value:function _setClippable(entityFlags){this.layer.setClippable(this.portionId,entityFlags,this._transparent);}},{key:"_setCollidable",value:function _setCollidable(entityFlags){this.layer.setCollidable(this.portionId,entityFlags);}},{key:"_setPickable",value:function _setPickable(flags){this.layer.setPickable(this.portionId,flags,this._transparent);}},{key:"_setCulled",value:function _setCulled(flags){this.layer.setCulled(this.portionId,flags,this._transparent);}/**
     * @private
     */},{key:"canPickTriangle",value:function canPickTriangle(){return false;}/**
     * @private
     */},{key:"drawPickTriangles",value:function drawPickTriangles(renderFlags,frameCtx){// NOP
}/**
     * @private
     */},{key:"pickTriangleSurface",value:function pickTriangleSurface(pickResult){// NOP
}/**
     * @private
     */},{key:"precisionRayPickSurface",value:function precisionRayPickSurface(worldRayOrigin,worldRayDir,worldSurfacePos,worldSurfaceNormal){return this.layer.precisionRayPickSurface?this.layer.precisionRayPickSurface(this.portionId,worldRayOrigin,worldRayDir,worldSurfacePos,worldSurfaceNormal):false;}/**
     * @private
     */},{key:"canPickWorldPos",value:function canPickWorldPos(){return true;}/**
     * @private
     */},{key:"drawPickDepths",value:function drawPickDepths(frameCtx){this.model.drawPickDepths(frameCtx);}/**
     * @private
     */},{key:"drawPickNormals",value:function drawPickNormals(frameCtx){this.model.drawPickNormals(frameCtx);}/**
     * @private
     */},{key:"delegatePickedEntity",value:function delegatePickedEntity(){return this.parent;}/**
     * @private
     */},{key:"getEachVertex",value:function getEachVertex(callback){this.layer.getEachVertex(this.portionId,callback);}/**
     * @private
     */},{key:"aabb",get:/**
     * @private
     */function get(){// called by SceneModelEntity
if(this._aabbWorldDirty){math.AABB3ToOBB3(this._aabbLocal,tempOBB3$1);if(this.transform){math.transformOBB3(this.transform.worldMatrix,tempOBB3$1,tempOBB3b);math.transformOBB3(this.model.worldMatrix,tempOBB3b,tempOBB3c);math.OBB3ToAABB3(tempOBB3c,this._aabbWorld);}else{math.transformOBB3(this.model.worldMatrix,tempOBB3$1,tempOBB3b);math.OBB3ToAABB3(tempOBB3b,this._aabbWorld);}if(this.origin){var origin=this.origin;this._aabbWorld[0]+=origin[0];this._aabbWorld[1]+=origin[1];this._aabbWorld[2]+=origin[2];this._aabbWorld[3]+=origin[0];this._aabbWorld[4]+=origin[1];this._aabbWorld[5]+=origin[2];}this._aabbWorldDirty=false;}return this._aabbWorld;}/**
     * @private
     */,set:function set(aabb){// Called by SceneModel
this._aabbLocal=aabb;}},{key:"_destroy",value:function _destroy(){this.model.scene._renderer.putPickID(this.pickId);}}]);return SceneModelMesh;}();/**
 * Provides scratch memory for methods like TrianglesBatchingLayer setFlags() and setColors(),
 * so they don't need to allocate temporary arrays that need garbage collection.
 *
 * @private
 */var ScratchMemory=/*#__PURE__*/function(){function ScratchMemory(){_classCallCheck(this,ScratchMemory);this._uint8Arrays={};this._float32Arrays={};}_createClass(ScratchMemory,[{key:"_clear",value:function _clear(){this._uint8Arrays={};this._float32Arrays={};}},{key:"getUInt8Array",value:function getUInt8Array(len){var uint8Array=this._uint8Arrays[len];if(!uint8Array){uint8Array=new Uint8Array(len);this._uint8Arrays[len]=uint8Array;}return uint8Array;}},{key:"getFloat32Array",value:function getFloat32Array(len){var float32Array=this._float32Arrays[len];if(!float32Array){float32Array=new Float32Array(len);this._float32Arrays[len]=float32Array;}return float32Array;}}]);return ScratchMemory;}();var batchingLayerScratchMemory=new ScratchMemory();var countUsers=0;/**
 * @private
 */function getScratchMemory(){countUsers++;return batchingLayerScratchMemory;}/**
 * @private
 */function putScratchMemory(){if(countUsers===0){return;}countUsers--;if(countUsers===0){batchingLayerScratchMemory._clear();}}/**
 * @private
 */var RENDER_PASSES={// Skipped - suppress rendering
NOT_RENDERED:0,// Normal rendering - mutually exclusive modes
COLOR_OPAQUE:1,COLOR_TRANSPARENT:2,// Emphasis silhouette rendering - mutually exclusive modes
SILHOUETTE_HIGHLIGHTED:3,SILHOUETTE_SELECTED:4,SILHOUETTE_XRAYED:5,// Edges rendering - mutually exclusive modes
EDGES_COLOR_OPAQUE:6,EDGES_COLOR_TRANSPARENT:7,EDGES_HIGHLIGHTED:8,EDGES_SELECTED:9,EDGES_XRAYED:10,// Picking
PICK:11};var defaultColor$2=new Float32Array([1,1,1,1]);var edgesDefaultColor=new Float32Array([0,0,0,1]);var tempVec4=math.vec4();var tempVec3a$C=math.vec3();var tempVec3c$t=math.vec3();var tempMat4a$r=math.mat4();/**
 * @private
 */var VBORenderer=/*#__PURE__*/function(){function VBORenderer(scene){var withSAO=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var _ref6=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref6$instancing=_ref6.instancing,instancing=_ref6$instancing===void 0?false:_ref6$instancing,_ref6$edges=_ref6.edges,edges=_ref6$edges===void 0?false:_ref6$edges;_classCallCheck(this,VBORenderer);this._scene=scene;this._withSAO=withSAO;this._instancing=instancing;this._edges=edges;this._hash=this._getHash();/**
         * Matrices Uniform Block Buffer
         *
         * In shaders, matrices in the Matrices Uniform Block MUST be set in this order:
         *  - worldMatrix
         *  - viewMatrix
         *  - projMatrix
         *  - positionsDecodeMatrix
         *  - worldNormalMatrix
         *  - viewNormalMatrix
         */this._matricesUniformBlockBufferBindingPoint=0;this._matricesUniformBlockBuffer=this._scene.canvas.gl.createBuffer();this._matricesUniformBlockBufferData=new Float32Array(4*4*6);// there is 6 mat4
/**
         * A Vertex Array Object by Layer
         */this._vaoCache=new WeakMap();this._allocate();}/**
     * Should be overrided by subclasses if it does not only "depend" on section planes state.
     * @returns { string }
     */_createClass(VBORenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){return[""];}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){return[""];}},{key:"_addMatricesUniformBlockLines",value:function _addMatricesUniformBlockLines(src){var normals=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;src.push("uniform Matrices {");src.push("    mat4 worldMatrix;");src.push("    mat4 viewMatrix;");src.push("    mat4 projMatrix;");src.push("    mat4 positionsDecodeMatrix;");if(normals){src.push("    mat4 worldNormalMatrix;");src.push("    mat4 viewNormalMatrix;");}src.push("};");return src;}},{key:"_addRemapClipPosLines",value:function _addRemapClipPosLines(src){var viewportSize=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;src.push("uniform vec2 drawingBufferSize;");src.push("uniform vec2 pickClipPos;");src.push("vec4 remapClipPos(vec4 clipPos) {");src.push("    clipPos.xy /= clipPos.w;");if(viewportSize===1){src.push("    clipPos.xy = (clipPos.xy - pickClipPos) * drawingBufferSize;");}else{src.push("    clipPos.xy = (clipPos.xy - pickClipPos) * (drawingBufferSize / float(".concat(viewportSize,"));"));}src.push("    clipPos.xy *= clipPos.w;");src.push("    return clipPos;");src.push("}");return src;}},{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"setSectionPlanesStateUniforms",value:function setSectionPlanesStateUniforms(layer){var scene=this._scene;var gl=scene.canvas.gl;var model=layer.model,layerIndex=layer.layerIndex;var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];var origin=layer._state.origin;if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$C);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;var lightsState=scene._lightsState;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uColor=program.getLocation("color");if(!this._uColor){// some shader may have color as attribute, in this case the uniform must be renamed silhouetteColor
this._uColor=program.getLocation("silhouetteColor");}this._uUVDecodeMatrix=program.getLocation("uvDecodeMatrix");this._uPickInvisible=program.getLocation("pickInvisible");this._uGammaFactor=program.getLocation("gammaFactor");gl.uniformBlockBinding(program.handle,gl.getUniformBlockIndex(program.handle,"Matrices"),this._matricesUniformBlockBufferBindingPoint);this._uShadowViewMatrix=program.getLocation("shadowViewMatrix");this._uShadowProjMatrix=program.getLocation("shadowProjMatrix");if(scene.logarithmicDepthBufferEnabled){this._uZFar=program.getLocation("zFar");}this._uLightAmbient=program.getLocation("lightAmbient");this._uLightColor=[];this._uLightDir=[];this._uLightPos=[];this._uLightAttenuation=[];// TODO add a gard to prevent light params if not affected by light ?
var lights=lightsState.lights;var light;for(var _i155=0,len=lights.length;_i155<len;_i155++){light=lights[_i155];switch(light.type){case"dir":this._uLightColor[_i155]=program.getLocation("lightColor"+_i155);this._uLightPos[_i155]=null;this._uLightDir[_i155]=program.getLocation("lightDir"+_i155);break;case"point":this._uLightColor[_i155]=program.getLocation("lightColor"+_i155);this._uLightPos[_i155]=program.getLocation("lightPos"+_i155);this._uLightDir[_i155]=null;this._uLightAttenuation[_i155]=program.getLocation("lightAttenuation"+_i155);break;case"spot":this._uLightColor[_i155]=program.getLocation("lightColor"+_i155);this._uLightPos[_i155]=program.getLocation("lightPos"+_i155);this._uLightDir[_i155]=program.getLocation("lightDir"+_i155);this._uLightAttenuation[_i155]=program.getLocation("lightAttenuation"+_i155);break;}}if(lightsState.reflectionMaps.length>0){this._uReflectionMap="reflectionMap";}if(lightsState.lightMaps.length>0){this._uLightMap="lightMap";}this._uSectionPlanes=[];for(var _i156=0,_len19=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i156<_len19;_i156++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i156),pos:program.getLocation("sectionPlanePos"+_i156),dir:program.getLocation("sectionPlaneDir"+_i156)});}this._aPosition=program.getAttribute("position");this._aOffset=program.getAttribute("offset");this._aNormal=program.getAttribute("normal");this._aUV=program.getAttribute("uv");this._aColor=program.getAttribute("color");this._aMetallicRoughness=program.getAttribute("metallicRoughness");this._aFlags=program.getAttribute("flags");this._aPickColor=program.getAttribute("pickColor");this._uPickZNear=program.getLocation("pickZNear");this._uPickZFar=program.getLocation("pickZFar");this._uPickClipPos=program.getLocation("pickClipPos");this._uDrawingBufferSize=program.getLocation("drawingBufferSize");this._uColorMap="uColorMap";this._uMetallicRoughMap="uMetallicRoughMap";this._uEmissiveMap="uEmissiveMap";this._uNormalMap="uNormalMap";this._uAOMap="uAOMap";if(this._instancing){this._aModelMatrix=program.getAttribute("modelMatrix");this._aModelMatrixCol0=program.getAttribute("modelMatrixCol0");this._aModelMatrixCol1=program.getAttribute("modelMatrixCol1");this._aModelMatrixCol2=program.getAttribute("modelMatrixCol2");this._aModelNormalMatrixCol0=program.getAttribute("modelNormalMatrixCol0");this._aModelNormalMatrixCol1=program.getAttribute("modelNormalMatrixCol1");this._aModelNormalMatrixCol2=program.getAttribute("modelNormalMatrixCol2");}if(this._withSAO){this._uOcclusionTexture="uOcclusionTexture";this._uSAOParams=program.getLocation("uSAOParams");}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}if(scene.pointsMaterial._state.filterIntensity){this._uIntensityRange=program.getLocation("intensityRange");}this._uPointSize=program.getLocation("pointSize");this._uNearPlaneHeight=program.getLocation("nearPlaneHeight");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var lightsState=scene._lightsState;var lights=lightsState.lights;program.bind();frameCtx.textureUnit=0;if(this._uLightAmbient){gl.uniform4fv(this._uLightAmbient,lightsState.getAmbientColorAndIntensity());}if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor);}for(var _i157=0,len=lights.length;_i157<len;_i157++){var light=lights[_i157];if(this._uLightColor[_i157]){gl.uniform4f(this._uLightColor[_i157],light.color[0],light.color[1],light.color[2],light.intensity);}if(this._uLightPos[_i157]){gl.uniform3fv(this._uLightPos[_i157],light.pos);if(this._uLightAttenuation[_i157]){gl.uniform1f(this._uLightAttenuation[_i157],light.attenuation);}}if(this._uLightDir[_i157]){gl.uniform3fv(this._uLightDir[_i157],light.dir);}}}},{key:"_makeVAO",value:function _makeVAO(state){var gl=this._scene.canvas.gl;var vao=gl.createVertexArray();gl.bindVertexArray(vao);if(this._instancing){this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);if(this._aModelNormalMatrixCol0){this._aModelNormalMatrixCol0.bindArrayBuffer(state.modelNormalMatrixCol0Buf);gl.vertexAttribDivisor(this._aModelNormalMatrixCol0.location,1);}if(this._aModelNormalMatrixCol1){this._aModelNormalMatrixCol1.bindArrayBuffer(state.modelNormalMatrixCol1Buf);gl.vertexAttribDivisor(this._aModelNormalMatrixCol1.location,1);}if(this._aModelNormalMatrixCol2){this._aModelNormalMatrixCol2.bindArrayBuffer(state.modelNormalMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelNormalMatrixCol2.location,1);}}this._aPosition.bindArrayBuffer(state.positionsBuf);if(this._aUV){this._aUV.bindArrayBuffer(state.uvBuf);}if(this._aNormal){this._aNormal.bindArrayBuffer(state.normalsBuf);}if(this._aMetallicRoughness){this._aMetallicRoughness.bindArrayBuffer(state.metallicRoughnessBuf);if(this._instancing){gl.vertexAttribDivisor(this._aMetallicRoughness.location,1);}}if(this._aColor){this._aColor.bindArrayBuffer(state.colorsBuf);if(this._instancing&&state.colorsBuf){gl.vertexAttribDivisor(this._aColor.location,1);}}if(this._aFlags){this._aFlags.bindArrayBuffer(state.flagsBuf);if(this._instancing){gl.vertexAttribDivisor(this._aFlags.location,1);}}if(this._aOffset){this._aOffset.bindArrayBuffer(state.offsetsBuf);if(this._instancing){gl.vertexAttribDivisor(this._aOffset.location,1);}}if(this._aPickColor){this._aPickColor.bindArrayBuffer(state.pickColorsBuf);if(this._instancing){gl.vertexAttribDivisor(this._aPickColor.location,1);}}if(this._instancing){if(this._edges){state.edgeIndicesBuf.bind();}else{if(state.indicesBuf){state.indicesBuf.bind();}}}else{if(this._edges){state.edgeIndicesBuf.bind();}else{if(state.indicesBuf){state.indicesBuf.bind();}}}return vao;}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){var _ref7=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{},_ref7$colorUniform=_ref7.colorUniform,colorUniform=_ref7$colorUniform===void 0?false:_ref7$colorUniform,_ref7$incrementDrawSt=_ref7.incrementDrawState,incrementDrawState=_ref7$incrementDrawSt===void 0?false:_ref7$incrementDrawSt;var maxTextureUnits=WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS;var scene=this._scene;var gl=scene.canvas.gl;var state=layer._state,model=layer.model;var textureSet=state.textureSet,origin=state.origin,positionsDecodeMatrix=state.positionsDecodeMatrix;var lightsState=scene._lightsState;var pointsMaterial=scene.pointsMaterial;var camera=model.scene.camera;var viewNormalMatrix=camera.viewNormalMatrix,project=camera.project;var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate,worldNormalMatrix=model.worldNormalMatrix;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx);}if(this._vaoCache.has(layer)){gl.bindVertexArray(this._vaoCache.get(layer));}else{this._vaoCache.set(layer,this._makeVAO(state));}var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$C;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$t);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];this._matricesUniformBlockBufferData.set(createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$r),offset+=mat4Size);}else{this._matricesUniformBlockBufferData.set(viewMatrix,offset+=mat4Size);}this._matricesUniformBlockBufferData.set(frameCtx.pickProjMatrix||project.matrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(positionsDecodeMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(worldNormalMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(viewNormalMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);gl.uniform1i(this._uRenderPass,renderPass);this.setSectionPlanesStateUniforms(layer);if(scene.logarithmicDepthBufferEnabled){if(this._uLogDepthBufFC){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}if(this._uZFar){gl.uniform1f(this._uZFar,scene.camera.project.far);}}if(this._uPickInvisible){gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);}if(this._uPickZNear){gl.uniform1f(this._uPickZNear,frameCtx.pickZNear);}if(this._uPickZFar){gl.uniform1f(this._uPickZFar,frameCtx.pickZFar);}if(this._uPickClipPos){gl.uniform2fv(this._uPickClipPos,frameCtx.pickClipPos);}if(this._uDrawingBufferSize){gl.uniform2f(this._uDrawingBufferSize,gl.drawingBufferWidth,gl.drawingBufferHeight);}if(this._uUVDecodeMatrix){gl.uniformMatrix3fv(this._uUVDecodeMatrix,false,state.uvDecodeMatrix);}if(this._uIntensityRange&&pointsMaterial.filterIntensity){gl.uniform2f(this._uIntensityRange,pointsMaterial.minIntensity,pointsMaterial.maxIntensity);}if(this._uPointSize){gl.uniform1f(this._uPointSize,pointsMaterial.pointSize);}if(this._uNearPlaneHeight){var nearPlaneHeight=scene.camera.projection==="ortho"?1.0:gl.drawingBufferHeight/(2*Math.tan(0.5*scene.camera.perspective.fov*Math.PI/180.0));gl.uniform1f(this._uNearPlaneHeight,nearPlaneHeight);}if(textureSet){var colorTexture=textureSet.colorTexture,metallicRoughnessTexture=textureSet.metallicRoughnessTexture,emissiveTexture=textureSet.emissiveTexture,normalsTexture=textureSet.normalsTexture,occlusionTexture=textureSet.occlusionTexture;if(this._uColorMap&&colorTexture){this._program.bindTexture(this._uColorMap,colorTexture.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;}if(this._uMetallicRoughMap&&metallicRoughnessTexture){this._program.bindTexture(this._uMetallicRoughMap,metallicRoughnessTexture.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;}if(this._uEmissiveMap&&emissiveTexture){this._program.bindTexture(this._uEmissiveMap,emissiveTexture.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;}if(this._uNormalMap&&normalsTexture){this._program.bindTexture(this._uNormalMap,normalsTexture.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;}if(this._uAOMap&&occlusionTexture){this._program.bindTexture(this._uAOMap,occlusionTexture.texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;}}if(lightsState.reflectionMaps.length>0&&lightsState.reflectionMaps[0].texture&&this._uReflectionMap){this._program.bindTexture(this._uReflectionMap,lightsState.reflectionMaps[0].texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;}if(lightsState.lightMaps.length>0&&lightsState.lightMaps[0].texture&&this._uLightMap){this._program.bindTexture(this._uLightMap,lightsState.lightMaps[0].texture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;}if(this._withSAO){var sao=scene.sao;var saoEnabled=sao.possible;if(saoEnabled){var viewportWidth=gl.drawingBufferWidth;var viewportHeight=gl.drawingBufferHeight;tempVec4[0]=viewportWidth;tempVec4[1]=viewportHeight;tempVec4[2]=sao.blendCutoff;tempVec4[3]=sao.blendFactor;gl.uniform4fv(this._uSAOParams,tempVec4);this._program.bindTexture(this._uOcclusionTexture,frameCtx.occlusionTexture,frameCtx.textureUnit);frameCtx.textureUnit=(frameCtx.textureUnit+1)%maxTextureUnits;frameCtx.bindTexture++;}}if(colorUniform){var colorKey=this._edges?"edgeColor":"fillColor";var alphaKey=this._edges?"edgeAlpha":"fillAlpha";if(renderPass===RENDER_PASSES["".concat(this._edges?"EDGES":"SILHOUETTE","_XRAYED")]){var material=scene.xrayMaterial._state;var _color3=material[colorKey];var alpha=material[alphaKey];gl.uniform4f(this._uColor,_color3[0],_color3[1],_color3[2],alpha);}else if(renderPass===RENDER_PASSES["".concat(this._edges?"EDGES":"SILHOUETTE","_HIGHLIGHTED")]){var _material=scene.highlightMaterial._state;var _color4=_material[colorKey];var _alpha=_material[alphaKey];gl.uniform4f(this._uColor,_color4[0],_color4[1],_color4[2],_alpha);}else if(renderPass===RENDER_PASSES["".concat(this._edges?"EDGES":"SILHOUETTE","_SELECTED")]){var _material2=scene.selectedMaterial._state;var _color5=_material2[colorKey];var _alpha2=_material2[alphaKey];gl.uniform4f(this._uColor,_color5[0],_color5[1],_color5[2],_alpha2);}else{gl.uniform4fv(this._uColor,this._edges?edgesDefaultColor:defaultColor$2);}}this._draw({state:state,frameCtx:frameCtx,incrementDrawState:incrementDrawState});gl.bindVertexArray(null);}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;stats.memory.programs--;}}]);return VBORenderer;}();/**
 * @private
 */var TrianglesBatchingRenderer=/*#__PURE__*/function(_VBORenderer){_inherits(TrianglesBatchingRenderer,_VBORenderer);var _super45=_createSuper(TrianglesBatchingRenderer);function TrianglesBatchingRenderer(scene,withSAO){var _ref8=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref8$edges=_ref8.edges,edges=_ref8$edges===void 0?false:_ref8$edges;_classCallCheck(this,TrianglesBatchingRenderer);return _super45.call(this,scene,withSAO,{instancing:false,edges:edges});}_createClass(TrianglesBatchingRenderer,[{key:"_draw",value:function _draw(drawCfg){var gl=this._scene.canvas.gl;var state=drawCfg.state,frameCtx=drawCfg.frameCtx,incrementDrawState=drawCfg.incrementDrawState;if(this._edges){gl.drawElements(gl.LINES,state.edgeIndicesBuf.numItems,state.edgeIndicesBuf.itemType,0);}else{var count=frameCtx.pickElementsCount||state.indicesBuf.numItems;var offset=frameCtx.pickElementsOffset?frameCtx.pickElementsOffset*state.indicesBuf.itemByteSize:0;gl.drawElements(gl.TRIANGLES,count,state.indicesBuf.itemType,offset);if(incrementDrawState){frameCtx.drawElements++;}}}}]);return TrianglesBatchingRenderer;}(VBORenderer);/**
 * @private
 */var TrianglesColorRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen){_inherits(TrianglesColorRenderer$1,_TrianglesBatchingRen);var _super46=_createSuper(TrianglesColorRenderer$1);function TrianglesColorRenderer$1(){_classCallCheck(this,TrianglesColorRenderer$1);return _super46.apply(this,arguments);}_createClass(TrianglesColorRenderer$1,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(TrianglesColorRenderer$1.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var light;var src=[];src.push("#version 300 es");src.push("// Triangles batching draw vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec3 normal;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}this._addMatricesUniformBlockLines(src,true);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("uniform vec4 lightAmbient;");for(var _i158=0,len=lightsState.lights.length;_i158<len;_i158++){light=lightsState.lights[_i158];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i158+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i158+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i158+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i158+";");src.push("uniform vec3 lightDir"+_i158+";");}}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vec4 worldNormal =  worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");src.push("vec3 viewNormal = normalize((viewNormalMatrix * worldNormal).xyz);");src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");for(var _i159=0,_len20=lightsState.lights.length;_i159<_len20;_i159++){light=lightsState.lights[_i159];if(light.type==="ambient"){continue;}if(light.type==="dir"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i159+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i159+", 0.0)).xyz);");}}else if(light.type==="point"){if(light.space==="view"){src.push("viewLightDir = -normalize(lightPos"+_i159+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+_i159+", 0.0)).xyz);");}}else if(light.type==="spot"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i159+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i159+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+_i159+".rgb * lightColor"+_i159+".a);");}src.push("vec3 rgb = (vec3(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0));");src.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching draw fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i160=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i160<len;_i160++){src.push("uniform bool sectionPlaneActive"+_i160+";");src.push("uniform vec3 sectionPlanePos"+_i160+";");src.push("uniform vec3 sectionPlaneDir"+_i160+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i161=0,_len21=sectionPlanesState.getNumAllocatedSectionPlanes();_i161<_len21;_i161++){src.push("if (sectionPlaneActive"+_i161+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i161+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i161+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor            = vec4(vColor.rgb * ambient, 1.0);");}else{src.push("   outColor            = vColor;");}src.push("}");return src;}}]);return TrianglesColorRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesFlatColorRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen2){_inherits(TrianglesFlatColorRenderer$1,_TrianglesBatchingRen2);var _super47=_createSuper(TrianglesFlatColorRenderer$1);function TrianglesFlatColorRenderer$1(){_classCallCheck(this,TrianglesFlatColorRenderer$1);return _super47.apply(this,arguments);}_createClass(TrianglesFlatColorRenderer$1,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching flat-shading draw vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vViewPosition = viewPosition;");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var lightsState=scene._lightsState;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching flat-shading draw fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i162=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i162<len;_i162++){src.push("uniform bool sectionPlaneActive"+_i162+";");src.push("uniform vec3 sectionPlanePos"+_i162+";");src.push("uniform vec3 sectionPlaneDir"+_i162+";");}}this._addMatricesUniformBlockLines(src);src.push("uniform vec4 lightAmbient;");for(var _i163=0,_len22=lightsState.lights.length;_i163<_len22;_i163++){var light=lightsState.lights[_i163];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i163+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i163+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i163+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i163+";");src.push("uniform vec3 lightDir"+_i163+";");}}src.push("in vec4 vViewPosition;");src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i164=0,_len23=sectionPlanesState.getNumAllocatedSectionPlanes();_i164<_len23;_i164++){src.push("if (sectionPlaneActive"+_i164+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i164+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i164+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");for(var _i165=0,_len24=lightsState.lights.length;_i165<_len24;_i165++){var _light4=lightsState.lights[_i165];if(_light4.type==="ambient"){continue;}if(_light4.type==="dir"){if(_light4.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i165+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i165+", 0.0)).xyz);");}}else if(_light4.type==="point"){if(_light4.space==="view"){src.push("viewLightDir = -normalize(lightPos"+_i165+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+_i165+", 0.0)).xyz);");}}else if(_light4.type==="spot"){if(_light4.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i165+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i165+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+_i165+".rgb * lightColor"+_i165+".a);");}src.push("vec4 fragColor =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor            = vec4(fragColor.rgb * ambient, 1.0);");}else{src.push("   outColor            = fragColor;");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return TrianglesFlatColorRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesSilhouetteRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen3){_inherits(TrianglesSilhouetteRenderer$1,_TrianglesBatchingRen3);var _super48=_createSuper(TrianglesSilhouetteRenderer$1);function TrianglesSilhouetteRenderer$1(){_classCallCheck(this,TrianglesSilhouetteRenderer$1);return _super48.apply(this,arguments);}_createClass(TrianglesSilhouetteRenderer$1,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){_get(_getPrototypeOf(TrianglesSilhouetteRenderer$1.prototype),"drawLayer",this).call(this,frameCtx,batchingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching silhouette vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 color;");this._addMatricesUniformBlockLines(src);src.push("uniform vec4 silhouetteColor;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// silhouetteFlag = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("int silhouetteFlag = int(flags) >> 4 & 0xF;");src.push("if (silhouetteFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vColor = vec4(silhouetteColor.r, silhouetteColor.g, silhouetteColor.b, min(silhouetteColor.a, color.a ));");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching silhouette fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return TrianglesSilhouetteRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var EdgesRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen4){_inherits(EdgesRenderer$1,_TrianglesBatchingRen4);var _super49=_createSuper(EdgesRenderer$1);function EdgesRenderer$1(scene){_classCallCheck(this,EdgesRenderer$1);return _super49.call(this,scene,false,{instancing:false,edges:true});}return _createClass(EdgesRenderer$1);}(TrianglesBatchingRenderer);/**
 * @private
 */var EdgesEmphasisRenderer$1=/*#__PURE__*/function(_EdgesRenderer$){_inherits(EdgesEmphasisRenderer$1,_EdgesRenderer$);var _super50=_createSuper(EdgesEmphasisRenderer$1);function EdgesEmphasisRenderer$1(){_classCallCheck(this,EdgesEmphasisRenderer$1);return _super50.apply(this,arguments);}_createClass(EdgesEmphasisRenderer$1,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){_get(_getPrototypeOf(EdgesEmphasisRenderer$1.prototype),"drawLayer",this).call(this,frameCtx,batchingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// EdgesEmphasisRenderer vertex shader");src.push("uniform int renderPass;");src.push("uniform vec4 color;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// edgeFlag = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
// renderPass = EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
src.push("int edgeFlag = int(flags) >> 8 & 0xF;");src.push("if (edgeFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("vColor = vec4(color.r, color.g, color.b, color.a);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// EdgesEmphasisRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i166=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i166<len;_i166++){src.push("uniform bool sectionPlaneActive"+_i166+";");src.push("uniform vec3 sectionPlanePos"+_i166+";");src.push("uniform vec3 sectionPlaneDir"+_i166+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i167=0,_len25=sectionPlanesState.getNumAllocatedSectionPlanes();_i167<_len25;_i167++){src.push("if (sectionPlaneActive"+_i167+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i167+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i167+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return EdgesEmphasisRenderer$1;}(EdgesRenderer$1);/**
 * @private
 */var EdgesColorRenderer$1=/*#__PURE__*/function(_EdgesRenderer$2){_inherits(EdgesColorRenderer$1,_EdgesRenderer$2);var _super51=_createSuper(EdgesColorRenderer$1);function EdgesColorRenderer$1(){_classCallCheck(this,EdgesColorRenderer$1);return _super51.apply(this,arguments);}_createClass(EdgesColorRenderer$1,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){_get(_getPrototypeOf(EdgesColorRenderer$1.prototype),"drawLayer",this).call(this,frameCtx,batchingLayer,renderPass,{colorUniform:false});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry edges drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// edgeFlag = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
// renderPass = EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT
src.push("int edgeFlag = int(flags) >> 8 & 0xF;");src.push("if (edgeFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");//src.push("vColor = vec4(float(color.r-100.0) / 255.0, float(color.g-100.0) / 255.0, float(color.b-100.0) / 255.0, float(color.a) / 255.0);");
src.push("vColor = vec4(float(color.r*0.5) / 255.0, float(color.g*0.5) / 255.0, float(color.b*0.5) / 255.0, float(color.a) / 255.0);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry edges drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i168=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i168<len;_i168++){src.push("uniform bool sectionPlaneActive"+_i168+";");src.push("uniform vec3 sectionPlanePos"+_i168+";");src.push("uniform vec3 sectionPlaneDir"+_i168+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i169=0,_len26=sectionPlanesState.getNumAllocatedSectionPlanes();_i169<_len26;_i169++){src.push("if (sectionPlaneActive"+_i169+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i169+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i169+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return EdgesColorRenderer$1;}(EdgesRenderer$1);/**
 * @private
 */var TrianglesPickMeshRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen5){_inherits(TrianglesPickMeshRenderer$1,_TrianglesBatchingRen5);var _super52=_createSuper(TrianglesPickMeshRenderer$1);function TrianglesPickMeshRenderer$1(){_classCallCheck(this,TrianglesPickMeshRenderer$1);return _super52.apply(this,arguments);}_createClass(TrianglesPickMeshRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry picking vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 pickColor;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}this._addRemapClipPosLines(src);src.push("out vec4 vPickColor;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry picking fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vPickColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i170=0;_i170<sectionPlanesState.getNumAllocatedSectionPlanes();_i170++){src.push("      if (sectionPlaneActive"+_i170+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i170+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i170+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor = vPickColor; ");src.push("}");return src;}}]);return TrianglesPickMeshRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesPickDepthRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen6){_inherits(TrianglesPickDepthRenderer$1,_TrianglesBatchingRen6);var _super53=_createSuper(TrianglesPickDepthRenderer$1);function TrianglesPickDepthRenderer$1(){_classCallCheck(this,TrianglesPickDepthRenderer$1);return _super53.apply(this,arguments);}_createClass(TrianglesPickDepthRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching pick depth vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}this._addRemapClipPosLines(src);src.push("out vec4 vViewPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vViewPosition = viewPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform float pickZNear;");src.push("uniform float pickZFar;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vViewPosition;");src.push("vec4 packDepth(const in float depth) {");src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");src.push("  vec4 res = fract(depth * bitShift);");src.push("  res -= res.xxyz * bitMask;");src.push("  return res;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i171=0;_i171<sectionPlanesState.getNumAllocatedSectionPlanes();_i171++){src.push("      if (sectionPlaneActive"+_i171+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i171+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i171+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");src.push("    outColor = packDepth(zNormalizedDepth); ");// Must be linear depth
src.push("}");return src;}}]);return TrianglesPickDepthRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesPickNormalsRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen7){_inherits(TrianglesPickNormalsRenderer$1,_TrianglesBatchingRen7);var _super54=_createSuper(TrianglesPickNormalsRenderer$1);function TrianglesPickNormalsRenderer$1(){_classCallCheck(this,TrianglesPickNormalsRenderer$1);return _super54.apply(this,arguments);}_createClass(TrianglesPickNormalsRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching pick normals vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec3 normal;");src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src,3);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec3 vWorldNormal;");src.push("out vec4 outColor;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vec3 worldNormal =  octDecode(normal.xy); ");src.push("      vWorldNormal = worldNormal;");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching pick normals fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec3 vWorldNormal;");src.push("out highp ivec4 outNormal;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i172=0;_i172<sectionPlanesState.getNumAllocatedSectionPlanes();_i172++){src.push("      if (sectionPlaneActive"+_i172+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i172+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i172+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outNormal = ivec4(vWorldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("}");return src;}}]);return TrianglesPickNormalsRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesOcclusionRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen8){_inherits(TrianglesOcclusionRenderer$1,_TrianglesBatchingRen8);var _super55=_createSuper(TrianglesOcclusionRenderer$1);function TrianglesOcclusionRenderer$1(){_classCallCheck(this,TrianglesOcclusionRenderer$1);return _super55.apply(this,arguments);}_createClass(TrianglesOcclusionRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching occlusion vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 color;");src.push("in float flags;");this._addMatricesUniformBlockLines(src);if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
// Only opaque objects can be occluders
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching occlusion fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i173=0;_i173<sectionPlanesState.getNumAllocatedSectionPlanes();_i173++){src.push("uniform bool sectionPlaneActive"+_i173+";");src.push("uniform vec3 sectionPlanePos"+_i173+";");src.push("uniform vec3 sectionPlaneDir"+_i173+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i174=0;_i174<sectionPlanesState.getNumAllocatedSectionPlanes();_i174++){src.push("      if (sectionPlaneActive"+_i174+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i174+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i174+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}src.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); ");// Occluders are blue
src.push("}");return src;}}]);return TrianglesOcclusionRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesDepthRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen9){_inherits(TrianglesDepthRenderer$1,_TrianglesBatchingRen9);var _super56=_createSuper(TrianglesDepthRenderer$1);function TrianglesDepthRenderer$1(){_classCallCheck(this,TrianglesDepthRenderer$1);return _super56.apply(this,arguments);}_createClass(TrianglesDepthRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching depth vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec2 vHighPrecisionZW;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("vHighPrecisionZW = gl_Position.zw;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching depth fragment shader");src.push("precision highp float;");src.push("precision highp int;");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i175=0;_i175<sectionPlanesState.getNumAllocatedSectionPlanes();_i175++){src.push("uniform bool sectionPlaneActive"+_i175+";");src.push("uniform vec3 sectionPlanePos"+_i175+";");src.push("uniform vec3 sectionPlaneDir"+_i175+";");}}src.push("const float   packUpScale = 256. / 255.;");src.push("const float   unpackDownscale = 255. / 256.;");src.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );");src.push("const float   shiftRight8 = 1.0 / 256.;");src.push("vec4 packDepthToRGBA( const in float v ) {");src.push("    vec4 r = vec4( fract( v * packFactors ), v );");src.push("    r.yzw -= r.xyz * shiftRight8;");src.push("    return r * packUpScale;");src.push("}");src.push("in vec2 vHighPrecisionZW;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;");src.push("    outColor = vec4(vec3(1.0 - fragCoordZ), 1.0); ");src.push("}");return src;}}]);return TrianglesDepthRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesNormalsRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen10){_inherits(TrianglesNormalsRenderer$1,_TrianglesBatchingRen10);var _super57=_createSuper(TrianglesNormalsRenderer$1);function TrianglesNormalsRenderer$1(){_classCallCheck(this,TrianglesNormalsRenderer$1);return _super57.apply(this,arguments);}_createClass(TrianglesNormalsRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry normals vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec3 normal;");src.push("in vec4 color;");src.push("in float flags;");this._addMatricesUniformBlockLines(src,true);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec3 vViewNormal;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition   = viewMatrix * worldPosition; ");src.push("      vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");src.push("      vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);");if(clipping){src.push("      vWorldPosition  = worldPosition;");src.push("      vFlags         = flags;");}src.push("      vViewNormal = viewNormal;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry normals fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i176=0;_i176<sectionPlanesState.getNumAllocatedSectionPlanes();_i176++){src.push("uniform bool sectionPlaneActive"+_i176+";");src.push("uniform vec3 sectionPlanePos"+_i176+";");src.push("uniform vec3 sectionPlaneDir"+_i176+";");}}src.push("in vec3 vViewNormal;");src.push("vec3 packNormalToRGB( const in vec3 normal ) {");src.push("    return normalize( normal ) * 0.5 + 0.5;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");src.push("}");return src;}}]);return TrianglesNormalsRenderer$1;}(TrianglesBatchingRenderer);/**
 * Renders BatchingLayer fragment depths to a shadow map.
 *
 * @private
 */var TrianglesShadowRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen11){_inherits(TrianglesShadowRenderer$1,_TrianglesBatchingRen11);var _super58=_createSuper(TrianglesShadowRenderer$1);function TrianglesShadowRenderer$1(){_classCallCheck(this,TrianglesShadowRenderer$1);return _super58.apply(this,arguments);}_createClass(TrianglesShadowRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry shadow vertex shader");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 color;");src.push("in float flags;");src.push("uniform mat4 shadowViewMatrix;");src.push("uniform mat4 shadowProjMatrix;");this._addMatricesUniformBlockLines(src);if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("out vec4 outColor;");src.push("void main(void) {");src.push("  int colorFlag = int(flags) & 0xF;");src.push("  bool visible        = (colorFlag > 0);");src.push("  bool transparent    = ((float(color.a) / 255.0) < 1.0);");src.push("  if (!visible || transparent) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");src.push("  } else {");src.push("      vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = shadowViewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("      vViewPosition = viewPosition;");src.push("      gl_Position = shadowProjMatrix * viewPosition;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry shadow fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i177=0;_i177<sectionPlanesState.getNumAllocatedSectionPlanes();_i177++){src.push("uniform bool sectionPlaneActive"+_i177+";");src.push("uniform vec3 sectionPlanePos"+_i177+";");src.push("uniform vec3 sectionPlaneDir"+_i177+";");}}src.push("in vec4 vViewPosition;");src.push("vec4 encodeFloat( const in float v ) {");src.push("  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);");src.push("  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);");src.push("  vec4 comp = fract(v * bitShift);");src.push("  comp -= comp.xxyz * bitMask;");src.push("  return comp;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}src.push("    outColor = encodeFloat( gl_FragCoord.z); ");src.push("}");return src;}}]);return TrianglesShadowRenderer$1;}(TrianglesBatchingRenderer);// const TEXTURE_DECODE_FUNCS = {};
// TEXTURE_DECODE_FUNCS[LinearEncoding] = "linearToLinear";
// TEXTURE_DECODE_FUNCS[sRGBEncoding] = "sRGBToLinear";
/**
 * @private
 */var TrianglesPBRRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen12){_inherits(TrianglesPBRRenderer$1,_TrianglesBatchingRen12);var _super59=_createSuper(TrianglesPBRRenderer$1);function TrianglesPBRRenderer$1(){_classCallCheck(this,TrianglesPBRRenderer$1);return _super59.apply(this,arguments);}_createClass(TrianglesPBRRenderer$1,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene.gammaOutput,scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(TrianglesPBRRenderer$1.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var clippingCaps=sectionPlanesState.clippingCaps;var src=[];src.push("#version 300 es");src.push("// Triangles batching quality draw vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec3 normal;");src.push("in vec4 color;");src.push("in vec2 uv;");src.push("in vec2 metallicRoughness;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}this._addMatricesUniformBlockLines(src,true);src.push("uniform mat3 uvDecodeMatrix;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");src.push("out vec4 vViewPosition;");src.push("out vec3 vViewNormal;");src.push("out vec4 vColor;");src.push("out vec2 vUV;");src.push("out vec2 vMetallicRoughness;");if(lightsState.lightMaps.length>0){src.push("out vec3 vWorldNormal;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");if(clippingCaps){src.push("out vec4 vClipPosition;");}}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vec4 worldNormal =  worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");src.push("vec3 viewNormal = normalize((viewNormalMatrix * worldNormal).xyz);");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");src.push("vFragDepth = 1.0 + clipPos.w;");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");if(clippingCaps){src.push("vClipPosition = clipPos;");}}src.push("vViewPosition = viewPosition;");src.push("vViewNormal = viewNormal;");src.push("vColor = color;");src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");src.push("vMetallicRoughness = metallicRoughness;");if(lightsState.lightMaps.length>0){src.push("vWorldNormal = worldNormal.xyz;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var gammaOutput=scene.gammaOutput;// If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var clippingCaps=sectionPlanesState.clippingCaps;var src=[];src.push('#version 300 es');src.push("// Triangles batching quality draw fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform sampler2D uColorMap;");src.push("uniform sampler2D uMetallicRoughMap;");src.push("uniform sampler2D uEmissiveMap;");src.push("uniform sampler2D uNormalMap;");src.push("uniform sampler2D uAOMap;");src.push("in vec4 vViewPosition;");src.push("in vec3 vViewNormal;");src.push("in vec4 vColor;");src.push("in vec2 vUV;");src.push("in vec2 vMetallicRoughness;");if(lightsState.lightMaps.length>0){src.push("in vec3 vWorldNormal;");}this._addMatricesUniformBlockLines(src,true);if(lightsState.reflectionMaps.length>0){src.push("uniform samplerCube reflectionMap;");}if(lightsState.lightMaps.length>0){src.push("uniform samplerCube lightMap;");}src.push("uniform vec4 lightAmbient;");for(var _i178=0,len=lightsState.lights.length;_i178<len;_i178++){var light=lightsState.lights[_i178];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i178+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i178+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i178+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i178+";");src.push("uniform vec3 lightDir"+_i178+";");}}if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}src.push("uniform float gammaFactor;");src.push("vec4 linearToLinear( in vec4 value ) {");src.push("  return value;");src.push("}");src.push("vec4 sRGBToLinear( in vec4 value ) {");src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");src.push("}");src.push("vec4 gammaToLinear( in vec4 value) {");src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");src.push("}");if(gammaOutput){src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");if(clippingCaps){src.push("in vec4 vClipPosition;");}for(var _i179=0,_len27=sectionPlanesState.getNumAllocatedSectionPlanes();_i179<_len27;_i179++){src.push("uniform bool sectionPlaneActive"+_i179+";");src.push("uniform vec3 sectionPlanePos"+_i179+";");src.push("uniform vec3 sectionPlaneDir"+_i179+";");}}// CONSTANT DEFINITIONS
src.push("#define PI 3.14159265359");src.push("#define RECIPROCAL_PI 0.31830988618");src.push("#define RECIPROCAL_PI2 0.15915494");src.push("#define EPSILON 1e-6");src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");// UTILITY DEFINITIONS
src.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");src.push("       vec3 texel = texture( uNormalMap, uv ).xyz;");src.push("       if (texel.x == 0.0 && texel.y == 0.0 && texel.z == 0.0) {");src.push("              return surf_norm;");src.push("       }");src.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");src.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");src.push("      vec2 st0 = dFdx( uv.st );");src.push("      vec2 st1 = dFdy( uv.st );");src.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");src.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");src.push("      vec3 N = normalize( surf_norm );");src.push("      vec3 mapN = texel.xyz * 2.0 - 1.0;");src.push("      mat3 tsn = mat3( S, T, N );");//src.push("      mapN *= 3.0;");
src.push("      return normalize( tsn * mapN );");src.push("}");src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");src.push("}");// STRUCTURES
src.push("struct IncidentLight {");src.push("   vec3 color;");src.push("   vec3 direction;");src.push("};");src.push("struct ReflectedLight {");src.push("   vec3 diffuse;");src.push("   vec3 specular;");src.push("};");src.push("struct Geometry {");src.push("   vec3 position;");src.push("   vec3 viewNormal;");src.push("   vec3 worldNormal;");src.push("   vec3 viewEyeDir;");src.push("};");src.push("struct Material {");src.push("   vec3  diffuseColor;");src.push("   float specularRoughness;");src.push("   vec3  specularColor;");src.push("   float shine;");// Only used for Phong
src.push("};");// IRRADIANCE EVALUATION
src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");src.push("   float r = ggxRoughness + 0.0001;");src.push("   return (2.0 / (r * r) - 2.0);");src.push("}");src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");src.push("}");if(lightsState.reflectionMaps.length>0){src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);");//TODO: a random factor - fix this
src.push("   vec3 envMapColor = sRGBToLinear(texture(reflectionMap, reflectVec, mipLevel)).rgb;");src.push("  return envMapColor;");src.push("}");}// SPECULAR BRDF EVALUATION
src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");src.push("}");src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   return 1.0 / ( gl * gv );");src.push("}");src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   return 0.5 / max( gv + gl, EPSILON );");src.push("}");src.push("float D_GGX(const in float alpha, const in float dotNH) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");src.push("}");src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float alpha = ( roughness * roughness );");src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");src.push("   vec3  F = F_Schlick( specularColor, dotLH );");src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");src.push("   float D = D_GGX( alpha, dotNH );");src.push("   return F * (G * D);");src.push("}");src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");src.push("   vec4 r = roughness * c0 + c1;");src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");src.push("   return specularColor * AB.x + AB.y;");src.push("}");if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");if(lightsState.lightMaps.length>0){src.push("   vec3 irradiance = sRGBToLinear(texture(lightMap, geometry.worldNormal)).rgb;");src.push("   irradiance *= PI;");src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.diffuse +=  irradiance * diffuseBRDFContrib;");}if(lightsState.reflectionMaps.length>0){src.push("   vec3 reflectVec             = reflect(geometry.viewEyeDir, geometry.viewNormal);");src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");}src.push("}");}// MAIN LIGHTING COMPUTATION FUNCTION
src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i180=0,_len28=sectionPlanesState.getNumAllocatedSectionPlanes();_i180<_len28;_i180++){src.push("if (sectionPlaneActive"+_i180+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i180+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i180+".xyz), 0.0, 1000.0);");src.push("}");}if(clippingCaps){src.push("  if (dist > (0.002 * vClipPosition.w)) {");src.push("      discard;");src.push("  }");src.push("  if (dist > 0.0) { ");src.push("      outColor=vec4(1.0, 0.0, 0.0, 1.0);");if(scene.logarithmicDepthBufferEnabled){src.push("  gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("  return;");src.push("}");}else{src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");}src.push("}");}src.push("IncidentLight  light;");src.push("Material       material;");src.push("Geometry       geometry;");src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");src.push("vec3 rgb = (vec3(float(vColor.r) / 255.0, float(vColor.g) / 255.0, float(vColor.b) / 255.0));");src.push("float opacity = float(vColor.a) / 255.0;");src.push("vec3  baseColor = rgb;");src.push("float specularF0 = 1.0;");src.push("float metallic = float(vMetallicRoughness.r) / 255.0;");src.push("float roughness = float(vMetallicRoughness.g) / 255.0;");src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");src.push("vec4 colorTexel = sRGBToLinear(texture(uColorMap, vUV));");src.push("baseColor *= colorTexel.rgb;");//    src.push("opacity *= colorTexel.a;");
src.push("vec3 metalRoughTexel = texture(uMetallicRoughMap, vUV).rgb;");src.push("metallic *= metalRoughTexel.b;");src.push("roughness *= metalRoughTexel.g;");src.push("vec3 viewNormal = perturbNormal2Arb(vViewPosition.xyz, normalize(vViewNormal), vUV );");src.push("material.diffuseColor      = baseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");src.push("material.specularColor     = mix(vec3(dielectricSpecular), baseColor, metallic);");src.push("geometry.position      = vViewPosition.xyz;");src.push("geometry.viewNormal    = -normalize(viewNormal);");src.push("geometry.viewEyeDir    = normalize(vViewPosition.xyz);");if(lightsState.lightMaps.length>0){src.push("geometry.worldNormal   = normalize(vWorldNormal);");}if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("computePBRLightMapping(geometry, material, reflectedLight);");}for(var _i181=0,_len29=lightsState.lights.length;_i181<_len29;_i181++){var _light5=lightsState.lights[_i181];if(_light5.type==="ambient"){continue;}if(_light5.type==="dir"){if(_light5.space==="view"){src.push("light.direction =  normalize(lightDir"+_i181+");");}else{src.push("light.direction =  normalize((viewMatrix * vec4(lightDir"+_i181+", 0.0)).xyz);");}}else if(_light5.type==="point"){if(_light5.space==="view"){src.push("light.direction =  normalize(lightPos"+_i181+" - vViewPosition.xyz);");}else{src.push("light.direction =  normalize((viewMatrix * vec4(lightPos"+_i181+", 0.0)).xyz);");}}else if(_light5.type==="spot"){if(_light5.space==="view"){src.push("light.direction =  normalize(lightDir"+_i181+");");}else{src.push("light.direction =  normalize((viewMatrix * vec4(lightDir"+_i181+", 0.0)).xyz);");}}else{continue;}src.push("light.color =  lightColor"+_i181+".rgb * lightColor"+_i181+".a;");// a is intensity
src.push("computePBRLighting(light, geometry, material, reflectedLight);");}src.push("vec3 emissiveColor = sRGBToLinear(texture(uEmissiveMap, vUV)).rgb;");// TODO: correct gamma function
src.push("float aoFactor = texture(uAOMap, vUV).r;");src.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * baseColor * opacity * rgb) + (reflectedLight.diffuse) + (reflectedLight.specular) + emissiveColor;");src.push("vec4 fragColor;");if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   fragColor               = vec4(outgoingLight.rgb * ambient * aoFactor, opacity);");}else{src.push("   fragColor            = vec4(outgoingLight.rgb * aoFactor, opacity);");}if(gammaOutput){src.push("fragColor = linearToGamma(fragColor, gammaFactor);");}src.push("outColor = fragColor;");if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return TrianglesPBRRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesPickNormalsFlatRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen13){_inherits(TrianglesPickNormalsFlatRenderer$1,_TrianglesBatchingRen13);var _super60=_createSuper(TrianglesPickNormalsFlatRenderer$1);function TrianglesPickNormalsFlatRenderer$1(){_classCallCheck(this,TrianglesPickNormalsFlatRenderer$1);return _super60.apply(this,arguments);}_createClass(TrianglesPickNormalsFlatRenderer$1,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching pick flat normals vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src,3);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vWorldPosition = worldPosition;");if(clipping){src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching pick flat normals fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("in vec4 vWorldPosition;");if(clipping){src.push("in float vFlags;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("out highp ivec4 outNormal;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i182=0;_i182<sectionPlanesState.getNumAllocatedSectionPlanes();_i182++){src.push("      if (sectionPlaneActive"+_i182+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i182+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i182+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("  outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("}");return src;}}]);return TrianglesPickNormalsFlatRenderer$1;}(TrianglesBatchingRenderer);/**
 * @private
 */var TrianglesColorTextureRenderer$1=/*#__PURE__*/function(_TrianglesBatchingRen14){_inherits(TrianglesColorTextureRenderer$1,_TrianglesBatchingRen14);var _super61=_createSuper(TrianglesColorTextureRenderer$1);function TrianglesColorTextureRenderer$1(){_classCallCheck(this,TrianglesColorTextureRenderer$1);return _super61.apply(this,arguments);}_createClass(TrianglesColorTextureRenderer$1,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene.gammaOutput,scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(TrianglesColorTextureRenderer$1.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching color texture vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in vec2 uv;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}this._addMatricesUniformBlockLines(src);src.push("uniform mat3 uvDecodeMatrix;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("out vec4 vColor;");src.push("out vec2 vUV;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vViewPosition = viewPosition;");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var gammaOutput=scene.gammaOutput;// If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
var lightsState=scene._lightsState;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles batching color texture fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform sampler2D uColorMap;");if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}src.push("uniform float gammaFactor;");src.push("vec4 linearToLinear( in vec4 value ) {");src.push("  return value;");src.push("}");src.push("vec4 sRGBToLinear( in vec4 value ) {");src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");src.push("}");src.push("vec4 gammaToLinear( in vec4 value) {");src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");src.push("}");if(gammaOutput){src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i183=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i183<len;_i183++){src.push("uniform bool sectionPlaneActive"+_i183+";");src.push("uniform vec3 sectionPlanePos"+_i183+";");src.push("uniform vec3 sectionPlaneDir"+_i183+";");}}this._addMatricesUniformBlockLines(src);src.push("uniform vec4 lightAmbient;");for(var _i184=0,_len30=lightsState.lights.length;_i184<_len30;_i184++){var light=lightsState.lights[_i184];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i184+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i184+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i184+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i184+";");src.push("uniform vec3 lightDir"+_i184+";");}}src.push("in vec4 vViewPosition;");src.push("in vec4 vColor;");src.push("in vec2 vUV;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i185=0,_len31=sectionPlanesState.getNumAllocatedSectionPlanes();_i185<_len31;_i185++){src.push("if (sectionPlaneActive"+_i185+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i185+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i185+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");for(var _i186=0,_len32=lightsState.lights.length;_i186<_len32;_i186++){var _light6=lightsState.lights[_i186];if(_light6.type==="ambient"){continue;}if(_light6.type==="dir"){if(_light6.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i186+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i186+", 0.0)).xyz);");}}else if(_light6.type==="point"){if(_light6.space==="view"){src.push("viewLightDir = -normalize(lightPos"+_i186+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+_i186+", 0.0)).xyz);");}}else if(_light6.type==="spot"){if(_light6.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i186+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i186+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+_i186+".rgb * lightColor"+_i186+".a);");}src.push("vec4 color =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");if(gammaOutput){src.push("vec4 colorTexel = color * sRGBToLinear(texture(uColorMap, vUV));");}else{src.push("vec4 colorTexel = color * texture(uColorMap, vUV);");}src.push("float opacity = color.a;");if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor                = vec4(colorTexel.rgb * ambient, opacity);");}else{src.push("   outColor                = vec4(colorTexel.rgb, opacity);");}if(gammaOutput){src.push("outColor = linearToGamma(outColor, gammaFactor);");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return TrianglesColorTextureRenderer$1;}(TrianglesBatchingRenderer);var tempVec3a$B=math.vec3();var tempVec3b$x=math.vec3();var tempVec3c$s=math.vec3();var tempVec3d$c=math.vec3();var tempMat4a$q=math.mat4();/**
 * @private
 */var TrianglesSnapInitRenderer$1=/*#__PURE__*/function(_VBORenderer2){_inherits(TrianglesSnapInitRenderer$1,_VBORenderer2);var _super62=_createSuper(TrianglesSnapInitRenderer$1);function TrianglesSnapInitRenderer$1(){_classCallCheck(this,TrianglesSnapInitRenderer$1);return _super62.apply(this,arguments);}_createClass(TrianglesSnapInitRenderer$1,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=batchingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=batchingLayer._state;var origin=batchingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=batchingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(batchingLayer)){gl.bindVertexArray(this._vaoCache.get(batchingLayer));}else{this._vaoCache.set(batchingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$B;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$x;if(origin){var rotatedOrigin=tempVec3c$s;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$q);rtcCameraEye=tempVec3d$c;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(batchingLayer);//=============================================================
// TODO: Use drawElements count and offset to draw only one entity
//=============================================================
state.indicesBuf.bind();gl.drawElements(gl.TRIANGLES,state.indicesBuf.numItems,state.indicesBuf.itemType,0);state.indicesBuf.unbind();}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(TrianglesSnapInitRenderer$1.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBO SnapBatchingDepthBufInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec4 pickColor;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vWorldPosition = worldPosition;");if(clipping){src.push("      vFlags = flags;");}src.push("vPickColor = pickColor;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBO SnapBatchingDepthBufInitRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("in float vFlags;");for(var _i187=0;_i187<sectionPlanesState.getNumAllocatedSectionPlanes();_i187++){src.push("uniform bool sectionPlaneActive"+_i187+";");src.push("uniform vec3 sectionPlanePos"+_i187+";");src.push("uniform vec3 sectionPlaneDir"+_i187+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");src.push("layout(location = 1) out highp ivec4 outNormal;");src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, -layerNumber);");src.push("vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return TrianglesSnapInitRenderer$1;}(VBORenderer);var tempVec3a$A=math.vec3();var tempVec3b$w=math.vec3();var tempVec3c$r=math.vec3();var tempVec3d$b=math.vec3();var tempMat4a$p=math.mat4();/**
 * @private
 */var TrianglesSnapRenderer$1=/*#__PURE__*/function(_VBORenderer3){_inherits(TrianglesSnapRenderer$1,_VBORenderer3);var _super63=_createSuper(TrianglesSnapRenderer$1);function TrianglesSnapRenderer$1(){_classCallCheck(this,TrianglesSnapRenderer$1);return _super63.apply(this,arguments);}_createClass(TrianglesSnapRenderer$1,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=batchingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=batchingLayer._state;var origin=batchingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=batchingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(batchingLayer)){gl.bindVertexArray(this._vaoCache.get(batchingLayer));}else{this._vaoCache.set(batchingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$A;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$w;if(origin){var rotatedOrigin=tempVec3c$r;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$p);rtcCameraEye=tempVec3d$b;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(batchingLayer);//=============================================================
// TODO: Use drawElements count and offset to draw only one entity
//=============================================================
if(frameCtx.snapMode==="edge"){state.edgeIndicesBuf.bind();gl.drawElements(gl.LINES,state.edgeIndicesBuf.numItems,state.edgeIndicesBuf.itemType,0);state.edgeIndicesBuf.unbind();// needed?
}else{gl.drawArrays(gl.POINTS,0,state.positionsBuf.numItems);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(TrianglesSnapRenderer$1.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// SnapBatchingDepthRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapBatchingDepthRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i188=0;_i188<sectionPlanesState.getNumAllocatedSectionPlanes();_i188++){src.push("uniform bool sectionPlaneActive"+_i188+";");src.push("uniform vec3 sectionPlanePos"+_i188+";");src.push("uniform vec3 sectionPlaneDir"+_i188+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, layerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return TrianglesSnapRenderer$1;}(VBORenderer);/**
 * @private
 */var Renderers$1=/*#__PURE__*/function(){function Renderers$1(scene){_classCallCheck(this,Renderers$1);this._scene=scene;}_createClass(Renderers$1,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._colorRendererWithSAO&&!this._colorRendererWithSAO.getValid()){this._colorRendererWithSAO.destroy();this._colorRendererWithSAO=null;}if(this._flatColorRenderer&&!this._flatColorRenderer.getValid()){this._flatColorRenderer.destroy();this._flatColorRenderer=null;}if(this._flatColorRendererWithSAO&&!this._flatColorRendererWithSAO.getValid()){this._flatColorRendererWithSAO.destroy();this._flatColorRendererWithSAO=null;}if(this._colorTextureRenderer&&!this._colorTextureRenderer.getValid()){this._colorTextureRenderer.destroy();this._colorTextureRenderer=null;}if(this._colorTextureRendererWithSAO&&!this._colorTextureRendererWithSAO.getValid()){this._colorTextureRendererWithSAO.destroy();this._colorTextureRendererWithSAO=null;}if(this._pbrRenderer&&!this._pbrRenderer.getValid()){this._pbrRenderer.destroy();this._pbrRenderer=null;}if(this._pbrRendererWithSAO&&!this._pbrRendererWithSAO.getValid()){this._pbrRendererWithSAO.destroy();this._pbrRendererWithSAO=null;}if(this._depthRenderer&&!this._depthRenderer.getValid()){this._depthRenderer.destroy();this._depthRenderer=null;}if(this._normalsRenderer&&!this._normalsRenderer.getValid()){this._normalsRenderer.destroy();this._normalsRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._edgesRenderer&&!this._edgesRenderer.getValid()){this._edgesRenderer.destroy();this._edgesRenderer=null;}if(this._edgesColorRenderer&&!this._edgesColorRenderer.getValid()){this._edgesColorRenderer.destroy();this._edgesColorRenderer=null;}if(this._pickMeshRenderer&&!this._pickMeshRenderer.getValid()){this._pickMeshRenderer.destroy();this._pickMeshRenderer=null;}if(this._pickDepthRenderer&&!this._pickDepthRenderer.getValid()){this._pickDepthRenderer.destroy();this._pickDepthRenderer=null;}if(this._pickNormalsRenderer&&this._pickNormalsRenderer.getValid()===false){this._pickNormalsRenderer.destroy();this._pickNormalsRenderer=null;}if(this._pickNormalsFlatRenderer&&this._pickNormalsFlatRenderer.getValid()===false){this._pickNormalsFlatRenderer.destroy();this._pickNormalsFlatRenderer=null;}if(this._occlusionRenderer&&this._occlusionRenderer.getValid()===false){this._occlusionRenderer.destroy();this._occlusionRenderer=null;}if(this._shadowRenderer&&!this._shadowRenderer.getValid()){this._shadowRenderer.destroy();this._shadowRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}}},{key:"eagerCreateRenders",value:function eagerCreateRenders(){// Pre-initialize certain renderers that would otherwise be lazy-initialised
// on user interaction, such as picking or emphasis, so that there is no delay
// when user first begins interacting with the viewer.
if(!this._silhouetteRenderer){// Used for highlighting and selection
this._silhouetteRenderer=new TrianglesSilhouetteRenderer$1(this._scene);}if(!this._pickMeshRenderer){this._pickMeshRenderer=new TrianglesPickMeshRenderer$1(this._scene);}if(!this._pickDepthRenderer){this._pickDepthRenderer=new TrianglesPickDepthRenderer$1(this._scene);}if(!this._snapInitRenderer){this._snapInitRenderer=new TrianglesSnapInitRenderer$1(this._scene,false);}if(!this._snapRenderer){this._snapRenderer=new TrianglesSnapRenderer$1(this._scene);}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new TrianglesColorRenderer$1(this._scene,false);}return this._colorRenderer;}},{key:"colorRendererWithSAO",get:function get(){if(!this._colorRendererWithSAO){this._colorRendererWithSAO=new TrianglesColorRenderer$1(this._scene,true);}return this._colorRendererWithSAO;}},{key:"flatColorRenderer",get:function get(){if(!this._flatColorRenderer){this._flatColorRenderer=new TrianglesFlatColorRenderer$1(this._scene,false);}return this._flatColorRenderer;}},{key:"flatColorRendererWithSAO",get:function get(){if(!this._flatColorRendererWithSAO){this._flatColorRendererWithSAO=new TrianglesFlatColorRenderer$1(this._scene,true);}return this._flatColorRendererWithSAO;}},{key:"colorTextureRenderer",get:function get(){if(!this._colorTextureRenderer){this._colorTextureRenderer=new TrianglesColorTextureRenderer$1(this._scene,false);}return this._colorTextureRenderer;}},{key:"colorTextureRendererWithSAO",get:function get(){if(!this._colorTextureRendererWithSAO){this._colorTextureRendererWithSAO=new TrianglesColorTextureRenderer$1(this._scene,true);}return this._colorTextureRendererWithSAO;}},{key:"pbrRenderer",get:function get(){if(!this._pbrRenderer){this._pbrRenderer=new TrianglesPBRRenderer$1(this._scene,false);}return this._pbrRenderer;}},{key:"pbrRendererWithSAO",get:function get(){if(!this._pbrRendererWithSAO){this._pbrRendererWithSAO=new TrianglesPBRRenderer$1(this._scene,true);}return this._pbrRendererWithSAO;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new TrianglesSilhouetteRenderer$1(this._scene);}return this._silhouetteRenderer;}},{key:"depthRenderer",get:function get(){if(!this._depthRenderer){this._depthRenderer=new TrianglesDepthRenderer$1(this._scene);}return this._depthRenderer;}},{key:"normalsRenderer",get:function get(){if(!this._normalsRenderer){this._normalsRenderer=new TrianglesNormalsRenderer$1(this._scene);}return this._normalsRenderer;}},{key:"edgesRenderer",get:function get(){if(!this._edgesRenderer){this._edgesRenderer=new EdgesEmphasisRenderer$1(this._scene);}return this._edgesRenderer;}},{key:"edgesColorRenderer",get:function get(){if(!this._edgesColorRenderer){this._edgesColorRenderer=new EdgesColorRenderer$1(this._scene);}return this._edgesColorRenderer;}},{key:"pickMeshRenderer",get:function get(){if(!this._pickMeshRenderer){this._pickMeshRenderer=new TrianglesPickMeshRenderer$1(this._scene);}return this._pickMeshRenderer;}},{key:"pickNormalsRenderer",get:function get(){if(!this._pickNormalsRenderer){this._pickNormalsRenderer=new TrianglesPickNormalsRenderer$1(this._scene);}return this._pickNormalsRenderer;}},{key:"pickNormalsFlatRenderer",get:function get(){if(!this._pickNormalsFlatRenderer){this._pickNormalsFlatRenderer=new TrianglesPickNormalsFlatRenderer$1(this._scene);}return this._pickNormalsFlatRenderer;}},{key:"pickDepthRenderer",get:function get(){if(!this._pickDepthRenderer){this._pickDepthRenderer=new TrianglesPickDepthRenderer$1(this._scene);}return this._pickDepthRenderer;}},{key:"occlusionRenderer",get:function get(){if(!this._occlusionRenderer){this._occlusionRenderer=new TrianglesOcclusionRenderer$1(this._scene);}return this._occlusionRenderer;}},{key:"shadowRenderer",get:function get(){if(!this._shadowRenderer){this._shadowRenderer=new TrianglesShadowRenderer$1(this._scene);}return this._shadowRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new TrianglesSnapRenderer$1(this._scene);}return this._snapRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new TrianglesSnapInitRenderer$1(this._scene);}return this._snapInitRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._colorRendererWithSAO){this._colorRendererWithSAO.destroy();}if(this._flatColorRenderer){this._flatColorRenderer.destroy();}if(this._flatColorRendererWithSAO){this._flatColorRendererWithSAO.destroy();}if(this._colorTextureRenderer){this._colorTextureRenderer.destroy();}if(this._colorTextureRendererWithSAO){this._colorTextureRendererWithSAO.destroy();}if(this._pbrRenderer){this._pbrRenderer.destroy();}if(this._pbrRendererWithSAO){this._pbrRendererWithSAO.destroy();}if(this._depthRenderer){this._depthRenderer.destroy();}if(this._normalsRenderer){this._normalsRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._edgesRenderer){this._edgesRenderer.destroy();}if(this._edgesColorRenderer){this._edgesColorRenderer.destroy();}if(this._pickMeshRenderer){this._pickMeshRenderer.destroy();}if(this._pickDepthRenderer){this._pickDepthRenderer.destroy();}if(this._pickNormalsRenderer){this._pickNormalsRenderer.destroy();}if(this._pickNormalsFlatRenderer){this._pickNormalsFlatRenderer.destroy();}if(this._occlusionRenderer){this._occlusionRenderer.destroy();}if(this._shadowRenderer){this._shadowRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}}}]);return Renderers$1;}();var cachdRenderers$1={};/**
 * @private
 */function getRenderers$7(scene){var sceneId=scene.id;var batchingRenderers=cachdRenderers$1[sceneId];if(!batchingRenderers){batchingRenderers=new Renderers$1(scene);cachdRenderers$1[sceneId]=batchingRenderers;batchingRenderers._compile();batchingRenderers.eagerCreateRenders();scene.on("compile",function(){batchingRenderers._compile();batchingRenderers.eagerCreateRenders();});scene.on("destroyed",function(){delete cachdRenderers$1[sceneId];batchingRenderers._destroy();});}return batchingRenderers;}var maxDataTextureHeight=1<<16;var maxGeometryBatchSize=5000000;/**
 * Manages global configurations for all {@link Viewer}s.
 *
 * ## Example
 *
 * In the example below, we'll disable xeokit's double-precision support, which gives a performance and memory boost
 * on low-power devices, but also means that we can no longer render double-precision models without jittering.
 *
 * That's OK if we know that we're not going to view models that are geographically vast, or offset far from the World coordinate origin.
 *
 * [[Run this example](/examples/#Configs_disableDoublePrecisionAndRAF)]
 *
 * ````javascript
 * import {Configs, Viewer, XKTLoaderPlugin} from "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/xeokit-sdk.es.min.js";
 *
 * // Access xeoit-sdk global configs.
 * // We typically set configs only before we create any Viewers.
 * const configs = new Configs();
 *
 * // Disable 64-bit precision for extra speed.
 * // Only set this config once, before you create any Viewers.
 * configs.doublePrecisionEnabled = false;
 *
 * // Create a Viewer, to which our configs apply
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 *  });
 *
 * viewer.camera.eye = [-3.933, 2.855, 27.018];
 * viewer.camera.look = [4.400, 3.724, 8.899];
 * viewer.camera.up = [-0.018, 0.999, 0.039];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     src: "../assets/models/xkt/v8/ifc/Duplex.ifc.xkt"
 * });
 * ````
 */var Configs=/*#__PURE__*/function(){/**
     * Creates a Configs.
     */function Configs(){_classCallCheck(this,Configs);}/**
     * Sets whether double precision mode is enabled for Viewers.
     *
     * When double precision mode is enabled (default), Viewers will accurately render models that contain
     * double-precision coordinates, without jittering.
     *
     * Internally, double precision incurs extra performance and memory overhead, so if we're certain that
     * we're not going to render models that rely on double-precision coordinates, then it's a good idea to disable
     * it, especially on low-power devices.
     *
     * This should only be set once, before creating any Viewers.
     *
     * @returns {Boolean}
     */_createClass(Configs,[{key:"doublePrecisionEnabled",get:/**
     * Gets whether double precision mode is enabled for all Viewers.
     *
     * @returns {Boolean}
     */function get(){return math.getDoublePrecisionEnabled();}/**
     * Sets the maximum data texture height.
     *
     * Should be a multiple of 1024. Default is 4096, which is the maximum allowed value.
     */,set:function set(doublePrecision){math.setDoublePrecisionEnabled(doublePrecision);}},{key:"maxDataTextureHeight",get:/**
     * Sets maximum data texture height.
     * @returns {*|number}
     */function get(){return maxDataTextureHeight;}/**
     * Sets the maximum batched geometry VBO size.
     *
     * Default value is 5000000, which is the maximum size.
     *
     * Minimum size is 100000.
     */,set:function set(value){value=Math.ceil(value/1024)*1024;if(value>4096){value=4096;}else if(value<1024){value=1024;}maxDataTextureHeight=value;}},{key:"maxGeometryBatchSize",get:/**
     * Gets the maximum batched geometry VBO size.
     */function get(){return maxGeometryBatchSize;},set:function set(value){if(value<100000){value=100000;}else if(value>5000000){value=5000000;}maxGeometryBatchSize=value;}}]);return Configs;}();var configs$2=new Configs();/**
 * @private
 */var VBOBatchingTrianglesBuffer=/*#__PURE__*/_createClass(function VBOBatchingTrianglesBuffer(){_classCallCheck(this,VBOBatchingTrianglesBuffer);this.maxVerts=configs$2.maxGeometryBatchSize;this.maxIndices=configs$2.maxGeometryBatchSize*3;// Rough rule-of-thumb
this.positions=[];this.colors=[];this.uv=[];this.metallicRoughness=[];this.normals=[];this.pickColors=[];this.offsets=[];this.indices=[];this.edgeIndices=[];});var translate=math.mat4();var scale=math.mat4();/**
 * @private
 */function quantizePositions(positions,aabb,positionsDecodeMatrix){// http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf
var lenPositions=positions.length;var quantizedPositions=new Uint16Array(lenPositions);var xmin=aabb[0];var ymin=aabb[1];var zmin=aabb[2];var xwid=aabb[3]-xmin;var ywid=aabb[4]-ymin;var zwid=aabb[5]-zmin;var maxInt=65525;var xMultiplier=maxInt/xwid;var yMultiplier=maxInt/ywid;var zMultiplier=maxInt/zwid;var verify=function verify(num){return num>=0?num:0;};for(var _i189=0;_i189<lenPositions;_i189+=3){quantizedPositions[_i189+0]=Math.floor(verify(positions[_i189+0]-xmin)*xMultiplier);quantizedPositions[_i189+1]=Math.floor(verify(positions[_i189+1]-ymin)*yMultiplier);quantizedPositions[_i189+2]=Math.floor(verify(positions[_i189+2]-zmin)*zMultiplier);}math.identityMat4(translate);math.translationMat4v(aabb,translate);math.identityMat4(scale);math.scalingMat4v([xwid/maxInt,ywid/maxInt,zwid/maxInt],scale);math.mulMat4(translate,scale,positionsDecodeMatrix);return quantizedPositions;}/**
 * @private
 * @param aabb
 * @param positionsDecodeMatrix
 * @returns {*}
 */function createPositionsDecodeMatrix(aabb,positionsDecodeMatrix){// http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf
var xmin=aabb[0];var ymin=aabb[1];var zmin=aabb[2];var xwid=aabb[3]-xmin;var ywid=aabb[4]-ymin;var zwid=aabb[5]-zmin;var maxInt=65525;math.identityMat4(translate);math.translationMat4v(aabb,translate);math.identityMat4(scale);math.scalingMat4v([xwid/maxInt,ywid/maxInt,zwid/maxInt],scale);math.mulMat4(translate,scale,positionsDecodeMatrix);return positionsDecodeMatrix;}/**
 * @private
 */function transformAndOctEncodeNormals(worldNormalMatrix,normals,lenNormals,compressedNormals,lenCompressedNormals){// http://jcgt.org/published/0003/02/01/
function dot(array,vec3){return array[0]*vec3[0]+array[1]*vec3[1]+array[2]*vec3[2];}var oct,dec,best,currentCos,bestCos;var i;var localNormal=new Float32Array([0,0,0,0]);var worldNormal=new Float32Array([0,0,0,0]);for(i=0;i<lenNormals;i+=3){localNormal[0]=normals[i];localNormal[1]=normals[i+1];localNormal[2]=normals[i+2];math.transformVec3(worldNormalMatrix,localNormal,worldNormal);math.normalizeVec3(worldNormal,worldNormal);// Test various combinations of ceil and floor to minimize rounding errors
best=oct=octEncodeVec3(worldNormal,"floor","floor");dec=octDecodeVec2(oct);currentCos=bestCos=dot(worldNormal,dec);oct=octEncodeVec3(worldNormal,"ceil","floor");dec=octDecodeVec2(oct);currentCos=dot(worldNormal,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos;}oct=octEncodeVec3(worldNormal,"floor","ceil");dec=octDecodeVec2(oct);currentCos=dot(worldNormal,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos;}oct=octEncodeVec3(worldNormal,"ceil","ceil");dec=octDecodeVec2(oct);currentCos=dot(worldNormal,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos;}compressedNormals[lenCompressedNormals+i+0]=best[0];compressedNormals[lenCompressedNormals+i+1]=best[1];compressedNormals[lenCompressedNormals+i+2]=0.0;// Unused
}lenCompressedNormals+=lenNormals;return lenCompressedNormals;}/**
 * @private
 */function octEncodeVec3(p,xfunc,yfunc){// Oct-encode single normal vector in 2 bytes
var x=p[0]/(Math.abs(p[0])+Math.abs(p[1])+Math.abs(p[2]));var y=p[1]/(Math.abs(p[0])+Math.abs(p[1])+Math.abs(p[2]));if(p[2]<0){var tempx=x;var tempy=y;tempx=(1-Math.abs(y))*(x>=0?1:-1);tempy=(1-Math.abs(x))*(y>=0?1:-1);x=tempx;y=tempy;}return new Int8Array([Math[xfunc](x*127.5+(x<0?-1:0)),Math[yfunc](y*127.5+(y<0?-1:0))]);}/**
 * @private
 */function octDecodeVec2(oct){// Decode an oct-encoded normal
var x=oct[0];var y=oct[1];x/=x<0?127:128;y/=y<0?127:128;var z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1);}var length=Math.sqrt(x*x+y*y+z*z);return[x/length,y/length,z/length];}var tempMat4$1=math.mat4();var tempMat4b=math.mat4();var tempVec4a$7=math.vec4([0,0,0,1]);var tempVec3a$z=math.vec3();var tempVec3b$v=math.vec3();var tempVec3c$q=math.vec3();var tempVec3d$a=math.vec3();var tempVec3e$1=math.vec3();var tempVec3f$1=math.vec3();var tempVec3g$1=math.vec3();/**
 * @private
 */var VBOBatchingTrianglesLayer=/*#__PURE__*/function(){/**
     * @param model
     * @param cfg.model
     * @param cfg.autoNormals
     * @param cfg.layerIndex
     * @param cfg.positionsDecodeMatrix
     * @param cfg.uvDecodeMatrix
     * @param cfg.maxGeometryBatchSize
     * @param cfg.origin
     * @param cfg.scratchMemory
     * @param cfg.textureSet
     * @param cfg.solid
     */function VBOBatchingTrianglesLayer(cfg){_classCallCheck(this,VBOBatchingTrianglesLayer);console.info("Creating VBOBatchingTrianglesLayer");/**
         * Owner model
         * @type {VBOSceneModel}
         */this.model=cfg.model;/**
         * State sorting key.
         * @type {string}
         */this.sortId="TrianglesBatchingLayer"+(cfg.solid?"-solid":"-surface")+(cfg.autoNormals?"-autonormals":"-normals")// TODO: These two parts need to be IDs (ie. unique):
+(cfg.textureSet&&cfg.textureSet.colorTexture?"-colorTexture":"")+(cfg.textureSet&&cfg.textureSet.metallicRoughnessTexture?"-metallicRoughnessTexture":"");/**
         * Index of this TrianglesBatchingLayer in {@link VBOSceneModel#_layerList}.
         * @type {Number}
         */this.layerIndex=cfg.layerIndex;this._renderers=getRenderers$7(cfg.model.scene);this._buffer=new VBOBatchingTrianglesBuffer(cfg.maxGeometryBatchSize);this._scratchMemory=cfg.scratchMemory;this._state=new RenderState({origin:math.vec3(),positionsBuf:null,offsetsBuf:null,normalsBuf:null,colorsBuf:null,uvBuf:null,metallicRoughnessBuf:null,flagsBuf:null,indicesBuf:null,edgeIndicesBuf:null,positionsDecodeMatrix:null,uvDecodeMatrix:null,textureSet:cfg.textureSet,pbrSupported:false// Set in #finalize if we have enough to support quality rendering
});// These counts are used to avoid unnecessary render passes
this._numPortions=0;this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numSelectedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numClippableLayerPortions=0;this._numEdgesLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;this._modelAABB=math.collapseAABB3();// Model-space AABB
this._portions=[];this._meshes=[];this._numVerts=0;this._aabb=math.collapseAABB3();this.aabbDirty=true;this._finalized=false;if(cfg.positionsDecodeMatrix){this._state.positionsDecodeMatrix=math.mat4(cfg.positionsDecodeMatrix);}if(cfg.uvDecodeMatrix){this._state.uvDecodeMatrix=math.mat3(cfg.uvDecodeMatrix);this._preCompressedUVsExpected=true;}else{this._preCompressedUVsExpected=false;}if(cfg.origin){this._state.origin.set(cfg.origin);}/**
         * When true, this layer contains solid triangle meshes, otherwise this layer contains surface triangle meshes
         * @type {boolean}
         */this.solid=!!cfg.solid;}_createClass(VBOBatchingTrianglesLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i190=0,len=this._meshes.length;_i190<len;_i190++){math.expandAABB3(this._aabb,this._meshes[_i190].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Tests if there is room for another portion in this TrianglesBatchingLayer.
     *
     * @param lenPositions Number of positions we'd like to create in the portion.
     * @param lenIndices Number of indices we'd like to create in this portion.
     * @returns {Boolean} True if OK to create another portion.
     */},{key:"canCreatePortion",value:function canCreatePortion(lenPositions,lenIndices){if(this._finalized){throw"Already finalized";}return this._buffer.positions.length+lenPositions<this._buffer.maxVerts*3&&this._buffer.indices.length+lenIndices<this._buffer.maxIndices;}/**
     * Creates a new portion within this TrianglesBatchingLayer, returns the new portion ID.
     *
     * Gives the portion the specified geometry, color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param cfg.positions Flat float Local-space positions array.
     * @param cfg.positionsCompressed Flat quantized positions array - decompressed with TrianglesBatchingLayer positionsDecodeMatrix
     * @param [cfg.normals] Flat float normals array.
     * @param [cfg.uv] Flat UVs array.
     * @param [cfg.uvCompressed]
     * @param [cfg.colors] Flat float colors array.
     * @param [cfg.colorsCompressed]
     * @param cfg.indices  Flat int indices array.
     * @param [cfg.edgeIndices] Flat int edges indices array.
     * @param cfg.color Quantized RGB color [0..255,0..255,0..255,0..255]
     * @param cfg.metallic Metalness factor [0..255]
     * @param cfg.roughness Roughness factor [0..255]
     * @param cfg.opacity Opacity [0..255]
     * @param [cfg.meshMatrix] Flat float 4x4 matrix
     * @param cfg.aabb Flat float AABB World-space AABB
     * @param cfg.pickColor Quantized pick color
     * @returns {number} Portion ID
     */},{key:"createPortion",value:function createPortion(mesh,cfg){if(this._finalized){throw"Already finalized";}var positions=cfg.positions;var positionsCompressed=cfg.positionsCompressed;var normals=cfg.normals;var normalsCompressed=cfg.normalsCompressed;var uv=cfg.uv;var uvCompressed=cfg.uvCompressed;var colors=cfg.colors;var colorsCompressed=cfg.colorsCompressed;var indices=cfg.indices;var edgeIndices=cfg.edgeIndices;var color=cfg.color;var metallic=cfg.metallic;var roughness=cfg.roughness;var opacity=cfg.opacity;var meshMatrix=cfg.meshMatrix;var pickColor=cfg.pickColor;var scene=this.model.scene;var buffer=this._buffer;var vertsBaseIndex=buffer.positions.length/3;var numVerts;math.expandAABB3(this._modelAABB,cfg.aabb);if(this._state.positionsDecodeMatrix){if(!positionsCompressed){throw"positionsCompressed expected";}numVerts=positionsCompressed.length/3;for(var _i191=0,len=positionsCompressed.length;_i191<len;_i191++){buffer.positions.push(positionsCompressed[_i191]);}}else{if(!positions){throw"positions expected";}numVerts=positions.length/3;for(var _i192=0,_len33=positions.length;_i192<_len33;_i192++){buffer.positions.push(positions[_i192]);}}if(normalsCompressed&&normalsCompressed.length>0){for(var _i193=0,_len34=normalsCompressed.length;_i193<_len34;_i193++){buffer.normals.push(normalsCompressed[_i193]);}}else if(normals&&normals.length>0){var worldNormalMatrix=tempMat4$1;if(meshMatrix){math.inverseMat4(math.transposeMat4(meshMatrix,tempMat4b),worldNormalMatrix);// Note: order of inverse and transpose doesn't matter
}else{math.identityMat4(worldNormalMatrix,worldNormalMatrix);}transformAndOctEncodeNormals(worldNormalMatrix,normals,normals.length,buffer.normals,buffer.normals.length);}if(colors){for(var _i194=0,_len35=colors.length;_i194<_len35;_i194+=3){buffer.colors.push(colors[_i194]*255);buffer.colors.push(colors[_i194+1]*255);buffer.colors.push(colors[_i194+2]*255);buffer.colors.push(255);}}else if(colorsCompressed){for(var _i195=0,_len36=colors.length;_i195<_len36;_i195+=3){buffer.colors.push(colors[_i195]);buffer.colors.push(colors[_i195+1]);buffer.colors.push(colors[_i195+2]);buffer.colors.push(255);}}else if(color){var _r3=color[0];// Color is pre-quantized by VBOSceneModel
var g=color[1];var b=color[2];var _a2=opacity;for(var _i196=0;_i196<numVerts;_i196++){buffer.colors.push(_r3);buffer.colors.push(g);buffer.colors.push(b);buffer.colors.push(_a2);}}var metallicValue=metallic!==null&&metallic!==undefined?metallic:0;var roughnessValue=roughness!==null&&roughness!==undefined?roughness:255;for(var _i197=0;_i197<numVerts;_i197++){buffer.metallicRoughness.push(metallicValue);buffer.metallicRoughness.push(roughnessValue);}if(uv&&uv.length>0){for(var _i198=0,_len37=uv.length;_i198<_len37;_i198++){buffer.uv.push(uv[_i198]);}}else if(uvCompressed&&uvCompressed.length>0){for(var _i199=0,_len38=uvCompressed.length;_i199<_len38;_i199++){buffer.uv.push(uvCompressed[_i199]);}}for(var _i200=0,_len39=indices.length;_i200<_len39;_i200++){buffer.indices.push(vertsBaseIndex+indices[_i200]);}if(edgeIndices){for(var _i201=0,_len40=edgeIndices.length;_i201<_len40;_i201++){buffer.edgeIndices.push(vertsBaseIndex+edgeIndices[_i201]);}}{var pickColorsBase=buffer.pickColors.length;var lenPickColors=numVerts*4;for(var _i202=pickColorsBase,_len41=pickColorsBase+lenPickColors;_i202<_len41;_i202+=4){buffer.pickColors.push(pickColor[0]);buffer.pickColors.push(pickColor[1]);buffer.pickColors.push(pickColor[2]);buffer.pickColors.push(pickColor[3]);}}if(scene.entityOffsetsEnabled){for(var _i203=0;_i203<numVerts;_i203++){buffer.offsets.push(0);buffer.offsets.push(0);buffer.offsets.push(0);}}var portionId=this._portions.length;var portion={vertsBaseIndex:vertsBaseIndex,numVerts:numVerts,indicesBaseIndex:buffer.indices.length-indices.length,numIndices:indices.length};if(scene.pickSurfacePrecisionEnabled){// Quantized in-memory positions are initialized in finalize()
portion.indices=indices;if(scene.entityOffsetsEnabled){portion.offset=new Float32Array(3);}}this._portions.push(portion);this._numPortions++;this.model.numPortions++;this._numVerts+=portion.numVerts;this._meshes.push(mesh);return portionId;}/**
     * Builds batch VBOs from appended geometries.
     * No more portions can then be created.
     */},{key:"finalize",value:function finalize(){if(this._finalized){return;}var state=this._state;var gl=this.model.scene.canvas.gl;var buffer=this._buffer;if(buffer.positions.length>0){var quantizedPositions=this._state.positionsDecodeMatrix?new Uint16Array(buffer.positions):quantizePositions(buffer.positions,this._modelAABB,this._state.positionsDecodeMatrix=math.mat4());// BOTTLENECK
state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,quantizedPositions,quantizedPositions.length,3,gl.STATIC_DRAW);if(this.model.scene.pickSurfacePrecisionEnabled){for(var _i204=0,numPortions=this._portions.length;_i204<numPortions;_i204++){var portion=this._portions[_i204];var start=portion.vertsBaseIndex*3;var end=start+portion.numVerts*3;portion.quantizedPositions=quantizedPositions.slice(start,end);}}}if(buffer.normals.length>0){// Normals are already oct-encoded
var normals=new Int8Array(buffer.normals);var normalized=true;// For oct encoded UInts
state.normalsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,normals,buffer.normals.length,3,gl.STATIC_DRAW,normalized);}if(buffer.colors.length>0){// Colors are already compressed
var colors=new Uint8Array(buffer.colors);var _normalized=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colors,buffer.colors.length,4,gl.DYNAMIC_DRAW,_normalized);}if(buffer.uv.length>0){if(!state.uvDecodeMatrix){var bounds=geometryCompressionUtils.getUVBounds(buffer.uv);var result=geometryCompressionUtils.compressUVs(buffer.uv,bounds.min,bounds.max);var uv=result.quantized;var notNormalized=false;state.uvDecodeMatrix=math.mat3(result.decodeMatrix);state.uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,uv,uv.length,2,gl.STATIC_DRAW,notNormalized);}else{var _notNormalized=false;state.uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,buffer.uv,buffer.uv.length,2,gl.STATIC_DRAW,_notNormalized);}}if(buffer.metallicRoughness.length>0){var metallicRoughness=new Uint8Array(buffer.metallicRoughness);var _normalized2=false;state.metallicRoughnessBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,metallicRoughness,buffer.metallicRoughness.length,2,gl.STATIC_DRAW,_normalized2);}if(buffer.positions.length>0){// Because we build flags arrays here, get their length from the positions array
var flagsLength=buffer.positions.length/3;var flags=new Float32Array(flagsLength);var _notNormalized2=false;state.flagsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,flags,flags.length,1,gl.DYNAMIC_DRAW,_notNormalized2);}if(buffer.pickColors.length>0){var pickColors=new Uint8Array(buffer.pickColors);var _normalized3=false;state.pickColorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,pickColors,buffer.pickColors.length,4,gl.STATIC_DRAW,_normalized3);}if(this.model.scene.entityOffsetsEnabled){if(buffer.offsets.length>0){var offsets=new Float32Array(buffer.offsets);state.offsetsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,offsets,buffer.offsets.length,3,gl.DYNAMIC_DRAW);}}if(buffer.indices.length>0){var indices=new Uint32Array(buffer.indices);state.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,indices,buffer.indices.length,1,gl.STATIC_DRAW);}if(buffer.edgeIndices.length>0){var edgeIndices=new Uint32Array(buffer.edgeIndices);state.edgeIndicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,edgeIndices,buffer.edgeIndices.length,1,gl.STATIC_DRAW);}this._state.pbrSupported=!!state.metallicRoughnessBuf&&!!state.uvBuf&&!!state.normalsBuf&&!!state.textureSet&&!!state.textureSet.colorTexture&&!!state.textureSet.metallicRoughnessTexture;this._state.colorTextureSupported=!!state.uvBuf&&!!state.textureSet&&!!state.textureSet.colorTexture;this._buffer=null;this._finalized=true;}},{key:"isEmpty",value:function isEmpty(){return!this._state.indicesBuf;}},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}var deferred=true;this._setFlags(portionId,flags,meshTransparent,deferred);}},{key:"flushInitFlags",value:function flushInitFlags(){this._setDeferredFlags();}},{key:"setVisible",value:function setVisible(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setSelected",value:function setSelected(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setEdges",value:function setEdges(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}else{this._numEdgesLayerPortions--;this.model.numEdgesLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags(portionId,flags);}},{key:"setCulled",value:function setCulled(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions--;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setColor",value:function setColor(portionId,color){if(!this._finalized){throw"Not finalized";}var portionsIdx=portionId;var portion=this._portions[portionsIdx];var vertsBaseIndex=portion.vertsBaseIndex;var numVerts=portion.numVerts;var firstColor=vertsBaseIndex*4;var lenColor=numVerts*4;var tempArray=this._scratchMemory.getUInt8Array(lenColor);var r=color[0];var g=color[1];var b=color[2];var a=color[3];for(var _i205=0;_i205<lenColor;_i205+=4){tempArray[_i205+0]=r;tempArray[_i205+1]=g;tempArray[_i205+2]=b;tempArray[_i205+3]=a;}if(this._state.colorsBuf){this._state.colorsBuf.setData(tempArray,firstColor,lenColor);}}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}/**
     * flags are 4bits values encoded on a 32bit base. color flag on the first 4 bits, silhouette flag on the next 4 bits and so on for edge, pick and clippable.
     */},{key:"_setFlags",value:function _setFlags(portionId,flags,transparent){var deferred=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(!this._finalized){throw"Not finalized";}var portionsIdx=portionId;var portion=this._portions[portionsIdx];var vertsBaseIndex=portion.vertsBaseIndex;var numVerts=portion.numVerts;var firstFlag=vertsBaseIndex;var lenFlags=numVerts;var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var edges=!!(flags&ENTITY_FLAGS.EDGES);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);var colorFlag;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){colorFlag=RENDER_PASSES.NOT_RENDERED;}else{if(transparent){colorFlag=RENDER_PASSES.COLOR_TRANSPARENT;}else{colorFlag=RENDER_PASSES.COLOR_OPAQUE;}}var silhouetteFlag;if(!visible||culled){silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){silhouetteFlag=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){silhouetteFlag=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){silhouetteFlag=RENDER_PASSES.SILHOUETTE_XRAYED;}else{silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}var edgeFlag=0;if(!visible||culled){edgeFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){edgeFlag=RENDER_PASSES.EDGES_SELECTED;}else if(highlighted){edgeFlag=RENDER_PASSES.EDGES_HIGHLIGHTED;}else if(xrayed){edgeFlag=RENDER_PASSES.EDGES_XRAYED;}else if(edges){if(transparent){edgeFlag=RENDER_PASSES.EDGES_COLOR_TRANSPARENT;}else{edgeFlag=RENDER_PASSES.EDGES_COLOR_OPAQUE;}}else{edgeFlag=RENDER_PASSES.NOT_RENDERED;}var pickFlag=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var clippableFlag=!!(flags&ENTITY_FLAGS.CLIPPABLE)?1:0;if(deferred){// Avoid zillions of individual WebGL bufferSubData calls - buffer them to apply in one shot
if(!this._deferredFlagValues){this._deferredFlagValues=new Float32Array(this._numVerts);}for(var _i206=firstFlag,len=firstFlag+lenFlags;_i206<len;_i206++){var vertFlag=0;vertFlag|=colorFlag;vertFlag|=silhouetteFlag<<4;vertFlag|=edgeFlag<<8;vertFlag|=pickFlag<<12;vertFlag|=clippableFlag<<16;this._deferredFlagValues[_i206]=vertFlag;}}else if(this._state.flagsBuf){var tempArray=this._scratchMemory.getFloat32Array(lenFlags);for(var _i207=0;_i207<lenFlags;_i207++){var _vertFlag=0;_vertFlag|=colorFlag;_vertFlag|=silhouetteFlag<<4;_vertFlag|=edgeFlag<<8;_vertFlag|=pickFlag<<12;_vertFlag|=clippableFlag<<16;tempArray[_i207]=_vertFlag;}this._state.flagsBuf.setData(tempArray,firstFlag,lenFlags);}}},{key:"_setDeferredFlags",value:function _setDeferredFlags(){if(this._deferredFlagValues){this._state.flagsBuf.setData(this._deferredFlagValues);this._deferredFlagValues=null;}}},{key:"setOffset",value:function setOffset(portionId,offset){if(!this._finalized){throw"Not finalized";}if(!this.model.scene.entityOffsetsEnabled){this.model.error("Entity#offset not enabled for this Viewer");// See Viewer entityOffsetsEnabled
return;}var portionsIdx=portionId;var portion=this._portions[portionsIdx];var vertsBaseIndex=portion.vertsBaseIndex;var numVerts=portion.numVerts;var firstOffset=vertsBaseIndex*3;var lenOffsets=numVerts*3;var tempArray=this._scratchMemory.getFloat32Array(lenOffsets);var x=offset[0];var y=offset[1];var z=offset[2];for(var _i208=0;_i208<lenOffsets;_i208+=3){tempArray[_i208+0]=x;tempArray[_i208+1]=y;tempArray[_i208+2]=z;}if(this._state.offsetsBuf){this._state.offsetsBuf.setData(tempArray,firstOffset,lenOffsets);}if(this.model.scene.pickSurfacePrecisionEnabled){portion.offset[0]=offset[0];portion.offset[1]=offset[1];portion.offset[2]=offset[2];}}},{key:"getEachVertex",value:function getEachVertex(portionId,callback){if(!this.model.scene.pickSurfacePrecisionEnabled){return;}var state=this._state;var portion=this._portions[portionId];if(!portion){this.model.error("portion not found: "+portionId);return;}var positions=portion.quantizedPositions;var origin=state.origin;var offset=portion.offset;var offsetX=origin[0]+offset[0];var offsetY=origin[1]+offset[1];var offsetZ=origin[2]+offset[2];var worldPos=tempVec4a$7;for(var _i209=0,len=positions.length;_i209<len;_i209+=3){worldPos[0]=positions[_i209];worldPos[1]=positions[_i209+1];worldPos[2]=positions[_i209+2];worldPos[3]=1.0;math.decompressPosition(worldPos,state.positionsDecodeMatrix);math.transformPoint4(this.model.worldMatrix,worldPos);worldPos[0]+=offsetX;worldPos[1]+=offsetY;worldPos[2]+=offsetZ;callback(worldPos);}}},{key:"getElementsCountAndOffset",value:function getElementsCountAndOffset(portionId){var count=null;var offset=null;var portion=this._portions[portionId];if(portion){count=portion.numIndices;offset=portion.indicesBaseIndex;}return{count:count,offset:offset};}// ---------------------- COLOR RENDERING -----------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(frameCtx.withSAO&&this.model.saoEnabled){if(frameCtx.pbrEnabled&&this.model.pbrEnabled&&this._state.pbrSupported){if(this._renderers.pbrRendererWithSAO){this._renderers.pbrRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(frameCtx.colorTextureEnabled&&this.model.colorTextureEnabled&&this._state.colorTextureSupported){if(this._renderers.colorTextureRendererWithSAO){this._renderers.colorTextureRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(this._state.normalsBuf){if(this._renderers.colorRendererWithSAO){this._renderers.colorRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else{if(this._renderers.flatColorRendererWithSAO){this._renderers.flatColorRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}}else{if(frameCtx.pbrEnabled&&this.model.pbrEnabled&&this._state.pbrSupported){if(this._renderers.pbrRenderer){this._renderers.pbrRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(frameCtx.colorTextureEnabled&&this.model.colorTextureEnabled&&this._state.colorTextureSupported){if(this._renderers.colorTextureRenderer){this._renderers.colorTextureRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(this._state.normalsBuf){if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else{if(this._renderers.flatColorRenderer){this._renderers.flatColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}}}},{key:"_updateBackfaceCull",value:function _updateBackfaceCull(renderFlags,frameCtx){var backfaces=this.model.backfaces||!this.solid||renderFlags.sectioned;if(frameCtx.backfaces!==backfaces){var _gl4=frameCtx.gl;if(backfaces){_gl4.disable(_gl4.CULL_FACE);}else{_gl4.enable(_gl4.CULL_FACE);}frameCtx.backfaces=backfaces;}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(frameCtx.pbrEnabled&&this.model.pbrEnabled&&this._state.pbrSupported){if(this._renderers.pbrRenderer){this._renderers.pbrRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}else if(frameCtx.colorTextureEnabled&&this.model.colorTextureEnabled&&this._state.colorTextureSupported){if(this._renderers.colorTextureRenderer){this._renderers.colorTextureRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}else if(this._state.normalsBuf){if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}else{if(this._renderers.flatColorRenderer){this._renderers.flatColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}}// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------
},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.depthRenderer){this._renderers.depthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);// Assume whatever post-effect uses depth (eg SAO) does not apply to transparent objects
}}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.normalsRenderer){this._renderers.normalsRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);// Assume whatever post-effect uses normals (eg SAO) does not apply to transparent objects
}}// ---------------------- SILHOUETTE RENDERING -----------------------------------
},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}// ---------------------- EDGES RENDERING -----------------------------------
},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numEdgesLayerPortions===0){return;}if(this._renderers.edgesColorRenderer){this._renderers.edgesColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_COLOR_OPAQUE);}}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numEdgesLayerPortions===0||this._numTransparentLayerPortions===0){return;}if(this._renderers.edgesColorRenderer){this._renderers.edgesColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_COLOR_TRANSPARENT);}}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_HIGHLIGHTED);}}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_SELECTED);}}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_XRAYED);}}// ---------------------- OCCLUSION CULL RENDERING -----------------------------------
},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.occlusionRenderer){this._renderers.occlusionRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}// ---------------------- SHADOW BUFFER RENDERING -----------------------------------
},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.shadowRenderer){this._renderers.shadowRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}//---- PICKING ----------------------------------------------------------------------------------------------------
},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickMeshRenderer){this._renderers.pickMeshRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickDepthRenderer){this._renderers.pickDepthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO
// if (this._state.normalsBuf) {
//     if (this._renderers.pickNormalsRenderer) {
//         this._renderers.pickNormalsRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
//     }
////////////////////////////////////////////////////////////////////////////////////////////////////
// } else {
if(this._renderers.pickNormalsFlatRenderer){this._renderers.pickNormalsFlatRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}// }
}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}//------------------------------------------------------------------------------------------------
},{key:"precisionRayPickSurface",value:function precisionRayPickSurface(portionId,worldRayOrigin,worldRayDir,worldSurfacePos,worldNormal){if(!this.model.scene.pickSurfacePrecisionEnabled){return false;}var state=this._state;var portion=this._portions[portionId];if(!portion){this.model.error("portion not found: "+portionId);return false;}var positions=portion.quantizedPositions;var indices=portion.indices;var origin=state.origin;var offset=portion.offset;var rtcRayOrigin=tempVec3a$z;var rtcRayDir=tempVec3b$v;rtcRayOrigin.set(origin?math.subVec3(worldRayOrigin,origin,tempVec3c$q):worldRayOrigin);// World -> RTC
rtcRayDir.set(worldRayDir);if(offset){math.subVec3(rtcRayOrigin,offset);}math.transformRay(this.model.worldNormalMatrix,rtcRayOrigin,rtcRayDir,rtcRayOrigin,rtcRayDir);// RTC -> local
var a=tempVec3d$a;var b=tempVec3e$1;var c=tempVec3f$1;var gotIntersect=false;var closestDist=0;var closestIntersectPos=tempVec3g$1;for(var _i210=0,len=indices.length;_i210<len;_i210+=3){var ia=indices[_i210]*3;var ib=indices[_i210+1]*3;var ic=indices[_i210+2]*3;a[0]=positions[ia];a[1]=positions[ia+1];a[2]=positions[ia+2];b[0]=positions[ib];b[1]=positions[ib+1];b[2]=positions[ib+2];c[0]=positions[ic];c[1]=positions[ic+1];c[2]=positions[ic+2];math.decompressPosition(a,state.positionsDecodeMatrix);math.decompressPosition(b,state.positionsDecodeMatrix);math.decompressPosition(c,state.positionsDecodeMatrix);if(math.rayTriangleIntersect(rtcRayOrigin,rtcRayDir,a,b,c,closestIntersectPos)){math.transformPoint3(this.model.worldMatrix,closestIntersectPos,closestIntersectPos);if(offset){math.addVec3(closestIntersectPos,offset);}if(origin){math.addVec3(closestIntersectPos,origin);}var dist=Math.abs(math.lenVec3(math.subVec3(closestIntersectPos,worldRayOrigin,[])));if(!gotIntersect||dist>closestDist){closestDist=dist;worldSurfacePos.set(closestIntersectPos);if(worldNormal){// Not that wasteful to eagerly compute - unlikely to hit >2 surfaces on most geometry
math.triangleNormal(a,b,c,worldNormal);}gotIntersect=true;}}}if(gotIntersect&&worldNormal){math.transformVec3(this.model.worldNormalMatrix,worldNormal,worldNormal);math.normalizeVec3(worldNormal);}return gotIntersect;}// ---------
},{key:"destroy",value:function destroy(){var state=this._state;if(state.positionsBuf){state.positionsBuf.destroy();state.positionsBuf=null;}if(state.offsetsBuf){state.offsetsBuf.destroy();state.offsetsBuf=null;}if(state.normalsBuf){state.normalsBuf.destroy();state.normalsBuf=null;}if(state.colorsBuf){state.colorsBuf.destroy();state.colorsBuf=null;}if(state.metallicRoughnessBuf){state.metallicRoughnessBuf.destroy();state.metallicRoughnessBuf=null;}if(state.flagsBuf){state.flagsBuf.destroy();state.flagsBuf=null;}if(state.pickColorsBuf){state.pickColorsBuf.destroy();state.pickColorsBuf=null;}if(state.indicesBuf){state.indicesBuf.destroy();state.indicessBuf=null;}if(state.edgeIndicesBuf){state.edgeIndicesBuf.destroy();state.edgeIndicessBuf=null;}state.destroy();}}]);return VBOBatchingTrianglesLayer;}();/**
 * @private
 */var TrianglesInstancingRenderer=/*#__PURE__*/function(_VBORenderer4){_inherits(TrianglesInstancingRenderer,_VBORenderer4);var _super64=_createSuper(TrianglesInstancingRenderer);function TrianglesInstancingRenderer(scene,withSAO){var _ref9=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref9$edges=_ref9.edges,edges=_ref9$edges===void 0?false:_ref9$edges;_classCallCheck(this,TrianglesInstancingRenderer);return _super64.call(this,scene,withSAO,{instancing:true,edges:edges});}_createClass(TrianglesInstancingRenderer,[{key:"_draw",value:function _draw(drawCfg){var gl=this._scene.canvas.gl;var state=drawCfg.state,frameCtx=drawCfg.frameCtx,incrementDrawState=drawCfg.incrementDrawState;if(this._edges){gl.drawElementsInstanced(gl.LINES,state.edgeIndicesBuf.numItems,state.edgeIndicesBuf.itemType,0,state.numInstances);}else{gl.drawElementsInstanced(gl.TRIANGLES,state.indicesBuf.numItems,state.indicesBuf.itemType,0,state.numInstances);if(incrementDrawState){frameCtx.drawElements++;}}}}]);return TrianglesInstancingRenderer;}(VBORenderer);/**
 * @private
 */var TrianglesColorRenderer=/*#__PURE__*/function(_TrianglesInstancingR){_inherits(TrianglesColorRenderer,_TrianglesInstancingR);var _super65=_createSuper(TrianglesColorRenderer);function TrianglesColorRenderer(){_classCallCheck(this,TrianglesColorRenderer);return _super65.apply(this,arguments);}_createClass(TrianglesColorRenderer,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(TrianglesColorRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var i;var len;var light;var src=[];src.push("#version 300 es");src.push("// Instancing geometry drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec2 normal;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("in vec4 modelNormalMatrixCol0;");src.push("in vec4 modelNormalMatrixCol1;");src.push("in vec4 modelNormalMatrixCol2;");this._addMatricesUniformBlockLines(src,true);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("uniform vec4 lightAmbient;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+i+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+i+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+i+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+i+";");src.push("uniform vec3 lightDir"+i+";");}}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); ");src.push("vec4 worldNormal = worldNormalMatrix * vec4(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2), 0.0);");src.push("vec3 viewNormal = normalize(vec4(viewNormalMatrix * worldNormal).xyz);");src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue;}if(light.type==="dir"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+i+", 0.0)).xyz);");}}else if(light.type==="point"){if(light.space==="view"){src.push("viewLightDir = -normalize(lightPos"+i+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+i+", 0.0)).xyz);");}}else if(light.type==="spot"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+i+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+i+".rgb * lightColor"+i+".a);");}src.push("vec3 rgb = (vec3(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0));");src.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i211=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i211<len;_i211++){src.push("uniform bool sectionPlaneActive"+_i211+";");src.push("uniform vec3 sectionPlanePos"+_i211+";");src.push("uniform vec3 sectionPlaneDir"+_i211+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i212=0,_len42=sectionPlanesState.getNumAllocatedSectionPlanes();_i212<_len42;_i212++){src.push("if (sectionPlaneActive"+_i212+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i212+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i212+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
if(this._withSAO){src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor                = vec4(vColor.rgb * ambient, 1.0);");}else{src.push("    outColor           = vColor;");}src.push("}");return src;}}]);return TrianglesColorRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesFlatColorRenderer=/*#__PURE__*/function(_TrianglesInstancingR2){_inherits(TrianglesFlatColorRenderer,_TrianglesInstancingR2);var _super66=_createSuper(TrianglesFlatColorRenderer);function TrianglesFlatColorRenderer(){_classCallCheck(this,TrianglesFlatColorRenderer);return _super66.apply(this,arguments);}_createClass(TrianglesFlatColorRenderer,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry flat-shading drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vViewPosition = viewPosition;");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry flat-shading drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i213=0,_len43=sectionPlanesState.getNumAllocatedSectionPlanes();_i213<_len43;_i213++){src.push("uniform bool sectionPlaneActive"+_i213+";");src.push("uniform vec3 sectionPlanePos"+_i213+";");src.push("uniform vec3 sectionPlaneDir"+_i213+";");}}this._addMatricesUniformBlockLines(src);src.push("uniform vec4 lightAmbient;");for(i=0,len=lightsState.lights.length;i<len;i++){var light=lightsState.lights[i];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+i+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+i+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+i+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+i+";");src.push("uniform vec3 lightDir"+i+";");}}src.push("in vec4 vViewPosition;");src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i214=0,_len44=sectionPlanesState.getNumAllocatedSectionPlanes();_i214<_len44;_i214++){src.push("if (sectionPlaneActive"+_i214+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i214+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i214+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");for(i=0,len=lightsState.lights.length;i<len;i++){var _light7=lightsState.lights[i];if(_light7.type==="ambient"){continue;}if(_light7.type==="dir"){if(_light7.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+i+", 0.0)).xyz);");}}else if(_light7.type==="point"){if(_light7.space==="view"){src.push("viewLightDir = -normalize(lightPos"+i+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+i+", 0.0)).xyz);");}}else if(_light7.type==="spot"){if(_light7.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+i+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+i+".rgb * lightColor"+i+".a);");}src.push("vec4 fragColor = vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor            = vec4(fragColor.rgb * ambient, 1.0);");}else{src.push("    outColor           = fragColor;");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return TrianglesFlatColorRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesSilhouetteRenderer=/*#__PURE__*/function(_TrianglesInstancingR3){_inherits(TrianglesSilhouetteRenderer,_TrianglesInstancingR3);var _super67=_createSuper(TrianglesSilhouetteRenderer);function TrianglesSilhouetteRenderer(){_classCallCheck(this,TrianglesSilhouetteRenderer);return _super67.apply(this,arguments);}_createClass(TrianglesSilhouetteRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){// TODO color uniform true ???
_get(_getPrototypeOf(TrianglesSilhouetteRenderer.prototype),"drawLayer",this).call(this,frameCtx,instancingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing silhouette vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 color;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);src.push("uniform vec4 silhouetteColor;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// silhouetteFlag = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("int silhouetteFlag = int(flags) >> 4 & 0xF;");src.push("if (silhouetteFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vColor = vec4(silhouetteColor.r, silhouetteColor.g, silhouetteColor.b, min(silhouetteColor.a, float(color.a) / 255.0));");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing fill fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i215=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i215<len;_i215++){src.push("uniform bool sectionPlaneActive"+_i215+";");src.push("uniform vec3 sectionPlanePos"+_i215+";");src.push("uniform vec3 sectionPlaneDir"+_i215+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i216=0,_len45=sectionPlanesState.getNumAllocatedSectionPlanes();_i216<_len45;_i216++){src.push("if (sectionPlaneActive"+_i216+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i216+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i216+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return TrianglesSilhouetteRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var EdgesRenderer=/*#__PURE__*/function(_TrianglesInstancingR4){_inherits(EdgesRenderer,_TrianglesInstancingR4);var _super68=_createSuper(EdgesRenderer);function EdgesRenderer(scene,withSAO){_classCallCheck(this,EdgesRenderer);return _super68.call(this,scene,withSAO,{instancing:true,edges:true});}return _createClass(EdgesRenderer);}(TrianglesInstancingRenderer);/**
 * @private
 */var EdgesEmphasisRenderer=/*#__PURE__*/function(_EdgesRenderer){_inherits(EdgesEmphasisRenderer,_EdgesRenderer);var _super69=_createSuper(EdgesEmphasisRenderer);function EdgesEmphasisRenderer(){_classCallCheck(this,EdgesEmphasisRenderer);return _super69.apply(this,arguments);}_createClass(EdgesEmphasisRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){_get(_getPrototypeOf(EdgesEmphasisRenderer.prototype),"drawLayer",this).call(this,frameCtx,instancingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// EdgesEmphasisRenderer vertex shader");src.push("uniform int renderPass;");src.push("uniform vec4 color;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// edgeFlag = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
// renderPass = EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
src.push("int edgeFlag = int(flags) >> 8 & 0xF;");src.push("if (edgeFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = worldMatrix * positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("vColor = vec4(color.r, color.g, color.b, color.a);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// EdgesEmphasisRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i217=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i217<len;_i217++){src.push("uniform bool sectionPlaneActive"+_i217+";");src.push("uniform vec3 sectionPlanePos"+_i217+";");src.push("uniform vec3 sectionPlaneDir"+_i217+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i218=0,_len46=sectionPlanesState.getNumAllocatedSectionPlanes();_i218<_len46;_i218++){src.push("if (sectionPlaneActive"+_i218+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i218+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i218+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return EdgesEmphasisRenderer;}(EdgesRenderer);/**
 * @private
 */var EdgesColorRenderer=/*#__PURE__*/function(_EdgesRenderer2){_inherits(EdgesColorRenderer,_EdgesRenderer2);var _super70=_createSuper(EdgesColorRenderer);function EdgesColorRenderer(){_classCallCheck(this,EdgesColorRenderer);return _super70.apply(this,arguments);}_createClass(EdgesColorRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){_get(_getPrototypeOf(EdgesColorRenderer.prototype),"drawLayer",this).call(this,frameCtx,batchingLayer,renderPass,{colorUniform:false});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// EdgesColorRenderer vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// edgeFlag = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
// renderPass = EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
src.push("int edgeFlag = int(flags) >> 8 & 0xF;");src.push("if (edgeFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");//   src.push("vColor = vec4(float(color.r-100.0) / 255.0, float(color.g-100.0) / 255.0, float(color.b-100.0) / 255.0, float(color.a) / 255.0);");
src.push("vColor = vec4(float(color.r*0.5) / 255.0, float(color.g*0.5) / 255.0, float(color.b*0.5) / 255.0, float(color.a) / 255.0);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// EdgesColorRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i219=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i219<len;_i219++){src.push("uniform bool sectionPlaneActive"+_i219+";");src.push("uniform vec3 sectionPlanePos"+_i219+";");src.push("uniform vec3 sectionPlaneDir"+_i219+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i220=0,_len47=sectionPlanesState.getNumAllocatedSectionPlanes();_i220<_len47;_i220++){src.push("if (sectionPlaneActive"+_i220+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i220+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i220+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return EdgesColorRenderer;}(EdgesRenderer);/**
 * @private
 */var TrianglesPickMeshRenderer=/*#__PURE__*/function(_TrianglesInstancingR5){_inherits(TrianglesPickMeshRenderer,_TrianglesInstancingR5);var _super71=_createSuper(TrianglesPickMeshRenderer);function TrianglesPickMeshRenderer(){_classCallCheck(this,TrianglesPickMeshRenderer);return _super71.apply(this,arguments);}_createClass(TrianglesPickMeshRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry picking vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 pickColor;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vPickColor;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry picking fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i221=0;_i221<sectionPlanesState.getNumAllocatedSectionPlanes();_i221++){src.push("uniform bool sectionPlaneActive"+_i221+";");src.push("uniform vec3 sectionPlanePos"+_i221+";");src.push("uniform vec3 sectionPlaneDir"+_i221+";");}}src.push("in vec4 vPickColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i222=0;_i222<sectionPlanesState.getNumAllocatedSectionPlanes();_i222++){src.push("if (sectionPlaneActive"+_i222+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i222+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i222+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vPickColor; ");src.push("}");return src;}}]);return TrianglesPickMeshRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesPickDepthRenderer=/*#__PURE__*/function(_TrianglesInstancingR6){_inherits(TrianglesPickDepthRenderer,_TrianglesInstancingR6);var _super72=_createSuper(TrianglesPickDepthRenderer);function TrianglesPickDepthRenderer(){_classCallCheck(this,TrianglesPickDepthRenderer);return _super72.apply(this,arguments);}_createClass(TrianglesPickDepthRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry depth vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("  vViewPosition = viewPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform float pickZNear;");src.push("uniform float pickZFar;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i223=0;_i223<sectionPlanesState.getNumAllocatedSectionPlanes();_i223++){src.push("uniform bool sectionPlaneActive"+_i223+";");src.push("uniform vec3 sectionPlanePos"+_i223+";");src.push("uniform vec3 sectionPlaneDir"+_i223+";");}}src.push("in vec4 vViewPosition;");src.push("vec4 packDepth(const in float depth) {");src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");src.push("  vec4 res = fract(depth * bitShift);");src.push("  res -= res.xxyz * bitMask;");src.push("  return res;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i224=0;_i224<sectionPlanesState.getNumAllocatedSectionPlanes();_i224++){src.push("if (sectionPlaneActive"+_i224+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i224+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i224+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");src.push("    outColor = packDepth(zNormalizedDepth); ");// Must be linear depth
src.push("}");return src;}}]);return TrianglesPickDepthRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesPickNormalsRenderer=/*#__PURE__*/function(_TrianglesInstancingR7){_inherits(TrianglesPickNormalsRenderer,_TrianglesInstancingR7);var _super73=_createSuper(TrianglesPickNormalsRenderer);function TrianglesPickNormalsRenderer(){_classCallCheck(this,TrianglesPickNormalsRenderer);return _super73.apply(this,arguments);}_createClass(TrianglesPickNormalsRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry normals vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec2 normal;");src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("in vec4 modelNormalMatrixCol0;");src.push("in vec4 modelNormalMatrixCol1;");src.push("in vec4 modelNormalMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src,3);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec3 vWorldNormal;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); ");src.push("  vec3 worldNormal = vec3(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2));");src.push("  vWorldNormal = worldNormal;");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry normals fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i225=0;_i225<sectionPlanesState.getNumAllocatedSectionPlanes();_i225++){src.push("uniform bool sectionPlaneActive"+_i225+";");src.push("uniform vec3 sectionPlanePos"+_i225+";");src.push("uniform vec3 sectionPlaneDir"+_i225+";");}}src.push("in vec3 vWorldNormal;");src.push("out highp ivec4 outNormal;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outNormal = ivec4(vWorldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("}");return src;}}]);return TrianglesPickNormalsRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesOcclusionRenderer=/*#__PURE__*/function(_TrianglesInstancingR8){_inherits(TrianglesOcclusionRenderer,_TrianglesInstancingR8);var _super74=_createSuper(TrianglesOcclusionRenderer);function TrianglesOcclusionRenderer(){_classCallCheck(this,TrianglesOcclusionRenderer);return _super74.apply(this,arguments);}_createClass(TrianglesOcclusionRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// TrianglesInstancingOcclusionRenderer vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 color;");src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// TrianglesInstancingOcclusionRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i226=0;_i226<sectionPlanesState.getNumAllocatedSectionPlanes();_i226++){src.push("uniform bool sectionPlaneActive"+_i226+";");src.push("uniform vec3 sectionPlanePos"+_i226+";");src.push("uniform vec3 sectionPlaneDir"+_i226+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i227=0;_i227<sectionPlanesState.getNumAllocatedSectionPlanes();_i227++){src.push("if (sectionPlaneActive"+_i227+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i227+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i227+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}src.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); ");// Occluders are blue
src.push("}");return src;}}]);return TrianglesOcclusionRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesDepthRenderer=/*#__PURE__*/function(_TrianglesInstancingR9){_inherits(TrianglesDepthRenderer,_TrianglesInstancingR9);var _super75=_createSuper(TrianglesDepthRenderer);function TrianglesDepthRenderer(){_classCallCheck(this,TrianglesDepthRenderer);return _super75.apply(this,arguments);}_createClass(TrianglesDepthRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry depth drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec2 vHighPrecisionZW;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("vHighPrecisionZW = gl_Position.zw;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry depth drawing fragment shader");src.push("precision highp float;");src.push("precision highp int;");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec2 vHighPrecisionZW;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;");src.push("    outColor = vec4(vec3(1.0 - fragCoordZ), 1.0); ");src.push("}");return src;}}]);return TrianglesDepthRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesNormalsRenderer=/*#__PURE__*/function(_TrianglesInstancingR10){_inherits(TrianglesNormalsRenderer,_TrianglesInstancingR10);var _super76=_createSuper(TrianglesNormalsRenderer);function TrianglesNormalsRenderer(){_classCallCheck(this,TrianglesNormalsRenderer);return _super76.apply(this,arguments);}_createClass(TrianglesNormalsRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry normals drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec3 normal;");src.push("in vec4 color;");src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src,true);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec3 vViewNormal;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");src.push("  vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("  vViewNormal = viewNormal;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry depth drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i228=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i228<len;_i228++){src.push("uniform bool sectionPlaneActive"+_i228+";");src.push("uniform vec3 sectionPlanePos"+_i228+";");src.push("uniform vec3 sectionPlaneDir"+_i228+";");}}src.push("in vec3 vViewNormal;");src.push("vec3 packNormalToRGB( const in vec3 normal ) {");src.push("    return normalize( normal ) * 0.5 + 0.5;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i229=0,_len48=sectionPlanesState.getNumAllocatedSectionPlanes();_i229<_len48;_i229++){src.push("if (sectionPlaneActive"+_i229+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i229+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i229+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");src.push("}");return src;}}]);return TrianglesNormalsRenderer;}(TrianglesInstancingRenderer);/**
 * Renders InstancingLayer fragment depths to a shadow map.
 *
 * @private
 */var TrianglesShadowRenderer=/*#__PURE__*/function(_TrianglesInstancingR11){_inherits(TrianglesShadowRenderer,_TrianglesInstancingR11);var _super77=_createSuper(TrianglesShadowRenderer);function TrianglesShadowRenderer(){_classCallCheck(this,TrianglesShadowRenderer);return _super77.apply(this,arguments);}_createClass(TrianglesShadowRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry shadow drawing vertex shader");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 color;");src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform mat4 shadowViewMatrix;");src.push("uniform mat4 shadowProjMatrix;");this._addMatricesUniformBlockLines(src);if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");src.push("int colorFlag = int(flags) & 0xF;");src.push("bool visible = (colorFlag > 0);");src.push("bool transparent  = ((float(color.a) / 255.0) < 1.0);");src.push("if (!visible || transparent) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = shadowViewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("  gl_Position = shadowProjMatrix * viewPosition;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry depth drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i230=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i230<len;_i230++){src.push("uniform bool sectionPlaneActive"+_i230+";");src.push("uniform vec3 sectionPlanePos"+_i230+";");src.push("uniform vec3 sectionPlaneDir"+_i230+";");}}src.push("in vec3 vViewNormal;");src.push("vec3 packNormalToRGB( const in vec3 normal ) {");src.push("    return normalize( normal ) * 0.5 + 0.5;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i231=0,_len49=sectionPlanesState.getNumAllocatedSectionPlanes();_i231<_len49;_i231++){src.push("if (sectionPlaneActive"+_i231+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i231+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i231+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");src.push("}");return src;}}]);return TrianglesShadowRenderer;}(TrianglesInstancingRenderer);var TEXTURE_DECODE_FUNCS={};TEXTURE_DECODE_FUNCS[LinearEncoding]="linearToLinear";TEXTURE_DECODE_FUNCS[sRGBEncoding]="sRGBToLinear";/**
 * @private
 */var TrianglesPBRRenderer=/*#__PURE__*/function(_TrianglesInstancingR12){_inherits(TrianglesPBRRenderer,_TrianglesInstancingR12);var _super78=_createSuper(TrianglesPBRRenderer);function TrianglesPBRRenderer(){_classCallCheck(this,TrianglesPBRRenderer);return _super78.apply(this,arguments);}_createClass(TrianglesPBRRenderer,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene.gammaOutput,scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(TrianglesPBRRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var clippingCaps=sectionPlanesState.clippingCaps;var src=[];src.push("#version 300 es");src.push("// Instancing geometry quality drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec3 normal;");src.push("in vec4 color;");src.push("in vec2 uv;");src.push("in vec2 metallicRoughness;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("in vec4 modelNormalMatrixCol0;");src.push("in vec4 modelNormalMatrixCol1;");src.push("in vec4 modelNormalMatrixCol2;");this._addMatricesUniformBlockLines(src,true);src.push("uniform mat3 uvDecodeMatrix;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");src.push("out vec4 vViewPosition;");src.push("out vec3 vViewNormal;");src.push("out vec4 vColor;");src.push("out vec2 vUV;");src.push("out vec2 vMetallicRoughness;");if(lightsState.lightMaps.length>0){src.push("out vec3 vWorldNormal;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");if(clippingCaps){src.push("out vec4 vClipPosition;");}}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); ");src.push("vec4 worldNormal = worldNormalMatrix * vec4(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2), 1.0);");src.push("vec3 viewNormal = vec4(viewNormalMatrix * worldNormal).xyz;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");if(clippingCaps){src.push("vClipPosition = clipPos;");}}src.push("vViewPosition = viewPosition;");src.push("vViewNormal = viewNormal;");src.push("vColor = color;");src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");src.push("vMetallicRoughness = metallicRoughness;");if(lightsState.lightMaps.length>0){src.push("vWorldNormal = worldNormal.xyz;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var gammaOutput=scene.gammaOutput;// If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var clippingCaps=sectionPlanesState.clippingCaps;var src=[];src.push("#version 300 es");src.push("// Instancing geometry quality drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform sampler2D uColorMap;");src.push("uniform sampler2D uMetallicRoughMap;");src.push("uniform sampler2D uEmissiveMap;");src.push("uniform sampler2D uNormalMap;");if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}if(lightsState.reflectionMaps.length>0){src.push("uniform samplerCube reflectionMap;");}if(lightsState.lightMaps.length>0){src.push("uniform samplerCube lightMap;");}src.push("uniform vec4 lightAmbient;");for(var _i232=0,len=lightsState.lights.length;_i232<len;_i232++){var light=lightsState.lights[_i232];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i232+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i232+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i232+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i232+";");src.push("uniform vec3 lightDir"+_i232+";");}}src.push("uniform float gammaFactor;");src.push("vec4 linearToLinear( in vec4 value ) {");src.push("  return value;");src.push("}");src.push("vec4 sRGBToLinear( in vec4 value ) {");src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");src.push("}");src.push("vec4 gammaToLinear( in vec4 value) {");src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");src.push("}");if(gammaOutput){src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");if(clippingCaps){src.push("in vec4 vClipPosition;");}for(var _i233=0,_len50=sectionPlanesState.getNumAllocatedSectionPlanes();_i233<_len50;_i233++){src.push("uniform bool sectionPlaneActive"+_i233+";");src.push("uniform vec3 sectionPlanePos"+_i233+";");src.push("uniform vec3 sectionPlaneDir"+_i233+";");}}src.push("in vec4 vViewPosition;");src.push("in vec3 vViewNormal;");src.push("in vec4 vColor;");src.push("in vec2 vUV;");src.push("in vec2 vMetallicRoughness;");if(lightsState.lightMaps.length>0){src.push("in vec3 vWorldNormal;");}this._addMatricesUniformBlockLines(src,true);// CONSTANT DEFINITIONS
src.push("#define PI 3.14159265359");src.push("#define RECIPROCAL_PI 0.31830988618");src.push("#define RECIPROCAL_PI2 0.15915494");src.push("#define EPSILON 1e-6");src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");// UTILITY DEFINITIONS
src.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");src.push("       vec3 texel = texture( uNormalMap, uv ).xyz;");src.push("       if (texel.r == 0.0 && texel.g == 0.0 && texel.b == 0.0) {");src.push("              return normalize(surf_norm );");src.push("       }");src.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");src.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");src.push("      vec2 st0 = dFdx( uv.st );");src.push("      vec2 st1 = dFdy( uv.st );");src.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");src.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");src.push("      vec3 N = normalize( surf_norm );");src.push("      vec3 mapN = texel.xyz * 2.0 - 1.0;");src.push("      mat3 tsn = mat3( S, T, N );");//     src.push("      mapN *= 3.0;");
src.push("      return normalize( tsn * mapN );");src.push("}");src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");src.push("}");// STRUCTURES
src.push("struct IncidentLight {");src.push("   vec3 color;");src.push("   vec3 direction;");src.push("};");src.push("struct ReflectedLight {");src.push("   vec3 diffuse;");src.push("   vec3 specular;");src.push("};");src.push("struct Geometry {");src.push("   vec3 position;");src.push("   vec3 viewNormal;");src.push("   vec3 worldNormal;");src.push("   vec3 viewEyeDir;");src.push("};");src.push("struct Material {");src.push("   vec3    diffuseColor;");src.push("   float   specularRoughness;");src.push("   vec3    specularColor;");src.push("   float   shine;");// Only used for Phong
src.push("};");// IRRADIANCE EVALUATION
src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");src.push("   float r = ggxRoughness + 0.0001;");src.push("   return (2.0 / (r * r) - 2.0);");src.push("}");src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");src.push("}");if(lightsState.reflectionMaps.length>0){src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);");//TODO: a random factor - fix this
src.push("   vec3 envMapColor = "+TEXTURE_DECODE_FUNCS[lightsState.reflectionMaps[0].encoding]+"(texture(reflectionMap, reflectVec, mipLevel)).rgb;");src.push("  return envMapColor;");src.push("}");}// SPECULAR BRDF EVALUATION
src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");src.push("}");src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   return 1.0 / ( gl * gv );");src.push("}");src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   return 0.5 / max( gv + gl, EPSILON );");src.push("}");src.push("float D_GGX(const in float alpha, const in float dotNH) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");src.push("}");src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float alpha = ( roughness * roughness );");src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");src.push("   vec3  F = F_Schlick( specularColor, dotLH );");src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");src.push("   float D = D_GGX( alpha, dotNH );");src.push("   return F * (G * D);");src.push("}");src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");src.push("   vec4 r = roughness * c0 + c1;");src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");src.push("   return specularColor * AB.x + AB.y;");src.push("}");if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");if(lightsState.lightMaps.length>0){src.push("   vec3 irradiance = "+TEXTURE_DECODE_FUNCS[lightsState.lightMaps[0].encoding]+"(texture(lightMap, geometry.worldNormal)).rgb;");src.push("   irradiance *= PI;");src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");}if(lightsState.reflectionMaps.length>0){src.push("   vec3 reflectVec             = reflect(geometry.viewEyeDir, geometry.viewNormal);");src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");}src.push("}");}// MAIN LIGHTING COMPUTATION FUNCTION
src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i234=0,_len51=sectionPlanesState.getNumAllocatedSectionPlanes();_i234<_len51;_i234++){src.push("if (sectionPlaneActive"+_i234+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i234+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i234+".xyz), 0.0, 1000.0);");src.push("}");}if(clippingCaps){src.push("  if (dist > (0.002 * vClipPosition.w)) {");src.push("      discard;");src.push("  }");src.push("  if (dist > 0.0) { ");src.push("      outColor=vec4(1.0, 0.0, 0.0, 1.0);");if(scene.logarithmicDepthBufferEnabled){src.push("  gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("  return;");src.push("}");}else{src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");}src.push("}");}src.push("IncidentLight  light;");src.push("Material       material;");src.push("Geometry       geometry;");src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");src.push("vec3 rgb = (vec3(float(vColor.r) / 255.0, float(vColor.g) / 255.0, float(vColor.b) / 255.0));");src.push("float opacity = float(vColor.a) / 255.0;");src.push("vec3  baseColor = rgb;");src.push("float specularF0 = 1.0;");src.push("float metallic = float(vMetallicRoughness.r) / 255.0;");src.push("float roughness = float(vMetallicRoughness.g) / 255.0;");src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");src.push("vec4 colorTexel = sRGBToLinear(texture(uColorMap, vUV));");src.push("baseColor *= colorTexel.rgb;");// src.push("opacity = colorTexel.a;");
src.push("vec3 metalRoughTexel = texture(uMetallicRoughMap, vUV).rgb;");src.push("metallic *= metalRoughTexel.b;");src.push("roughness *= metalRoughTexel.g;");src.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition.xyz, normalize(vViewNormal), vUV );");src.push("material.diffuseColor      = baseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");src.push("material.specularColor     = mix(vec3(dielectricSpecular), baseColor, metallic);");src.push("geometry.position      = vViewPosition.xyz;");src.push("geometry.viewNormal    = -normalize(viewNormal);");src.push("geometry.viewEyeDir    = normalize(vViewPosition.xyz);");if(lightsState.lightMaps.length>0){src.push("geometry.worldNormal   = normalize(vWorldNormal);");}if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("computePBRLightMapping(geometry, material, reflectedLight);");}for(var _i235=0,_len52=lightsState.lights.length;_i235<_len52;_i235++){var _light8=lightsState.lights[_i235];if(_light8.type==="ambient"){continue;}if(_light8.type==="dir"){if(_light8.space==="view"){src.push("light.direction = normalize(lightDir"+_i235+");");}else{src.push("light.direction = normalize((viewMatrix * vec4(lightDir"+_i235+", 0.0)).xyz);");}}else if(_light8.type==="point"){if(_light8.space==="view"){src.push("light.direction = normalize(lightPos"+_i235+" - vViewPosition.xyz);");}else{src.push("light.direction = normalize((viewMatrix * vec4(lightPos"+_i235+", 0.0)).xyz);");}}else if(_light8.type==="spot"){if(_light8.space==="view"){src.push("light.direction = normalize(lightDir"+_i235+");");}else{src.push("light.direction = normalize((viewMatrix * vec4(lightDir"+_i235+", 0.0)).xyz);");}}else{continue;}src.push("light.color =  lightColor"+_i235+".rgb * lightColor"+_i235+".a;");// a is intensity
src.push("computePBRLighting(light, geometry, material, reflectedLight);");}src.push("vec3 emissiveColor = sRGBToLinear(texture(uEmissiveMap, vUV)).rgb;");// TODO: correct gamma function
src.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * baseColor * opacity * rgb) + (reflectedLight.diffuse) + (reflectedLight.specular) + emissiveColor;");src.push("vec4 fragColor;");if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   fragColor            = vec4(outgoingLight.rgb * ambient, opacity);");}else{src.push("   fragColor            = vec4(outgoingLight.rgb, opacity);");}if(gammaOutput){src.push("fragColor = linearToGamma(fragColor, gammaFactor);");}src.push("outColor = fragColor;");if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return TrianglesPBRRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesPickNormalsFlatRenderer=/*#__PURE__*/function(_TrianglesInstancingR13){_inherits(TrianglesPickNormalsFlatRenderer,_TrianglesInstancingR13);var _super79=_createSuper(TrianglesPickNormalsFlatRenderer);function TrianglesPickNormalsFlatRenderer(){_classCallCheck(this,TrianglesPickNormalsFlatRenderer);return _super79.apply(this,arguments);}_createClass(TrianglesPickNormalsFlatRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry normals vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src,3);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out float vFlags;");}src.push("out vec4 vWorldPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vWorldPosition = worldPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vFlags = flags;");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry normals fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("in vec4 vWorldPosition;");if(clipping){src.push("in float vFlags;");for(var _i236=0;_i236<sectionPlanesState.getNumAllocatedSectionPlanes();_i236++){src.push("uniform bool sectionPlaneActive"+_i236+";");src.push("uniform vec3 sectionPlanePos"+_i236+";");src.push("uniform vec3 sectionPlaneDir"+_i236+";");}}src.push("out highp ivec4 outNormal;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("  outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("}");return src;}}]);return TrianglesPickNormalsFlatRenderer;}(TrianglesInstancingRenderer);/**
 * @private
 */var TrianglesColorTextureRenderer=/*#__PURE__*/function(_TrianglesInstancingR14){_inherits(TrianglesColorTextureRenderer,_TrianglesInstancingR14);var _super80=_createSuper(TrianglesColorTextureRenderer);function TrianglesColorTextureRenderer(){_classCallCheck(this,TrianglesColorTextureRenderer);return _super80.apply(this,arguments);}_createClass(TrianglesColorTextureRenderer,[{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene.gammaOutput,scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(TrianglesColorTextureRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry drawing vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in vec2 uv;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);src.push("uniform mat3 uvDecodeMatrix;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("out vec4 vColor;");src.push("out vec2 vUV;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vViewPosition = viewPosition;");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var gammaOutput=scene.gammaOutput;// If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Instancing geometry drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform sampler2D uColorMap;");if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}src.push("uniform float gammaFactor;");src.push("vec4 linearToLinear( in vec4 value ) {");src.push("  return value;");src.push("}");src.push("vec4 sRGBToLinear( in vec4 value ) {");src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");src.push("}");src.push("vec4 gammaToLinear( in vec4 value) {");src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");src.push("}");if(gammaOutput){src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i237=0,_len53=sectionPlanesState.getNumAllocatedSectionPlanes();_i237<_len53;_i237++){src.push("uniform bool sectionPlaneActive"+_i237+";");src.push("uniform vec3 sectionPlanePos"+_i237+";");src.push("uniform vec3 sectionPlaneDir"+_i237+";");}}this._addMatricesUniformBlockLines(src);src.push("uniform vec4 lightAmbient;");for(i=0,len=lightsState.lights.length;i<len;i++){var light=lightsState.lights[i];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+i+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+i+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+i+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+i+";");src.push("uniform vec3 lightDir"+i+";");}}src.push("in vec4 vViewPosition;");src.push("in vec4 vColor;");src.push("in vec2 vUV;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i238=0,_len54=sectionPlanesState.getNumAllocatedSectionPlanes();_i238<_len54;_i238++){src.push("if (sectionPlaneActive"+_i238+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i238+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i238+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");for(i=0,len=lightsState.lights.length;i<len;i++){var _light9=lightsState.lights[i];if(_light9.type==="ambient"){continue;}if(_light9.type==="dir"){if(_light9.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+i+", 0.0)).xyz);");}}else if(_light9.type==="point"){if(_light9.space==="view"){src.push("viewLightDir = -normalize(lightPos"+i+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+i+", 0.0)).xyz);");}}else if(_light9.type==="spot"){if(_light9.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+i+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+i+".rgb * lightColor"+i+".a);");}src.push("vec4 color =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");if(gammaOutput){src.push("vec4 colorTexel = color * sRGBToLinear(texture(uColorMap, vUV));");}else{src.push("vec4 colorTexel = color * texture(uColorMap, vUV);");}src.push("float opacity = color.a;");if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor                = vec4(vColor.rgb * colorTexel.rgb * ambient, opacity);");}else{src.push("   outColor                = vec4(vColor.rgb * colorTexel.rgb, opacity);");}if(gammaOutput){src.push("outColor = linearToGamma(outColor, gammaFactor);");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return TrianglesColorTextureRenderer;}(TrianglesInstancingRenderer);var tempVec3a$y=math.vec3();var tempVec3b$u=math.vec3();var tempVec3c$p=math.vec3();var tempVec3d$9=math.vec3();var tempMat4a$o=math.mat4();/**
 * @private
 */var TrianglesSnapInitRenderer=/*#__PURE__*/function(_VBORenderer5){_inherits(TrianglesSnapInitRenderer,_VBORenderer5);var _super81=_createSuper(TrianglesSnapInitRenderer);function TrianglesSnapInitRenderer(scene){_classCallCheck(this,TrianglesSnapInitRenderer);return _super81.call(this,scene,false,{instancing:true});}_createClass(TrianglesSnapInitRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=instancingLayer.model;var scene=model.scene;var gl=scene.canvas.gl;var camera=scene.camera;var state=instancingLayer._state;var origin=instancingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=instancingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(instancingLayer)){gl.bindVertexArray(this._vaoCache.get(instancingLayer));}else{this._vaoCache.set(instancingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$y;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$u;if(origin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$p);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$o);rtcCameraEye=tempVec3d$9;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(instancingLayer);this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);if(this._aFlags){this._aFlags.bindArrayBuffer(state.flagsBuf);gl.vertexAttribDivisor(this._aFlags.location,1);}state.indicesBuf.bind();gl.drawElementsInstanced(gl.TRIANGLES,state.indicesBuf.numItems,state.indicesBuf.itemType,0,state.numInstances);state.indicesBuf.unbind();// Cleanup
gl.vertexAttribDivisor(this._aModelMatrixCol0.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,0);if(this._aFlags){gl.vertexAttribDivisor(this._aFlags.location,0);}if(this._aOffset){gl.vertexAttribDivisor(this._aOffset.location,0);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(TrianglesSnapInitRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthBufInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec4 pickColor;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vWorldPosition = worldPosition;");if(clipping){src.push("  vFlags = flags;");}src.push("vPickColor = pickColor;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("in float vFlags;");for(var _i239=0;_i239<sectionPlanesState.getNumAllocatedSectionPlanes();_i239++){src.push("uniform bool sectionPlaneActive"+_i239+";");src.push("uniform vec3 sectionPlanePos"+_i239+";");src.push("uniform vec3 sectionPlaneDir"+_i239+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");src.push("layout(location = 1) out highp ivec4 outNormal;");src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i240=0;_i240<sectionPlanesState.getNumAllocatedSectionPlanes();_i240++){src.push("if (sectionPlaneActive"+_i240+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i240+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i240+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, -layerNumber);");src.push("vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return TrianglesSnapInitRenderer;}(VBORenderer);var tempVec3a$x=math.vec3();var tempVec3b$t=math.vec3();var tempVec3c$o=math.vec3();var tempVec3d$8=math.vec3();var tempMat4a$n=math.mat4();/**
 * @private
 */var TrianglesSnapRenderer=/*#__PURE__*/function(_VBORenderer6){_inherits(TrianglesSnapRenderer,_VBORenderer6);var _super82=_createSuper(TrianglesSnapRenderer);function TrianglesSnapRenderer(scene){_classCallCheck(this,TrianglesSnapRenderer);return _super82.call(this,scene,false,{instancing:true});}_createClass(TrianglesSnapRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){if(!this._program){this._allocate(instancingLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=instancingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=instancingLayer._state;var origin=instancingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=instancingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(instancingLayer)){gl.bindVertexArray(this._vaoCache.get(instancingLayer));}else{this._vaoCache.set(instancingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$x;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$t;if(origin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$o);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$n);rtcCameraEye=tempVec3d$8;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(instancingLayer);this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);this._aFlags.bindArrayBuffer(state.flagsBuf);gl.vertexAttribDivisor(this._aFlags.location,1);if(frameCtx.snapMode==="edge"){state.edgeIndicesBuf.bind();gl.drawElementsInstanced(gl.LINES,state.edgeIndicesBuf.numItems,state.edgeIndicesBuf.itemType,0,state.numInstances);state.edgeIndicesBuf.unbind();// needed?
}else{gl.drawArraysInstanced(gl.POINTS,0,state.positionsBuf.numItems,state.numInstances);}// Cleanup
gl.vertexAttribDivisor(this._aModelMatrixCol0.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,0);gl.vertexAttribDivisor(this._aFlags.location,0);if(this._aOffset){gl.vertexAttribDivisor(this._aOffset.location,0);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(TrianglesSnapRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i241=0;_i241<sectionPlanesState.getNumAllocatedSectionPlanes();_i241++){src.push("uniform bool sectionPlaneActive"+_i241+";");src.push("uniform vec3 sectionPlanePos"+_i241+";");src.push("uniform vec3 sectionPlaneDir"+_i241+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i242=0;_i242<sectionPlanesState.getNumAllocatedSectionPlanes();_i242++){src.push("if (sectionPlaneActive"+_i242+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i242+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i242+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, layerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return TrianglesSnapRenderer;}(VBORenderer);/**
 * @private
 */var Renderers=/*#__PURE__*/function(){function Renderers(scene){_classCallCheck(this,Renderers);this._scene=scene;}_createClass(Renderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._colorRendererWithSAO&&!this._colorRendererWithSAO.getValid()){this._colorRendererWithSAO.destroy();this._colorRendererWithSAO=null;}if(this._flatColorRenderer&&!this._flatColorRenderer.getValid()){this._flatColorRenderer.destroy();this._flatColorRenderer=null;}if(this._flatColorRendererWithSAO&&!this._flatColorRendererWithSAO.getValid()){this._flatColorRendererWithSAO.destroy();this._flatColorRendererWithSAO=null;}if(this._pbrRenderer&&!this._pbrRenderer.getValid()){this._pbrRenderer.destroy();this._pbrRenderer=null;}if(this._pbrRendererWithSAO&&!this._pbrRendererWithSAO.getValid()){this._pbrRendererWithSAO.destroy();this._pbrRendererWithSAO=null;}if(this._colorTextureRenderer&&!this._colorTextureRenderer.getValid()){this._colorTextureRenderer.destroy();this._colorTextureRenderer=null;}if(this._colorTextureRendererWithSAO&&!this._colorTextureRendererWithSAO.getValid()){this._colorTextureRendererWithSAO.destroy();this._colorTextureRendererWithSAO=null;}if(this._depthRenderer&&!this._depthRenderer.getValid()){this._depthRenderer.destroy();this._depthRenderer=null;}if(this._normalsRenderer&&!this._normalsRenderer.getValid()){this._normalsRenderer.destroy();this._normalsRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._edgesRenderer&&!this._edgesRenderer.getValid()){this._edgesRenderer.destroy();this._edgesRenderer=null;}if(this._edgesColorRenderer&&!this._edgesColorRenderer.getValid()){this._edgesColorRenderer.destroy();this._edgesColorRenderer=null;}if(this._pickMeshRenderer&&!this._pickMeshRenderer.getValid()){this._pickMeshRenderer.destroy();this._pickMeshRenderer=null;}if(this._pickDepthRenderer&&!this._pickDepthRenderer.getValid()){this._pickDepthRenderer.destroy();this._pickDepthRenderer=null;}if(this._pickNormalsRenderer&&this._pickNormalsRenderer.getValid()===false){this._pickNormalsRenderer.destroy();this._pickNormalsRenderer=null;}if(this._pickNormalsFlatRenderer&&!this._pickNormalsFlatRenderer.getValid()){this._pickNormalsFlatRenderer.destroy();this._pickNormalsFlatRenderer=null;}if(this._occlusionRenderer&&this._occlusionRenderer.getValid()===false){this._occlusionRenderer.destroy();this._occlusionRenderer=null;}if(this._shadowRenderer&&!this._shadowRenderer.getValid()){this._shadowRenderer.destroy();this._shadowRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}}},{key:"eagerCreateRenders",value:function eagerCreateRenders(){// Pre-initialize certain renderers that would otherwise be lazy-initialised
// on user interaction, such as picking or emphasis, so that there is no delay
// when user first begins interacting with the viewer.
if(!this._silhouetteRenderer){// Used for highlighting and selection
this._silhouetteRenderer=new TrianglesSilhouetteRenderer(this._scene);}if(!this._pickMeshRenderer){this._pickMeshRenderer=new TrianglesPickMeshRenderer(this._scene);}if(!this._pickDepthRenderer){this._pickDepthRenderer=new TrianglesPickDepthRenderer(this._scene);}if(!this._snapInitRenderer){this._snapInitRenderer=new TrianglesSnapInitRenderer(this._scene,false);}if(!this._snapRenderer){this._snapRenderer=new TrianglesSnapRenderer(this._scene);}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new TrianglesColorRenderer(this._scene,false);}return this._colorRenderer;}},{key:"colorRendererWithSAO",get:function get(){if(!this._colorRendererWithSAO){this._colorRendererWithSAO=new TrianglesColorRenderer(this._scene,true);}return this._colorRendererWithSAO;}},{key:"flatColorRenderer",get:function get(){if(!this._flatColorRenderer){this._flatColorRenderer=new TrianglesFlatColorRenderer(this._scene,false);}return this._flatColorRenderer;}},{key:"flatColorRendererWithSAO",get:function get(){if(!this._flatColorRendererWithSAO){this._flatColorRendererWithSAO=new TrianglesFlatColorRenderer(this._scene,true);}return this._flatColorRendererWithSAO;}},{key:"pbrRenderer",get:function get(){if(!this._pbrRenderer){this._pbrRenderer=new TrianglesPBRRenderer(this._scene,false);}return this._pbrRenderer;}},{key:"pbrRendererWithSAO",get:function get(){if(!this._pbrRendererWithSAO){this._pbrRendererWithSAO=new TrianglesPBRRenderer(this._scene,true);}return this._pbrRendererWithSAO;}},{key:"colorTextureRenderer",get:function get(){if(!this._colorTextureRenderer){this._colorTextureRenderer=new TrianglesColorTextureRenderer(this._scene,false);}return this._colorTextureRenderer;}},{key:"colorTextureRendererWithSAO",get:function get(){if(!this._colorTextureRendererWithSAO){this._colorTextureRendererWithSAO=new TrianglesColorTextureRenderer(this._scene,true);}return this._colorTextureRendererWithSAO;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new TrianglesSilhouetteRenderer(this._scene);}return this._silhouetteRenderer;}},{key:"depthRenderer",get:function get(){if(!this._depthRenderer){this._depthRenderer=new TrianglesDepthRenderer(this._scene);}return this._depthRenderer;}},{key:"normalsRenderer",get:function get(){if(!this._normalsRenderer){this._normalsRenderer=new TrianglesNormalsRenderer(this._scene);}return this._normalsRenderer;}},{key:"edgesRenderer",get:function get(){if(!this._edgesRenderer){this._edgesRenderer=new EdgesEmphasisRenderer(this._scene);}return this._edgesRenderer;}},{key:"edgesColorRenderer",get:function get(){if(!this._edgesColorRenderer){this._edgesColorRenderer=new EdgesColorRenderer(this._scene);}return this._edgesColorRenderer;}},{key:"pickMeshRenderer",get:function get(){if(!this._pickMeshRenderer){this._pickMeshRenderer=new TrianglesPickMeshRenderer(this._scene);}return this._pickMeshRenderer;}},{key:"pickNormalsRenderer",get:function get(){if(!this._pickNormalsRenderer){this._pickNormalsRenderer=new TrianglesPickNormalsRenderer(this._scene);}return this._pickNormalsRenderer;}},{key:"pickNormalsFlatRenderer",get:function get(){if(!this._pickNormalsFlatRenderer){this._pickNormalsFlatRenderer=new TrianglesPickNormalsFlatRenderer(this._scene);}return this._pickNormalsFlatRenderer;}},{key:"pickDepthRenderer",get:function get(){if(!this._pickDepthRenderer){this._pickDepthRenderer=new TrianglesPickDepthRenderer(this._scene);}return this._pickDepthRenderer;}},{key:"occlusionRenderer",get:function get(){if(!this._occlusionRenderer){this._occlusionRenderer=new TrianglesOcclusionRenderer(this._scene);}return this._occlusionRenderer;}},{key:"shadowRenderer",get:function get(){if(!this._shadowRenderer){this._shadowRenderer=new TrianglesShadowRenderer(this._scene);}return this._shadowRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new TrianglesSnapInitRenderer(this._scene,false);}return this._snapInitRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new TrianglesSnapRenderer(this._scene);}return this._snapRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._colorRendererWithSAO){this._colorRendererWithSAO.destroy();}if(this._flatColorRenderer){this._flatColorRenderer.destroy();}if(this._flatColorRendererWithSAO){this._flatColorRendererWithSAO.destroy();}if(this._pbrRenderer){this._pbrRenderer.destroy();}if(this._pbrRendererWithSAO){this._pbrRendererWithSAO.destroy();}if(this._colorTextureRenderer){this._colorTextureRenderer.destroy();}if(this._colorTextureRendererWithSAO){this._colorTextureRendererWithSAO.destroy();}if(this._depthRenderer){this._depthRenderer.destroy();}if(this._normalsRenderer){this._normalsRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._edgesRenderer){this._edgesRenderer.destroy();}if(this._edgesColorRenderer){this._edgesColorRenderer.destroy();}if(this._pickMeshRenderer){this._pickMeshRenderer.destroy();}if(this._pickDepthRenderer){this._pickDepthRenderer.destroy();}if(this._pickNormalsRenderer){this._pickNormalsRenderer.destroy();}if(this._pickNormalsFlatRenderer){this._pickNormalsFlatRenderer.destroy();}if(this._occlusionRenderer){this._occlusionRenderer.destroy();}if(this._shadowRenderer){this._shadowRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}}}]);return Renderers;}();var cachedRenderers$5={};/**
 * @private
 */function getRenderers$6(scene){var sceneId=scene.id;var instancingRenderers=cachedRenderers$5[sceneId];if(!instancingRenderers){instancingRenderers=new Renderers(scene);cachedRenderers$5[sceneId]=instancingRenderers;instancingRenderers._compile();instancingRenderers.eagerCreateRenders();scene.on("compile",function(){instancingRenderers._compile();instancingRenderers.eagerCreateRenders();});scene.on("destroyed",function(){delete cachedRenderers$5[sceneId];instancingRenderers._destroy();});}return instancingRenderers;}var tempUint8Vec4$2=new Uint8Array(4);var tempFloat32$2=new Float32Array(1);var tempVec4a$6=math.vec4([0,0,0,1]);var tempVec3fa$2=new Float32Array(3);var tempVec3a$w=math.vec3();var tempVec3b$s=math.vec3();var tempVec3c$n=math.vec3();var tempVec3d$7=math.vec3();var tempVec3e=math.vec3();var tempVec3f=math.vec3();var tempVec3g=math.vec3();var tempFloat32Vec4$2=new Float32Array(4);/**
 * @private
 */var VBOInstancingTrianglesLayer=/*#__PURE__*/function(){/**
     * @param cfg
     * @param cfg.layerIndex
     * @param cfg.model
     * @param cfg.geometry
     * @param cfg.textureSet
     * @param cfg.origin
     */function VBOInstancingTrianglesLayer(cfg){_classCallCheck(this,VBOInstancingTrianglesLayer);console.info("Creating VBOInstancingTrianglesLayer");/**
         * Owner model
         * @type {VBOSceneModel}
         */this.model=cfg.model;/**
         * State sorting key.
         * @type {string}
         */this.sortId="TrianglesInstancingLayer"+(cfg.solid?"-solid":"-surface")+(cfg.normals?"-normals":"-autoNormals");/**
         * Index of this InstancingLayer in VBOSceneModel#_layerList
         * @type {Number}
         */this.layerIndex=cfg.layerIndex;this._renderers=getRenderers$6(cfg.model.scene);this._aabb=math.collapseAABB3();this._state=new RenderState({numInstances:0,obb:math.OBB3(),origin:math.vec3(),geometry:cfg.geometry,textureSet:cfg.textureSet,pbrSupported:false,// Set in #finalize if we have enough to support quality rendering
positionsDecodeMatrix:cfg.geometry.positionsDecodeMatrix,// So we can null the geometry for GC
colorsBuf:null,metallicRoughnessBuf:null,flagsBuf:null,offsetsBuf:null,modelMatrixBuf:null,modelMatrixCol0Buf:null,modelMatrixCol1Buf:null,modelMatrixCol2Buf:null,modelNormalMatrixCol0Buf:null,modelNormalMatrixCol1Buf:null,modelNormalMatrixCol2Buf:null,pickColorsBuf:null});// These counts are used to avoid unnecessary render passes
this._numPortions=0;this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numSelectedLayerPortions=0;this._numClippableLayerPortions=0;this._numEdgesLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;/** @private */this.numIndices=cfg.geometry.numIndices;// Vertex arrays
this._colors=[];this._metallicRoughness=[];this._pickColors=[];this._offsets=[];// Modeling matrix per instance, array for each column
this._modelMatrix=[];this._modelMatrixCol0=[];this._modelMatrixCol1=[];this._modelMatrixCol2=[];// Modeling normal matrix per instance, array for each column
this._modelNormalMatrixCol0=[];this._modelNormalMatrixCol1=[];this._modelNormalMatrixCol2=[];this._portions=[];this._meshes=[];this._aabb=math.collapseAABB3();this.aabbDirty=true;if(cfg.origin){this._state.origin.set(cfg.origin);}this._finalized=false;/**
         * When true, this layer contains solid triangle meshes, otherwise this layer contains surface triangle meshes
         * @type {boolean}
         */this.solid=!!cfg.solid;/**
         * The number of indices in this layer.
         * @type {number|*}
         */this.numIndices=cfg.geometry.numIndices;}_createClass(VBOInstancingTrianglesLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i243=0,len=this._meshes.length;_i243<len;_i243++){math.expandAABB3(this._aabb,this._meshes[_i243].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Creates a new portion within this InstancingLayer, returns the new portion ID.
     *
     * The portion will instance this InstancingLayer's geometry.
     *
     * Gives the portion the specified color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param cfg Portion params
     * @param cfg.color Color [0..255,0..255,0..255]
     * @param cfg.metallic Metalness factor [0..255]
     * @param cfg.roughness Roughness factor [0..255]
     * @param cfg.opacity Opacity [0..255].
     * @param cfg.meshMatrix Flat float 4x4 matrix.
     * @param [cfg.worldMatrix] Flat float 4x4 matrix.
     * @param cfg.pickColor Quantized pick color
     * @returns {number} Portion ID.
     */},{key:"createPortion",value:function createPortion(mesh,cfg){var color=cfg.color;var metallic=cfg.metallic;var roughness=cfg.roughness;var opacity=cfg.opacity!==null&&cfg.opacity!==undefined?cfg.opacity:255;var meshMatrix=cfg.meshMatrix;var pickColor=cfg.pickColor;if(this._finalized){throw"Already finalized";}var r=color[0];// Color is pre-quantized by SceneModel
var g=color[1];var b=color[2];this._colors.push(r);this._colors.push(g);this._colors.push(b);this._colors.push(opacity);this._metallicRoughness.push(metallic!==null&&metallic!==undefined?metallic:0);this._metallicRoughness.push(roughness!==null&&roughness!==undefined?roughness:255);if(this.model.scene.entityOffsetsEnabled){this._offsets.push(0);this._offsets.push(0);this._offsets.push(0);}this._modelMatrixCol0.push(meshMatrix[0]);this._modelMatrixCol0.push(meshMatrix[4]);this._modelMatrixCol0.push(meshMatrix[8]);this._modelMatrixCol0.push(meshMatrix[12]);this._modelMatrixCol1.push(meshMatrix[1]);this._modelMatrixCol1.push(meshMatrix[5]);this._modelMatrixCol1.push(meshMatrix[9]);this._modelMatrixCol1.push(meshMatrix[13]);this._modelMatrixCol2.push(meshMatrix[2]);this._modelMatrixCol2.push(meshMatrix[6]);this._modelMatrixCol2.push(meshMatrix[10]);this._modelMatrixCol2.push(meshMatrix[14]);if(this._state.geometry.normals){// Note: order of inverse and transpose doesn't matter
var transposedMat=math.transposeMat4(meshMatrix,math.mat4());// TODO: Use cached matrix
var normalMatrix=math.inverseMat4(transposedMat);this._modelNormalMatrixCol0.push(normalMatrix[0]);this._modelNormalMatrixCol0.push(normalMatrix[4]);this._modelNormalMatrixCol0.push(normalMatrix[8]);this._modelNormalMatrixCol0.push(normalMatrix[12]);this._modelNormalMatrixCol1.push(normalMatrix[1]);this._modelNormalMatrixCol1.push(normalMatrix[5]);this._modelNormalMatrixCol1.push(normalMatrix[9]);this._modelNormalMatrixCol1.push(normalMatrix[13]);this._modelNormalMatrixCol2.push(normalMatrix[2]);this._modelNormalMatrixCol2.push(normalMatrix[6]);this._modelNormalMatrixCol2.push(normalMatrix[10]);this._modelNormalMatrixCol2.push(normalMatrix[14]);}// Per-vertex pick colors
this._pickColors.push(pickColor[0]);this._pickColors.push(pickColor[1]);this._pickColors.push(pickColor[2]);this._pickColors.push(pickColor[3]);this._state.numInstances++;var portionId=this._portions.length;var portion={};if(this.model.scene.pickSurfacePrecisionEnabled){portion.matrix=meshMatrix.slice();portion.inverseMatrix=null;// Lazy-computed in precisionRayPickSurface
portion.normalMatrix=null;// Lazy-computed in precisionRayPickSurface
}this._portions.push(portion);this._numPortions++;this.model.numPortions++;this._meshes.push(mesh);return portionId;}},{key:"finalize",value:function finalize(){if(this._finalized){return;}var state=this._state;var geometry=state.geometry;var textureSet=state.textureSet;var gl=this.model.scene.canvas.gl;var colorsLength=this._colors.length;var flagsLength=colorsLength/4;if(colorsLength>0){var notNormalized=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Uint8Array(this._colors),this._colors.length,4,gl.DYNAMIC_DRAW,notNormalized);this._colors=[];// Release memory
}if(this._metallicRoughness.length>0){var metallicRoughness=new Uint8Array(this._metallicRoughness);var normalized=false;state.metallicRoughnessBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,metallicRoughness,this._metallicRoughness.length,2,gl.STATIC_DRAW,normalized);}if(flagsLength>0){// Because we only build flags arrays here,
// get their length from the colors array
var _notNormalized3=false;state.flagsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(flagsLength),flagsLength,1,gl.DYNAMIC_DRAW,_notNormalized3);}if(this.model.scene.entityOffsetsEnabled){if(this._offsets.length>0){var _notNormalized4=false;state.offsetsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._offsets),this._offsets.length,3,gl.DYNAMIC_DRAW,_notNormalized4);this._offsets=[];// Release memory
}}if(geometry.positionsCompressed&&geometry.positionsCompressed.length>0){var _normalized4=false;state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,geometry.positionsCompressed,geometry.positionsCompressed.length,3,gl.STATIC_DRAW,_normalized4);state.positionsDecodeMatrix=math.mat4(geometry.positionsDecodeMatrix);}// if (geometry.normalsCompressed && geometry.normalsCompressed.length > 0) {
//     const normalized = true; // For oct-encoded UInt8
//     state.normalsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, geometry.normalsCompressed, geometry.normalsCompressed.length, 3, gl.STATIC_DRAW, normalized);
// }
if(geometry.colorsCompressed&&geometry.colorsCompressed.length>0){var colorsCompressed=new Uint8Array(geometry.colorsCompressed);var _notNormalized5=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colorsCompressed,colorsCompressed.length,4,gl.STATIC_DRAW,_notNormalized5);}if(geometry.uvCompressed&&geometry.uvCompressed.length>0){var uvCompressed=geometry.uvCompressed;state.uvDecodeMatrix=geometry.uvDecodeMatrix;state.uvBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,uvCompressed,uvCompressed.length,2,gl.STATIC_DRAW,false);}if(geometry.indices&&geometry.indices.length>0){state.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,new Uint32Array(geometry.indices),geometry.indices.length,1,gl.STATIC_DRAW);state.numIndices=geometry.indices.length;}if(geometry.primitive==="triangles"||geometry.primitive==="solid"||geometry.primitive==="surface"){state.edgeIndicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,new Uint32Array(geometry.edgeIndices),geometry.edgeIndices.length,1,gl.STATIC_DRAW);}if(this._modelMatrixCol0.length>0){var _normalized5=false;state.modelMatrixCol0Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol0),this._modelMatrixCol0.length,4,gl.STATIC_DRAW,_normalized5);state.modelMatrixCol1Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol1),this._modelMatrixCol1.length,4,gl.STATIC_DRAW,_normalized5);state.modelMatrixCol2Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol2),this._modelMatrixCol2.length,4,gl.STATIC_DRAW,_normalized5);this._modelMatrixCol0=[];this._modelMatrixCol1=[];this._modelMatrixCol2=[];if(state.normalsBuf){state.modelNormalMatrixCol0Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelNormalMatrixCol0),this._modelNormalMatrixCol0.length,4,gl.STATIC_DRAW,_normalized5);state.modelNormalMatrixCol1Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelNormalMatrixCol1),this._modelNormalMatrixCol1.length,4,gl.STATIC_DRAW,_normalized5);state.modelNormalMatrixCol2Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelNormalMatrixCol2),this._modelNormalMatrixCol2.length,4,gl.STATIC_DRAW,_normalized5);this._modelNormalMatrixCol0=[];this._modelNormalMatrixCol1=[];this._modelNormalMatrixCol2=[];}}if(this._pickColors.length>0){var _normalized6=false;state.pickColorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Uint8Array(this._pickColors),this._pickColors.length,4,gl.STATIC_DRAW,_normalized6);this._pickColors=[];// Release memory
}state.pbrSupported=!!state.metallicRoughnessBuf&&!!state.uvBuf&&!!state.normalsBuf&&!!textureSet&&!!textureSet.colorTexture&&!!textureSet.metallicRoughnessTexture;state.colorTextureSupported=!!state.uvBuf&&!!textureSet&&!!textureSet.colorTexture;this._state.geometry=null;this._finalized=true;}// The following setters are called by VBOSceneModelMesh, in turn called by VBOSceneModelNode, only after the layer is finalized.
// It's important that these are called after finalize() in order to maintain integrity of counts like _numVisibleLayerPortions etc.
},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setVisible",value:function setVisible(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setSelected",value:function setSelected(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setEdges",value:function setEdges(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}else{this._numEdgesLayerPortions--;this.model.numEdgesLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags(portionId,flags);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setCulled",value:function setCulled(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions--;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setColor",value:function setColor(portionId,color){// RGBA color is normalized as ints
if(!this._finalized){throw"Not finalized";}tempUint8Vec4$2[0]=color[0];tempUint8Vec4$2[1]=color[1];tempUint8Vec4$2[2]=color[2];tempUint8Vec4$2[3]=color[3];if(this._state.colorsBuf){this._state.colorsBuf.setData(tempUint8Vec4$2,portionId*4);}}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}// setMatrix(portionId, matrix) {
//
//     if (!this._finalized) {
//         throw "Not finalized";
//     }
//
//     var offset = portionId * 4;
//
//     tempFloat32Vec4[0] = matrix[0];
//     tempFloat32Vec4[1] = matrix[4];
//     tempFloat32Vec4[2] = matrix[8];
//     tempFloat32Vec4[3] = matrix[12];
//
//     this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4, offset);
//
//     tempFloat32Vec4[0] = matrix[1];
//     tempFloat32Vec4[1] = matrix[5];
//     tempFloat32Vec4[2] = matrix[9];
//     tempFloat32Vec4[3] = matrix[13];
//
//     this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4, offset);
//
//     tempFloat32Vec4[0] = matrix[2];
//     tempFloat32Vec4[1] = matrix[6];
//     tempFloat32Vec4[2] = matrix[10];
//     tempFloat32Vec4[3] = matrix[14];
//
//     this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4, offset);
// }
/**
     * flags are 4bits values encoded on a 32bit base. color flag on the first 4 bits, silhouette flag on the next 4 bits and so on for edge, pick and clippable.
     */},{key:"_setFlags",value:function _setFlags(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var edges=!!(flags&ENTITY_FLAGS.EDGES);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);var colorFlag;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){colorFlag=RENDER_PASSES.NOT_RENDERED;}else{if(meshTransparent){colorFlag=RENDER_PASSES.COLOR_TRANSPARENT;}else{colorFlag=RENDER_PASSES.COLOR_OPAQUE;}}var silhouetteFlag;if(!visible||culled){silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){silhouetteFlag=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){silhouetteFlag=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){silhouetteFlag=RENDER_PASSES.SILHOUETTE_XRAYED;}else{silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}var edgeFlag=0;if(!visible||culled){edgeFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){edgeFlag=RENDER_PASSES.EDGES_SELECTED;}else if(highlighted){edgeFlag=RENDER_PASSES.EDGES_HIGHLIGHTED;}else if(xrayed){edgeFlag=RENDER_PASSES.EDGES_XRAYED;}else if(edges){if(meshTransparent){edgeFlag=RENDER_PASSES.EDGES_COLOR_TRANSPARENT;}else{edgeFlag=RENDER_PASSES.EDGES_COLOR_OPAQUE;}}else{edgeFlag=RENDER_PASSES.NOT_RENDERED;}var pickFlag=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var clippableFlag=!!(flags&ENTITY_FLAGS.CLIPPABLE)?1:0;var vertFlag=0;vertFlag|=colorFlag;vertFlag|=silhouetteFlag<<4;vertFlag|=edgeFlag<<8;vertFlag|=pickFlag<<12;vertFlag|=clippableFlag<<16;tempFloat32$2[0]=vertFlag;if(this._state.flagsBuf){this._state.flagsBuf.setData(tempFloat32$2,portionId);}}},{key:"setOffset",value:function setOffset(portionId,offset){if(!this._finalized){throw"Not finalized";}if(!this.model.scene.entityOffsetsEnabled){this.model.error("Entity#offset not enabled for this Viewer");// See Viewer entityOffsetsEnabled
return;}tempVec3fa$2[0]=offset[0];tempVec3fa$2[1]=offset[1];tempVec3fa$2[2]=offset[2];if(this._state.offsetsBuf){this._state.offsetsBuf.setData(tempVec3fa$2,portionId*3);}}},{key:"getEachVertex",value:function getEachVertex(portionId,callback){if(!this.model.scene.pickSurfacePrecisionEnabled){return false;}var state=this._state;var geometry=state.geometry;var portion=this._portions[portionId];if(!portion){this.model.error("portion not found: "+portionId);return;}var positions=geometry.quantizedPositions;var origin=state.origin;var offset=portion.offset;var offsetX=origin[0]+offset[0];var offsetY=origin[1]+offset[1];var offsetZ=origin[2]+offset[2];var worldPos=tempVec4a$6;var portionMatrix=portion.matrix;var sceneModelPatrix=this.model.sceneModelMatrix;var positionsDecodeMatrix=state.positionsDecodeMatrix;for(var _i244=0,len=positions.length;_i244<len;_i244+=3){worldPos[0]=positions[_i244];worldPos[1]=positions[_i244+1];worldPos[2]=positions[_i244+2];math.decompressPosition(worldPos,positionsDecodeMatrix);math.transformPoint3(portionMatrix,worldPos);math.transformPoint3(sceneModelPatrix,worldPos);worldPos[0]+=offsetX;worldPos[1]+=offsetY;worldPos[2]+=offsetZ;callback(worldPos);}}},{key:"setMatrix",value:function setMatrix(portionId,matrix){if(!this._finalized){throw"Not finalized";}////////////////////////////////////////
// TODO: Update portion matrix
////////////////////////////////////////
var offset=portionId*4;tempFloat32Vec4$2[0]=matrix[0];tempFloat32Vec4$2[1]=matrix[4];tempFloat32Vec4$2[2]=matrix[8];tempFloat32Vec4$2[3]=matrix[12];this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4$2,offset);tempFloat32Vec4$2[0]=matrix[1];tempFloat32Vec4$2[1]=matrix[5];tempFloat32Vec4$2[2]=matrix[9];tempFloat32Vec4$2[3]=matrix[13];this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4$2,offset);tempFloat32Vec4$2[0]=matrix[2];tempFloat32Vec4$2[1]=matrix[6];tempFloat32Vec4$2[2]=matrix[10];tempFloat32Vec4$2[3]=matrix[14];this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4$2,offset);}// ---------------------- COLOR RENDERING -----------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(frameCtx.withSAO&&this.model.saoEnabled){if(frameCtx.pbrEnabled&&this.model.pbrEnabled&&this._state.pbrSupported){if(this._renderers.pbrRendererWithSAO){this._renderers.pbrRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(frameCtx.colorTextureEnabled&&this.model.colorTextureEnabled&&this._state.colorTextureSupported){if(this._renderers.colorTextureRendererWithSAO){this._renderers.colorTextureRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(this._state.normalsBuf){if(this._renderers.colorRendererWithSAO){this._renderers.colorRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else{if(this._renderers.flatColorRendererWithSAO){this._renderers.flatColorRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}}else if(frameCtx.pbrEnabled&&this.model.pbrEnabled&&this._state.pbrSupported){if(this._renderers.pbrRenderer){this._renderers.pbrRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(frameCtx.colorTextureEnabled&&this.model.colorTextureEnabled&&this._state.colorTextureSupported){if(this._renderers.colorTextureRenderer){this._renderers.colorTextureRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else if(this._state.normalsBuf){if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else{if(this._renderers.flatColorRenderer){this._renderers.flatColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}}},{key:"_updateBackfaceCull",value:function _updateBackfaceCull(renderFlags,frameCtx){var backfaces=this.model.backfaces||!this.solid||renderFlags.sectioned;if(frameCtx.backfaces!==backfaces){var _gl5=frameCtx.gl;if(backfaces){_gl5.disable(_gl5.CULL_FACE);}else{_gl5.enable(_gl5.CULL_FACE);}frameCtx.backfaces=backfaces;}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(frameCtx.pbrEnabled&&this.model.pbrEnabled&&this._state.pbrSupported){if(this._renderers.pbrRenderer){this._renderers.pbrRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}else if(frameCtx.colorTextureEnabled&&this.model.colorTextureEnabled&&this._state.colorTextureSupported){if(this._renderers.colorTextureRenderer){this._renderers.colorTextureRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}else if(this._state.normalsBuf){if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}else{if(this._renderers.flatColorRenderer){this._renderers.flatColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}}// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------
},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.depthRenderer){this._renderers.depthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);// Assume whatever post-effect uses depth (eg SAO) does not apply to transparent objects
}}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.normalsRenderer){this._renderers.normalsRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);// Assume whatever post-effect uses normals (eg SAO) does not apply to transparent objects
}}// ---------------------- SILHOUETTE RENDERING -----------------------------------
},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}// ---------------------- EDGES RENDERING -----------------------------------
},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numEdgesLayerPortions===0){return;}if(this._renderers.edgesColorRenderer){this._renderers.edgesColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_COLOR_OPAQUE);}}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numEdgesLayerPortions===0){return;}if(this._renderers.edgesColorRenderer){this._renderers.edgesColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_COLOR_TRANSPARENT);}}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_XRAYED);}}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_HIGHLIGHTED);}}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_SELECTED);}}// ---------------------- OCCLUSION CULL RENDERING -----------------------------------
},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.occlusionRenderer){// Only opaque, filled objects can be occluders
this._renderers.occlusionRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}// ---------------------- SHADOW BUFFER RENDERING -----------------------------------
},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.shadowRenderer){this._renderers.shadowRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}//---- PICKING ----------------------------------------------------------------------------------------------------
},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickMeshRenderer){this._renderers.pickMeshRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickDepthRenderer){this._renderers.pickDepthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO
// if (this._state.normalsBuf) {
//     if (this._renderers.pickNormalsRenderer) {
//         this._renderers.pickNormalsRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
//     }
////////////////////////////////////////////////////////////////////////////////////////////////////
// } else {
if(this._renderers.pickNormalsFlatRenderer){this._renderers.pickNormalsFlatRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}// }
}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}//-----------------------------------------------------------------------------------------
},{key:"precisionRayPickSurface",value:function precisionRayPickSurface(portionId,worldRayOrigin,worldRayDir,worldSurfacePos,worldNormal){if(!this.model.scene.pickSurfacePrecisionEnabled){return false;}var geometry=this._state.geometry;var state=this._state;var portion=this._portions[portionId];if(!portion){this.model.error("portion not found: "+portionId);return false;}if(!portion.inverseMatrix){portion.inverseMatrix=math.inverseMat4(portion.matrix,math.mat4());}if(worldNormal&&!portion.normalMatrix){portion.normalMatrix=math.transposeMat4(portion.inverseMatrix,math.mat4());}var quantizedPositions=geometry.quantizedPositions;var indices=geometry.indices;var origin=state.origin;var offset=portion.offset;var rtcRayOrigin=tempVec3a$w;var rtcRayDir=tempVec3b$s;rtcRayOrigin.set(origin?math.subVec3(worldRayOrigin,origin,tempVec3c$n):worldRayOrigin);// World -> RTC
rtcRayDir.set(worldRayDir);if(offset){math.subVec3(rtcRayOrigin,offset);}math.transformRay(this.model.worldNormalMatrix,rtcRayOrigin,rtcRayDir,rtcRayOrigin,rtcRayDir);math.transformRay(portion.inverseMatrix,rtcRayOrigin,rtcRayDir,rtcRayOrigin,rtcRayDir);var a=tempVec3d$7;var b=tempVec3e;var c=tempVec3f;var gotIntersect=false;var closestDist=0;var closestIntersectPos=tempVec3g;for(var _i245=0,len=indices.length;_i245<len;_i245+=3){var ia=indices[_i245+0]*3;var ib=indices[_i245+1]*3;var ic=indices[_i245+2]*3;a[0]=quantizedPositions[ia];a[1]=quantizedPositions[ia+1];a[2]=quantizedPositions[ia+2];b[0]=quantizedPositions[ib];b[1]=quantizedPositions[ib+1];b[2]=quantizedPositions[ib+2];c[0]=quantizedPositions[ic];c[1]=quantizedPositions[ic+1];c[2]=quantizedPositions[ic+2];var positionsDecodeMatrix=state.geometry.positionsDecodeMatrix;math.decompressPosition(a,positionsDecodeMatrix);math.decompressPosition(b,positionsDecodeMatrix);math.decompressPosition(c,positionsDecodeMatrix);if(math.rayTriangleIntersect(rtcRayOrigin,rtcRayDir,a,b,c,closestIntersectPos)){math.transformPoint3(portion.matrix,closestIntersectPos,closestIntersectPos);math.transformPoint3(this.model.worldMatrix,closestIntersectPos,closestIntersectPos);if(offset){math.addVec3(closestIntersectPos,offset);}if(origin){math.addVec3(closestIntersectPos,origin);}var dist=Math.abs(math.lenVec3(math.subVec3(closestIntersectPos,worldRayOrigin,[])));if(!gotIntersect||dist>closestDist){closestDist=dist;worldSurfacePos.set(closestIntersectPos);if(worldNormal){// Not that wasteful to eagerly compute - unlikely to hit >2 surfaces on most geometry
math.triangleNormal(a,b,c,worldNormal);}gotIntersect=true;}}}if(gotIntersect&&worldNormal){math.transformVec3(portion.normalMatrix,worldNormal,worldNormal);math.transformVec3(this.model.worldNormalMatrix,worldNormal,worldNormal);math.normalizeVec3(worldNormal);}return gotIntersect;}},{key:"destroy",value:function destroy(){var state=this._state;if(state.colorsBuf){state.colorsBuf.destroy();state.colorsBuf=null;}if(state.metallicRoughnessBuf){state.metallicRoughnessBuf.destroy();state.metallicRoughnessBuf=null;}if(state.flagsBuf){state.flagsBuf.destroy();state.flagsBuf=null;}if(state.offsetsBuf){state.offsetsBuf.destroy();state.offsetsBuf=null;}if(state.modelMatrixCol0Buf){state.modelMatrixCol0Buf.destroy();state.modelMatrixCol0Buf=null;}if(state.modelMatrixCol1Buf){state.modelMatrixCol1Buf.destroy();state.modelMatrixCol1Buf=null;}if(state.modelMatrixCol2Buf){state.modelMatrixCol2Buf.destroy();state.modelMatrixCol2Buf=null;}if(state.modelNormalMatrixCol0Buf){state.modelNormalMatrixCol0Buf.destroy();state.modelNormalMatrixCol0Buf=null;}if(state.modelNormalMatrixCol1Buf){state.modelNormalMatrixCol1Buf.destroy();state.modelNormalMatrixCol1Buf=null;}if(state.modelNormalMatrixCol2Buf){state.modelNormalMatrixCol2Buf.destroy();state.modelNormalMatrixCol2Buf=null;}if(state.pickColorsBuf){state.pickColorsBuf.destroy();state.pickColorsBuf=null;}state.destroy();this._state=null;}}]);return VBOInstancingTrianglesLayer;}();/**
 * @private
 */var VBOSceneModelLineBatchingRenderer=/*#__PURE__*/function(_VBORenderer7){_inherits(VBOSceneModelLineBatchingRenderer,_VBORenderer7);var _super83=_createSuper(VBOSceneModelLineBatchingRenderer);function VBOSceneModelLineBatchingRenderer(){_classCallCheck(this,VBOSceneModelLineBatchingRenderer);return _super83.apply(this,arguments);}_createClass(VBOSceneModelLineBatchingRenderer,[{key:"_draw",value:function _draw(drawCfg){var gl=this._scene.canvas.gl;var state=drawCfg.state,frameCtx=drawCfg.frameCtx,incrementDrawState=drawCfg.incrementDrawState;gl.drawElements(gl.LINES,state.indicesBuf.numItems,state.indicesBuf.itemType,0);if(incrementDrawState){frameCtx.drawElements++;}}}]);return VBOSceneModelLineBatchingRenderer;}(VBORenderer);/**
 * @private
 */var VBOBatchingLinesColorRenderer=/*#__PURE__*/function(_VBOSceneModelLineBat){_inherits(VBOBatchingLinesColorRenderer,_VBOSceneModelLineBat);var _super84=_createSuper(VBOBatchingLinesColorRenderer);function VBOBatchingLinesColorRenderer(){_classCallCheck(this,VBOBatchingLinesColorRenderer);return _super84.apply(this,arguments);}_createClass(VBOBatchingLinesColorRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(VBOBatchingLinesColorRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines batching color vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines batching color fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i246=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i246<len;_i246++){src.push("uniform bool sectionPlaneActive"+_i246+";");src.push("uniform vec3 sectionPlanePos"+_i246+";");src.push("uniform vec3 sectionPlaneDir"+_i246+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i247=0,_len55=sectionPlanesState.getNumAllocatedSectionPlanes();_i247<_len55;_i247++){src.push("if (sectionPlaneActive"+_i247+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i247+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i247+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}src.push("   outColor            = vColor;");if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return VBOBatchingLinesColorRenderer;}(VBOSceneModelLineBatchingRenderer);/**
 * @private
 */var VBOBatchingLinesSilhouetteRenderer=/*#__PURE__*/function(_VBOSceneModelLineBat2){_inherits(VBOBatchingLinesSilhouetteRenderer,_VBOSceneModelLineBat2);var _super85=_createSuper(VBOBatchingLinesSilhouetteRenderer);function VBOBatchingLinesSilhouetteRenderer(){_classCallCheck(this,VBOBatchingLinesSilhouetteRenderer);return _super85.apply(this,arguments);}_createClass(VBOBatchingLinesSilhouetteRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){_get(_getPrototypeOf(VBOBatchingLinesSilhouetteRenderer.prototype),"drawLayer",this).call(this,frameCtx,batchingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines batching silhouette vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");this._addMatricesUniformBlockLines(src);src.push("uniform vec4 color;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// silhouetteFlag = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("int silhouetteFlag = int(flags) >> 4 & 0xF;");src.push("if (silhouetteFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines batching silhouette fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i248=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i248<len;_i248++){src.push("uniform bool sectionPlaneActive"+_i248+";");src.push("uniform vec3 sectionPlanePos"+_i248+";");src.push("uniform vec3 sectionPlaneDir"+_i248+";");}}src.push("uniform vec4 color;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i249=0,_len56=sectionPlanesState.getNumAllocatedSectionPlanes();_i249<_len56;_i249++){src.push("if (sectionPlaneActive"+_i249+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i249+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i249+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = color;");src.push("}");return src;}}]);return VBOBatchingLinesSilhouetteRenderer;}(VBOSceneModelLineBatchingRenderer);var tempVec3a$v=math.vec3();var tempVec3b$r=math.vec3();var tempVec3c$m=math.vec3();var tempVec3d$6=math.vec3();var tempMat4a$m=math.mat4();/**
 * @private
 */var VBOBatchingLinesSnapInitRenderer=/*#__PURE__*/function(_VBORenderer8){_inherits(VBOBatchingLinesSnapInitRenderer,_VBORenderer8);var _super86=_createSuper(VBOBatchingLinesSnapInitRenderer);function VBOBatchingLinesSnapInitRenderer(){_classCallCheck(this,VBOBatchingLinesSnapInitRenderer);return _super86.apply(this,arguments);}_createClass(VBOBatchingLinesSnapInitRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=batchingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=batchingLayer._state;var origin=batchingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=batchingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(batchingLayer)){gl.bindVertexArray(this._vaoCache.get(batchingLayer));}else{this._vaoCache.set(batchingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$v;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$r;if(origin){var rotatedOrigin=tempVec3c$m;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$m);rtcCameraEye=tempVec3d$6;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(batchingLayer);//=============================================================
// TODO: Use drawElements count and offset to draw only one entity
//=============================================================
state.indicesBuf.bind();gl.drawElements(gl.LINES,state.indicesBuf.numItems,state.indicesBuf.itemType,0);state.indicesBuf.unbind();}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOBatchingLinesSnapInitRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBO SnapBatchingDepthBufInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec4 pickColor;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vWorldPosition = worldPosition;");if(clipping){src.push("      vFlags = flags;");}src.push("vPickColor = pickColor;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBO SnapBatchingDepthBufInitRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("in float vFlags;");for(var _i250=0;_i250<sectionPlanesState.getNumAllocatedSectionPlanes();_i250++){src.push("uniform bool sectionPlaneActive"+_i250+";");src.push("uniform vec3 sectionPlanePos"+_i250+";");src.push("uniform vec3 sectionPlaneDir"+_i250+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");src.push("layout(location = 1) out highp ivec4 outNormal;");src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, -layerNumber);");src.push("vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOBatchingLinesSnapInitRenderer;}(VBORenderer);var tempVec3a$u=math.vec3();var tempVec3b$q=math.vec3();var tempVec3c$l=math.vec3();var tempVec3d$5=math.vec3();var tempMat4a$l=math.mat4();/**
 * @private
 */var VBOBatchingLinesSnapRenderer=/*#__PURE__*/function(_VBORenderer9){_inherits(VBOBatchingLinesSnapRenderer,_VBORenderer9);var _super87=_createSuper(VBOBatchingLinesSnapRenderer);function VBOBatchingLinesSnapRenderer(){_classCallCheck(this,VBOBatchingLinesSnapRenderer);return _super87.apply(this,arguments);}_createClass(VBOBatchingLinesSnapRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=batchingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=batchingLayer._state;var origin=batchingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=batchingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(batchingLayer)){gl.bindVertexArray(this._vaoCache.get(batchingLayer));}else{this._vaoCache.set(batchingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$u;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$q;if(origin){var rotatedOrigin=tempVec3c$l;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$l);rtcCameraEye=tempVec3d$5;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(batchingLayer);//=============================================================
// TODO: Use drawElements count and offset to draw only one entity
//=============================================================
if(frameCtx.snapMode==="edge"){state.indicesBuf.bind();gl.drawElements(gl.LINES,state.indicesBuf.numItems,state.indicesBuf.itemType,0);state.indicesBuf.unbind();// needed?
}else{gl.drawArrays(gl.POINTS,0,state.positionsBuf.numItems);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOBatchingLinesSnapRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// SnapBatchingDepthRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapBatchingDepthRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i251=0;_i251<sectionPlanesState.getNumAllocatedSectionPlanes();_i251++){src.push("uniform bool sectionPlaneActive"+_i251+";");src.push("uniform vec3 sectionPlanePos"+_i251+";");src.push("uniform vec3 sectionPlaneDir"+_i251+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, layerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOBatchingLinesSnapRenderer;}(VBORenderer);/**
 * @private
 */var VBOBatchingLinesRenderers=/*#__PURE__*/function(){function VBOBatchingLinesRenderers(scene){_classCallCheck(this,VBOBatchingLinesRenderers);this._scene=scene;}_createClass(VBOBatchingLinesRenderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new VBOBatchingLinesColorRenderer(this._scene,false);}return this._colorRenderer;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new VBOBatchingLinesSilhouetteRenderer(this._scene);}return this._silhouetteRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new VBOBatchingLinesSnapInitRenderer(this._scene,false);}return this._snapInitRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new VBOBatchingLinesSnapRenderer(this._scene);}return this._snapRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}}}]);return VBOBatchingLinesRenderers;}();var cachedRenderers$4={};/**
 * @private
 */function getRenderers$5(scene){var sceneId=scene.id;var batchingRenderers=cachedRenderers$4[sceneId];if(!batchingRenderers){batchingRenderers=new VBOBatchingLinesRenderers(scene);cachedRenderers$4[sceneId]=batchingRenderers;batchingRenderers._compile();scene.on("compile",function(){batchingRenderers._compile();});scene.on("destroyed",function(){delete cachedRenderers$4[sceneId];batchingRenderers._destroy();});}return batchingRenderers;}/**
 * @private
 */var VBOBatchingLinesBuffer=/*#__PURE__*/_createClass(function VBOBatchingLinesBuffer(){var maxGeometryBatchSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5000000;_classCallCheck(this,VBOBatchingLinesBuffer);if(maxGeometryBatchSize>5000000){maxGeometryBatchSize=5000000;}this.maxVerts=maxGeometryBatchSize;this.maxIndices=maxGeometryBatchSize*3;// Rough rule-of-thumb
this.positions=[];this.colors=[];this.offsets=[];this.indices=[];});/**
 * @private
 */var VBOBatchingLinesLayer=/*#__PURE__*/function(){/**
     * @param model
     * @param cfg
     * @param cfg.layerIndex
     * @param cfg.positionsDecodeMatrix
     * @param cfg.maxGeometryBatchSize
     * @param cfg.origin
     * @param cfg.scratchMemory
     */function VBOBatchingLinesLayer(cfg){_classCallCheck(this,VBOBatchingLinesLayer);console.info("Creating VBOBatchingLinesLayer");/**
         * Index of this LinesBatchingLayer in {@link VBOSceneModel#_layerList}.
         * @type {Number}
         */this.layerIndex=cfg.layerIndex;this._renderers=getRenderers$5(cfg.model.scene);this.model=cfg.model;this._buffer=new VBOBatchingLinesBuffer(cfg.maxGeometryBatchSize);this._scratchMemory=cfg.scratchMemory;this._state=new RenderState({positionsBuf:null,offsetsBuf:null,colorsBuf:null,flagsBuf:null,indicesBuf:null,positionsDecodeMatrix:math.mat4(),origin:null});// These counts are used to avoid unnecessary render passes
this._numPortions=0;this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numSelectedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numClippableLayerPortions=0;this._numEdgesLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;this._modelAABB=math.collapseAABB3();// Model-space AABB
this._portions=[];this._meshes=[];this._numVerts=0;this._aabb=math.collapseAABB3();this.aabbDirty=true;this._finalized=false;if(cfg.positionsDecodeMatrix){this._state.positionsDecodeMatrix.set(cfg.positionsDecodeMatrix);this._preCompressedPositionsExpected=true;}else{this._preCompressedPositionsExpected=false;}if(cfg.origin){this._state.origin=math.vec3(cfg.origin);}}_createClass(VBOBatchingLinesLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i252=0,len=this._meshes.length;_i252<len;_i252++){math.expandAABB3(this._aabb,this._meshes[_i252].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Tests if there is room for another portion in this LinesBatchingLayer.
     *
     * @param lenPositions Number of positions we'd like to create in the portion.
     * @param lenIndices Number of indices we'd like to create in this portion.
     * @returns {Boolean} True if OK to create another portion.
     */},{key:"canCreatePortion",value:function canCreatePortion(lenPositions,lenIndices){if(this._finalized){throw"Already finalized";}return this._buffer.positions.length+lenPositions<this._buffer.maxVerts*3&&this._buffer.indices.length+lenIndices<this._buffer.maxIndices;}/**
     * Creates a new portion within this LinesBatchingLayer, returns the new portion ID.
     *
     * Gives the portion the specified geometry, color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param cfg.positions Flat float Local-space positions array.
     * @param cfg.positionsCompressed Flat quantized positions array - decompressed with TrianglesBatchingLayer positionsDecodeMatrix
     * @param cfg.indices  Flat int indices array.
     * @param cfg.color Quantized RGB color [0..255,0..255,0..255,0..255]
     * @param cfg.opacity Opacity [0..255]
     * @param [cfg.meshMatrix] Flat float 4x4 matrix
     * @param cfg.aabb Flat float AABB World-space AABB
     * @param cfg.pickColor Quantized pick color
     * @returns {number} Portion ID
     */},{key:"createPortion",value:function createPortion(mesh,cfg){if(this._finalized){throw"Already finalized";}var positions=cfg.positions;var positionsCompressed=cfg.positionsCompressed;var indices=cfg.indices;var color=cfg.color;var opacity=cfg.opacity;var buffer=this._buffer;var positionsIndex=buffer.positions.length;var vertsIndex=positionsIndex/3;var numVerts;math.expandAABB3(this._modelAABB,cfg.aabb);if(this._preCompressedPositionsExpected){if(!positionsCompressed){throw"positionsCompressed expected";}numVerts=positionsCompressed.length/3;for(var _i253=0,len=positionsCompressed.length;_i253<len;_i253++){buffer.positions.push(positionsCompressed[_i253]);}}else{if(!positions){throw"positions expected";}numVerts=positions.length/3;for(var _i254=0,_len57=positions.length;_i254<_len57;_i254++){buffer.positions.push(positions[_i254]);}}if(color){var _r4=color[0];// Color is pre-quantized by VBOSceneModel
var g=color[1];var b=color[2];var _a3=opacity;for(var _i255=0;_i255<numVerts;_i255++){buffer.colors.push(_r4);buffer.colors.push(g);buffer.colors.push(b);buffer.colors.push(_a3);}}if(indices){for(var _i256=0,_len58=indices.length;_i256<_len58;_i256++){buffer.indices.push(indices[_i256]+vertsIndex);}}if(this.model.scene.entityOffsetsEnabled){for(var _i257=0;_i257<numVerts;_i257++){buffer.offsets.push(0);buffer.offsets.push(0);buffer.offsets.push(0);}}var portionId=this._portions.length/2;this._portions.push(vertsIndex);this._portions.push(numVerts);this._numPortions++;this.model.numPortions++;this._numVerts+=numVerts;this._meshes.push(mesh);return portionId;}/**
     * Builds batch VBOs from appended geometries.
     * No more portions can then be created.
     */},{key:"finalize",value:function finalize(){if(this._finalized){return;}var state=this._state;var gl=this.model.scene.canvas.gl;var buffer=this._buffer;if(buffer.positions.length>0){if(this._preCompressedPositionsExpected){var positions=new Uint16Array(buffer.positions);state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,positions,buffer.positions.length,3,gl.STATIC_DRAW);}else{var _positions2=new Float32Array(buffer.positions);var quantizedPositions=quantizePositions(_positions2,this._modelAABB,state.positionsDecodeMatrix);state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,quantizedPositions,buffer.positions.length,3,gl.STATIC_DRAW);}}if(buffer.colors.length>0){var colors=new Uint8Array(buffer.colors);var normalized=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colors,buffer.colors.length,4,gl.DYNAMIC_DRAW,normalized);}if(buffer.colors.length>0){// Because we build flags arrays here, get their length from the colors array
var flagsLength=buffer.colors.length/4;var flags=new Float32Array(flagsLength);var notNormalized=false;state.flagsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,flags,flags.length,1,gl.DYNAMIC_DRAW,notNormalized);}if(this.model.scene.entityOffsetsEnabled){if(buffer.offsets.length>0){var offsets=new Float32Array(buffer.offsets);state.offsetsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,offsets,buffer.offsets.length,3,gl.DYNAMIC_DRAW);}}if(buffer.indices.length>0){var indices=new Uint32Array(buffer.indices);state.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,indices,buffer.indices.length,1,gl.STATIC_DRAW);}this._buffer=null;this._finalized=true;}},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}var deferred=true;this._setFlags(portionId,flags,meshTransparent,deferred);}},{key:"flushInitFlags",value:function flushInitFlags(){this._setDeferredFlags();}},{key:"setVisible",value:function setVisible(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setSelected",value:function setSelected(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setEdges",value:function setEdges(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}else{this._numEdgesLayerPortions--;this.model.numEdgesLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags(portionId,flags);}},{key:"setCulled",value:function setCulled(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions--;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setColor",value:function setColor(portionId,color){if(!this._finalized){throw"Not finalized";}var portionsIdx=portionId*2;var vertexBase=this._portions[portionsIdx];var numVerts=this._portions[portionsIdx+1];var firstColor=vertexBase*4;var lenColor=numVerts*4;var tempArray=this._scratchMemory.getUInt8Array(lenColor);var r=color[0];var g=color[1];var b=color[2];var a=color[3];for(var _i258=0;_i258<lenColor;_i258+=4){tempArray[_i258+0]=r;tempArray[_i258+1]=g;tempArray[_i258+2]=b;tempArray[_i258+3]=a;}this._state.colorsBuf.setData(tempArray,firstColor,lenColor);}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}/**
     * flags are 4bits values encoded on a 32bit base. color flag on the first 4 bits, silhouette flag on the next 4 bits and so on for edge, pick and clippable.
     */},{key:"_setFlags",value:function _setFlags(portionId,flags,transparent){var deferred=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(!this._finalized){throw"Not finalized";}var portionsIdx=portionId*2;var vertexBase=this._portions[portionsIdx];var numVerts=this._portions[portionsIdx+1];var firstFlag=vertexBase;var lenFlags=numVerts;var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);// no edges
var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);var colorFlag;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){colorFlag=RENDER_PASSES.NOT_RENDERED;}else{if(transparent){colorFlag=RENDER_PASSES.COLOR_TRANSPARENT;}else{colorFlag=RENDER_PASSES.COLOR_OPAQUE;}}var silhouetteFlag;if(!visible||culled){silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){silhouetteFlag=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){silhouetteFlag=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){silhouetteFlag=RENDER_PASSES.SILHOUETTE_XRAYED;}else{silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}var pickFlag=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var clippableFlag=!!(flags&ENTITY_FLAGS.CLIPPABLE)?1:0;if(deferred){// Avoid zillions of individual WebGL bufferSubData calls - buffer them to apply in one shot
if(!this._deferredFlagValues){this._deferredFlagValues=new Float32Array(this._numVerts);}for(var _i259=firstFlag,len=firstFlag+lenFlags;_i259<len;_i259++){var vertFlag=0;vertFlag|=colorFlag;vertFlag|=silhouetteFlag<<4;// no edges
vertFlag|=pickFlag<<12;vertFlag|=clippableFlag<<16;this._deferredFlagValues[_i259]=vertFlag;}}else if(this._state.flagsBuf){var tempArray=this._scratchMemory.getFloat32Array(lenFlags);for(var _i260=0;_i260<lenFlags;_i260++){var _vertFlag2=0;_vertFlag2|=colorFlag;_vertFlag2|=silhouetteFlag<<4;// no edges
_vertFlag2|=pickFlag<<12;_vertFlag2|=clippableFlag<<16;tempArray[_i260]=_vertFlag2;}this._state.flagsBuf.setData(tempArray,firstFlag,lenFlags);}}},{key:"_setDeferredFlags",value:function _setDeferredFlags(){if(this._deferredFlagValues){this._state.flagsBuf.setData(this._deferredFlagValues);this._deferredFlagValues=null;}}},{key:"setOffset",value:function setOffset(portionId,offset){if(!this._finalized){throw"Not finalized";}if(!this.model.scene.entityOffsetsEnabled){this.model.error("Entity#offset not enabled for this Viewer");// See Viewer entityOffsetsEnabled
return;}var portionsIdx=portionId*2;var vertexBase=this._portions[portionsIdx];var numVerts=this._portions[portionsIdx+1];var firstOffset=vertexBase*3;var lenOffsets=numVerts*3;var tempArray=this._scratchMemory.getFloat32Array(lenOffsets);var x=offset[0];var y=offset[1];var z=offset[2];for(var _i261=0;_i261<lenOffsets;_i261+=3){tempArray[_i261+0]=x;tempArray[_i261+1]=y;tempArray[_i261+2]=z;}this._state.offsetsBuf.setData(tempArray,firstOffset,lenOffsets);}//-- RENDERING ----------------------------------------------------------------------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){}},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){}},{key:"drawPickMesh",value:function drawPickMesh(frameCtx){}},{key:"drawPickDepths",value:function drawPickDepths(frameCtx){}},{key:"drawPickNormals",value:function drawPickNormals(frameCtx){}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawOcclusion",value:function drawOcclusion(frameCtx){}},{key:"drawShadow",value:function drawShadow(frameCtx){}},{key:"destroy",value:function destroy(){var state=this._state;if(state.positionsBuf){state.positionsBuf.destroy();state.positionsBuf=null;}if(state.offsetsBuf){state.offsetsBuf.destroy();state.offsetsBuf=null;}if(state.colorsBuf){state.colorsBuf.destroy();state.colorsBuf=null;}if(state.flagsBuf){state.flagsBuf.destroy();state.flagsBuf=null;}if(state.indicesBuf){state.indicesBuf.destroy();state.indicesBuf=null;}state.destroy();}}]);return VBOBatchingLinesLayer;}();/**
 * @private
 */var VBOInstancingLinesRenderer=/*#__PURE__*/function(_VBORenderer10){_inherits(VBOInstancingLinesRenderer,_VBORenderer10);var _super88=_createSuper(VBOInstancingLinesRenderer);function VBOInstancingLinesRenderer(scene,withSAO){_classCallCheck(this,VBOInstancingLinesRenderer);return _super88.call(this,scene,withSAO,{instancing:true});}_createClass(VBOInstancingLinesRenderer,[{key:"_draw",value:function _draw(drawCfg){var gl=this._scene.canvas.gl;var state=drawCfg.state,frameCtx=drawCfg.frameCtx,incrementDrawState=drawCfg.incrementDrawState;gl.drawElementsInstanced(gl.LINES,state.indicesBuf.numItems,state.indicesBuf.itemType,0,state.numInstances);if(incrementDrawState){frameCtx.drawElements++;}}}]);return VBOInstancingLinesRenderer;}(VBORenderer);/**
 * @private
 */var VBOInstancingLinesColorRenderer=/*#__PURE__*/function(_VBOInstancingLinesRe){_inherits(VBOInstancingLinesColorRenderer,_VBOInstancingLinesRe);var _super89=_createSuper(VBOInstancingLinesColorRenderer);function VBOInstancingLinesColorRenderer(){_classCallCheck(this,VBOInstancingLinesColorRenderer);return _super89.apply(this,arguments);}_createClass(VBOInstancingLinesColorRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(VBOInstancingLinesColorRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines instancing color vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}src.push("uniform vec4 lightAmbient;");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0,  float(color.a) / 255.0);");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines instancing color fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
if(this._withSAO){src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBAToDepth(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor            = vec4(vColor.rgb * ambient, vColor.a);");}else{src.push("    outColor           = vColor;");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return VBOInstancingLinesColorRenderer;}(VBOInstancingLinesRenderer);/**
 * @private
 */var VBOInstancingLinesSilhouetteRenderer=/*#__PURE__*/function(_VBOInstancingLinesRe2){_inherits(VBOInstancingLinesSilhouetteRenderer,_VBOInstancingLinesRe2);var _super90=_createSuper(VBOInstancingLinesSilhouetteRenderer);function VBOInstancingLinesSilhouetteRenderer(){_classCallCheck(this,VBOInstancingLinesSilhouetteRenderer);return _super90.apply(this,arguments);}_createClass(VBOInstancingLinesSilhouetteRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){_get(_getPrototypeOf(VBOInstancingLinesSilhouetteRenderer.prototype),"drawLayer",this).call(this,frameCtx,instancingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines instancing silhouette vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}src.push("uniform vec4 color;");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// silhouetteFlag = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("int silhouetteFlag = int(flags) >> 4 & 0xF;");src.push("if (silhouetteFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Lines instancing silhouette fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i262=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i262<len;_i262++){src.push("uniform bool sectionPlaneActive"+_i262+";");src.push("uniform vec3 sectionPlanePos"+_i262+";");src.push("uniform vec3 sectionPlaneDir"+_i262+";");}}src.push("uniform vec4 color;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i263=0,_len59=sectionPlanesState.getNumAllocatedSectionPlanes();_i263<_len59;_i263++){src.push("if (sectionPlaneActive"+_i263+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i263+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i263+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = color;");src.push("}");return src;}}]);return VBOInstancingLinesSilhouetteRenderer;}(VBOInstancingLinesRenderer);var tempVec3a$t=math.vec3();var tempVec3b$p=math.vec3();var tempVec3c$k=math.vec3();math.vec3();var tempMat4a$k=math.mat4();/**
 * @private
 */var VBOInstancingLinesSnapInitRenderer=/*#__PURE__*/function(_VBORenderer11){_inherits(VBOInstancingLinesSnapInitRenderer,_VBORenderer11);var _super91=_createSuper(VBOInstancingLinesSnapInitRenderer);function VBOInstancingLinesSnapInitRenderer(scene){_classCallCheck(this,VBOInstancingLinesSnapInitRenderer);return _super91.call(this,scene,false,{instancing:true});}_createClass(VBOInstancingLinesSnapInitRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=instancingLayer.model;var scene=model.scene;var gl=scene.canvas.gl;var camera=scene.camera;var state=instancingLayer._state;var origin=instancingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=instancingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(instancingLayer)){gl.bindVertexArray(this._vaoCache.get(instancingLayer));}else{this._vaoCache.set(instancingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$t;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$p;if(origin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$k);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$k);frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(instancingLayer);this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);if(this._aFlags){this._aFlags.bindArrayBuffer(state.flagsBuf);gl.vertexAttribDivisor(this._aFlags.location,1);}state.indicesBuf.bind();gl.drawElementsInstanced(gl.LINES,state.indicesBuf.numItems,state.indicesBuf.itemType,0,state.numInstances);state.indicesBuf.unbind();// Cleanup
gl.vertexAttribDivisor(this._aModelMatrixCol0.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,0);if(this._aFlags){gl.vertexAttribDivisor(this._aFlags.location,0);}if(this._aOffset){gl.vertexAttribDivisor(this._aOffset.location,0);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOInstancingLinesSnapInitRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthBufInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec4 pickColor;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vWorldPosition = worldPosition;");if(clipping){src.push("  vFlags = flags;");}src.push("vPickColor = pickColor;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("in float vFlags;");for(var _i264=0;_i264<sectionPlanesState.getNumAllocatedSectionPlanes();_i264++){src.push("uniform bool sectionPlaneActive"+_i264+";");src.push("uniform vec3 sectionPlanePos"+_i264+";");src.push("uniform vec3 sectionPlaneDir"+_i264+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");///////////////////////////////////////////
// TODO: normal placeholder?
// Primitive type?
///////////////////////////////////////////
src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i265=0;_i265<sectionPlanesState.getNumAllocatedSectionPlanes();_i265++){src.push("if (sectionPlaneActive"+_i265+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i265+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i265+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, -layerNumber);");src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOInstancingLinesSnapInitRenderer;}(VBORenderer);var tempVec3a$s=math.vec3();var tempVec3b$o=math.vec3();var tempVec3c$j=math.vec3();math.vec3();var tempMat4a$j=math.mat4();/**
 * @private
 */var VBOInstancingLinesSnapRenderer=/*#__PURE__*/function(_VBORenderer12){_inherits(VBOInstancingLinesSnapRenderer,_VBORenderer12);var _super92=_createSuper(VBOInstancingLinesSnapRenderer);function VBOInstancingLinesSnapRenderer(scene){_classCallCheck(this,VBOInstancingLinesSnapRenderer);return _super92.call(this,scene,false,{instancing:true});}_createClass(VBOInstancingLinesSnapRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){if(!this._program){this._allocate(instancingLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=instancingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=instancingLayer._state;var origin=instancingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=instancingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(instancingLayer)){gl.bindVertexArray(this._vaoCache.get(instancingLayer));}else{this._vaoCache.set(instancingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$s;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$o;if(origin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$j);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$j);frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(instancingLayer);this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);this._aFlags.bindArrayBuffer(state.flagsBuf);gl.vertexAttribDivisor(this._aFlags.location,1);if(frameCtx.snapMode==="edge"){state.indicesBuf.bind();gl.drawElementsInstanced(gl.LINES,state.indicesBuf.numItems,state.indicesBuf.itemType,0,state.numInstances);state.indicesBuf.unbind();// needed?
}else{gl.drawArraysInstanced(gl.POINTS,0,state.positionsBuf.numItems,state.numInstances);}// Cleanup
gl.vertexAttribDivisor(this._aModelMatrixCol0.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,0);gl.vertexAttribDivisor(this._aFlags.location,0);if(this._aOffset){gl.vertexAttribDivisor(this._aOffset.location,0);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOInstancingLinesSnapRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i266=0;_i266<sectionPlanesState.getNumAllocatedSectionPlanes();_i266++){src.push("uniform bool sectionPlaneActive"+_i266+";");src.push("uniform vec3 sectionPlanePos"+_i266+";");src.push("uniform vec3 sectionPlaneDir"+_i266+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i267=0;_i267<sectionPlanesState.getNumAllocatedSectionPlanes();_i267++){src.push("if (sectionPlaneActive"+_i267+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i267+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i267+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, layerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOInstancingLinesSnapRenderer;}(VBORenderer);/**
 * @private
 */var VBOInstancingLinesRenderers=/*#__PURE__*/function(){function VBOInstancingLinesRenderers(scene){_classCallCheck(this,VBOInstancingLinesRenderers);this._scene=scene;}_createClass(VBOInstancingLinesRenderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}}},{key:"eagerCreateRenders",value:function eagerCreateRenders(){// Pre-initialize renderers that would otherwise be lazy-initialised
// on user interaction, such as picking or emphasis, so that there is no delay
// when user first begins interacting with the viewer.
if(!this._snapInitRenderer){this._snapInitRenderer=new VBOInstancingLinesSnapInitRenderer(this._scene,false);}if(!this._snapRenderer){this._snapRenderer=new VBOInstancingLinesSnapRenderer(this._scene);}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new VBOInstancingLinesColorRenderer(this._scene);}return this._colorRenderer;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new VBOInstancingLinesSilhouetteRenderer(this._scene);}return this._silhouetteRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new VBOInstancingLinesSnapInitRenderer(this._scene,false);}return this._snapInitRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new VBOInstancingLinesSnapRenderer(this._scene);}return this._snapRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}}}]);return VBOInstancingLinesRenderers;}();var cachedRenderers$3={};/**
 * @private
 */function getRenderers$4(scene){var sceneId=scene.id;var instancingRenderers=cachedRenderers$3[sceneId];if(!instancingRenderers){instancingRenderers=new VBOInstancingLinesRenderers(scene);cachedRenderers$3[sceneId]=instancingRenderers;instancingRenderers._compile();scene.on("compile",function(){instancingRenderers._compile();});scene.on("destroyed",function(){delete cachedRenderers$3[sceneId];instancingRenderers._destroy();});}return instancingRenderers;}/*

function getSnapInstancingRenderers(scene) {
    const sceneId = scene.id;
    let instancingRenderers = cachedRenderers[sceneId];
    if (!instancingRenderers) {
        instancingRenderers = new VBOInstancingLineSnapRenderers(scene);
        cachedRenderers[sceneId] = instancingRenderers;
        instancingRenderers._compile();
        instancingRenderers.eagerCreateRenders();
        scene.on("compile", () => {
            instancingRenderers._compile();
            instancingRenderers.eagerCreateRenders();
        });
        scene.on("destroyed", () => {
            delete cachedRenderers[sceneId];
            instancingRenderers._destroy();
        });
    }
    return instancingRenderers;
}

 */var tempUint8Vec4$1=new Uint8Array(4);var tempFloat32$1=new Float32Array(1);var tempVec3fa$1=new Float32Array(3);var tempFloat32Vec4$1=new Float32Array(4);/**
 * @private
 */var VBOInstancingLinesLayer=/*#__PURE__*/function(){/**
     * @param cfg
     * @param cfg.layerIndex
     * @param cfg.model
     * @param cfg.geometry
     * @param cfg.material
     * @param cfg.origin
     */function VBOInstancingLinesLayer(cfg){_classCallCheck(this,VBOInstancingLinesLayer);console.info("VBOInstancingLinesLayer");/**
         * Owner model
         * @type {VBOSceneModel}
         */this.model=cfg.model;/**
         * Shared material
         * @type {VBOSceneModelGeometry}
         */this.material=cfg.material;/**
         * State sorting key.
         * @type {string}
         */this.sortId="LinesInstancingLayer";/**
         * Index of this InstancingLayer in VBOSceneModel#_layerList
         * @type {Number}
         */this.layerIndex=cfg.layerIndex;this._renderers=getRenderers$4(cfg.model.scene);this._aabb=math.collapseAABB3();this._state=new RenderState({obb:math.OBB3(),numInstances:0,origin:null,geometry:cfg.geometry,positionsDecodeMatrix:cfg.geometry.positionsDecodeMatrix,// So we can null the geometry for GC
positionsBuf:null,colorsBuf:null,flagsBuf:null,offsetsBuf:null,modelMatrixCol0Buf:null,modelMatrixCol1Buf:null,modelMatrixCol2Buf:null});// These counts are used to avoid unnecessary render passes
this._numPortions=0;this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numSelectedLayerPortions=0;this._numClippableLayerPortions=0;this._numEdgesLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;/** @private */this.numIndices=cfg.geometry.numIndices;// Vertex arrays
this._colors=[];this._offsets=[];// Modeling matrix per instance, array for each column
this._modelMatrixCol0=[];this._modelMatrixCol1=[];this._modelMatrixCol2=[];this._portions=[];this._meshes=[];this._aabb=math.collapseAABB3();this.aabbDirty=true;if(cfg.origin){this._state.origin=math.vec3(cfg.origin);}this._finalized=false;}_createClass(VBOInstancingLinesLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i268=0,len=this._meshes.length;_i268<len;_i268++){math.expandAABB3(this._aabb,this._meshes[_i268].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Creates a new portion within this InstancingLayer, returns the new portion ID.
     *
     * The portion will instance this InstancingLayer's geometry.
     *
     * Gives the portion the specified color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param cfg Portion params
     * @param cfg.color Color [0..255,0..255,0..255]
     * @param cfg.opacity Opacity [0..255].
     * @param cfg.meshMatrix Flat float 4x4 matrix.
     * @returns {number} Portion ID.
     */},{key:"createPortion",value:function createPortion(mesh,cfg){var color=cfg.color;var opacity=cfg.opacity;var meshMatrix=cfg.meshMatrix;if(this._finalized){throw"Already finalized";}var r=color[0];// Color is pre-quantized by VBOSceneModel
var g=color[1];var b=color[2];color[3];this._colors.push(r);this._colors.push(g);this._colors.push(b);this._colors.push(opacity);if(this.model.scene.entityOffsetsEnabled){this._offsets.push(0);this._offsets.push(0);this._offsets.push(0);}this._modelMatrixCol0.push(meshMatrix[0]);this._modelMatrixCol0.push(meshMatrix[4]);this._modelMatrixCol0.push(meshMatrix[8]);this._modelMatrixCol0.push(meshMatrix[12]);this._modelMatrixCol1.push(meshMatrix[1]);this._modelMatrixCol1.push(meshMatrix[5]);this._modelMatrixCol1.push(meshMatrix[9]);this._modelMatrixCol1.push(meshMatrix[13]);this._modelMatrixCol2.push(meshMatrix[2]);this._modelMatrixCol2.push(meshMatrix[6]);this._modelMatrixCol2.push(meshMatrix[10]);this._modelMatrixCol2.push(meshMatrix[14]);this._state.numInstances++;var portionId=this._portions.length;this._portions.push({});this._numPortions++;this.model.numPortions++;this._meshes.push(mesh);return portionId;}},{key:"finalize",value:function finalize(){if(this._finalized){throw"Already finalized";}var gl=this.model.scene.canvas.gl;var state=this._state;var geometry=state.geometry;var colorsLength=this._colors.length;var flagsLength=colorsLength/4;if(colorsLength>0){var notNormalized=false;this._state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Uint8Array(this._colors),this._colors.length,4,gl.DYNAMIC_DRAW,notNormalized);this._colors=[];// Release memory
}if(flagsLength>0){// Because we only build flags arrays here, 
// get their length from the colors array
var _notNormalized6=false;this._state.flagsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(flagsLength),flagsLength,1,gl.DYNAMIC_DRAW,_notNormalized6);}if(this.model.scene.entityOffsetsEnabled){if(this._offsets.length>0){var _notNormalized7=false;this._state.offsetsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._offsets),this._offsets.length,3,gl.DYNAMIC_DRAW,_notNormalized7);this._offsets=[];// Release memory
}}if(geometry.colorsCompressed&&geometry.colorsCompressed.length>0){var colorsCompressed=new Uint8Array(geometry.colorsCompressed);var _notNormalized8=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colorsCompressed,colorsCompressed.length,4,gl.STATIC_DRAW,_notNormalized8);}if(geometry.positionsCompressed&&geometry.positionsCompressed.length>0){var normalized=false;state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,geometry.positionsCompressed,geometry.positionsCompressed.length,3,gl.STATIC_DRAW,normalized);state.positionsDecodeMatrix=math.mat4(geometry.positionsDecodeMatrix);}if(geometry.indices&&geometry.indices.length>0){state.indicesBuf=new ArrayBuf(gl,gl.ELEMENT_ARRAY_BUFFER,new Uint32Array(geometry.indices),geometry.indices.length,1,gl.STATIC_DRAW);state.numIndices=geometry.indices.length;}if(this._modelMatrixCol0.length>0){var _normalized7=false;this._state.modelMatrixCol0Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol0),this._modelMatrixCol0.length,4,gl.STATIC_DRAW,_normalized7);this._state.modelMatrixCol1Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol1),this._modelMatrixCol1.length,4,gl.STATIC_DRAW,_normalized7);this._state.modelMatrixCol2Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol2),this._modelMatrixCol2.length,4,gl.STATIC_DRAW,_normalized7);this._modelMatrixCol0=[];this._modelMatrixCol1=[];this._modelMatrixCol2=[];}this._state.geometry=null;this._finalized=true;}// The following setters are called by VBOSceneModelMesh, in turn called by VBOSceneModelNode, only after the layer is finalized.
// It's important that these are called after finalize() in order to maintain integrity of counts like _numVisibleLayerPortions etc.
},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setVisible",value:function setVisible(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setSelected",value:function setSelected(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setEdges",value:function setEdges(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}else{this._numEdgesLayerPortions--;this.model.numEdgesLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags(portionId,flags);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setCulled",value:function setCulled(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions--;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setColor",value:function setColor(portionId,color){// RGBA color is normalized as ints
if(!this._finalized){throw"Not finalized";}tempUint8Vec4$1[0]=color[0];tempUint8Vec4$1[1]=color[1];tempUint8Vec4$1[2]=color[2];tempUint8Vec4$1[3]=color[3];this._state.colorsBuf.setData(tempUint8Vec4$1,portionId*4,4);}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}/**
     * flags are 4bits values encoded on a 32bit base. color flag on the first 4 bits, silhouette flag on the next 4 bits and so on for edge, pick and clippable.
     */},{key:"_setFlags",value:function _setFlags(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var edges=!!(flags&ENTITY_FLAGS.EDGES);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);var colorFlag;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){colorFlag=RENDER_PASSES.NOT_RENDERED;}else{if(meshTransparent){colorFlag=RENDER_PASSES.COLOR_TRANSPARENT;}else{colorFlag=RENDER_PASSES.COLOR_OPAQUE;}}var silhouetteFlag;if(!visible||culled){silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){silhouetteFlag=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){silhouetteFlag=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){silhouetteFlag=RENDER_PASSES.SILHOUETTE_XRAYED;}else{silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}var edgeFlag=0;if(!visible||culled){edgeFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){edgeFlag=RENDER_PASSES.EDGES_SELECTED;}else if(highlighted){edgeFlag=RENDER_PASSES.EDGES_HIGHLIGHTED;}else if(xrayed){edgeFlag=RENDER_PASSES.EDGES_XRAYED;}else if(edges){if(meshTransparent){edgeFlag=RENDER_PASSES.EDGES_COLOR_TRANSPARENT;}else{edgeFlag=RENDER_PASSES.EDGES_COLOR_OPAQUE;}}else{edgeFlag=RENDER_PASSES.NOT_RENDERED;}var pickFlag=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var clippableFlag=!!(flags&ENTITY_FLAGS.CLIPPABLE)?255:0;var vertFlag=0;vertFlag|=colorFlag;vertFlag|=silhouetteFlag<<4;vertFlag|=edgeFlag<<8;vertFlag|=pickFlag<<12;vertFlag|=clippableFlag<<16;tempFloat32$1[0]=vertFlag;this._state.flagsBuf.setData(tempFloat32$1,portionId);}},{key:"setOffset",value:function setOffset(portionId,offset){if(!this._finalized){throw"Not finalized";}if(!this.model.scene.entityOffsetsEnabled){this.model.error("Entity#offset not enabled for this Viewer");// See Viewer entityOffsetsEnabled
return;}tempVec3fa$1[0]=offset[0];tempVec3fa$1[1]=offset[1];tempVec3fa$1[2]=offset[2];this._state.offsetsBuf.setData(tempVec3fa$1,portionId*3,3);}},{key:"setMatrix",value:function setMatrix(portionId,matrix){////////////////////////////////////////
// TODO: Update portion matrix
////////////////////////////////////////
if(!this._finalized){throw"Not finalized";}var offset=portionId*4;tempFloat32Vec4$1[0]=matrix[0];tempFloat32Vec4$1[1]=matrix[4];tempFloat32Vec4$1[2]=matrix[8];tempFloat32Vec4$1[3]=matrix[12];this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4$1,offset);tempFloat32Vec4$1[0]=matrix[1];tempFloat32Vec4$1[1]=matrix[5];tempFloat32Vec4$1[2]=matrix[9];tempFloat32Vec4$1[3]=matrix[13];this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4$1,offset);tempFloat32Vec4$1[0]=matrix[2];tempFloat32Vec4$1[1]=matrix[6];tempFloat32Vec4$1[2]=matrix[10];tempFloat32Vec4$1[3]=matrix[14];this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4$1,offset);}// ---------------------- NORMAL RENDERING -----------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------
},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){}// ---------------------- EMPHASIS RENDERING -----------------------------------
},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}// ---------------------- EDGES RENDERING -----------------------------------
},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}// ---------------------- OCCLUSION CULL RENDERING -----------------------------------
},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){}// ---------------------- SHADOW BUFFER RENDERING -----------------------------------
},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){}//---- PICKING ----------------------------------------------------------------------------------------------------
},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){}},{key:"destroy",value:function destroy(){var state=this._state;if(state.positionsBuf){state.positionsBuf.destroy();state.positionsBuf=null;}if(state.colorsBuf){state.colorsBuf.destroy();state.colorsBuf=null;}if(state.flagsBuf){state.flagsBuf.destroy();state.flagsBuf=null;}if(state.offsetsBuf){state.offsetsBuf.destroy();state.offsetsBuf=null;}if(state.modelMatrixCol0Buf){state.modelMatrixCol0Buf.destroy();state.modelMatrixCol0Buf=null;}if(state.modelMatrixCol1Buf){state.modelMatrixCol1Buf.destroy();state.modelMatrixCol1Buf=null;}if(state.modelMatrixCol2Buf){state.modelMatrixCol2Buf.destroy();state.modelMatrixCol2Buf=null;}state.destroy();}}]);return VBOInstancingLinesLayer;}();/**
 * @private
 */var VBOBatchingPointsRenderer=/*#__PURE__*/function(_VBORenderer13){_inherits(VBOBatchingPointsRenderer,_VBORenderer13);var _super93=_createSuper(VBOBatchingPointsRenderer);function VBOBatchingPointsRenderer(){_classCallCheck(this,VBOBatchingPointsRenderer);return _super93.apply(this,arguments);}_createClass(VBOBatchingPointsRenderer,[{key:"_draw",value:function _draw(drawCfg){var gl=this._scene.canvas.gl;var state=drawCfg.state,frameCtx=drawCfg.frameCtx,incrementDrawState=drawCfg.incrementDrawState;gl.drawArrays(gl.POINTS,0,state.positionsBuf.numItems);if(incrementDrawState){frameCtx.drawArrays++;}}}]);return VBOBatchingPointsRenderer;}(VBORenderer);/**
 * @private
 */var VBOBatchingPointsColorRenderer=/*#__PURE__*/function(_VBOBatchingPointsRen){_inherits(VBOBatchingPointsColorRenderer,_VBOBatchingPointsRen);var _super94=_createSuper(VBOBatchingPointsColorRenderer);function VBOBatchingPointsColorRenderer(){_classCallCheck(this,VBOBatchingPointsColorRenderer);return _super94.apply(this,arguments);}_createClass(VBOBatchingPointsColorRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(VBOBatchingPointsColorRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial;var src=[];src.push('#version 300 es');src.push("// Points batching color vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(pointsMaterial.filterIntensity){src.push("uniform vec2 intensityRange;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");if(pointsMaterial.filterIntensity){src.push("float intensity = float(color.a) / 255.0;");src.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");}src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");if(pointsMaterial.filterIntensity){src.push("}");}src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points batching color fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i269=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i269<len;_i269++){src.push("uniform bool sectionPlaneActive"+_i269+";");src.push("uniform vec3 sectionPlanePos"+_i269+";");src.push("uniform vec3 sectionPlaneDir"+_i269+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i270=0,_len60=sectionPlanesState.getNumAllocatedSectionPlanes();_i270<_len60;_i270++){src.push("if (sectionPlaneActive"+_i270+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i270+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i270+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}src.push("   outColor = vColor;");if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return VBOBatchingPointsColorRenderer;}(VBOBatchingPointsRenderer);/**
 * @private
 */var VBOBatchingPointsSilhouetteRenderer=/*#__PURE__*/function(_VBOBatchingPointsRen2){_inherits(VBOBatchingPointsSilhouetteRenderer,_VBOBatchingPointsRen2);var _super95=_createSuper(VBOBatchingPointsSilhouetteRenderer);function VBOBatchingPointsSilhouetteRenderer(){_classCallCheck(this,VBOBatchingPointsSilhouetteRenderer);return _super95.apply(this,arguments);}_createClass(VBOBatchingPointsSilhouetteRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,pointsBatchingLayer,renderPass){_get(_getPrototypeOf(VBOBatchingPointsSilhouetteRenderer.prototype),"drawLayer",this).call(this,frameCtx,pointsBatchingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points batching silhouette vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");this._addMatricesUniformBlockLines(src);src.push("uniform vec4 color;");src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// silhouetteFlag = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("int silhouetteFlag = int(flags) >> 4 & 0xF;");src.push("if (silhouetteFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points batching silhouette vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("uniform vec4 color;");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = color;");src.push("}");return src;}}]);return VBOBatchingPointsSilhouetteRenderer;}(VBOBatchingPointsRenderer);/**
 * @private
 */var VBOBatchingPointsPickMeshRenderer=/*#__PURE__*/function(_VBOBatchingPointsRen3){_inherits(VBOBatchingPointsPickMeshRenderer,_VBOBatchingPointsRen3);var _super96=_createSuper(VBOBatchingPointsPickMeshRenderer);function VBOBatchingPointsPickMeshRenderer(){_classCallCheck(this,VBOBatchingPointsPickMeshRenderer);return _super96.apply(this,arguments);}_createClass(VBOBatchingPointsPickMeshRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points batching pick mesh vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 pickColor;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vPickColor;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = remapClipPos(clipPos);");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("gl_PointSize += 10.0;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points batching pick mesh vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vPickColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i271=0;_i271<sectionPlanesState.getNumAllocatedSectionPlanes();_i271++){src.push("      if (sectionPlaneActive"+_i271+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i271+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i271+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor = vPickColor; ");src.push("}");return src;}}]);return VBOBatchingPointsPickMeshRenderer;}(VBOBatchingPointsRenderer);/**
 * @private
 */var VBOBatchingPointsPickDepthRenderer=/*#__PURE__*/function(_VBOBatchingPointsRen4){_inherits(VBOBatchingPointsPickDepthRenderer,_VBOBatchingPointsRen4);var _super97=_createSuper(VBOBatchingPointsPickDepthRenderer);function VBOBatchingPointsPickDepthRenderer(){_classCallCheck(this,VBOBatchingPointsPickDepthRenderer);return _super97.apply(this,arguments);}_createClass(VBOBatchingPointsPickDepthRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points batched pick depth vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vViewPosition = viewPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = remapClipPos(clipPos);");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("gl_PointSize += 10.0;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points batched pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform float pickZNear;");src.push("uniform float pickZFar;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i272=0;_i272<sectionPlanesState.getNumAllocatedSectionPlanes();_i272++){src.push("uniform bool sectionPlaneActive"+_i272+";");src.push("uniform vec3 sectionPlanePos"+_i272+";");src.push("uniform vec3 sectionPlaneDir"+_i272+";");}}src.push("in vec4 vViewPosition;");src.push("vec4 packDepth(const in float depth) {");src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");src.push("  vec4 res = fract(depth * bitShift);");src.push("  res -= res.xxyz * bitMask;");src.push("  return res;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");src.push("    outColor = packDepth(zNormalizedDepth); ");// Must be linear depth
src.push("}");return src;}}]);return VBOBatchingPointsPickDepthRenderer;}(VBOBatchingPointsRenderer);/**
 * @private
 */var VBOBatchingPointsOcclusionRenderer=/*#__PURE__*/function(_VBOBatchingPointsRen5){_inherits(VBOBatchingPointsOcclusionRenderer,_VBOBatchingPointsRen5);var _super98=_createSuper(VBOBatchingPointsOcclusionRenderer);function VBOBatchingPointsOcclusionRenderer(){_classCallCheck(this,VBOBatchingPointsOcclusionRenderer);return _super98.apply(this,arguments);}_createClass(VBOBatchingPointsOcclusionRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points batching occlusion vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
// Only opaque objects can be occluders
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("  gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points batching occlusion fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i273=0;_i273<sectionPlanesState.getNumAllocatedSectionPlanes();_i273++){src.push("uniform bool sectionPlaneActive"+_i273+";");src.push("uniform vec3 sectionPlanePos"+_i273+";");src.push("uniform vec3 sectionPlaneDir"+_i273+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i274=0;_i274<sectionPlanesState.getNumAllocatedSectionPlanes();_i274++){src.push("      if (sectionPlaneActive"+_i274+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i274+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i274+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); ");// Occluders are blue
src.push("}");return src;}}]);return VBOBatchingPointsOcclusionRenderer;}(VBOBatchingPointsRenderer);var tempVec3a$r=math.vec3();var tempVec3b$n=math.vec3();var tempVec3c$i=math.vec3();var tempVec3d$4=math.vec3();var tempMat4a$i=math.mat4();/**
 * @private
 */var VBOBatchingPointsSnapInitRenderer=/*#__PURE__*/function(_VBORenderer14){_inherits(VBOBatchingPointsSnapInitRenderer,_VBORenderer14);var _super99=_createSuper(VBOBatchingPointsSnapInitRenderer);function VBOBatchingPointsSnapInitRenderer(){_classCallCheck(this,VBOBatchingPointsSnapInitRenderer);return _super99.apply(this,arguments);}_createClass(VBOBatchingPointsSnapInitRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=batchingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=batchingLayer._state;var origin=batchingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=batchingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(batchingLayer)){gl.bindVertexArray(this._vaoCache.get(batchingLayer));}else{this._vaoCache.set(batchingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$r;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$n;if(origin){var rotatedOrigin=tempVec3c$i;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$i);rtcCameraEye=tempVec3d$4;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(batchingLayer);//=============================================================
// TODO: Use drawElements count and offset to draw only one entity
//=============================================================
gl.drawArrays(gl.POINTS,0,state.positionsBuf.numItems);}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOBatchingPointsSnapInitRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBOBatchingPointsSnapInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec4 pickColor;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("      vWorldPosition = worldPosition;");if(clipping){src.push("      vFlags = flags;");}src.push("vPickColor = pickColor;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBOBatchingPointsSnapInitRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("in float vFlags;");for(var _i275=0;_i275<sectionPlanesState.getNumAllocatedSectionPlanes();_i275++){src.push("uniform bool sectionPlaneActive"+_i275+";");src.push("uniform vec3 sectionPlanePos"+_i275+";");src.push("uniform vec3 sectionPlaneDir"+_i275+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");src.push("layout(location = 1) out highp ivec4 outNormal;");src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, -layerNumber);");// src.push("vec3 xTangent = dFdx( vWorldPosition.xyz );");
// src.push("vec3 yTangent = dFdy( vWorldPosition.xyz );");
// src.push("vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");
src.push("outNormal = ivec4(1.0, 1.0, 1.0, 1.0);");src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOBatchingPointsSnapInitRenderer;}(VBORenderer);var tempVec3a$q=math.vec3();var tempVec3b$m=math.vec3();var tempVec3c$h=math.vec3();var tempVec3d$3=math.vec3();var tempMat4a$h=math.mat4();/**
 * @private
 */var VBOBatchingPointsSnapRenderer=/*#__PURE__*/function(_VBORenderer15){_inherits(VBOBatchingPointsSnapRenderer,_VBORenderer15);var _super100=_createSuper(VBOBatchingPointsSnapRenderer);function VBOBatchingPointsSnapRenderer(){_classCallCheck(this,VBOBatchingPointsSnapRenderer);return _super100.apply(this,arguments);}_createClass(VBOBatchingPointsSnapRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,batchingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=batchingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=batchingLayer._state;var origin=batchingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=batchingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(batchingLayer)){gl.bindVertexArray(this._vaoCache.get(batchingLayer));}else{this._vaoCache.set(batchingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$q;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$m;if(origin){var rotatedOrigin=tempVec3c$h;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$h);rtcCameraEye=tempVec3d$3;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(batchingLayer);//=============================================================
// TODO: Use drawElements count and offset to draw only one entity
//=============================================================
gl.drawArrays(gl.POINTS,0,state.positionsBuf.numItems);}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOBatchingPointsSnapRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// VBOBatchingPointsSnapRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// VBOBatchingPointsSnapRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i276=0;_i276<sectionPlanesState.getNumAllocatedSectionPlanes();_i276++){src.push("uniform bool sectionPlaneActive"+_i276+";");src.push("uniform vec3 sectionPlanePos"+_i276+";");src.push("uniform vec3 sectionPlaneDir"+_i276+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, layerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOBatchingPointsSnapRenderer;}(VBORenderer);/**
 * @private
 */var VBOBatchingPointsRenderers=/*#__PURE__*/function(){function VBOBatchingPointsRenderers(scene){_classCallCheck(this,VBOBatchingPointsRenderers);this._scene=scene;}_createClass(VBOBatchingPointsRenderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._pickMeshRenderer&&!this._pickMeshRenderer.getValid()){this._pickMeshRenderer.destroy();this._pickMeshRenderer=null;}if(this._pickDepthRenderer&&!this._pickDepthRenderer.getValid()){this._pickDepthRenderer.destroy();this._pickDepthRenderer=null;}if(this._occlusionRenderer&&this._occlusionRenderer.getValid()===false){this._occlusionRenderer.destroy();this._occlusionRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new VBOBatchingPointsColorRenderer(this._scene);}return this._colorRenderer;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new VBOBatchingPointsSilhouetteRenderer(this._scene);}return this._silhouetteRenderer;}},{key:"pickMeshRenderer",get:function get(){if(!this._pickMeshRenderer){this._pickMeshRenderer=new VBOBatchingPointsPickMeshRenderer(this._scene);}return this._pickMeshRenderer;}},{key:"pickDepthRenderer",get:function get(){if(!this._pickDepthRenderer){this._pickDepthRenderer=new VBOBatchingPointsPickDepthRenderer(this._scene);}return this._pickDepthRenderer;}},{key:"occlusionRenderer",get:function get(){if(!this._occlusionRenderer){this._occlusionRenderer=new VBOBatchingPointsOcclusionRenderer(this._scene);}return this._occlusionRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new VBOBatchingPointsSnapInitRenderer(this._scene,false);}return this._snapInitRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new VBOBatchingPointsSnapRenderer(this._scene);}return this._snapRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._pickMeshRenderer){this._pickMeshRenderer.destroy();}if(this._pickDepthRenderer){this._pickDepthRenderer.destroy();}if(this._occlusionRenderer){this._occlusionRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}}}]);return VBOBatchingPointsRenderers;}();var cachedRenderers$2={};/**
 * @private
 */function getRenderers$3(scene){var sceneId=scene.id;var renderers=cachedRenderers$2[sceneId];if(!renderers){renderers=new VBOBatchingPointsRenderers(scene);cachedRenderers$2[sceneId]=renderers;renderers._compile();scene.on("compile",function(){renderers._compile();});scene.on("destroyed",function(){delete cachedRenderers$2[sceneId];renderers._destroy();});}return renderers;}/**
 * @private
 */var VBOBatchingPointsBuffer=/*#__PURE__*/_createClass(function VBOBatchingPointsBuffer(){var maxGeometryBatchSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5000000;_classCallCheck(this,VBOBatchingPointsBuffer);if(maxGeometryBatchSize>5000000){maxGeometryBatchSize=5000000;}this.maxVerts=maxGeometryBatchSize;this.maxIndices=maxGeometryBatchSize*3;// Rough rule-of-thumb
this.positions=[];this.colors=[];this.intensities=[];this.pickColors=[];this.offsets=[];});/**
 * @private
 */var VBOBatchingPointsLayer=/*#__PURE__*/function(){/**
     * @param model
     * @param cfg
     * @param cfg.layerIndex
     * @param cfg.positionsDecodeMatrix
     * @param cfg.maxGeometryBatchSize
     * @param cfg.origin
     * @param cfg.scratchMemory
     */function VBOBatchingPointsLayer(cfg){_classCallCheck(this,VBOBatchingPointsLayer);console.info("Creating VBOBatchingPointsLayer");/**
         * Owner model
         * @type {VBOSceneModel}
         */this.model=cfg.model;/**
         * State sorting key.
         * @type {string}
         */this.sortId="PointsBatchingLayer";/**
         * Index of this PointsBatchingLayer in {@link VBOSceneModel#_layerList}.
         * @type {Number}
         */this.layerIndex=cfg.layerIndex;this._renderers=getRenderers$3(cfg.model.scene);this._buffer=new VBOBatchingPointsBuffer(cfg.maxGeometryBatchSize);this._scratchMemory=cfg.scratchMemory;this._state=new RenderState({positionsBuf:null,offsetsBuf:null,colorsBuf:null,flagsBuf:null,positionsDecodeMatrix:math.mat4(),origin:null});// These counts are used to avoid unnecessary render passes
this._numPortions=0;this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numSelectedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numClippableLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;this._modelAABB=math.collapseAABB3();// Model-space AABB
this._portions=[];this._meshes=[];this._aabb=math.collapseAABB3();this.aabbDirty=true;this._finalized=false;if(cfg.positionsDecodeMatrix){this._state.positionsDecodeMatrix.set(cfg.positionsDecodeMatrix);this._preCompressedPositionsExpected=true;}else{this._preCompressedPositionsExpected=false;}if(cfg.origin){this._state.origin=math.vec3(cfg.origin);}}_createClass(VBOBatchingPointsLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i277=0,len=this._meshes.length;_i277<len;_i277++){math.expandAABB3(this._aabb,this._meshes[_i277].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Tests if there is room for another portion in this PointsBatchingLayer.
     *
     * @param lenPositions Number of positions we'd like to create in the portion.
     * @returns {Boolean} True if OK to create another portion.
     */},{key:"canCreatePortion",value:function canCreatePortion(lenPositions){if(this._finalized){throw"Already finalized";}return this._buffer.positions.length+lenPositions<this._buffer.maxVerts*3;}/**
     * Creates a new portion within this PointsBatchingLayer, returns the new portion ID.
     *
     * Gives the portion the specified geometry, color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param cfg.positions Flat float Local-space positions array.
     * @param cfg.positionsCompressed Flat quantized positions array - decompressed with PointsBatchingLayer positionsDecodeMatrix
     * @param [cfg.colorsCompressed] Quantized RGB colors [0..255,0..255,0..255,0..255]
     * @param [cfg.colors] Flat float colors array.
     * @param cfg.color Float RGB color [0..1,0..1,0..1]
     * @param [cfg.meshMatrix] Flat float 4x4 matrix
     * @param cfg.aabb Flat float AABB World-space AABB
     * @param cfg.pickColor Quantized pick color
     * @returns {number} Portion ID
     */},{key:"createPortion",value:function createPortion(mesh,cfg){if(this._finalized){throw"Already finalized";}var positions=cfg.positions;var positionsCompressed=cfg.positionsCompressed;var color=cfg.color;var colorsCompressed=cfg.colorsCompressed;var colors=cfg.colors;var pickColor=cfg.pickColor;var buffer=this._buffer;var positionsIndex=buffer.positions.length;var vertsIndex=positionsIndex/3;var numVerts;math.expandAABB3(this._modelAABB,cfg.aabb);if(this._preCompressedPositionsExpected){if(!positionsCompressed){throw"positionsCompressed expected";}for(var _i278=0,len=positionsCompressed.length;_i278<len;_i278++){buffer.positions.push(positionsCompressed[_i278]);}numVerts=positionsCompressed.length/3;}else{if(!positions){throw"positions expected";}numVerts=positions.length/3;positions.length;buffer.positions.length;for(var _i279=0,_len61=positions.length;_i279<_len61;_i279++){buffer.positions.push(positions[_i279]);}}if(colorsCompressed){for(var _i280=0,_len62=colorsCompressed.length;_i280<_len62;_i280++){buffer.colors.push(colorsCompressed[_i280]);}}else if(colors){for(var _i281=0,_len63=colors.length;_i281<_len63;_i281++){buffer.colors.push(colors[_i281]*255);}}else if(color){var _r5=color[0];// Color is pre-quantized by VBOSceneModel
var g=color[1];var b=color[2];var _a4=1.0;for(var _i282=0;_i282<numVerts;_i282++){buffer.colors.push(_r5);buffer.colors.push(g);buffer.colors.push(b);buffer.colors.push(_a4);}}{var pickColorsBase=buffer.pickColors.length;var lenPickColors=numVerts*4;for(var _i283=pickColorsBase,_len64=pickColorsBase+lenPickColors;_i283<_len64;_i283+=4){buffer.pickColors.push(pickColor[0]);buffer.pickColors.push(pickColor[1]);buffer.pickColors.push(pickColor[2]);buffer.pickColors.push(pickColor[3]);}}if(this.model.scene.entityOffsetsEnabled){for(var _i284=0;_i284<numVerts;_i284++){buffer.offsets.push(0);buffer.offsets.push(0);buffer.offsets.push(0);}}var portionId=this._portions.length/2;this._portions.push(vertsIndex);this._portions.push(numVerts);this._numPortions++;this.model.numPortions++;this._meshes.push(mesh);return portionId;}/**
     * Builds batch VBOs from appended geometries.
     * No more portions can then be created.
     */},{key:"finalize",value:function finalize(){if(this._finalized){return;}var state=this._state;var gl=this.model.scene.canvas.gl;var buffer=this._buffer;if(buffer.positions.length>0){if(this._preCompressedPositionsExpected){var positions=new Uint16Array(buffer.positions);state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,positions,buffer.positions.length,3,gl.STATIC_DRAW);}else{var _positions3=new Float32Array(buffer.positions);var quantizedPositions=quantizePositions(_positions3,this._modelAABB,state.positionsDecodeMatrix);state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,quantizedPositions,buffer.positions.length,3,gl.STATIC_DRAW);}}if(buffer.colors.length>0){var colors=new Uint8Array(buffer.colors);var normalized=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colors,buffer.colors.length,4,gl.STATIC_DRAW,normalized);}if(buffer.positions.length>0){// Because we build flags arrays here, get their length from the positions array
var flagsLength=buffer.positions.length/3;var flags=new Float32Array(flagsLength);var notNormalized=false;state.flagsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,flags,flags.length,1,gl.DYNAMIC_DRAW,notNormalized);}if(buffer.pickColors.length>0){var pickColors=new Uint8Array(buffer.pickColors);var _normalized8=false;state.pickColorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,pickColors,buffer.pickColors.length,4,gl.STATIC_DRAW,_normalized8);}if(this.model.scene.entityOffsetsEnabled){if(buffer.offsets.length>0){var offsets=new Float32Array(buffer.offsets);state.offsetsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,offsets,buffer.offsets.length,3,gl.DYNAMIC_DRAW);}}this._buffer=null;this._finalized=true;}},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setVisible",value:function setVisible(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setSelected",value:function setSelected(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setEdges",value:function setEdges(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}// Not applicable to point clouds
}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags(portionId,flags);}},{key:"setCulled",value:function setCulled(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions--;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setColor",value:function setColor(portionId,color){if(!this._finalized){throw"Not finalized";}var portionsIdx=portionId*2;var vertexBase=this._portions[portionsIdx];var numVerts=this._portions[portionsIdx+1];var firstColor=vertexBase*4;var lenColor=numVerts*4;var tempArray=this._scratchMemory.getUInt8Array(lenColor);var r=color[0];var g=color[1];var b=color[2];for(var _i285=0;_i285<lenColor;_i285+=4){tempArray[_i285+0]=r;tempArray[_i285+1]=g;tempArray[_i285+2]=b;}this._state.colorsBuf.setData(tempArray,firstColor,lenColor);}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}/**
     * flags are 4bits values encoded on a 32bit base. color flag on the first 4 bits, silhouette flag on the next 4 bits and so on for edge, pick and clippable.
     */},{key:"_setFlags",value:function _setFlags(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}var portionsIdx=portionId*2;var vertexBase=this._portions[portionsIdx];var numVerts=this._portions[portionsIdx+1];var firstFlag=vertexBase;var lenFlags=numVerts;var tempArray=this._scratchMemory.getFloat32Array(lenFlags);var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);var colorFlag;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){colorFlag=RENDER_PASSES.NOT_RENDERED;}else{if(transparent){colorFlag=RENDER_PASSES.COLOR_TRANSPARENT;}else{colorFlag=RENDER_PASSES.COLOR_OPAQUE;}}var silhouetteFlag;if(!visible||culled){silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){silhouetteFlag=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){silhouetteFlag=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){silhouetteFlag=RENDER_PASSES.SILHOUETTE_XRAYED;}else{silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}var pickFlag=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var clippableFlag=!!(flags&ENTITY_FLAGS.CLIPPABLE)?1:0;for(var _i286=0;_i286<lenFlags;_i286++){var vertFlag=0;vertFlag|=colorFlag;vertFlag|=silhouetteFlag<<4;// no edges
vertFlag|=pickFlag<<12;vertFlag|=clippableFlag<<16;tempArray[_i286]=vertFlag;}this._state.flagsBuf.setData(tempArray,firstFlag);}},{key:"setOffset",value:function setOffset(portionId,offset){if(!this._finalized){throw"Not finalized";}if(!this.model.scene.entityOffsetsEnabled){this.model.error("Entity#offset not enabled for this Viewer");// See Viewer entityOffsetsEnabled
return;}var portionsIdx=portionId*2;var vertexBase=this._portions[portionsIdx];var numVerts=this._portions[portionsIdx+1];var firstOffset=vertexBase*3;var lenOffsets=numVerts*3;var tempArray=this._scratchMemory.getFloat32Array(lenOffsets);var x=offset[0];var y=offset[1];var z=offset[2];for(var _i287=0;_i287<lenOffsets;_i287+=3){tempArray[_i287+0]=x;tempArray[_i287+1]=y;tempArray[_i287+2]=z;}this._state.offsetsBuf.setData(tempArray,firstOffset,lenOffsets);}//-- NORMAL RENDERING ----------------------------------------------------------------------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}// -- RENDERING SAO POST EFFECT TARGETS ----------------------------------------------------------------------------
},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){}// -- EMPHASIS RENDERING -------------------------------------------------------------------------------------------
},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}//-- EDGES RENDERING -----------------------------------------------------------------------------------------------
},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){}//---- PICKING ----------------------------------------------------------------------------------------------------
},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.pickMeshRenderer){this._renderers.pickMeshRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.pickDepthRenderer){this._renderers.pickDepthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}//---- OCCLUSION TESTING -------------------------------------------------------------------------------------------
},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.occlusionRenderer){this._renderers.occlusionRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}//---- SHADOWS -----------------------------------------------------------------------------------------------------
},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){}},{key:"destroy",value:function destroy(){var state=this._state;if(state.positionsBuf){state.positionsBuf.destroy();state.positionsBuf=null;}if(state.offsetsBuf){state.offsetsBuf.destroy();state.offsetsBuf=null;}if(state.colorsBuf){state.colorsBuf.destroy();state.colorsBuf=null;}if(state.flagsBuf){state.flagsBuf.destroy();state.flagsBuf=null;}if(state.pickColorsBuf){state.pickColorsBuf.destroy();state.pickColorsBuf=null;}state.destroy();}}]);return VBOBatchingPointsLayer;}();/**
 * @private
 */var VBOInstancingPointsRenderer=/*#__PURE__*/function(_VBORenderer16){_inherits(VBOInstancingPointsRenderer,_VBORenderer16);var _super101=_createSuper(VBOInstancingPointsRenderer);function VBOInstancingPointsRenderer(scene,withSAO){_classCallCheck(this,VBOInstancingPointsRenderer);return _super101.call(this,scene,withSAO,{instancing:true});}_createClass(VBOInstancingPointsRenderer,[{key:"_draw",value:function _draw(drawCfg){var gl=this._scene.canvas.gl;var state=drawCfg.state,frameCtx=drawCfg.frameCtx,incrementDrawState=drawCfg.incrementDrawState;gl.drawArraysInstanced(gl.POINTS,0,state.positionsBuf.numItems,state.numInstances);if(incrementDrawState){frameCtx.drawArrays++;}}}]);return VBOInstancingPointsRenderer;}(VBORenderer);/**
 * @private
 */var VBOInstancingPointsColorRenderer=/*#__PURE__*/function(_VBOInstancingPointsR){_inherits(VBOInstancingPointsColorRenderer,_VBOInstancingPointsR);var _super102=_createSuper(VBOInstancingPointsColorRenderer);function VBOInstancingPointsColorRenderer(){_classCallCheck(this,VBOInstancingPointsColorRenderer);return _super102.apply(this,arguments);}_createClass(VBOInstancingPointsColorRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,layer,renderPass){_get(_getPrototypeOf(VBOInstancingPointsColorRenderer.prototype),"drawLayer",this).call(this,frameCtx,layer,renderPass,{incrementDrawState:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points instancing color vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");src.push("in vec4 color;");src.push("in float flags;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(pointsMaterial.filterIntensity){src.push("uniform vec2 intensityRange;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");if(pointsMaterial.filterIntensity){src.push("float intensity = float(color.a) / 255.0;");src.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");}src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");if(pointsMaterial.filterIntensity){src.push("}");}src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing color fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i288=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i288<len;_i288++){src.push("uniform bool sectionPlaneActive"+_i288+";");src.push("uniform vec3 sectionPlanePos"+_i288+";");src.push("uniform vec3 sectionPlaneDir"+_i288+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i289=0,_len65=sectionPlanesState.getNumAllocatedSectionPlanes();_i289<_len65;_i289++){src.push("if (sectionPlaneActive"+_i289+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i289+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i289+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}src.push("   outColor = vColor;");if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return VBOInstancingPointsColorRenderer;}(VBOInstancingPointsRenderer);/**
 * @private
 */var VBOInstancingPointsSilhouetteRenderer=/*#__PURE__*/function(_VBOInstancingPointsR2){_inherits(VBOInstancingPointsSilhouetteRenderer,_VBOInstancingPointsR2);var _super103=_createSuper(VBOInstancingPointsSilhouetteRenderer);function VBOInstancingPointsSilhouetteRenderer(){_classCallCheck(this,VBOInstancingPointsSilhouetteRenderer);return _super103.apply(this,arguments);}_createClass(VBOInstancingPointsSilhouetteRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){_get(_getPrototypeOf(VBOInstancingPointsSilhouetteRenderer.prototype),"drawLayer",this).call(this,frameCtx,instancingLayer,renderPass,{colorUniform:true});}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points instancing silhouette vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 color;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}src.push("uniform vec4 silhouetteColor;");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vColor;");src.push("void main(void) {");// silhouetteFlag = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("int silhouetteFlag = int(flags) >> 4 & 0xF;");src.push("if (silhouetteFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("vColor = vec4(float(silhouetteColor.r) / 255.0, float(silhouetteColor.g) / 255.0, float(silhouetteColor.b) / 255.0, float(color.a) / 255.0);");src.push("gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing silhouette fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i290=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i290<len;_i290++){src.push("uniform bool sectionPlaneActive"+_i290+";");src.push("uniform vec3 sectionPlanePos"+_i290+";");src.push("uniform vec3 sectionPlaneDir"+_i290+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i291=0,_len66=sectionPlanesState.getNumAllocatedSectionPlanes();_i291<_len66;_i291++){src.push("if (sectionPlaneActive"+_i291+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i291+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i291+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vColor;");src.push("}");return src;}}]);return VBOInstancingPointsSilhouetteRenderer;}(VBOInstancingPointsRenderer);/**
 * @private
 */var VBOInstancingPointsPickMeshRenderer=/*#__PURE__*/function(_VBOInstancingPointsR3){_inherits(VBOInstancingPointsPickMeshRenderer,_VBOInstancingPointsR3);var _super104=_createSuper(VBOInstancingPointsPickMeshRenderer);function VBOInstancingPointsPickMeshRenderer(){_classCallCheck(this,VBOInstancingPointsPickMeshRenderer);return _super104.apply(this,arguments);}_createClass(VBOInstancingPointsPickMeshRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points instancing pick mesh vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 pickColor;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vPickColor;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("gl_Position = remapClipPos(clipPos);");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing pick mesh fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i292=0;_i292<sectionPlanesState.getNumAllocatedSectionPlanes();_i292++){src.push("uniform bool sectionPlaneActive"+_i292+";");src.push("uniform vec3 sectionPlanePos"+_i292+";");src.push("uniform vec3 sectionPlaneDir"+_i292+";");}}src.push("in vec4 vPickColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i293=0;_i293<sectionPlanesState.getNumAllocatedSectionPlanes();_i293++){src.push("if (sectionPlaneActive"+_i293+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i293+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i293+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outColor = vPickColor; ");src.push("}");return src;}}]);return VBOInstancingPointsPickMeshRenderer;}(VBOInstancingPointsRenderer);/**
 * @private
 */var VBOInstancingPointsPickDepthRenderer=/*#__PURE__*/function(_VBOInstancingPointsR4){_inherits(VBOInstancingPointsPickDepthRenderer,_VBOInstancingPointsR4);var _super105=_createSuper(VBOInstancingPointsPickDepthRenderer);function VBOInstancingPointsPickDepthRenderer(){_classCallCheck(this,VBOInstancingPointsPickDepthRenderer);return _super105.apply(this,arguments);}_createClass(VBOInstancingPointsPickDepthRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points instancing pick depth vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);this._addRemapClipPosLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out vec4 vViewPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("  vViewPosition = viewPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("gl_Position = remapClipPos(clipPos);");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = remapClipPos(clipPos);");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform float pickZNear;");src.push("uniform float pickZFar;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i294=0;_i294<sectionPlanesState.getNumAllocatedSectionPlanes();_i294++){src.push("uniform bool sectionPlaneActive"+_i294+";");src.push("uniform vec3 sectionPlanePos"+_i294+";");src.push("uniform vec3 sectionPlaneDir"+_i294+";");}}src.push("in vec4 vViewPosition;");src.push("vec4 packDepth(const in float depth) {");src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");src.push("  vec4 res = fract(depth * bitShift);");src.push("  res -= res.xxyz * bitMask;");src.push("  return res;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i295=0;_i295<sectionPlanesState.getNumAllocatedSectionPlanes();_i295++){src.push("if (sectionPlaneActive"+_i295+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i295+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i295+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");src.push("    outColor = packDepth(zNormalizedDepth); ");// Must be linear depth
src.push("}");return src;}}]);return VBOInstancingPointsPickDepthRenderer;}(VBOInstancingPointsRenderer);/**
 * @private
 */var VBOInstancingPointsOcclusionRenderer=/*#__PURE__*/function(_VBOInstancingPointsR5){_inherits(VBOInstancingPointsOcclusionRenderer,_VBOInstancingPointsR5);var _super106=_createSuper(VBOInstancingPointsOcclusionRenderer);function VBOInstancingPointsOcclusionRenderer(){_classCallCheck(this,VBOInstancingPointsOcclusionRenderer);return _super106.apply(this,arguments);}_createClass(VBOInstancingPointsOcclusionRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points instancing occlusion vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 color;");src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing occlusion vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i296=0;_i296<sectionPlanesState.getNumAllocatedSectionPlanes();_i296++){src.push("uniform bool sectionPlaneActive"+_i296+";");src.push("uniform vec3 sectionPlanePos"+_i296+";");src.push("uniform vec3 sectionPlaneDir"+_i296+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i297=0;_i297<sectionPlanesState.getNumAllocatedSectionPlanes();_i297++){src.push("if (sectionPlaneActive"+_i297+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i297+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i297+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}src.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); ");// Occluders are blue
if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return VBOInstancingPointsOcclusionRenderer;}(VBOInstancingPointsRenderer);/**
 * @private
 */var VBOInstancingPointsDepthRenderer=/*#__PURE__*/function(_VBOInstancingPointsR6){_inherits(VBOInstancingPointsDepthRenderer,_VBOInstancingPointsR6);var _super107=_createSuper(VBOInstancingPointsDepthRenderer);function VBOInstancingPointsDepthRenderer(){_classCallCheck(this,VBOInstancingPointsDepthRenderer);return _super107.apply(this,arguments);}_createClass(VBOInstancingPointsDepthRenderer,[{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash()+this._scene.pointsMaterial.hash;}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var pointsMaterial=scene.pointsMaterial._state;var src=[];src.push('#version 300 es');src.push("// Points instancing depth vertex shader");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(pointsMaterial.perspectivePoints){src.push("uniform float nearPlaneHeight;");}if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");// colorFlag = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("int colorFlag = int(flags) & 0xF;");src.push("if (colorFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");}src.push("gl_Position = clipPos;");if(pointsMaterial.perspectivePoints){src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");src.push("gl_PointSize = max(gl_PointSize, "+Math.floor(pointsMaterial.minPerspectivePointSize)+".0);");src.push("gl_PointSize = min(gl_PointSize, "+Math.floor(pointsMaterial.maxPerspectivePointSize)+".0);");}else{src.push("gl_PointSize = pointSize;");}src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var i;var len;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing depth vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("const float   packUpScale = 256. / 255.;");src.push("const float   unpackDownscale = 255. / 256.;");src.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );");src.push("const float   shiftRight8 = 1.0 / 256.;");src.push("vec4 packDepthToRGBA( const in float v ) {");src.push("    vec4 r = vec4( fract( v * packFactors ), v );");src.push("    r.yzw -= r.xyz * shiftRight8;");src.push("    return r * packUpScale;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");if(scene.pointsMaterial.roundPoints){src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");}if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();i<len;i++){src.push("if (sectionPlaneActive"+i+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}src.push("    outColor = packDepthToRGBA( gl_FragCoord.z); ");// Must be linear depth
if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("}");return src;}}]);return VBOInstancingPointsDepthRenderer;}(VBOInstancingPointsRenderer);/**
 * Renders InstancingLayer fragment depths to a shadow map.
 *
 * @private
 */var VBOInstancingPointsShadowRenderer=/*#__PURE__*/function(_VBOInstancingPointsR7){_inherits(VBOInstancingPointsShadowRenderer,_VBOInstancingPointsR7);var _super108=_createSuper(VBOInstancingPointsShadowRenderer);function VBOInstancingPointsShadowRenderer(){_classCallCheck(this,VBOInstancingPointsShadowRenderer);return _super108.apply(this,arguments);}_createClass(VBOInstancingPointsShadowRenderer,[{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Instancing geometry shadow drawing vertex shader");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in vec4 color;");src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform mat4 shadowViewMatrix;");src.push("uniform mat4 shadowProjMatrix;");this._addMatricesUniformBlockLines(src);src.push("uniform float pointSize;");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("void main(void) {");src.push("int colorFlag     = int(flags) & 0xF;");src.push("bool visible      = (colorFlag > 0);");src.push("bool transparent  = ((float(color.a) / 255.0) < 1.0);");src.push("if (!visible || transparent) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("  vec4 viewPosition  = shadowViewMatrix * worldPosition; ");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags = flags;");}src.push("  gl_Position = shadowProjMatrix * viewPosition;");src.push("}");src.push("gl_PointSize = pointSize;");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Instancing geometry depth drawing fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i298=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i298<len;_i298++){src.push("uniform bool sectionPlaneActive"+_i298+";");src.push("uniform vec3 sectionPlanePos"+_i298+";");src.push("uniform vec3 sectionPlaneDir"+_i298+";");}}src.push("in vec3 vViewNormal;");src.push("vec3 packNormalToRGB( const in vec3 normal ) {");src.push("    return normalize( normal ) * 0.5 + 0.5;");src.push("}");src.push("out vec4 outColor;");src.push("void main(void) {");src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("  float r = dot(cxy, cxy);");src.push("  if (r > 1.0) {");src.push("       discard;");src.push("  }");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i299=0,_len67=sectionPlanesState.getNumAllocatedSectionPlanes();_i299<_len67;_i299++){src.push("if (sectionPlaneActive"+_i299+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i299+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i299+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");src.push("}");return src;}}]);return VBOInstancingPointsShadowRenderer;}(VBOInstancingPointsRenderer);var tempVec3a$p=math.vec3();var tempVec3b$l=math.vec3();var tempVec3c$g=math.vec3();math.vec3();var tempMat4a$g=math.mat4();/**
 * @private
 */var VBOInstancingPointsSnapInitRenderer=/*#__PURE__*/function(_VBORenderer17){_inherits(VBOInstancingPointsSnapInitRenderer,_VBORenderer17);var _super109=_createSuper(VBOInstancingPointsSnapInitRenderer);function VBOInstancingPointsSnapInitRenderer(scene){_classCallCheck(this,VBOInstancingPointsSnapInitRenderer);return _super109.call(this,scene,false,{instancing:true});}_createClass(VBOInstancingPointsSnapInitRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=instancingLayer.model;var scene=model.scene;var gl=scene.canvas.gl;var camera=scene.camera;var state=instancingLayer._state;var origin=instancingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=instancingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(instancingLayer)){gl.bindVertexArray(this._vaoCache.get(instancingLayer));}else{this._vaoCache.set(instancingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$p;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$l;if(origin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$g);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$g);frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(instancingLayer);this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);if(this._aFlags){this._aFlags.bindArrayBuffer(state.flagsBuf);gl.vertexAttribDivisor(this._aFlags.location,1);}gl.drawArraysInstanced(gl.POINTS,0,state.positionsBuf.numItems,state.numInstances);// Cleanup
gl.vertexAttribDivisor(this._aModelMatrixCol0.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,0);if(this._aFlags){gl.vertexAttribDivisor(this._aFlags.location,0);}if(this._aOffset){gl.vertexAttribDivisor(this._aOffset.location,0);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOInstancingPointsSnapInitRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthBufInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec4 pickColor;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("  vWorldPosition = worldPosition;");if(clipping){src.push("  vFlags = flags;");}src.push("vPickColor = pickColor;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Points instancing pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("in float vFlags;");for(var _i300=0;_i300<sectionPlanesState.getNumAllocatedSectionPlanes();_i300++){src.push("uniform bool sectionPlaneActive"+_i300+";");src.push("uniform vec3 sectionPlanePos"+_i300+";");src.push("uniform vec3 sectionPlaneDir"+_i300+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");src.push("layout(location = 1) out highp ivec4 outNormal;");src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i301=0;_i301<sectionPlanesState.getNumAllocatedSectionPlanes();_i301++){src.push("if (sectionPlaneActive"+_i301+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i301+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i301+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, -layerNumber);");// src.push("vec3 xTangent = dFdx( vWorldPosition.xyz );");
// src.push("vec3 yTangent = dFdy( vWorldPosition.xyz );");
// src.push("vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");
src.push("outNormal = ivec4(1.0, 1.0, 1.0, 1.0);");src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOInstancingPointsSnapInitRenderer;}(VBORenderer);var tempVec3a$o=math.vec3();var tempVec3b$k=math.vec3();var tempVec3c$f=math.vec3();math.vec3();var tempMat4a$f=math.mat4();/**
 * @private
 */var VBOInstancingPointsSnapRenderer=/*#__PURE__*/function(_VBORenderer18){_inherits(VBOInstancingPointsSnapRenderer,_VBORenderer18);var _super110=_createSuper(VBOInstancingPointsSnapRenderer);function VBOInstancingPointsSnapRenderer(scene){_classCallCheck(this,VBOInstancingPointsSnapRenderer);return _super110.call(this,scene,false,{instancing:true});}_createClass(VBOInstancingPointsSnapRenderer,[{key:"drawLayer",value:function drawLayer(frameCtx,instancingLayer,renderPass){if(!this._program){this._allocate(instancingLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=instancingLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=instancingLayer._state;var origin=instancingLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=instancingLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(this._vaoCache.has(instancingLayer)){gl.bindVertexArray(this._vaoCache.get(instancingLayer));}else{this._vaoCache.set(instancingLayer,this._makeVAO(state));}var coordinateScaler=tempVec3a$o;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);var rtcViewMatrix;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3b$k;if(origin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$f);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$f);frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);var offset=0;var mat4Size=4*4;this._matricesUniformBlockBufferData.set(rotationMatrixConjugate,0);this._matricesUniformBlockBufferData.set(rtcViewMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(camera.projMatrix,offset+=mat4Size);this._matricesUniformBlockBufferData.set(state.positionsDecodeMatrix,offset+=mat4Size);gl.bindBuffer(gl.UNIFORM_BUFFER,this._matricesUniformBlockBuffer);gl.bufferData(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferData,gl.DYNAMIC_DRAW);gl.bindBufferBase(gl.UNIFORM_BUFFER,this._matricesUniformBlockBufferBindingPoint,this._matricesUniformBlockBuffer);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}this.setSectionPlanesStateUniforms(instancingLayer);this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);gl.vertexAttribDivisor(this._aModelMatrixCol0.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,1);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,1);this._aFlags.bindArrayBuffer(state.flagsBuf);gl.vertexAttribDivisor(this._aFlags.location,1);gl.drawArraysInstanced(gl.POINTS,0,state.positionsBuf.numItems,state.numInstances);// Cleanup
gl.vertexAttribDivisor(this._aModelMatrixCol0.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol1.location,0);gl.vertexAttribDivisor(this._aModelMatrixCol2.location,0);gl.vertexAttribDivisor(this._aFlags.location,0);if(this._aOffset){gl.vertexAttribDivisor(this._aOffset.location,0);}}},{key:"_allocate",value:function _allocate(){_get(_getPrototypeOf(VBOInstancingPointsSnapRenderer.prototype),"_allocate",this).call(this);var program=this._program;{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uVectorA=program.getLocation("snapVectorA");this.uInverseVectorAB=program.getLocation("snapInvVectorAB");this._uLayerNumber=program.getLocation("layerNumber");this._uCoordinateScaler=program.getLocation("coordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("in vec3 position;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("in float flags;");src.push("in vec4 modelMatrixCol0;");// Modeling matrix
src.push("in vec4 modelMatrixCol1;");src.push("in vec4 modelMatrixCol2;");src.push("uniform bool pickInvisible;");this._addMatricesUniformBlockLines(src);src.push("uniform vec2 snapVectorA;");src.push("uniform vec2 snapInvVectorAB;");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - snapVectorA.x) * snapInvVectorAB.x;");src.push("    float y = (clipPos.y - snapVectorA.y) * snapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out float vFlags;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("int pickFlag = int(flags) >> 12 & 0xF;");src.push("if (pickFlag != renderPass) {");src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("} else {");src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags = flags;");}src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// SnapInstancingDepthRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int layerNumber;");src.push("uniform vec3 coordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("in float vFlags;");for(var _i302=0;_i302<sectionPlanesState.getNumAllocatedSectionPlanes();_i302++){src.push("uniform bool sectionPlaneActive"+_i302+";");src.push("uniform vec3 sectionPlanePos"+_i302+";");src.push("uniform vec3 sectionPlaneDir"+_i302+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (int(vFlags) >> 16 & 0xF) == 1;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i303=0;_i303<sectionPlanesState.getNumAllocatedSectionPlanes();_i303++){src.push("if (sectionPlaneActive"+_i303+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i303+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i303+".xyz), 0.0, 1000.0);");src.push("}");}src.push("if (dist > 0.0) { discard; }");src.push("}");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz*coordinateScaler.xyz, layerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return VBOInstancingPointsSnapRenderer;}(VBORenderer);/**
 * @private
 */var VBOInstancingPointsRenderers=/*#__PURE__*/function(){function VBOInstancingPointsRenderers(scene){_classCallCheck(this,VBOInstancingPointsRenderers);this._scene=scene;}_createClass(VBOInstancingPointsRenderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._depthRenderer&&!this._depthRenderer.getValid()){this._depthRenderer.destroy();this._depthRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._pickMeshRenderer&&!this._pickMeshRenderer.getValid()){this._pickMeshRenderer.destroy();this._pickMeshRenderer=null;}if(this._pickDepthRenderer&&!this._pickDepthRenderer.getValid()){this._pickDepthRenderer.destroy();this._pickDepthRenderer=null;}if(this._occlusionRenderer&&this._occlusionRenderer.getValid()===false){this._occlusionRenderer.destroy();this._occlusionRenderer=null;}if(this._shadowRenderer&&!this._shadowRenderer.getValid()){this._shadowRenderer.destroy();this._shadowRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new VBOInstancingPointsColorRenderer(this._scene,false);}return this._colorRenderer;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new VBOInstancingPointsSilhouetteRenderer(this._scene);}return this._silhouetteRenderer;}},{key:"depthRenderer",get:function get(){if(!this._depthRenderer){this._depthRenderer=new VBOInstancingPointsDepthRenderer(this._scene);}return this._depthRenderer;}},{key:"pickMeshRenderer",get:function get(){if(!this._pickMeshRenderer){this._pickMeshRenderer=new VBOInstancingPointsPickMeshRenderer(this._scene);}return this._pickMeshRenderer;}},{key:"pickDepthRenderer",get:function get(){if(!this._pickDepthRenderer){this._pickDepthRenderer=new VBOInstancingPointsPickDepthRenderer(this._scene);}return this._pickDepthRenderer;}},{key:"occlusionRenderer",get:function get(){if(!this._occlusionRenderer){this._occlusionRenderer=new VBOInstancingPointsOcclusionRenderer(this._scene);}return this._occlusionRenderer;}},{key:"shadowRenderer",get:function get(){if(!this._shadowRenderer){this._shadowRenderer=new VBOInstancingPointsShadowRenderer(this._scene);}return this._shadowRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new VBOInstancingPointsSnapInitRenderer(this._scene,false);}return this._snapInitRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new VBOInstancingPointsSnapRenderer(this._scene);}return this._snapRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._depthRenderer){this._depthRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._pickMeshRenderer){this._pickMeshRenderer.destroy();}if(this._pickDepthRenderer){this._pickDepthRenderer.destroy();}if(this._occlusionRenderer){this._occlusionRenderer.destroy();}if(this._shadowRenderer){this._shadowRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}}}]);return VBOInstancingPointsRenderers;}();var cachedRenderers$1={};/**
 * @private
 */function getRenderers$2(scene){var sceneId=scene.id;var instancingRenderers=cachedRenderers$1[sceneId];if(!instancingRenderers){instancingRenderers=new VBOInstancingPointsRenderers(scene);cachedRenderers$1[sceneId]=instancingRenderers;instancingRenderers._compile();scene.on("compile",function(){instancingRenderers._compile();});scene.on("destroyed",function(){delete cachedRenderers$1[sceneId];instancingRenderers._destroy();});}return instancingRenderers;}var tempUint8Vec4=new Uint8Array(4);var tempFloat32=new Float32Array(1);var tempVec3fa=new Float32Array(3);var tempFloat32Vec4=new Float32Array(4);/**
 * @private
 */var VBOInstancingPointsLayer=/*#__PURE__*/function(){/**
     * @param cfg
     * @param cfg.layerIndex
     * @param cfg.model
     * @param cfg.geometry
     * @param cfg.material
     * @param cfg.origin
     */function VBOInstancingPointsLayer(cfg){_classCallCheck(this,VBOInstancingPointsLayer);console.info("VBOInstancingPointsLayer");/**
         * Owner model
         * @type {VBOSceneModel}
         */this.model=cfg.model;/**
         * Shared material
         * @type {VBOSceneModelGeometry}
         */this.material=cfg.material;/**
         * State sorting key.
         * @type {string}
         */this.sortId="PointsInstancingLayer";/**
         * Index of this InstancingLayer in VBOSceneModel#_layerList
         * @type {Number}
         */this.layerIndex=cfg.layerIndex;this._renderers=getRenderers$2(cfg.model.scene);this._aabb=math.collapseAABB3();this._state=new RenderState({obb:math.OBB3(),numInstances:0,origin:cfg.origin?math.vec3(cfg.origin):null,geometry:cfg.geometry,positionsDecodeMatrix:cfg.geometry.positionsDecodeMatrix,// So we can null the geometry for GC
colorsBuf:null,flagsBuf:null,offsetsBuf:null,modelMatrixCol0Buf:null,modelMatrixCol1Buf:null,modelMatrixCol2Buf:null,pickColorsBuf:null});// These counts are used to avoid unnecessary render passes
this._numPortions=0;this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numSelectedLayerPortions=0;this._numClippableLayerPortions=0;this._numEdgesLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;/** @private */this.numIndices=cfg.geometry.numIndices;// Per-instance arrays
this._pickColors=[];this._offsets=[];// Modeling matrix per instance, array for each column
this._modelMatrixCol0=[];this._modelMatrixCol1=[];this._modelMatrixCol2=[];this._portions=[];this._meshes=[];this._aabb=math.collapseAABB3();this.aabbDirty=true;this._finalized=false;}_createClass(VBOInstancingPointsLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i304=0,len=this._meshes.length;_i304<len;_i304++){math.expandAABB3(this._aabb,this._meshes[_i304].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Creates a new portion within this InstancingLayer, returns the new portion ID.
     *
     * The portion will instance this InstancingLayer's geometry.
     *
     * Gives the portion the specified color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param cfg Portion params
     * @param cfg.meshMatrix Flat float 4x4 matrix.
     * @param [cfg.worldMatrix] Flat float 4x4 matrix.
     * @param cfg.pickColor Quantized pick color
     * @returns {number} Portion ID.
     */},{key:"createPortion",value:function createPortion(mesh,cfg){var meshMatrix=cfg.meshMatrix;var pickColor=cfg.pickColor;if(this._finalized){throw"Already finalized";}if(this.model.scene.entityOffsetsEnabled){this._offsets.push(0);this._offsets.push(0);this._offsets.push(0);}this._modelMatrixCol0.push(meshMatrix[0]);this._modelMatrixCol0.push(meshMatrix[4]);this._modelMatrixCol0.push(meshMatrix[8]);this._modelMatrixCol0.push(meshMatrix[12]);this._modelMatrixCol1.push(meshMatrix[1]);this._modelMatrixCol1.push(meshMatrix[5]);this._modelMatrixCol1.push(meshMatrix[9]);this._modelMatrixCol1.push(meshMatrix[13]);this._modelMatrixCol2.push(meshMatrix[2]);this._modelMatrixCol2.push(meshMatrix[6]);this._modelMatrixCol2.push(meshMatrix[10]);this._modelMatrixCol2.push(meshMatrix[14]);// Per-instance pick colors
this._pickColors.push(pickColor[0]);this._pickColors.push(pickColor[1]);this._pickColors.push(pickColor[2]);this._pickColors.push(pickColor[3]);this._state.numInstances++;var portionId=this._portions.length;this._portions.push({});this._numPortions++;this.model.numPortions++;this._meshes.push(mesh);return portionId;}},{key:"finalize",value:function finalize(){if(this._finalized){throw"Already finalized";}var gl=this.model.scene.canvas.gl;var flagsLength=this._pickColors.length/4;var state=this._state;var geometry=state.geometry;if(flagsLength>0){// Because we only build flags arrays here, 
// get their length from the colors array
var notNormalized=false;state.flagsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(flagsLength),flagsLength,1,gl.DYNAMIC_DRAW,notNormalized);}if(this.model.scene.entityOffsetsEnabled){if(this._offsets.length>0){var _notNormalized9=false;state.offsetsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._offsets),this._offsets.length,3,gl.DYNAMIC_DRAW,_notNormalized9);this._offsets=[];// Release memory
}}if(geometry.positionsCompressed&&geometry.positionsCompressed.length>0){var normalized=false;state.positionsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,geometry.positionsCompressed,geometry.positionsCompressed.length,3,gl.STATIC_DRAW,normalized);state.positionsDecodeMatrix=math.mat4(geometry.positionsDecodeMatrix);}if(geometry.colorsCompressed&&geometry.colorsCompressed.length>0){var colorsCompressed=new Uint8Array(geometry.colorsCompressed);var _notNormalized10=false;state.colorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,colorsCompressed,colorsCompressed.length,4,gl.STATIC_DRAW,_notNormalized10);}if(this._modelMatrixCol0.length>0){var _normalized9=false;state.modelMatrixCol0Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol0),this._modelMatrixCol0.length,4,gl.STATIC_DRAW,_normalized9);state.modelMatrixCol1Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol1),this._modelMatrixCol1.length,4,gl.STATIC_DRAW,_normalized9);state.modelMatrixCol2Buf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Float32Array(this._modelMatrixCol2),this._modelMatrixCol2.length,4,gl.STATIC_DRAW,_normalized9);this._modelMatrixCol0=[];this._modelMatrixCol1=[];this._modelMatrixCol2=[];}if(this._pickColors.length>0){var _normalized10=false;state.pickColorsBuf=new ArrayBuf(gl,gl.ARRAY_BUFFER,new Uint8Array(this._pickColors),this._pickColors.length,4,gl.STATIC_DRAW,_normalized10);this._pickColors=[];// Release memory
}state.geometry=null;this._finalized=true;}// The following setters are called by VBOSceneModelMesh, in turn called by VBOSceneModelNode, only after the layer is finalized.
// It's important that these are called after finalize() in order to maintain integrity of counts like _numVisibleLayerPortions etc.
},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setVisible",value:function setVisible(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setSelected",value:function setSelected(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setEdges",value:function setEdges(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}else{this._numEdgesLayerPortions--;this.model.numEdgesLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags(portionId,flags);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setCulled",value:function setCulled(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions--;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,meshTransparent);}},{key:"setColor",value:function setColor(portionId,color){// RGBA color is normalized as ints
if(!this._finalized){throw"Not finalized";}tempUint8Vec4[0]=color[0];tempUint8Vec4[1]=color[1];tempUint8Vec4[2]=color[2];this._state.colorsBuf.setData(tempUint8Vec4,portionId*3);}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}// setMatrix(portionId, matrix) {
////////////////////////////////////////
// TODO: Update portion matrix
////////////////////////////////////////
//
//     if (!this._finalized) {
//         throw "Not finalized";
//     }
//
//     var offset = portionId * 4;
//
//     tempFloat32Vec4[0] = matrix[0];
//     tempFloat32Vec4[1] = matrix[4];
//     tempFloat32Vec4[2] = matrix[8];
//     tempFloat32Vec4[3] = matrix[12];
//
//     this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4, offset);
//
//     tempFloat32Vec4[0] = matrix[1];
//     tempFloat32Vec4[1] = matrix[5];
//     tempFloat32Vec4[2] = matrix[9];
//     tempFloat32Vec4[3] = matrix[13];
//
//     this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4, offset);
//
//     tempFloat32Vec4[0] = matrix[2];
//     tempFloat32Vec4[1] = matrix[6];
//     tempFloat32Vec4[2] = matrix[10];
//     tempFloat32Vec4[3] = matrix[14];
//
//     this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4, offset);
// }
/**
     * flags are 4bits values encoded on a 32bit base. color flag on the first 4 bits, silhouette flag on the next 4 bits and so on for edge, pick and clippable.
     */},{key:"_setFlags",value:function _setFlags(portionId,flags,meshTransparent){if(!this._finalized){throw"Not finalized";}var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var edges=!!(flags&ENTITY_FLAGS.EDGES);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);var colorFlag;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){colorFlag=RENDER_PASSES.NOT_RENDERED;}else{if(meshTransparent){colorFlag=RENDER_PASSES.COLOR_TRANSPARENT;}else{colorFlag=RENDER_PASSES.COLOR_OPAQUE;}}var silhouetteFlag;if(!visible||culled){silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){silhouetteFlag=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){silhouetteFlag=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){silhouetteFlag=RENDER_PASSES.SILHOUETTE_XRAYED;}else{silhouetteFlag=RENDER_PASSES.NOT_RENDERED;}var edgeFlag=0;if(!visible||culled){edgeFlag=RENDER_PASSES.NOT_RENDERED;}else if(selected){edgeFlag=RENDER_PASSES.EDGES_SELECTED;}else if(highlighted){edgeFlag=RENDER_PASSES.EDGES_HIGHLIGHTED;}else if(xrayed){edgeFlag=RENDER_PASSES.EDGES_XRAYED;}else if(edges){if(meshTransparent){edgeFlag=RENDER_PASSES.EDGES_COLOR_TRANSPARENT;}else{edgeFlag=RENDER_PASSES.EDGES_COLOR_OPAQUE;}}else{edgeFlag=RENDER_PASSES.NOT_RENDERED;}var pickFlag=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var clippableFlag=!!(flags&ENTITY_FLAGS.CLIPPABLE)?255:0;var vertFlag=0;vertFlag|=colorFlag;vertFlag|=silhouetteFlag<<4;vertFlag|=edgeFlag<<8;vertFlag|=pickFlag<<12;vertFlag|=clippableFlag<<16;tempFloat32[0]=vertFlag;this._state.flagsBuf.setData(tempFloat32,portionId);}},{key:"setOffset",value:function setOffset(portionId,offset){if(!this._finalized){throw"Not finalized";}if(!this.model.scene.entityOffsetsEnabled){this.model.error("Entity#offset not enabled for this Viewer");// See Viewer entityOffsetsEnabled
return;}tempVec3fa[0]=offset[0];tempVec3fa[1]=offset[1];tempVec3fa[2]=offset[2];this._state.offsetsBuf.setData(tempVec3fa,portionId*3);}},{key:"setMatrix",value:function setMatrix(portionId,matrix){if(!this._finalized){throw"Not finalized";}var offset=portionId*4;tempFloat32Vec4[0]=matrix[0];tempFloat32Vec4[1]=matrix[4];tempFloat32Vec4[2]=matrix[8];tempFloat32Vec4[3]=matrix[12];this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4,offset);tempFloat32Vec4[0]=matrix[1];tempFloat32Vec4[1]=matrix[5];tempFloat32Vec4[2]=matrix[9];tempFloat32Vec4[3]=matrix[13];this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4,offset);tempFloat32Vec4[0]=matrix[2];tempFloat32Vec4[1]=matrix[6];tempFloat32Vec4[2]=matrix[10];tempFloat32Vec4[3]=matrix[14];this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4,offset);}// ---------------------- NORMAL RENDERING -----------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}// -- RENDERING SAO POST EFFECT TARGETS ----------------------------------------------------------------------------
},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){}// ---------------------- EMPHASIS RENDERING -----------------------------------
},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}//-- EDGES RENDERING -----------------------------------------------------------------------------------------------
},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){}// ---------------------- OCCLUSION CULL RENDERING -----------------------------------
},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.occlusionRenderer){// Only opaque, filled objects can be occluders
this._renderers.occlusionRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}// ---------------------- SHADOW BUFFER RENDERING -----------------------------------
},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){}//---- PICKING ----------------------------------------------------------------------------------------------------
},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.pickMeshRenderer){this._renderers.pickMeshRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.pickDepthRenderer){this._renderers.pickDepthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"destroy",value:function destroy(){var state=this._state;if(state.colorsBuf){state.colorsBuf.destroy();state.colorsBuf=null;}if(state.flagsBuf){state.flagsBuf.destroy();state.flagsBuf=null;}if(state.offsetsBuf){state.offsetsBuf.destroy();state.offsetsBuf=null;}if(state.modelMatrixCol0Buf){state.modelMatrixCol0Buf.destroy();state.modelMatrixCol0Buf=null;}if(state.modelMatrixCol1Buf){state.modelMatrixCol1Buf.destroy();state.modelMatrixCol1Buf=null;}if(state.modelMatrixCol2Buf){state.modelMatrixCol2Buf.destroy();state.modelMatrixCol2Buf=null;}if(state.pickColorsBuf){state.pickColorsBuf.destroy();state.pickColorsBuf=null;}state.destroy();}}]);return VBOInstancingPointsLayer;}();var tempVec3a$n=math.vec3();var tempVec3b$j=math.vec3();var tempMat4a$e=math.mat4();/**
 * @private
 */var DTXLinesColorRenderer=/*#__PURE__*/function(){function DTXLinesColorRenderer(scene){_classCallCheck(this,DTXLinesColorRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXLinesColorRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var scene=this._scene;var camera=scene.camera;var model=dataTextureLayer.model;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=camera.viewMatrix;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx,state);}textureState.bindCommonTextures(this._program,this.uPerObjectDecodeMatrix,this._uPerVertexPosition,this.uPerObjectColorAndFlags,this._uPerObjectMatrix);var rtcViewMatrix;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$n;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$j);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$e);}else{rtcViewMatrix=viewMatrix;}gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);gl.uniform1i(this._uRenderPass,renderPass);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$n);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindLineIndicesTextures(this._program,this._uPerLineObject,this._uPerLineIndices,8// 8 bits indices
);gl.drawArrays(gl.LINES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindLineIndicesTextures(this._program,this._uPerLineObject,this._uPerLineIndices,16// 16 bits indices
);gl.drawArrays(gl.LINES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindLineIndicesTextures(this._program,this._uPerLineObject,this._uPerLineIndices,32// 32 bits indices
);gl.drawArrays(gl.LINES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;console.error(this.errors);return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i305=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i305<len;_i305++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i305),pos:program.getLocation("sectionPlanePos"+_i305),dir:program.getLocation("sectionPlaneDir"+_i305)});}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uPerObjectDecodeMatrix="uPerObjectDecodeMatrix";this.uPerObjectColorAndFlags="uPerObjectColorAndFlags";this._uPerVertexPosition="uPerVertexPosition";this._uPerLineIndices="uPerLineIndices";this._uPerLineObject="uPerLineObject";this._uPerObjectMatrix="uPerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var project=scene.camera.project;program.bind();if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// LinesDataTextureColorRenderer");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled);src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uPerObjectDecodeMatrix;");src.push("uniform highp sampler2D uPerObjectMatrix;");src.push("uniform lowp usampler2D uPerObjectColorAndFlags;");src.push("uniform mediump usampler2D uPerVertexPosition;");src.push("uniform highp usampler2D uPerLineIndices;");src.push("uniform mediump usampler2D uPerLineObject;");//  src.push("uniform vec4 color;");
if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("out vec4 vColor;");src.push("void main(void) {");src.push("  int lineIndex = gl_VertexID / 2;");src.push("  int h_packed_object_id_index = (lineIndex >> 3) & 4095;");src.push("  int v_packed_object_id_index = (lineIndex >> 3) >> 12;");src.push("  int objectIndex = int(texelFetch(uPerLineObject, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("  ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");src.push("  uvec4 flags = texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("  uvec4 flags2 = texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("  if (int(flags.x) != renderPass) {");src.push("      gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("      return;");// Cull vertex
src.push("  } else {");src.push("      ivec4 packedVertexBase = ivec4(texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("      ivec4 packedLineIndexBaseOffset = ivec4(texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+6, objectIndexCoords.y), 0));");src.push("      int lineIndexBaseOffset = (packedLineIndexBaseOffset.r << 24) + (packedLineIndexBaseOffset.g << 16) + (packedLineIndexBaseOffset.b << 8) + packedLineIndexBaseOffset.a;");src.push("      int h_index = (lineIndex - lineIndexBaseOffset) & 4095;");src.push("      int v_index = (lineIndex - lineIndexBaseOffset) >> 12;");src.push("      ivec3 vertexIndices = ivec3(texelFetch(uPerLineIndices, ivec2(h_index, v_index), 0));");src.push("      ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("      int indexPositionH = uniqueVertexIndexes[gl_VertexID % 2] & 4095;");src.push("      int indexPositionV = uniqueVertexIndexes[gl_VertexID % 2] >> 12;");src.push("      mat4 objectInstanceMatrix = mat4 (texelFetch (uPerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uPerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uPerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uPerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("      mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uPerObjectDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uPerObjectDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uPerObjectDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uPerObjectDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("      uvec4 flags = texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("      uvec4 flags2 = texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");src.push("      vec3 position = vec3(texelFetch(uPerVertexPosition, ivec2(indexPositionH, indexPositionV), 0));");src.push("      uvec4 color = texelFetch (uPerObjectColorAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("      if (color.a == 0u) {");src.push("          gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("          return;");src.push("      };");src.push("      vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags2 = flags2.r;");}src.push("      vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("      vFragDepth = 1.0 + clipPos.w;");src.push("      isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("      gl_Position = clipPos;");src.push("      vec4 rgb = vec4(color.rgba);");src.push("      vColor = vec4(float(rgb.r*0.5) / 255.0, float(rgb.g*0.5) / 255.0, float(rgb.b*0.5) / 255.0, float(rgb.a) / 255.0);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// LinesDataTextureColorRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i306=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i306<len;_i306++){src.push("uniform bool sectionPlaneActive"+_i306+";");src.push("uniform vec3 sectionPlanePos"+_i306+";");src.push("uniform vec3 sectionPlaneDir"+_i306+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i307=0,_len68=sectionPlanesState.getNumAllocatedSectionPlanes();_i307<_len68;_i307++){src.push("if (sectionPlaneActive"+_i307+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i307+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i307+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor            = vColor;");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXLinesColorRenderer;}();/**
 * @private
 */var DTXLinesRenderers=/*#__PURE__*/function(){function DTXLinesRenderers(scene){_classCallCheck(this,DTXLinesRenderers);this._scene=scene;}_createClass(DTXLinesRenderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}}},{key:"eagerCreateRenders",value:function eagerCreateRenders(){// Pre-initialize certain renderers that would otherwise be lazy-initialised
// on user interaction, such as picking or emphasis, so that there is no delay
// when user first begins interacting with the viewer.
}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new DTXLinesColorRenderer(this._scene,false);}return this._colorRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}}}]);return DTXLinesRenderers;}();var cachedRenderers={};/**
 * @private
 */function getRenderers$1(scene){var sceneId=scene.id;var dataTextureRenderers=cachedRenderers[sceneId];if(!dataTextureRenderers){dataTextureRenderers=new DTXLinesRenderers(scene);cachedRenderers[sceneId]=dataTextureRenderers;dataTextureRenderers._compile();dataTextureRenderers.eagerCreateRenders();scene.on("compile",function(){dataTextureRenderers._compile();dataTextureRenderers.eagerCreateRenders();});scene.on("destroyed",function(){delete cachedRenderers[sceneId];dataTextureRenderers._destroy();});}return dataTextureRenderers;}/**
 * @private
 */var DTXLinesBuffer=/*#__PURE__*/_createClass(function DTXLinesBuffer(){_classCallCheck(this,DTXLinesBuffer);this.positionsCompressed=[];this.lenPositionsCompressed=0;this.indices8Bits=[];this.lenIndices8Bits=0;this.indices16Bits=[];this.lenIndices16Bits=0;this.indices32Bits=[];this.lenIndices32Bits=0;this.perObjectColors=[];this.perObjectPickColors=[];this.perObjectSolid=[];this.perObjectOffsets=[];this.perObjectPositionsDecodeMatrices=[];this.perObjectInstancePositioningMatrices=[];this.perObjectVertexBases=[];this.perObjectIndexBaseOffsets=[];this.perLineNumberPortionId8Bits=[];this.perLineNumberPortionId16Bits=[];this.perLineNumberPortionId32Bits=[];});/**
 * @private
 */var DTXLinesState=/*#__PURE__*/function(){function DTXLinesState(){_classCallCheck(this,DTXLinesState);this.texturePerObjectColorsAndFlags=null;this.texturePerObjectOffsets=null;this.texturePerObjectInstanceMatrices=null;this.texturePerObjectPositionsDecodeMatrix=null;this.texturePerVertexIdCoordinates=null;this.texturePerLineIdPortionIds8Bits=null;this.texturePerLineIdPortionIds16Bits=null;this.texturePerLineIdPortionIds32Bits=null;this.texturePerLineIdIndices8Bits=null;this.texturePerLineIdIndices16Bits=null;this.texturePerLineIdIndices32Bits=null;this.textureModelMatrices=null;}_createClass(DTXLinesState,[{key:"finalize",value:function finalize(){this.indicesPerBitnessTextures={8:this.texturePerLineIdIndices8Bits,16:this.texturePerLineIdIndices16Bits,32:this.texturePerLineIdIndices32Bits};this.indicesPortionIdsPerBitnessTextures={8:this.texturePerLineIdPortionIds8Bits,16:this.texturePerLineIdPortionIds16Bits,32:this.texturePerLineIdPortionIds32Bits};}},{key:"bindCommonTextures",value:function bindCommonTextures(glProgram,objectDecodeMatricesShaderName,vertexTextureShaderName,objectAttributesTextureShaderName,objectMatricesShaderName){this.texturePerObjectPositionsDecodeMatrix.bindTexture(glProgram,objectDecodeMatricesShaderName,1);this.texturePerVertexIdCoordinates.bindTexture(glProgram,vertexTextureShaderName,2);this.texturePerObjectColorsAndFlags.bindTexture(glProgram,objectAttributesTextureShaderName,3);this.texturePerObjectInstanceMatrices.bindTexture(glProgram,objectMatricesShaderName,4);}},{key:"bindLineIndicesTextures",value:function bindLineIndicesTextures(glProgram,portionIdsShaderName,lineIndicesShaderName,textureBitness){this.indicesPortionIdsPerBitnessTextures[textureBitness].bindTexture(glProgram,portionIdsShaderName,5);this.indicesPerBitnessTextures[textureBitness].bindTexture(glProgram,lineIndicesShaderName,6);}}]);return DTXLinesState;}();/**
 * @private
 */var BindableDataTexture=/*#__PURE__*/function(){function BindableDataTexture(gl,texture,textureWidth,textureHeight){var textureData=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;_classCallCheck(this,BindableDataTexture);this._gl=gl;this._texture=texture;this._textureWidth=textureWidth;this._textureHeight=textureHeight;this._textureData=textureData;}_createClass(BindableDataTexture,[{key:"bindTexture",value:function bindTexture(glProgram,shaderName,glTextureUnit){return glProgram.bindTexture(shaderName,this,glTextureUnit);}},{key:"bind",value:function bind(unit){this._gl.activeTexture(this._gl["TEXTURE"+unit]);this._gl.bindTexture(this._gl.TEXTURE_2D,this._texture);return true;}},{key:"unbind",value:function unbind(unit){// This `unbind` method is ignored at the moment to allow avoiding
// to rebind same texture already bound to a texture unit.
// this._gl.activeTexture(this.state.gl["TEXTURE" + unit]);
// this._gl.bindTexture(this.state.gl.TEXTURE_2D, null);
}}]);return BindableDataTexture;}();var dataTextureRamStats$1={sizeDataColorsAndFlags:0,sizeDataPositionDecodeMatrices:0,sizeDataTextureOffsets:0,sizeDataTexturePositions:0,sizeDataTextureIndices:0,sizeDataTexturePortionIds:0,numberOfGeometries:0,numberOfPortions:0,numberOfLayers:0,numberOfTextures:0,totalLines:0,totalLines8Bits:0,totalLines16Bits:0,totalLines32Bits:0,cannotCreatePortion:{because10BitsObjectId:0,becauseTextureSize:0},overheadSizeAlignementIndices:0,overheadSizeAlignementEdgeIndices:0};window.printDataTextureRamStats=function(){console.log(JSON.stringify(dataTextureRamStats$1,null,4));var totalRamSize=0;Object.keys(dataTextureRamStats$1).forEach(function(key){if(key.startsWith("size")){totalRamSize+=dataTextureRamStats$1[key];}});console.log("Total size ".concat(totalRamSize," bytes (").concat((totalRamSize/1000/1000).toFixed(2)," MB)"));console.log("Avg bytes / triangle: ".concat((totalRamSize/dataTextureRamStats$1.totalLines).toFixed(2)));var percentualRamStats={};Object.keys(dataTextureRamStats$1).forEach(function(key){if(key.startsWith("size")){percentualRamStats[key]="".concat((dataTextureRamStats$1[key]/totalRamSize*100).toFixed(2)," % of total");}});console.log(JSON.stringify({percentualRamUsage:percentualRamStats},null,4));};/**
 * @private
 */var DTXLinesTextureFactory=/*#__PURE__*/function(){function DTXLinesTextureFactory(){_classCallCheck(this,DTXLinesTextureFactory);}_createClass(DTXLinesTextureFactory,[{key:"disableBindedTextureFiltering",value:/**
     * Enables the currently binded ````WebGLTexture```` to be used as a data texture.
     *
     * @param {WebGL2RenderingContext} gl
     *
     * @private
     */function disableBindedTextureFiltering(gl){gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);}/**
     * This will generate an RGBA texture for:
     * - colors
     * - pickColors
     * - flags
     * - flags2
     * - vertex bases
     * - vertex base offsets
     *
     * The texture will have:
     * - 4 RGBA columns per row: for each object (pick) color and flags(2)
     * - N rows where N is the number of objects
     *
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<ArrayLike<int>>} colors Array of colors for all objects in the layer
     * @param {ArrayLike<ArrayLike<int>>} pickColors Array of pickColors for all objects in the layer
     * @param {ArrayLike<int>} vertexBases Array of position-index-bases foteh all objects in the layer
     * @param {ArrayLike<int>} indexBaseOffsets For lines: array of offests between the (gl_VertexID / 2) and the position where the indices start in the texture layer
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureForColorsAndFlags",value:function generateTextureForColorsAndFlags(gl,colors,pickColors,vertexBases,indexBaseOffsets){var numPortions=colors.length;// The number of rows in the texture is the number of
// objects in the layer.
this.numPortions=numPortions;var textureWidth=512*8;var textureHeight=Math.ceil(numPortions/(textureWidth/8));if(textureHeight===0){throw"texture height===0";}// 8 columns per texture row:
// - col0: (RGBA) object color RGBA
// - col1: (packed Uint32 as RGBA) object pick color
// - col2: (packed 4 bytes as RGBA) object flags
// - col3: (packed 4 bytes as RGBA) object flags2
// - col4: (packed Uint32 bytes as RGBA) vertex base
// - col5: (packed Uint32 bytes as RGBA) index base offset
// // - col6: (packed Uint32 bytes as RGBA) edge index base offset
// // - col7: (packed 4 bytes as RGBA) is-solid flag for objects
var texArray=new Uint8Array(4*textureWidth*textureHeight);dataTextureRamStats$1.sizeDataColorsAndFlags+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;for(var _i308=0;_i308<numPortions;_i308++){// object color
texArray.set(colors[_i308],_i308*32+0);texArray.set(pickColors[_i308],_i308*32+4);// object pick color
texArray.set([0,0,0,0],_i308*32+8);// object flags
texArray.set([0,0,0,0],_i308*32+12);// object flags2
// vertex base
texArray.set([vertexBases[_i308]>>24&255,vertexBases[_i308]>>16&255,vertexBases[_i308]>>8&255,vertexBases[_i308]&255],_i308*32+16);// lines index base offset
texArray.set([indexBaseOffsets[_i308]>>24&255,indexBaseOffsets[_i308]>>16&255,indexBaseOffsets[_i308]>>8&255,indexBaseOffsets[_i308]&255],_i308*32+20);// // edge index base offset
// texArray.set(
//     [
//         (edgeIndexBaseOffsets[i] >> 24) & 255,
//         (edgeIndexBaseOffsets[i] >> 16) & 255,
//         (edgeIndexBaseOffsets[i] >> 8) & 255,
//         (edgeIndexBaseOffsets[i]) & 255,
//     ],
//     i * 32 + 24
// );
//
// // is-solid flag
// texArray.set([solid[i] ? 1 : 0, 0, 0, 0], i * 32 + 28);
}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGBA8UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight,texArray);}/**
     * This will generate a texture for all object offsets.
     *
     * @param {WebGL2RenderingContext} gl
     * @param {int[]} offsets Array of int[3], one XYZ offset array for each object
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureForObjectOffsets",value:function generateTextureForObjectOffsets(gl,numOffsets){var textureWidth=512;var textureHeight=Math.ceil(numOffsets/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArray=new Float32Array(3*textureWidth*textureHeight).fill(0);dataTextureRamStats$1.sizeDataTextureOffsets+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB32F,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB,gl.FLOAT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight,texArray);}/**
     * This will generate a texture for all positions decode matrices in the layer.
     *
     * The texture will have:
     * - 4 RGBA columns per row (each column will contain 4 packed half-float (16 bits) components).
     *   Thus, each row will contain 16 packed half-floats corresponding to a complete positions decode matrix)
     * - N rows where N is the number of objects
     *
     * @param {WebGL2RenderingContext} gl
    * @param {ArrayLike<Matrix4x4>} instanceMatrices Array of geometry instancing matrices for all objects in the layer. Null if the objects are not instanced.
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureForInstancingMatrices",value:function generateTextureForInstancingMatrices(gl,instanceMatrices){var numMatrices=instanceMatrices.length;if(numMatrices===0){throw"num instance matrices===0";}// in one row we can fit 512 matrices
var textureWidth=512*4;var textureHeight=Math.ceil(numMatrices/(textureWidth/4));var texArray=new Float32Array(4*textureWidth*textureHeight);// dataTextureRamStats.sizeDataPositionDecodeMatrices += texArray.byteLength;
dataTextureRamStats$1.numberOfTextures++;for(var _i309=0;_i309<instanceMatrices.length;_i309++){// 4x4 values
texArray.set(instanceMatrices[_i309],_i309*16);}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGBA32F,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGBA,gl.FLOAT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight,texArray);}/**
     * This will generate a texture for all positions decode matrices in the layer.
     *
     * The texture will have:
     * - 4 RGBA columns per row (each column will contain 4 packed half-float (16 bits) components).
     *   Thus, each row will contain 16 packed half-floats corresponding to a complete positions decode matrix)
     * - N rows where N is the number of objects
     *
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<Matrix4x4>} positionDecodeMatrices Array of positions decode matrices for all objects in the layer
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureForPositionsDecodeMatrices",value:function generateTextureForPositionsDecodeMatrices(gl,positionDecodeMatrices){var numMatrices=positionDecodeMatrices.length;if(numMatrices===0){throw"num decode+entity matrices===0";}// in one row we can fit 512 matrices
var textureWidth=512*4;var textureHeight=Math.ceil(numMatrices/(textureWidth/4));var texArray=new Float32Array(4*textureWidth*textureHeight);dataTextureRamStats$1.sizeDataPositionDecodeMatrices+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;for(var _i310=0;_i310<positionDecodeMatrices.length;_i310++){// 4x4 values
texArray.set(positionDecodeMatrices[_i310],_i310*16);}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGBA32F,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGBA,gl.FLOAT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureFor8BitIndices",value:function generateTextureFor8BitIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/3/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint8Array(texArraySize);dataTextureRamStats$1.sizeDataTextureIndices+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;for(var _i311=0,j=0,len=indicesArrays.length;_i311<len;_i311++){var pc=indicesArrays[_i311];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB8UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_BYTE,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureFor16BitIndices",value:function generateTextureFor16BitIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/3/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint16Array(texArraySize);dataTextureRamStats$1.sizeDataTextureIndices+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;for(var _i312=0,j=0,len=indicesArrays.length;_i312<len;_i312++){var pc=indicesArrays[_i312];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_SHORT,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureFor32BitIndices",value:function generateTextureFor32BitIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/3/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint32Array(texArraySize);dataTextureRamStats$1.sizeDataTextureIndices+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;for(var _i313=0,j=0,len=indicesArrays.length;_i313<len;_i313++){var pc=indicesArrays[_i313];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB32UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_INT,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<int>} positionsArrays Arrays of  quantized positions in the layer
     * @param lenPositions
     *
     * This will generate a texture for positions in the layer.
     *
     * The texture will have:
     * - 1024 columns, where each pixel will be a 16-bit-per-component RGB texture, corresponding to the XYZ of the position
     * - a number of rows R where R*1024 is just >= than the number of vertices (positions / 3)
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureForPositions",value:function generateTextureForPositions(gl,positionsArrays,lenPositions){var numVertices=lenPositions/3;var textureWidth=4096;var textureHeight=Math.ceil(numVertices/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint16Array(texArraySize);dataTextureRamStats$1.sizeDataTexturePositions+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;for(var _i314=0,j=0,len=positionsArrays.length;_i314<len;_i314++){var pc=positionsArrays[_i314];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_SHORT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<int>} portionIdsArray
     *
     * @returns {BindableDataTexture}
     */},{key:"generateTextureForPackedPortionIds",value:function generateTextureForPackedPortionIds(gl,portionIdsArray){if(portionIdsArray.length===0){return{texture:null,textureHeight:0};}var lenArray=portionIdsArray.length;var textureWidth=4096;var textureHeight=Math.ceil(lenArray/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight;var texArray=new Uint16Array(texArraySize);texArray.set(portionIdsArray,0);dataTextureRamStats$1.sizeDataTexturePortionIds+=texArray.byteLength;dataTextureRamStats$1.numberOfTextures++;var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.R16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RED_INTEGER,gl.UNSIGNED_SHORT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}}]);return DTXLinesTextureFactory;}();var configs$1=new Configs();var MAX_NUMBER_OF_OBJECTS_IN_LAYER$1=1<<16;var MAX_DATA_TEXTURE_HEIGHT$1=configs$1.maxDataTextureHeight;var INDICES_EDGE_INDICES_ALIGNEMENT_SIZE$1=8;var MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE$1=10;var tempMat4a$d=new Float32Array(16);var tempUint8Array4$1=new Uint8Array(4);var tempFloat32Array3$1=new Float32Array(3);var numLayers$1=0;var DEFAULT_MATRIX$2=math.identityMat4();/**
 * @private
 */var DTXLinesLayer=/*#__PURE__*/function(){function DTXLinesLayer(model,cfg){_classCallCheck(this,DTXLinesLayer);console.info("Creating DTXLinesLayer");dataTextureRamStats$1.numberOfLayers++;this._layerNumber=numLayers$1++;this.sortId="TriDTX-".concat(this._layerNumber);// State sorting key.
this.layerIndex=cfg.layerIndex;// Index of this DTXLinesLayer in {@link SceneModel#_layerList}.
this._renderers=getRenderers$1(model.scene);this.model=model;this._buffer=new DTXLinesBuffer();this._dataTextureState=new DTXLinesState();this._dataTextureGenerator=new DTXLinesTextureFactory();this._state=new RenderState({origin:math.vec3(cfg.origin),textureState:this._dataTextureState,numIndices8Bits:0,numIndices16Bits:0,numIndices32Bits:0,numVertices:0});this._numPortions=0;// These counts are used to avoid unnecessary render passes
this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numSelectedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numClippableLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;this._subPortions=[];this._portionToSubPortionsMap=[];this._bucketGeometries={};this._meshes=[];this._aabb=math.collapseAABB3();this.aabbDirty=true;this._numUpdatesInFrame=0;this._finalized=false;}_createClass(DTXLinesLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i315=0,len=this._meshes.length;_i315<len;_i315++){math.expandAABB3(this._aabb,this._meshes[_i315].aabb);}this.aabbDirty=false;}return this._aabb;}},{key:"canCreatePortion",value:function canCreatePortion(portionCfg){if(this._finalized){throw"Already finalized";}var numNewPortions=portionCfg.buckets.length;if(this._numPortions+numNewPortions>MAX_NUMBER_OF_OBJECTS_IN_LAYER$1){dataTextureRamStats$1.cannotCreatePortion.because10BitsObjectId++;}var retVal=this._numPortions+numNewPortions<=MAX_NUMBER_OF_OBJECTS_IN_LAYER$1;var bucketIndex=0;// TODO: Is this a bug?
var bucketGeometryId=portionCfg.geometryId!==undefined&&portionCfg.geometryId!==null?"".concat(portionCfg.geometryId,"#").concat(bucketIndex):"".concat(portionCfg.id,"#").concat(bucketIndex);var alreadyHasPortionGeometry=this._bucketGeometries[bucketGeometryId];if(!alreadyHasPortionGeometry){var maxIndicesOfAnyBits=Math.max(this._state.numIndices8Bits,this._state.numIndices16Bits,this._state.numIndices32Bits);var numVertices=0;var _numIndices=0;portionCfg.buckets.forEach(function(bucket){numVertices+=bucket.positionsCompressed.length/3;_numIndices+=bucket.indices.length/2;});if(this._state.numVertices+numVertices>MAX_DATA_TEXTURE_HEIGHT$1*4096||maxIndicesOfAnyBits+_numIndices>MAX_DATA_TEXTURE_HEIGHT$1*4096){dataTextureRamStats$1.cannotCreatePortion.becauseTextureSize++;}retVal&&(retVal=this._state.numVertices+numVertices<=MAX_DATA_TEXTURE_HEIGHT$1*4096&&maxIndicesOfAnyBits+_numIndices<=MAX_DATA_TEXTURE_HEIGHT$1*4096);}return retVal;}},{key:"createPortion",value:function createPortion(mesh,portionCfg){var _this66=this;if(this._finalized){throw"Already finalized";}var subPortionIds=[];//   const portionAABB = portionCfg.worldAABB;
portionCfg.buckets.forEach(function(bucket,bucketIndex){var bucketGeometryId=portionCfg.geometryId!==undefined&&portionCfg.geometryId!==null?"".concat(portionCfg.geometryId,"#").concat(bucketIndex):"".concat(portionCfg.id,"#").concat(bucketIndex);var bucketGeometry=_this66._bucketGeometries[bucketGeometryId];if(!bucketGeometry){bucketGeometry=_this66._createBucketGeometry(portionCfg,bucket);_this66._bucketGeometries[bucketGeometryId]=bucketGeometry;}//  const subPortionAABB = math.collapseAABB3(tempAABB3b);
var subPortionId=_this66._createSubPortion(portionCfg,bucketGeometry,bucket);//math.expandAABB3(portionAABB, subPortionAABB);
subPortionIds.push(subPortionId);});var portionId=this._portionToSubPortionsMap.length;this._portionToSubPortionsMap.push(subPortionIds);this.model.numPortions++;this._meshes.push(mesh);return portionId;}},{key:"_createBucketGeometry",value:function _createBucketGeometry(portionCfg,bucket){if(bucket.indices){var alignedIndicesLen=Math.ceil(bucket.indices.length/2/INDICES_EDGE_INDICES_ALIGNEMENT_SIZE$1)*INDICES_EDGE_INDICES_ALIGNEMENT_SIZE$1*2;dataTextureRamStats$1.overheadSizeAlignementIndices+=2*(alignedIndicesLen-bucket.indices.length);var alignedIndices=new Uint32Array(alignedIndicesLen);alignedIndices.fill(0);alignedIndices.set(bucket.indices);bucket.indices=alignedIndices;}var positionsCompressed=bucket.positionsCompressed;var indices=bucket.indices;var buffer=this._buffer;buffer.positionsCompressed.push(positionsCompressed);var vertexBase=buffer.lenPositionsCompressed/3;var numVertices=positionsCompressed.length/3;buffer.lenPositionsCompressed+=positionsCompressed.length;var indicesBase;var numLines=0;if(indices){numLines=indices.length/2;var indicesBuffer;if(numVertices<=1<<8){indicesBuffer=buffer.indices8Bits;indicesBase=buffer.lenIndices8Bits/2;buffer.lenIndices8Bits+=indices.length;}else if(numVertices<=1<<16){indicesBuffer=buffer.indices16Bits;indicesBase=buffer.lenIndices16Bits/2;buffer.lenIndices16Bits+=indices.length;}else{indicesBuffer=buffer.indices32Bits;indicesBase=buffer.lenIndices32Bits/2;buffer.lenIndices32Bits+=indices.length;}indicesBuffer.push(indices);}this._state.numVertices+=numVertices;dataTextureRamStats$1.numberOfGeometries++;var bucketGeometry={vertexBase:vertexBase,numVertices:numVertices,numLines:numLines,indicesBase:indicesBase};return bucketGeometry;}},{key:"_createSubPortion",value:function _createSubPortion(portionCfg,bucketGeometry){var color=portionCfg.color;var colors=portionCfg.colors;var opacity=portionCfg.opacity;var meshMatrix=portionCfg.meshMatrix;var pickColor=portionCfg.pickColor;var buffer=this._buffer;var state=this._state;buffer.perObjectPositionsDecodeMatrices.push(portionCfg.positionsDecodeMatrix);buffer.perObjectInstancePositioningMatrices.push(meshMatrix||DEFAULT_MATRIX$2);buffer.perObjectSolid.push(!!portionCfg.solid);if(colors){buffer.perObjectColors.push([colors[0]*255,colors[1]*255,colors[2]*255,255]);}else if(color){// Color is pre-quantized by SceneModel
buffer.perObjectColors.push([color[0],color[1],color[2],opacity]);}buffer.perObjectPickColors.push(pickColor);buffer.perObjectVertexBases.push(bucketGeometry.vertexBase);{var currentNumIndices;if(bucketGeometry.numVertices<=1<<8){currentNumIndices=state.numIndices8Bits;}else if(bucketGeometry.numVertices<=1<<16){currentNumIndices=state.numIndices16Bits;}else{currentNumIndices=state.numIndices32Bits;}buffer.perObjectIndexBaseOffsets.push(currentNumIndices/2-bucketGeometry.indicesBase);}var subPortionId=this._subPortions.length;if(bucketGeometry.numLines>0){var _numIndices2=bucketGeometry.numLines*2;var indicesPortionIdBuffer;if(bucketGeometry.numVertices<=1<<8){indicesPortionIdBuffer=buffer.perLineNumberPortionId8Bits;state.numIndices8Bits+=_numIndices2;dataTextureRamStats$1.totalLines8Bits+=bucketGeometry.numLines;}else if(bucketGeometry.numVertices<=1<<16){indicesPortionIdBuffer=buffer.perLineNumberPortionId16Bits;state.numIndices16Bits+=_numIndices2;dataTextureRamStats$1.totalLines16Bits+=bucketGeometry.numLines;}else{indicesPortionIdBuffer=buffer.perLineNumberPortionId32Bits;state.numIndices32Bits+=_numIndices2;dataTextureRamStats$1.totalLines32Bits+=bucketGeometry.numLines;}dataTextureRamStats$1.totalLines+=bucketGeometry.numLines;for(var _i316=0;_i316<bucketGeometry.numLines;_i316+=INDICES_EDGE_INDICES_ALIGNEMENT_SIZE$1){indicesPortionIdBuffer.push(subPortionId);}}this._subPortions.push({// vertsBase: vertsIndex,
numVertices:bucketGeometry.numLines});this._numPortions++;dataTextureRamStats$1.numberOfPortions++;return subPortionId;}/**
     * Builds data textures from the appended geometries and loads them into the GPU.
     *
     * No more portions can then be created.
     */},{key:"finalize",value:function finalize(){var _this67=this;if(this._finalized){return;}var state=this._state;var textureState=this._dataTextureState;var gl=this.model.scene.canvas.gl;var buffer=this._buffer;state.gl=gl;textureState.texturePerObjectColorsAndFlags=this._dataTextureGenerator.generateTextureForColorsAndFlags(gl,buffer.perObjectColors,buffer.perObjectPickColors,buffer.perObjectVertexBases,buffer.perObjectIndexBaseOffsets,buffer.perObjectSolid);textureState.texturePerObjectInstanceMatrices=this._dataTextureGenerator.generateTextureForInstancingMatrices(gl,buffer.perObjectInstancePositioningMatrices);textureState.texturePerObjectPositionsDecodeMatrix=this._dataTextureGenerator.generateTextureForPositionsDecodeMatrices(gl,buffer.perObjectPositionsDecodeMatrices);textureState.texturePerVertexIdCoordinates=this._dataTextureGenerator.generateTextureForPositions(gl,buffer.positionsCompressed,buffer.lenPositionsCompressed);textureState.texturePerLineIdPortionIds8Bits=this._dataTextureGenerator.generateTextureForPackedPortionIds(gl,buffer.perLineNumberPortionId8Bits);textureState.texturePerLineIdPortionIds16Bits=this._dataTextureGenerator.generateTextureForPackedPortionIds(gl,buffer.perLineNumberPortionId16Bits);textureState.texturePerLineIdPortionIds32Bits=this._dataTextureGenerator.generateTextureForPackedPortionIds(gl,buffer.perLineNumberPortionId32Bits);if(buffer.lenIndices8Bits>0){textureState.texturePerLineIdIndices8Bits=this._dataTextureGenerator.generateTextureFor8BitIndices(gl,buffer.indices8Bits,buffer.lenIndices8Bits);}if(buffer.lenIndices16Bits>0){textureState.texturePerLineIdIndices16Bits=this._dataTextureGenerator.generateTextureFor16BitIndices(gl,buffer.indices16Bits,buffer.lenIndices16Bits);}if(buffer.lenIndices32Bits>0){textureState.texturePerLineIdIndices32Bits=this._dataTextureGenerator.generateTextureFor32BitIndices(gl,buffer.indices32Bits,buffer.lenIndices32Bits);}textureState.finalize();// Free up memory
this._buffer=null;this._bucketGeometries={};this._finalized=true;this._deferredSetFlagsDirty=false;//
this._onSceneRendering=this.model.scene.on("rendering",function(){if(_this67._deferredSetFlagsDirty){_this67._uploadDeferredFlags();}_this67._numUpdatesInFrame=0;});}},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}var deferred=true;this._setFlags(portionId,flags,meshTransparent,deferred);this._setFlags2(portionId,flags,deferred);}},{key:"flushInitFlags",value:function flushInitFlags(){this._setDeferredFlags();this._setDeferredFlags2();}},{key:"setVisible",value:function setVisible(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setSelected",value:function setSelected(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setEdges",value:function setEdges(portionId,flags,transparent){}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags2(portionId,flags);}/**
     * This will _start_ a "set-flags transaction".
     *
     * After invoking this method, calling setFlags/setFlags2 will not update
     * the colors+flags texture but only store the new flags/flag2 in the
     * colors+flags texture data array.
     *
     * After invoking this method, and when all desired setFlags/setFlags2 have
     * been called on needed portions of the layer, invoke `_uploadDeferredFlags`
     * to actually upload the data array into the texture.
     *
     * In massive "set-flags" scenarios like VFC or LOD mechanisms, the combination of
     * `_beginDeferredFlags` + `_uploadDeferredFlags`brings a speed-up of
     * up to 80x when e.g. objects are massively (un)culled .
     */},{key:"_beginDeferredFlags",value:function _beginDeferredFlags(){this._deferredSetFlagsActive=true;}/**
     * This will _commit_ a "set-flags transaction".
     *
     * Invoking this method will update the colors+flags texture data with new
     * flags/flags2 set since the previous invocation of `_beginDeferredFlags`.
     */},{key:"_uploadDeferredFlags",value:function _uploadDeferredFlags(){this._deferredSetFlagsActive=false;if(!this._deferredSetFlagsDirty){return;}this._deferredSetFlagsDirty=false;var gl=this.model.scene.canvas.gl;var textureState=this._dataTextureState;gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
0,// xoffset
0,// yoffset
textureState.texturePerObjectColorsAndFlags._textureWidth,// width
textureState.texturePerObjectColorsAndFlags._textureHeight,// width
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,textureState.texturePerObjectColorsAndFlags._textureData);}},{key:"setCulled",value:function setCulled(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions+=this._portionToSubPortionsMap[portionId].length;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions-=this._portionToSubPortionsMap[portionId].length;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setColor",value:function setColor(portionId,color){var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i317=0,len=subPortionIds.length;_i317<len;_i317++){this._subPortionSetColor(subPortionIds[_i317],color);}}},{key:"_subPortionSetColor",value:function _subPortionSetColor(subPortionId,color){if(!this._finalized){throw"Not finalized";}// Color
var textureState=this._dataTextureState;var gl=this.model.scene.canvas.gl;tempUint8Array4$1[0]=color[0];tempUint8Array4$1[1]=color[1];tempUint8Array4$1[2]=color[2];tempUint8Array4$1[3]=color[3];// object colors
textureState.texturePerObjectColorsAndFlags._textureData.set(tempUint8Array4$1,subPortionId*32);if(this._deferredSetFlagsActive){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE$1){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*8,// xoffset
Math.floor(subPortionId/512),// yoffset
1,// width
1,//height
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,tempUint8Array4$1);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"_setFlags",value:function _setFlags(portionId,flags,transparent){var deferred=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i318=0,len=subPortionIds.length;_i318<len;_i318++){this._subPortionSetFlags(subPortionIds[_i318],flags,transparent,deferred);}}},{key:"_subPortionSetFlags",value:function _subPortionSetFlags(subPortionId,flags,transparent){var deferred=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(!this._finalized){throw"Not finalized";}var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);// Color
var f0;if(!visible||culled||xrayed){// Highlight & select are layered on top of color - not mutually exclusive
f0=RENDER_PASSES.NOT_RENDERED;}else{if(transparent){f0=RENDER_PASSES.COLOR_TRANSPARENT;}else{f0=RENDER_PASSES.COLOR_OPAQUE;}}// Silhouette
var f1;if(!visible||culled){f1=RENDER_PASSES.NOT_RENDERED;}else if(selected){f1=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){f1=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){f1=RENDER_PASSES.SILHOUETTE_XRAYED;}else{f1=RENDER_PASSES.NOT_RENDERED;}// // Edges
//
// let f2 = 0;
// if (!visible || culled) {
//     f2 = RENDER_PASSES.NOT_RENDERED;
// } else if (selected) {
//     f2 = RENDER_PASSES.EDGES_SELECTED;
// } else if (highlighted) {
//     f2 = RENDER_PASSES.EDGES_HIGHLIGHTED;
// } else if (xrayed) {
//     f2 = RENDER_PASSES.EDGES_XRAYED;
// } else if (edges) {
//     if (transparent) {
//         f2 = RENDER_PASSES.EDGES_COLOR_TRANSPARENT;
//     } else {
//         f2 = RENDER_PASSES.EDGES_COLOR_OPAQUE;
//     }
// } else {
//     f2 = RENDER_PASSES.NOT_RENDERED;
// }
// Pick
var f3=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var textureState=this._dataTextureState;var gl=this.model.scene.canvas.gl;tempUint8Array4$1[0]=f0;tempUint8Array4$1[1]=f1;// tempUint8Array4 [2] = f2;
tempUint8Array4$1[3]=f3;// object flags
textureState.texturePerObjectColorsAndFlags._textureData.set(tempUint8Array4$1,subPortionId*32+8);if(this._deferredSetFlagsActive||deferred){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE$1){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*8+2,// xoffset
Math.floor(subPortionId/512),// yoffset
1,// width
1,//height
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,tempUint8Array4$1);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"_setDeferredFlags",value:function _setDeferredFlags(){}},{key:"_setFlags2",value:function _setFlags2(portionId,flags){var deferred=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i319=0,len=subPortionIds.length;_i319<len;_i319++){this._subPortionSetFlags2(subPortionIds[_i319],flags,deferred);}}},{key:"_subPortionSetFlags2",value:function _subPortionSetFlags2(subPortionId,flags){var deferred=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!this._finalized){throw"Not finalized";}var clippable=!!(flags&ENTITY_FLAGS.CLIPPABLE)?255:0;var textureState=this._dataTextureState;var gl=this.model.scene.canvas.gl;tempUint8Array4$1[0]=clippable;tempUint8Array4$1[1]=0;tempUint8Array4$1[2]=1;tempUint8Array4$1[3]=2;// object flags2
textureState.texturePerObjectColorsAndFlags._textureData.set(tempUint8Array4$1,subPortionId*32+12);if(this._deferredSetFlagsActive||deferred){// console.log("_subPortionSetFlags2 set flags defer");
this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE$1){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*8+3,// xoffset
Math.floor(subPortionId/512),// yoffset
1,// width
1,//height
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,tempUint8Array4$1);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"_setDeferredFlags2",value:function _setDeferredFlags2(){}},{key:"setOffset",value:function setOffset(portionId,offset){var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i320=0,len=subPortionIds.length;_i320<len;_i320++){this._subPortionSetOffset(subPortionIds[_i320],offset);}}},{key:"_subPortionSetOffset",value:function _subPortionSetOffset(subPortionId,offset){if(!this._finalized){throw"Not finalized";}// if (!this.model.scene.entityOffsetsEnabled) {
//     this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
//     return;
// }
var textureState=this._dataTextureState;var gl=this.model.scene.canvas.gl;tempFloat32Array3$1[0]=offset[0];tempFloat32Array3$1[1]=offset[1];tempFloat32Array3$1[2]=offset[2];// object offset
textureState.texturePerObjectOffsets._textureData.set(tempFloat32Array3$1,subPortionId*3);if(this._deferredSetFlagsActive){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE$1){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectOffsets._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
0,// x offset
subPortionId,// yoffset
1,// width
1,// height
gl.RGB,gl.FLOAT,tempFloat32Array3$1);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"setMatrix",value:function setMatrix(portionId,matrix){var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i321=0,len=subPortionIds.length;_i321<len;_i321++){this._subPortionSetMatrix(subPortionIds[_i321],matrix);}}},{key:"_subPortionSetMatrix",value:function _subPortionSetMatrix(subPortionId,matrix){if(!this._finalized){throw"Not finalized";}// if (!this.model.scene.entityMatrixsEnabled) {
//     this.model.error("Entity#matrix not enabled for this Viewer"); // See Viewer entityMatrixsEnabled
//     return;
// }
var textureState=this._dataTextureState;var gl=this.model.scene.canvas.gl;tempMat4a$d.set(matrix);textureState.texturePerObjectInstanceMatrices._textureData.set(tempMat4a$d,subPortionId*16);if(this._deferredSetFlagsActive){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE$1){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectInstanceMatrices._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*4,// xoffset
Math.floor(subPortionId/512),// yoffset
// 1,
4,// width
1,// height
gl.RGBA,gl.FLOAT,tempMat4a$d);// gl.bindTexture (gl.TEXTURE_2D, null);
}// ---------------------- COLOR RENDERING -----------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){}},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){// if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
//     return;
// }
// if (this._renderers.silhouetteRenderer) {
//     this._renderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
// }
}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){// if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
//     return;
// }
// if (this._renderers.silhouetteRenderer) {
//     this._renderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
// }
}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){// if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
//     return;
// }
// if (this._renderers.silhouetteRenderer) {
//     this._renderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
// }
}},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){}},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){}},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){}},{key:"setPickMatrices",value:function setPickMatrices(pickViewMatrix,pickProjMatrix){}},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){}},{key:"destroy",value:function destroy(){if(this._destroyed){return;}var state=this._state;this.model.scene.off(this._onSceneRendering);state.destroy();this._destroyed=true;}}]);return DTXLinesLayer;}();var tempVec3a$m=math.vec3();var tempVec3b$i=math.vec3();var tempVec3c$e=math.vec3();math.vec3();var tempVec4a$5=math.vec4();var tempMat4a$c=math.mat4();/**
 * @private
 */var DTXTrianglesColorRenderer=/*#__PURE__*/function(){function DTXTrianglesColorRenderer(scene,withSAO){_classCallCheck(this,DTXTrianglesColorRenderer);this._scene=scene;this._withSAO=withSAO;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesColorRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var scene=this._scene;var camera=scene.camera;var model=dataTextureLayer.model;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx,state);}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$m;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$i);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(camera.viewMatrix,rtcOrigin,tempMat4a$c);rtcCameraEye=tempVec3c$e;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=camera.viewMatrix;rtcCameraEye=camera.eye;}gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$m);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;var lightsState=scene._lightsState;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;console.error(this.errors);return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uLightAmbient=program.getLocation("lightAmbient");this._uLightColor=[];this._uLightDir=[];this._uLightPos=[];this._uLightAttenuation=[];var lights=lightsState.lights;var light;for(var _i322=0,len=lights.length;_i322<len;_i322++){light=lights[_i322];switch(light.type){case"dir":this._uLightColor[_i322]=program.getLocation("lightColor"+_i322);this._uLightPos[_i322]=null;this._uLightDir[_i322]=program.getLocation("lightDir"+_i322);break;case"point":this._uLightColor[_i322]=program.getLocation("lightColor"+_i322);this._uLightPos[_i322]=program.getLocation("lightPos"+_i322);this._uLightDir[_i322]=null;this._uLightAttenuation[_i322]=program.getLocation("lightAttenuation"+_i322);break;case"spot":this._uLightColor[_i322]=program.getLocation("lightColor"+_i322);this._uLightPos[_i322]=program.getLocation("lightPos"+_i322);this._uLightDir[_i322]=program.getLocation("lightDir"+_i322);this._uLightAttenuation[_i322]=program.getLocation("lightAttenuation"+_i322);break;}}this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i323=0,_len69=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i323<_len69;_i323++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i323),pos:program.getLocation("sectionPlanePos"+_i323),dir:program.getLocation("sectionPlaneDir"+_i323)});}if(this._withSAO){this._uOcclusionTexture="uOcclusionTexture";this._uSAOParams=program.getLocation("uSAOParams");}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var lights=scene._lightsState.lights;var project=scene.camera.project;program.bind();if(this._uLightAmbient){gl.uniform4fv(this._uLightAmbient,scene._lightsState.getAmbientColorAndIntensity());}for(var _i324=0,len=lights.length;_i324<len;_i324++){var light=lights[_i324];if(this._uLightColor[_i324]){gl.uniform4f(this._uLightColor[_i324],light.color[0],light.color[1],light.color[2],light.intensity);}if(this._uLightPos[_i324]){gl.uniform3fv(this._uLightPos[_i324],light.pos);if(this._uLightAttenuation[_i324]){gl.uniform1f(this._uLightAttenuation[_i324],light.attenuation);}}if(this._uLightDir[_i324]){gl.uniform3fv(this._uLightDir[_i324],light.dir);}}if(this._withSAO){var sao=scene.sao;var saoEnabled=sao.possible;if(saoEnabled){var viewportWidth=gl.drawingBufferWidth;var viewportHeight=gl.drawingBufferHeight;tempVec4a$5[0]=viewportWidth;tempVec4a$5[1]=viewportHeight;tempVec4a$5[2]=sao.blendCutoff;tempVec4a$5[3]=sao.blendFactor;gl.uniform4fv(this._uSAOParams,tempVec4a$5);this._program.bindTexture(this._uOcclusionTexture,frameCtx.occlusionTexture,10);}}if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var lightsState=scene._lightsState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var light;var src=[];src.push("#version 300 es");src.push("// TrianglesDataTextureColorRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("uniform vec4 lightAmbient;");for(var _i325=0,len=lightsState.lights.length;_i325<len;_i325++){light=lightsState.lights[_i325];if(light.type==="ambient"){continue;}src.push("uniform vec4 lightColor"+_i325+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+_i325+";");}if(light.type==="point"){src.push("uniform vec3 lightPos"+_i325+";");}if(light.type==="spot"){src.push("uniform vec3 lightPos"+_i325+";");src.push("uniform vec3 lightDir"+_i325+";");}}if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("out vec4 vColor;");src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("if (int(flags.x) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("if (isPerspectiveMatrix(projMatrix)) {");src.push("vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");// src.push("vColor = vec4(vec3(1, -1, 0)*dot(normalize(position.xyz - uCameraEyeRtcInQuantizedSpace), normal), 1);")
src.push("if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("} else {");// src.push("vColor = vec4(vec3(1, -1, 0)*viewNormal.z, 1);")
src.push("if (viewNormal.z < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("}");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix * ((objectDecodeAndInstanceMatrix * vec4(position, 1.0))); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");for(var _i326=0,_len70=lightsState.lights.length;_i326<_len70;_i326++){light=lightsState.lights[_i326];if(light.type==="ambient"){continue;}if(light.type==="dir"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i326+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i326+", 0.0)).xyz);");}}else if(light.type==="point"){if(light.space==="view"){src.push("viewLightDir = -normalize(lightPos"+_i326+" - viewPosition.xyz);");}else{src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos"+_i326+", 0.0)).xyz);");}}else if(light.type==="spot"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+_i326+");");}else{src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir"+_i326+", 0.0)).xyz);");}}else{continue;}src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+_i326+".rgb * lightColor"+_i326+".a);");}src.push("vec3 rgb = vec3(color.rgb) / 255.0;");src.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags2 = flags2.r;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// TrianglesDataTextureColorRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(this._withSAO){src.push("uniform sampler2D uOcclusionTexture;");src.push("uniform vec4      uSAOParams;");src.push("const float       packUpscale = 256. / 255.;");src.push("const float       unpackDownScale = 255. / 256.;");src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");src.push("float unpackRGBToFloat( const in vec4 v ) {");src.push("    return dot( v, unPackFactors );");src.push("}");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i327=0,len=sectionPlanesState.getNumAllocatedSectionPlanes();_i327<len;_i327++){src.push("uniform bool sectionPlaneActive"+_i327+";");src.push("uniform vec3 sectionPlanePos"+_i327+";");src.push("uniform vec3 sectionPlaneDir"+_i327+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i328=0,_len71=sectionPlanesState.getNumAllocatedSectionPlanes();_i328<_len71;_i328++){src.push("if (sectionPlaneActive"+_i328+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i328+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i328+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");//src.push("    gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");
}if(this._withSAO){// Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
// Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
src.push("   float viewportWidth     = uSAOParams[0];");src.push("   float viewportHeight    = uSAOParams[1];");src.push("   float blendCutoff       = uSAOParams[2];");src.push("   float blendFactor       = uSAOParams[3];");src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;");src.push("   outColor            = vec4(vColor.rgb * ambient, 1.0);");}else{src.push("   outColor            = vColor;");}src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesColorRenderer;}();var defaultColor$1=new Float32Array([1,1,1]);var tempVec3a$l=math.vec3();var tempVec3b$h=math.vec3();var tempVec3c$d=math.vec3();math.vec3();var tempMat4a$b=math.mat4();/**
 * @private
 */var DTXTrianglesSilhouetteRenderer=/*#__PURE__*/function(){function DTXTrianglesSilhouetteRenderer(scene,primitiveType){_classCallCheck(this,DTXTrianglesSilhouetteRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesSilhouetteRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var scene=this._scene;var camera=scene.camera;var model=dataTextureLayer.model;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=camera.viewMatrix;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx,state);}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3a$l;if(origin){var rotatedOrigin=tempVec3b$h;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$b);rtcCameraEye=tempVec3c$d;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);gl.uniformMatrix4fv(this._uWorldMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);if(renderPass===RENDER_PASSES.SILHOUETTE_XRAYED){var material=scene.xrayMaterial._state;var fillColor=material.fillColor;var fillAlpha=material.fillAlpha;gl.uniform4f(this._uColor,fillColor[0],fillColor[1],fillColor[2],fillAlpha);}else if(renderPass===RENDER_PASSES.SILHOUETTE_HIGHLIGHTED){var _material3=scene.highlightMaterial._state;var _fillColor=_material3.fillColor;var _fillAlpha=_material3.fillAlpha;gl.uniform4f(this._uColor,_fillColor[0],_fillColor[1],_fillColor[2],_fillAlpha);}else if(renderPass===RENDER_PASSES.SILHOUETTE_SELECTED){var _material4=scene.selectedMaterial._state;var _fillColor2=_material4.fillColor;var _fillAlpha2=_material4.fillAlpha;gl.uniform4f(this._uColor,_fillColor2[0],_fillColor2[1],_fillColor2[2],_fillAlpha2);}else{gl.uniform4fv(this._uColor,defaultColor$1);}if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$l);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uColor=program.getLocation("color");this._uWorldMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i329=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i329<len;_i329++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i329),pos:program.getLocation("sectionPlanePos"+_i329),dir:program.getLocation("sectionPlaneDir"+_i329)});}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var project=scene.camera.project;this._program.bind();if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles dataTexture silhouette vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");// src.push("uniform sampler2D uOcclusionTexture;"); 
src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | SILHOUETTE_XRAYED
// renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
src.push("if (int(flags.y) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get normal
src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("if (isPerspectiveMatrix(projMatrix)) {");src.push("vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");src.push("if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("} else {");src.push("if (viewNormal.z < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("}");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix *  (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags2 = flags2.r;");}src.push("gl_Position = clipPos;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Triangles dataTexture draw fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i330=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i330<len;_i330++){src.push("uniform bool sectionPlaneActive"+_i330+";");src.push("uniform vec3 sectionPlanePos"+_i330+";");src.push("uniform vec3 sectionPlaneDir"+_i330+";");}}src.push("uniform vec4 color;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i331=0,_len72=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i331<_len72;_i331++){src.push("if (sectionPlaneActive"+_i331+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i331+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i331+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    outColor = color;");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesSilhouetteRenderer;}();var defaultColor=new Float32Array([0,0,0,1]);var tempVec3a$k=math.vec3();var tempVec3b$g=math.vec3();math.vec3();var tempMat4a$a=math.mat4();/**
 * @private
 */var DTXTrianglesEdgesRenderer=/*#__PURE__*/function(){function DTXTrianglesEdgesRenderer(scene){_classCallCheck(this,DTXTrianglesEdgesRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesEdgesRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=camera.viewMatrix;if(!this._program){this._allocate(dataTextureLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$k;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$g);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$a);}else{rtcViewMatrix=viewMatrix;}gl.uniform1i(this._uRenderPass,renderPass);gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);if(renderPass===RENDER_PASSES.EDGES_XRAYED){var material=scene.xrayMaterial._state;var edgeColor=material.edgeColor;var edgeAlpha=material.edgeAlpha;gl.uniform4f(this._uColor,edgeColor[0],edgeColor[1],edgeColor[2],edgeAlpha);}else if(renderPass===RENDER_PASSES.EDGES_HIGHLIGHTED){var _material5=scene.highlightMaterial._state;var _edgeColor=_material5.edgeColor;var _edgeAlpha=_material5.edgeAlpha;gl.uniform4f(this._uColor,_edgeColor[0],_edgeColor[1],_edgeColor[2],_edgeAlpha);}else if(renderPass===RENDER_PASSES.EDGES_SELECTED){var _material6=scene.selectedMaterial._state;var _edgeColor2=_material6.edgeColor;var _edgeAlpha2=_material6.edgeAlpha;gl.uniform4f(this._uColor,_edgeColor2[0],_edgeColor2[1],_edgeColor2[2],_edgeAlpha2);}else{gl.uniform4fv(this._uColor,defaultColor);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$k);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numEdgeIndices8Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,8// 8 bits edge indices
);gl.drawArrays(gl.LINES,0,state.numEdgeIndices8Bits);}if(state.numEdgeIndices16Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,16// 16 bits edge indices
);gl.drawArrays(gl.LINES,0,state.numEdgeIndices16Bits);}if(state.numEdgeIndices32Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,32// 32 bits edge indices
);gl.drawArrays(gl.LINES,0,state.numEdgeIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uColor=program.getLocation("color");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uWorldMatrix=program.getLocation("worldMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i332=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i332<len;_i332++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i332),pos:program.getLocation("sectionPlanePos"+_i332),dir:program.getLocation("sectionPlaneDir"+_i332)});}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdEdgeIndices="uTexturePerPolygonIdEdgeIndices";this._uTexturePerEdgeIdPortionIds="uTexturePerEdgeIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";}},{key:"_bindProgram",value:function _bindProgram(){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var project=scene.camera.project;program.bind();if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// DTXTrianglesEdgesRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");// if (scene.entityOffsetsEnabled) {
//     src.push("in vec3 offset;");
// }
src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdEdgeIndices;");src.push("uniform mediump usampler2D uTexturePerEdgeIdPortionIds;");src.push("uniform vec4 color;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("out vec4 vColor;");src.push("void main(void) {");// constants
src.push("int edgeIndex = gl_VertexID / 2;");// get packed object-id
src.push("int h_packed_object_id_index = (edgeIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (edgeIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerEdgeIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.z = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
// renderPass = EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
src.push("if (int(flags.z) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedEdgeIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+6, objectIndexCoords.y), 0));");src.push("int edgeIndexBaseOffset = (packedEdgeIndexBaseOffset.r << 24) + (packedEdgeIndexBaseOffset.g << 16) + (packedEdgeIndexBaseOffset.b << 8) + packedEdgeIndexBaseOffset.a;");src.push("int h_index = (edgeIndex - edgeIndexBaseOffset) & 4095;");src.push("int v_index = (edgeIndex - edgeIndexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdEdgeIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("int indexPositionH = uniqueVertexIndexes[gl_VertexID % 2] & 4095;");src.push("int indexPositionV = uniqueVertexIndexes[gl_VertexID % 2] >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// get position
src.push("vec3 position = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH, indexPositionV), 0));");src.push("mat4 matrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags2 = flags2.r;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("vColor = vec4(color.r, color.g, color.b, color.a);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// DTXTrianglesEdgesRenderer fragment shader");if(scene.logarithmicDepthBufferEnabled){src.push("#extension GL_EXT_frag_depth : enable");}src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i333=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i333<len;_i333++){src.push("uniform bool sectionPlaneActive"+_i333+";");src.push("uniform vec3 sectionPlanePos"+_i333+";");src.push("uniform vec3 sectionPlaneDir"+_i333+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i334=0,_len73=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i334<_len73;_i334++){src.push("if (sectionPlaneActive"+_i334+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i334+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i334+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor            = vColor;");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesEdgesRenderer;}();var tempVec3a$j=math.vec3();var tempVec3b$f=math.vec3();var tempMat4a$9=math.mat4();/**
 * @private
 */var DTXTrianglesEdgesColorRenderer=/*#__PURE__*/function(){function DTXTrianglesEdgesColorRenderer(scene){_classCallCheck(this,DTXTrianglesEdgesColorRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesEdgesColorRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=camera.viewMatrix;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$j;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$f);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$9);}else{rtcViewMatrix=viewMatrix;}gl.uniform1i(this._uRenderPass,renderPass);gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$j);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numEdgeIndices8Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,8// 8 bits edge indices
);gl.drawArrays(gl.LINES,0,state.numEdgeIndices8Bits);}if(state.numEdgeIndices16Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,16// 16 bits edge indices
);gl.drawArrays(gl.LINES,0,state.numEdgeIndices16Bits);}if(state.numEdgeIndices32Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,32// 32 bits edge indices
);gl.drawArrays(gl.LINES,0,state.numEdgeIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i335=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i335<len;_i335++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i335),pos:program.getLocation("sectionPlanePos"+_i335),dir:program.getLocation("sectionPlaneDir"+_i335)});}//this._aOffset = program.getAttribute("offset");
if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdEdgeIndices="uTexturePerPolygonIdEdgeIndices";this._uTexturePerEdgeIdPortionIds="uTexturePerEdgeIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";}},{key:"_bindProgram",value:function _bindProgram(){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var project=scene.camera.project;program.bind();if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// TrianglesDataTextureEdgesColorRenderer");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled);src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform highp sampler2D uObjectPerObjectOffsets;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdEdgeIndices;");src.push("uniform mediump usampler2D uTexturePerEdgeIdPortionIds;");//  src.push("uniform vec4 color;");
if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("out vec4 vColor;");src.push("void main(void) {");// constants
src.push("int edgeIndex = gl_VertexID / 2;");// get packed object-id
src.push("int h_packed_object_id_index = (edgeIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (edgeIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerEdgeIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.z = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
// renderPass = EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT
src.push("if (int(flags.z) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedEdgeIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+6, objectIndexCoords.y), 0));");src.push("int edgeIndexBaseOffset = (packedEdgeIndexBaseOffset.r << 24) + (packedEdgeIndexBaseOffset.g << 16) + (packedEdgeIndexBaseOffset.b << 8) + packedEdgeIndexBaseOffset.a;");src.push("int h_index = (edgeIndex - edgeIndexBaseOffset) & 4095;");src.push("int v_index = (edgeIndex - edgeIndexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdEdgeIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("int indexPositionH = uniqueVertexIndexes[gl_VertexID % 2] & 4095;");src.push("int indexPositionV = uniqueVertexIndexes[gl_VertexID % 2] >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// get position
src.push("vec3 position = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH, indexPositionV), 0));");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags2 = flags2.r;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("vec4 rgb = vec4(color.rgba);");//src.push("vColor = vec4(float(color.r-100.0) / 255.0, float(color.g-100.0) / 255.0, float(color.b-100.0) / 255.0, float(color.a) / 255.0);");
src.push("vColor = vec4(float(rgb.r*0.5) / 255.0, float(rgb.g*0.5) / 255.0, float(rgb.b*0.5) / 255.0, float(rgb.a) / 255.0);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// TrianglesDataTextureEdgesColorRenderer");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i336=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i336<len;_i336++){src.push("uniform bool sectionPlaneActive"+_i336+";");src.push("uniform vec3 sectionPlanePos"+_i336+";");src.push("uniform vec3 sectionPlaneDir"+_i336+";");}}src.push("in vec4 vColor;");src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i337=0,_len74=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i337<_len74;_i337++){src.push("if (sectionPlaneActive"+_i337+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i337+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i337+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { discard; }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("   outColor            = vColor;");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesEdgesColorRenderer;}();var tempVec3a$i=math.vec3();var tempVec3b$e=math.vec3();var tempVec3c$c=math.vec3();var tempMat4a$8=math.mat4();/**
 * @private
 */var DTXTrianglesPickMeshRenderer=/*#__PURE__*/function(){function DTXTrianglesPickMeshRenderer(scene){_classCallCheck(this,DTXTrianglesPickMeshRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesPickMeshRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){if(!this._program){this._allocate(dataTextureLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx);}var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$i;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$e);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(camera.viewMatrix,rtcOrigin,tempMat4a$8);rtcCameraEye=tempVec3c$c;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=camera.viewMatrix;rtcCameraEye=camera.eye;}gl.uniform2fv(this._uPickClipPos,frameCtx.pickClipPos);gl.uniform2f(this._uDrawingBufferSize,gl.drawingBufferWidth,gl.drawingBufferHeight);gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(camera.project.far+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$i);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPickInvisible=program.getLocation("pickInvisible");this._uPickClipPos=program.getLocation("pickClipPos");this._uDrawingBufferSize=program.getLocation("drawingBufferSize");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i338=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i338<len;_i338++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i338),pos:program.getLocation("sectionPlanePos"+_i338),dir:program.getLocation("sectionPlaneDir"+_i338)});}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;this._program.bind();gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry picking vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform bool pickInvisible;");// src.push("uniform sampler2D uOcclusionTexture;"); 
src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("uniform vec2 pickClipPos;");src.push("uniform vec2 drawingBufferSize;");src.push("vec4 remapClipPos(vec4 clipPos) {");src.push("    clipPos.xy /= clipPos.w;");src.push("    clipPos.xy = (clipPos.xy - pickClipPos) * drawingBufferSize;");src.push("    clipPos.xy *= clipPos.w;");src.push("    return clipPos;");src.push("}");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");if(clipping){src.push("smooth out vec4 vWorldPosition;");src.push("flat out uvec4 vFlags2;");}src.push("out vec4 vPickColor;");src.push("void main(void) {");src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.w = NOT_RENDERED | PICK
// renderPass = PICK
src.push("if (int(flags.w) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");// get pick-color
src.push("vPickColor = vec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+1, objectIndexCoords.y), 0)) / 255.0;");// get normal
src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("if (isPerspectiveMatrix(projMatrix)) {");src.push("vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");src.push("if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("}");src.push("} else {");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");src.push("if (viewNormal.z < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("}");src.push("}");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags2 = flags2;");}src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Batched geometry picking fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uvec4 vFlags2;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vPickColor;");src.push("out vec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (float(vFlags2.x) > 0.0);");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");//src.push("    gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");
}src.push("   outPickColor = vPickColor; ");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesPickMeshRenderer;}();var tempVec3a$h=math.vec3();var tempVec3b$d=math.vec3();var tempVec3c$b=math.vec3();math.vec3();var tempMat4a$7=math.mat4();/**
 * @private
 */var DTXTrianglesPickDepthRenderer=/*#__PURE__*/function(){function DTXTrianglesPickDepthRenderer(scene){_classCallCheck(this,DTXTrianglesPickDepthRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesPickDepthRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(!this._program){this._allocate();}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3a$h;if(origin){var rotatedOrigin=tempVec3b$d;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$7);rtcCameraEye=tempVec3c$b;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);gl.uniform2fv(this._uPickClipPos,frameCtx.pickClipPos);gl.uniform2f(this._uDrawingBufferSize,gl.drawingBufferWidth,gl.drawingBufferHeight);gl.uniform1f(this._uPickZNear,frameCtx.pickZNear);gl.uniform1f(this._uPickZFar,frameCtx.pickZFar);gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);// TODO: Far from pick project matrix?
gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$h);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPickInvisible=program.getLocation("pickInvisible");this._uPickClipPos=program.getLocation("pickClipPos");this._uDrawingBufferSize=program.getLocation("drawingBufferSize");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i339=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i339<len;_i339++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i339),pos:program.getLocation("sectionPlanePos"+_i339),dir:program.getLocation("sectionPlaneDir"+_i339)});}this._uPickZNear=program.getLocation("pickZNear");this._uPickZFar=program.getLocation("pickZFar");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles dataTexture pick depth vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform bool pickInvisible;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("uniform vec2 pickClipPos;");src.push("uniform vec2 drawingBufferSize;");src.push("vec4 remapClipPos(vec4 clipPos) {");src.push("    clipPos.xy /= clipPos.w;");src.push("    clipPos.xy = (clipPos.xy - pickClipPos) * drawingBufferSize;");src.push("    clipPos.xy *= clipPos.w;");src.push("    return clipPos;");src.push("}");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("out vec4 vViewPosition;");src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.w = NOT_RENDERED | PICK
// renderPass = PICK
src.push("if (int(flags.w) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");// get normal
src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("if (isPerspectiveMatrix(projMatrix)) {");src.push("vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");src.push("if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("}");src.push("} else {");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");src.push("if (viewNormal.z < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("}");src.push("}");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");if(clipping){src.push("      vWorldPosition = worldPosition;");src.push("      vFlags2 = flags2.r;");}src.push("vViewPosition = viewPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = remapClipPos(clipPos);");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Triangles dataTexture pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform float pickZNear;");src.push("uniform float pickZFar;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("uniform bool sectionPlaneActive"+i+";");src.push("uniform vec3 sectionPlanePos"+i+";");src.push("uniform vec3 sectionPlaneDir"+i+";");}}src.push("in vec4 vViewPosition;");src.push("vec4 packDepth(const in float depth) {");src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");src.push("  vec4 res = fract(depth * bitShift);");src.push("  res -= res.xxyz * bitMask;");src.push("  return res;");src.push("}");src.push("out vec4 outPackedDepth;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");src.push("    outPackedDepth = packDepth(zNormalizedDepth); ");// Must be linear depth
src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesPickDepthRenderer;}();var tempVec3a$g=math.vec3();var tempVec3b$c=math.vec3();var tempVec3c$a=math.vec3();var tempVec3d$2=math.vec3();math.vec3();var tempMat4a$6=math.mat4();/**
 * @private
 */var DTXTrianglesSnapRenderer=/*#__PURE__*/function(){function DTXTrianglesSnapRenderer(scene){_classCallCheck(this,DTXTrianglesSnapRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesSnapRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=dataTextureLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;var coordinateScaler=tempVec3a$g;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3b$c;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3c$a);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$6);rtcCameraEye=tempVec3d$2;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this.uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this.uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$g);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}var glMode=frameCtx.snapMode==="edge"?gl.LINES:gl.POINTS;if(state.numEdgeIndices8Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,8// 8 bits edge indices
);gl.drawArrays(glMode,0,state.numEdgeIndices8Bits);}if(state.numEdgeIndices16Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,16// 16 bits edge indices
);gl.drawArrays(glMode,0,state.numEdgeIndices16Bits);}if(state.numEdgeIndices32Bits>0){textureState.bindEdgeIndicesTextures(this._program,this._uTexturePerEdgeIdPortionIds,this._uTexturePerPolygonIdEdgeIndices,32// 32 bits edge indices
);gl.drawArrays(glMode,0,state.numEdgeIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPickInvisible=program.getLocation("pickInvisible");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i340=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i340<len;_i340++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i340),pos:program.getLocation("sectionPlanePos"+_i340),dir:program.getLocation("sectionPlaneDir"+_i340)});}{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdEdgeIndices="uTexturePerPolygonIdEdgeIndices";this._uTexturePerEdgeIdPortionIds="uTexturePerEdgeIdPortionIds";this._uTextureModelMatrices="uTextureModelMatrices";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this.uVectorA=program.getLocation("uSnapVectorA");this.uInverseVectorAB=program.getLocation("uSnapInvVectorAB");this._uLayerNumber=program.getLocation("uLayerNumber");this._uCoordinateScaler=program.getLocation("uCoordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry edges drawing vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdEdgeIndices;");src.push("uniform mediump usampler2D uTexturePerEdgeIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 uSnapVectorA;");src.push("uniform vec2 uSnapInvVectorAB;");src.push("vec3 positions[3];");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out float isPerspective;");}src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - uSnapVectorA.x) * uSnapInvVectorAB.x;");src.push("    float y = (clipPos.y - uSnapVectorA.y) * uSnapInvVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("out vec4 vViewPosition;");src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// constants
src.push("int edgeIndex = gl_VertexID / 2;");// get packed object-id
src.push("int h_packed_object_id_index = (edgeIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (edgeIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerEdgeIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");src.push("{");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedEdgeIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+6, objectIndexCoords.y), 0));");src.push("int edgeIndexBaseOffset = (packedEdgeIndexBaseOffset.r << 24) + (packedEdgeIndexBaseOffset.g << 16) + (packedEdgeIndexBaseOffset.b << 8) + packedEdgeIndexBaseOffset.a;");src.push("int h_index = (edgeIndex - edgeIndexBaseOffset) & 4095;");src.push("int v_index = (edgeIndex - edgeIndexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdEdgeIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("int indexPositionH = uniqueVertexIndexes[gl_VertexID % 2] & 4095;");src.push("int indexPositionV = uniqueVertexIndexes[gl_VertexID % 2] >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");src.push("vec3 position = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH, indexPositionV), 0));");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");if(clipping){src.push("  vWorldPosition = worldPosition;");src.push("  vFlags2 = flags2.r;");}src.push("vViewPosition = viewPosition;");src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");src.push("vViewPosition = clipPos;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("gl_PointSize = 1.0;");// Windows needs this?
src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Triangles dataTexture pick depth fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int uLayerNumber;");src.push("uniform vec3 uCoordinateScaler;");if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i341=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i341<len;_i341++){src.push("uniform bool sectionPlaneActive"+_i341+";");src.push("uniform vec3 sectionPlanePos"+_i341+";");src.push("uniform vec3 sectionPlaneDir"+_i341+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("out highp ivec4 outCoords;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz * uCoordinateScaler.xyz, uLayerNumber);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesSnapRenderer;}();var tempVec3a$f=math.vec3();var tempVec3b$b=math.vec3();var tempVec3c$9=math.vec3();var tempVec3d$1=math.vec3();math.vec3();var tempMat4a$5=math.mat4();/**
 * @private
 */var DTXTrianglesSnapInitRenderer=/*#__PURE__*/function(){function DTXTrianglesSnapInitRenderer(scene){_classCallCheck(this,DTXTrianglesSnapInitRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesSnapInitRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){if(!this._program){this._allocate();}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var aabb=dataTextureLayer.aabb;// Per-layer AABB for best RTC accuracy
var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;var coordinateScaler=tempVec3a$f;coordinateScaler[0]=math.safeInv(aabb[3]-aabb[0])*math.MAX_INT;coordinateScaler[1]=math.safeInv(aabb[4]-aabb[1])*math.MAX_INT;coordinateScaler[2]=math.safeInv(aabb[5]-aabb[2])*math.MAX_INT;frameCtx.snapPickCoordinateScale[0]=math.safeInv(coordinateScaler[0]);frameCtx.snapPickCoordinateScale[1]=math.safeInv(coordinateScaler[1]);frameCtx.snapPickCoordinateScale[2]=math.safeInv(coordinateScaler[2]);textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3b$b;if(gotOrigin){var rotatedOrigin=tempVec3c$9;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$5);rtcCameraEye=tempVec3d$1;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];frameCtx.snapPickOrigin[0]=rtcOrigin[0];frameCtx.snapPickOrigin[1]=rtcOrigin[1];frameCtx.snapPickOrigin[2]=rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;frameCtx.snapPickOrigin[0]=0;frameCtx.snapPickOrigin[1]=0;frameCtx.snapPickOrigin[2]=0;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform2fv(this._uVectorA,frameCtx.snapVectorA);gl.uniform2fv(this._uInverseVectorAB,frameCtx.snapInvVectorAB);gl.uniform1i(this._uLayerNumber,frameCtx.snapPickLayerNumber);gl.uniform3fv(this._uCoordinateScaler,coordinateScaler);gl.uniform1i(this._uRenderPass,renderPass);gl.uniform1i(this._uPickInvisible,frameCtx.pickInvisible);gl.uniformMatrix4fv(this._uSceneWorldModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);{var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$f);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPickInvisible=program.getLocation("pickInvisible");this._uSceneWorldModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i342=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i342<len;_i342++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i342),pos:program.getLocation("sectionPlanePos"+_i342),dir:program.getLocation("sectionPlaneDir"+_i342)});}{this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");this._uVectorA=program.getLocation("uVectorAB");this._uInverseVectorAB=program.getLocation("uInverseVectorAB");this._uLayerNumber=program.getLocation("uLayerNumber");this._uCoordinateScaler=program.getLocation("uCoordinateScaler");}},{key:"_bindProgram",value:function _bindProgram(){this._program.bind();}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// DTXTrianglesSnapInitRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("uniform vec2 uVectorAB;");src.push("uniform vec2 uInverseVectorAB;");src.push("vec3 positions[3];");{src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("vec2 remapClipPos(vec2 clipPos) {");src.push("    float x = (clipPos.x - uVectorAB.x) * uInverseVectorAB.x;");src.push("    float y = (clipPos.y - uVectorAB.y) * uInverseVectorAB.y;");src.push("    return vec2(x, y);");src.push("}");src.push("flat out vec4 vPickColor;");src.push("out vec4 vWorldPosition;");if(clipping){src.push("flat out uint vFlags2;");}src.push("out highp vec3 relativeToOriginPosition;");src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");src.push("{");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get normal
src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("  if (isPerspectiveMatrix(projMatrix)) {");src.push("      vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");src.push("      if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("          position = positions[2 - (gl_VertexID % 3)];");src.push("          viewNormal = -viewNormal;");src.push("      }");src.push("  } else {");src.push("      if (viewNormal.z < 0.0) {");src.push("          position = positions[2 - (gl_VertexID % 3)];");src.push("          viewNormal = -viewNormal;");src.push("      }");src.push("  }");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("relativeToOriginPosition = worldPosition.xyz;");src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");src.push("vWorldPosition = worldPosition;");if(clipping){src.push("vFlags2 = flags2.r;");}src.push("vPickColor = vec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+1, objectIndexCoords.y), 0));");// TODO: Normalized color? See here:
//src.push("vPickColor = vec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+1, objectIndexCoords.y), 0)) /255.0;");
src.push("vec4 clipPos = projMatrix * viewPosition;");src.push("float tmp = clipPos.w;");src.push("clipPos.xyzw /= tmp;");src.push("clipPos.xy = remapClipPos(clipPos.xy);");src.push("clipPos.xyzw *= tmp;");{src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// DTXTrianglesSnapInitRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");{src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("uniform int uLayerNumber;");src.push("uniform vec3 uCoordinateScaler;");src.push("in vec4 vWorldPosition;");src.push("flat in vec4 vPickColor;");if(clipping){src.push("flat in uint vFlags2;");for(var _i343=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i343<len;_i343++){src.push("uniform bool sectionPlaneActive"+_i343+";");src.push("uniform vec3 sectionPlanePos"+_i343+";");src.push("uniform vec3 sectionPlaneDir"+_i343+";");}}src.push("in highp vec3 relativeToOriginPosition;");src.push("layout(location = 0) out highp ivec4 outCoords;");src.push("layout(location = 1) out highp ivec4 outNormal;");src.push("layout(location = 2) out lowp uvec4 outPickColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}{src.push("    float dx = dFdx(vFragDepth);");src.push("    float dy = dFdy(vFragDepth);");src.push("    float diff = sqrt(dx*dx+dy*dy);");src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth + diff ) * logDepthBufFC * 0.5;");}src.push("outCoords = ivec4(relativeToOriginPosition.xyz * uCoordinateScaler.xyz, - uLayerNumber);");src.push("vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("outPickColor = uvec4(vPickColor);");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesSnapInitRenderer;}();var tempVec3a$e=math.vec3();var tempVec3b$a=math.vec3();var tempVec3c$8=math.vec3();math.vec3();var tempMat4a$4=math.mat4();/**
 * @private
 */var DTXTrianglesOcclusionRenderer=/*#__PURE__*/function(){function DTXTrianglesOcclusionRenderer(scene){_classCallCheck(this,DTXTrianglesOcclusionRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesOcclusionRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=frameCtx.pickViewMatrix||camera.viewMatrix;if(!this._program){this._allocate(dataTextureLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram();}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;if(origin||position[0]!==0||position[1]!==0||position[2]!==0){var rtcOrigin=tempVec3a$e;if(origin){var rotatedOrigin=tempVec3b$a;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$4);rtcCameraEye=tempVec3c$8;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;}gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);gl.uniformMatrix4fv(this._uWorldMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$e);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPickInvisible=program.getLocation("pickInvisible");this._uWorldMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i344=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i344<len;_i344++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i344),pos:program.getLocation("sectionPlanePos"+_i344),dir:program.getLocation("sectionPlaneDir"+_i344)});}this._uPickZNear=program.getLocation("pickZNear");this._uPickZFar=program.getLocation("pickZFar");if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(){var scene=this._scene;scene.canvas.gl;scene.camera.project;this._program.bind();}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// TrianglesDataTextureOcclusionRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
// Only opaque objects can be occluders
src.push("if (int(flags.x) != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");// Cull vertex
src.push("  } else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("  if (isPerspectiveMatrix(projMatrix)) {");src.push("      vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");src.push("      if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("          position = positions[2 - (gl_VertexID % 3)];");src.push("      }");src.push("  } else {");src.push("      vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");src.push("      if (viewNormal.z < 0.0) {");src.push("          position = positions[2 - (gl_VertexID % 3)];");src.push("      }");src.push("  }");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix *  (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");src.push("vec4 clipPos = projMatrix * viewPosition;");if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags2 = flags2.r;");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var sectionPlanesState=scene._sectionPlanesState;var clipping=sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// TrianglesDataTextureColorRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i345=0;_i345<sectionPlanesState.getNumAllocatedSectionPlanes();_i345++){src.push("uniform bool sectionPlaneActive"+_i345+";");src.push("uniform vec3 sectionPlanePos"+_i345+";");src.push("uniform vec3 sectionPlaneDir"+_i345+";");}}src.push("out vec4 outColor;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (float(vFlags2) > 0.0);");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var _i346=0;_i346<sectionPlanesState.getNumAllocatedSectionPlanes();_i346++){src.push("      if (sectionPlaneActive"+_i346+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+_i346+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i346+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}src.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); ");// Occluders are blue
src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesOcclusionRenderer;}();var tempVec3a$d=math.vec3();var tempVec3b$9=math.vec3();var tempVec3c$7=math.vec3();math.vec3();var tempMat4a$3=math.mat4();/**
 * @private
 */var DTXTrianglesDepthRenderer=/*#__PURE__*/function(){function DTXTrianglesDepthRenderer(scene){_classCallCheck(this,DTXTrianglesDepthRenderer);this._scene=scene;this._allocate();this._hash=this._getHash();}_createClass(DTXTrianglesDepthRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var scene=this._scene;var camera=scene.camera;var model=dataTextureLayer.model;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx,state);}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$d;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$9);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(camera.viewMatrix,rtcOrigin,tempMat4a$3);rtcCameraEye=tempVec3c$7;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=camera.viewMatrix;rtcCameraEye=camera.eye;}gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$d);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPositionsDecodeMatrix=program.getLocation("objectDecodeAndInstanceMatrix");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i347=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i347<len;_i347++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i347),pos:program.getLocation("sectionPlanePos"+_i347),dir:program.getLocation("sectionPlaneDir"+_i347)});}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var project=scene.camera.project;program.bind();gl.uniformMatrix4fv(this._uProjMatrix,false,project.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Triangles dataTexture draw vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out highp vec2 vHighPrecisionZW;");if(clipping){src.push("out vec4 vWorldPosition;");src.push("flat out uint vFlags2;");}src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("if (int(flags.x) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");// get normal
src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("if (isPerspectiveMatrix(projMatrix)) {");src.push("vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");src.push("if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("} else {");src.push("if (viewNormal.z < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("}");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}if(clipping){src.push("vWorldPosition = worldPosition;");src.push("vFlags2 = flags2.r;");}src.push("gl_Position = clipPos;");src.push("vHighPrecisionZW = gl_Position.zw;");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// Triangles dataTexture draw fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");src.push("in highp vec2 vHighPrecisionZW;");src.push("out vec4 outColor;");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("flat in uint vFlags2;");for(var _i348=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i348<len;_i348++){src.push("uniform bool sectionPlaneActive"+_i348+";");src.push("uniform vec3 sectionPlanePos"+_i348+";");src.push("uniform vec3 sectionPlaneDir"+_i348+";");}}src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i349=0,_len75=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i349<_len75;_i349++){src.push("if (sectionPlaneActive"+_i349+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i349+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i349+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");//src.push("    gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;");
}src.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;");src.push("    outColor = vec4(vec3(1.0 - fragCoordZ), 1.0); ");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesDepthRenderer;}();var tempVec3a$c=math.vec3();var tempVec3b$8=math.vec3();var tempVec3c$6=math.vec3();math.vec3();var tempMat4a$2=math.mat4();/**
 * @private
 */var DTXTrianglesNormalsRenderer=/*#__PURE__*/function(){function DTXTrianglesNormalsRenderer(scene){_classCallCheck(this,DTXTrianglesNormalsRenderer);this._scene=scene;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesNormalsRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){return this._scene._sectionPlanesState.getHash();}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var model=dataTextureLayer.model;var scene=model.scene;var camera=scene.camera;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;var viewMatrix=camera.viewMatrix;if(!this._program){this._allocate(dataTextureLayer);if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(dataTextureLayer);}var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$c;if(gotOrigin){var rotatedOrigin=tempVec3b$8;math.transformPoint3(rotationMatrix,origin,rotatedOrigin);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(viewMatrix,rtcOrigin,tempMat4a$2);rtcCameraEye=tempVec3c$6;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=viewMatrix;rtcCameraEye=camera.eye;}gl.uniform1i(this._uRenderPass,renderPass);gl.uniformMatrix4fv(this._uWorldMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);gl.uniformMatrix4fv(this._uViewNormalMatrix,false,camera.viewNormalMatrix);gl.uniformMatrix4fv(this._uWorldNormalMatrix,false,model.worldNormalMatrix);var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$c);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,false,dataTextureLayer._state.objectDecodeAndInstanceMatrix);this._aPosition.bindArrayBuffer(state.positionsBuf);this._aOffset.bindArrayBuffer(state.offsetsBuf);this._aNormal.bindArrayBuffer(state.normalsBuf);this._aColor.bindArrayBuffer(state.colorsBuf);// Needed for masking out transparent entities using alpha channel
this._aFlags.bindArrayBuffer(state.flagsBuf);if(this._aFlags2){this._aFlags2.bindArrayBuffer(state.flags2Buf);}state.indicesBuf.bind();gl.drawElements(gl.TRIANGLES,state.indicesBuf.numItems,state.indicesBuf.itemType,0);}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPositionsDecodeMatrix=program.getLocation("objectDecodeAndInstanceMatrix");this._uWorldMatrix=program.getLocation("worldMatrix");this._uWorldNormalMatrix=program.getLocation("worldNormalMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uViewNormalMatrix=program.getLocation("viewNormalMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i350=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i350<len;_i350++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i350),pos:program.getLocation("sectionPlanePos"+_i350),dir:program.getLocation("sectionPlaneDir"+_i350)});}this._aPosition=program.getAttribute("position");this._aOffset=program.getAttribute("offset");this._aNormal=program.getAttribute("normal");this._aColor=program.getAttribute("color");this._aFlags=program.getAttribute("flags");if(this._aFlags2){// Won't be in shader when not clipping
this._aFlags2=program.getAttribute("flags2");}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}}},{key:"_bindProgram",value:function _bindProgram(){var scene=this._scene;var gl=scene.canvas.gl;var project=scene.camera.project;this._program.bind();gl.uniformMatrix4fv(this._uProjMatrix,false,project.matrix);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("// Batched geometry normals vertex shader");if(scene.logarithmicDepthBufferEnabled&&WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]){src.push("#extension GL_EXT_frag_depth : enable");}src.push("uniform int renderPass;");src.push("attribute vec3 position;");if(scene.entityOffsetsEnabled){src.push("attribute vec3 offset;");}src.push("attribute vec3 normal;");src.push("attribute vec4 color;");src.push("attribute vec4 flags;");src.push("attribute vec4 flags2;");src.push("uniform mat4 worldMatrix;");src.push("uniform mat4 worldNormalMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform mat4 viewNormalMatrix;");src.push("uniform mat4 objectDecodeAndInstanceMatrix;");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");if(WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]){src.push("out float vFragDepth;");}src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("varying float isPerspective;");}src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}");if(clipping){src.push("out vec4 vWorldPosition;");src.push("out vec4 vFlags2;");}src.push("out vec3 vViewNormal;");src.push("void main(void) {");// flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
// renderPass = COLOR_OPAQUE
src.push("if (int(flags.x) != renderPass) {");src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");src.push("  } else {");src.push("      vec4 worldPosition = worldMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");if(scene.entityOffsetsEnabled){src.push("      worldPosition.xyz = worldPosition.xyz + offset;");}src.push("      vec4 viewPosition   = viewMatrix * worldPosition; ");src.push("      vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");src.push("      vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);");if(clipping){src.push("      vWorldPosition  = worldPosition;");src.push("      vFlags2         = flags2;");}src.push("      vViewNormal = viewNormal;");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){if(WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]){src.push("vFragDepth = 1.0 + clipPos.w;");}else{src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");src.push("clipPos.z *= clipPos.w;");}src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("gl_Position = clipPos;");src.push("  }");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// Batched geometry normals fragment shader");if(scene.logarithmicDepthBufferEnabled&&WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]){src.push("#extension GL_EXT_frag_depth : enable");}src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled&&WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}if(clipping){src.push("in vec4 vWorldPosition;");src.push("in vec4 vFlags2;");for(var _i351=0;_i351<scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i351++){src.push("uniform bool sectionPlaneActive"+_i351+";");src.push("uniform vec3 sectionPlanePos"+_i351+";");src.push("uniform vec3 sectionPlaneDir"+_i351+";");}}src.push("in vec3 vViewNormal;");src.push("vec3 packNormalToRGB( const in vec3 normal ) {");src.push("    return normalize( normal ) * 0.5 + 0.5;");src.push("}");src.push("void main(void) {");if(clipping){src.push("  bool clippable = (float(vFlags2.x) > 0.0);");src.push("  if (clippable) {");src.push("      float dist = 0.0;");for(var i=0;i<scene._sectionPlanesState.getNumAllocatedSectionPlanes();i++){src.push("      if (sectionPlaneActive"+i+") {");src.push("          dist += clamp(dot(-sectionPlaneDir"+i+".xyz, vWorldPosition.xyz - sectionPlanePos"+i+".xyz), 0.0, 1000.0);");src.push("      }");}src.push("      if (dist > 0.0) { discard; }");src.push("  }");}if(scene.logarithmicDepthBufferEnabled&&WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]){src.push("    gl_FragDepthEXT = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("    gl_FragColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesNormalsRenderer;}();var tempVec3a$b=math.vec3();var tempVec3b$7=math.vec3();var tempVec3c$5=math.vec3();math.vec3();math.vec4();var tempMat4a$1=math.mat4();/**
 * @private
 */var DTXTrianglesPickNormalsFlatRenderer=/*#__PURE__*/function(){function DTXTrianglesPickNormalsFlatRenderer(scene,withSAO){_classCallCheck(this,DTXTrianglesPickNormalsFlatRenderer);this._scene=scene;this._withSAO=withSAO;this._hash=this._getHash();this._allocate();}_createClass(DTXTrianglesPickNormalsFlatRenderer,[{key:"getValid",value:function getValid(){return this._hash===this._getHash();}},{key:"_getHash",value:function _getHash(){var scene=this._scene;return[scene._lightsState.getHash(),scene._sectionPlanesState.getHash(),this._withSAO?"sao":"nosao"].join(";");}},{key:"drawLayer",value:function drawLayer(frameCtx,dataTextureLayer,renderPass){var scene=this._scene;var camera=scene.camera;var model=dataTextureLayer.model;var gl=scene.canvas.gl;var state=dataTextureLayer._state;var textureState=state.textureState;var origin=dataTextureLayer._state.origin;var position=model.position,rotationMatrix=model.rotationMatrix,rotationMatrixConjugate=model.rotationMatrixConjugate;if(!this._program){this._allocate();if(this.errors){return;}}if(frameCtx.lastProgramId!==this._program.id){frameCtx.lastProgramId=this._program.id;this._bindProgram(frameCtx,state);}textureState.bindCommonTextures(this._program,this.uTexturePerObjectPositionsDecodeMatrix,this._uTexturePerVertexIdCoordinates,this.uTexturePerObjectColorsAndFlags,this._uTexturePerObjectMatrix);var rtcViewMatrix;var rtcCameraEye;var gotOrigin=origin[0]!==0||origin[1]!==0||origin[2]!==0;var gotPosition=position[0]!==0||position[1]!==0||position[2]!==0;if(gotOrigin||gotPosition){var rtcOrigin=tempVec3a$b;if(gotOrigin){var rotatedOrigin=math.transformPoint3(rotationMatrix,origin,tempVec3b$7);rtcOrigin[0]=rotatedOrigin[0];rtcOrigin[1]=rotatedOrigin[1];rtcOrigin[2]=rotatedOrigin[2];}else{rtcOrigin[0]=0;rtcOrigin[1]=0;rtcOrigin[2]=0;}rtcOrigin[0]+=position[0];rtcOrigin[1]+=position[1];rtcOrigin[2]+=position[2];rtcViewMatrix=createRTCViewMat(camera.viewMatrix,rtcOrigin,tempMat4a$1);rtcCameraEye=tempVec3c$5;rtcCameraEye[0]=camera.eye[0]-rtcOrigin[0];rtcCameraEye[1]=camera.eye[1]-rtcOrigin[1];rtcCameraEye[2]=camera.eye[2]-rtcOrigin[2];}else{rtcViewMatrix=camera.viewMatrix;// TODO: make pickMatrix
rtcCameraEye=camera.eye;}gl.uniform2fv(this._uPickClipPos,frameCtx.pickClipPos);gl.uniform2f(this._uDrawingBufferSize,gl.drawingBufferWidth,gl.drawingBufferHeight);gl.uniformMatrix4fv(this._uSceneModelMatrix,false,rotationMatrixConjugate);gl.uniformMatrix4fv(this._uViewMatrix,false,rtcViewMatrix);gl.uniformMatrix4fv(this._uProjMatrix,false,camera.projMatrix);// TODO: pickProjMatrix
gl.uniform3fv(this._uCameraEyeRtc,rtcCameraEye);gl.uniform1i(this._uRenderPass,renderPass);if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(frameCtx.pickZFar+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}var numAllocatedSectionPlanes=scene._sectionPlanesState.getNumAllocatedSectionPlanes();var numSectionPlanes=scene._sectionPlanesState.sectionPlanes.length;if(numAllocatedSectionPlanes>0){var sectionPlanes=scene._sectionPlanesState.sectionPlanes;var baseIndex=dataTextureLayer.layerIndex*numSectionPlanes;var renderFlags=model.renderFlags;for(var sectionPlaneIndex=0;sectionPlaneIndex<numAllocatedSectionPlanes;sectionPlaneIndex++){var sectionPlaneUniforms=this._uSectionPlanes[sectionPlaneIndex];if(sectionPlaneUniforms){if(sectionPlaneIndex<numSectionPlanes){var active=renderFlags.sectionPlanesActivePerLayer[baseIndex+sectionPlaneIndex];gl.uniform1i(sectionPlaneUniforms.active,active?1:0);if(active){var sectionPlane=sectionPlanes[sectionPlaneIndex];if(origin){var rtcSectionPlanePos=getPlaneRTCPos(sectionPlane.dist,sectionPlane.dir,origin,tempVec3a$b);gl.uniform3fv(sectionPlaneUniforms.pos,rtcSectionPlanePos);}else{gl.uniform3fv(sectionPlaneUniforms.pos,sectionPlane.pos);}gl.uniform3fv(sectionPlaneUniforms.dir,sectionPlane.dir);}}else{gl.uniform1i(sectionPlaneUniforms.active,0);}}}}if(state.numIndices8Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,8// 8 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices8Bits);}if(state.numIndices16Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,16// 16 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices16Bits);}if(state.numIndices32Bits>0){textureState.bindTriangleIndicesTextures(this._program,this._uTexturePerPolygonIdPortionIds,this._uTexturePerPolygonIdIndices,32// 32 bits indices
);gl.drawArrays(gl.TRIANGLES,0,state.numIndices32Bits);}frameCtx.drawElements++;}},{key:"_allocate",value:function _allocate(){var scene=this._scene;var gl=scene.canvas.gl;this._program=new Program(gl,this._buildShader());if(this._program.errors){this.errors=this._program.errors;return;}var program=this._program;this._uRenderPass=program.getLocation("renderPass");this._uPickInvisible=program.getLocation("pickInvisible");this._uPickClipPos=program.getLocation("pickClipPos");this._uDrawingBufferSize=program.getLocation("drawingBufferSize");this._uSceneModelMatrix=program.getLocation("sceneModelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uSectionPlanes=[];for(var _i352=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i352<len;_i352++){this._uSectionPlanes.push({active:program.getLocation("sectionPlaneActive"+_i352),pos:program.getLocation("sectionPlanePos"+_i352),dir:program.getLocation("sectionPlaneDir"+_i352)});}if(scene.logarithmicDepthBufferEnabled){this._uLogDepthBufFC=program.getLocation("logDepthBufFC");}this.uTexturePerObjectPositionsDecodeMatrix="uObjectPerObjectPositionsDecodeMatrix";this.uTexturePerObjectColorsAndFlags="uObjectPerObjectColorsAndFlags";this._uTexturePerVertexIdCoordinates="uTexturePerVertexIdCoordinates";this._uTexturePerPolygonIdNormals="uTexturePerPolygonIdNormals";this._uTexturePerPolygonIdIndices="uTexturePerPolygonIdIndices";this._uTexturePerPolygonIdPortionIds="uTexturePerPolygonIdPortionIds";this._uTexturePerObjectMatrix="uTexturePerObjectMatrix";this._uCameraEyeRtc=program.getLocation("uCameraEyeRtc");}},{key:"_bindProgram",value:function _bindProgram(frameCtx){var scene=this._scene;var gl=scene.canvas.gl;var program=this._program;var project=scene.camera.project;program.bind();if(scene.logarithmicDepthBufferEnabled){var logDepthBufFC=2.0/(Math.log(project.far+1.0)/Math.LN2);gl.uniform1f(this._uLogDepthBufFC,logDepthBufFC);}}},{key:"_buildShader",value:function _buildShader(){return{vertex:this._buildVertexShader(),fragment:this._buildFragmentShader()};}},{key:"_buildVertexShader",value:function _buildVertexShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push("#version 300 es");src.push("// trianglesDatatextureNormalsRenderer vertex shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("precision highp usampler2D;");src.push("precision highp isampler2D;");src.push("precision highp sampler2D;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("precision mediump usampler2D;");src.push("precision mediump isampler2D;");src.push("precision mediump sampler2D;");src.push("#endif");src.push("uniform int renderPass;");if(scene.entityOffsetsEnabled){src.push("in vec3 offset;");}src.push("uniform mat4 sceneModelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform highp sampler2D uObjectPerObjectPositionsDecodeMatrix;");src.push("uniform lowp usampler2D uObjectPerObjectColorsAndFlags;");src.push("uniform highp sampler2D uTexturePerObjectMatrix;");src.push("uniform mediump usampler2D uTexturePerVertexIdCoordinates;");src.push("uniform highp usampler2D uTexturePerPolygonIdIndices;");src.push("uniform mediump usampler2D uTexturePerPolygonIdPortionIds;");src.push("uniform vec3 uCameraEyeRtc;");src.push("vec3 positions[3];");if(scene.logarithmicDepthBufferEnabled){src.push("uniform float logDepthBufFC;");src.push("out float vFragDepth;");src.push("out float isPerspective;");}src.push("uniform vec2 pickClipPos;");src.push("uniform vec2 drawingBufferSize;");src.push("vec4 remapClipPos(vec4 clipPos) {");src.push("    clipPos.xy /= clipPos.w;");src.push("    clipPos.xy = (clipPos.xy - pickClipPos) * drawingBufferSize;");src.push("    clipPos.xy *= clipPos.w;");src.push("    return clipPos;");src.push("}");src.push("bool isPerspectiveMatrix(mat4 m) {");src.push("    return (m[2][3] == - 1.0);");src.push("}");src.push("out vec4 vWorldPosition;");if(clipping){src.push("flat out uint vFlags2;");}src.push("void main(void) {");// constants
src.push("int polygonIndex = gl_VertexID / 3;");// get packed object-id
src.push("int h_packed_object_id_index = (polygonIndex >> 3) & 4095;");src.push("int v_packed_object_id_index = (polygonIndex >> 3) >> 12;");src.push("int objectIndex = int(texelFetch(uTexturePerPolygonIdPortionIds, ivec2(h_packed_object_id_index, v_packed_object_id_index), 0).r);");src.push("ivec2 objectIndexCoords = ivec2(objectIndex % 512, objectIndex / 512);");// get flags & flags2
src.push("uvec4 flags = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+2, objectIndexCoords.y), 0);");src.push("uvec4 flags2 = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+3, objectIndexCoords.y), 0);");// pickFlag = NOT_RENDERED | PICK
// renderPass = PICK
src.push("if (int(flags.w) != renderPass) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");// Cull vertex
src.push("} else {");// get vertex base
src.push("ivec4 packedVertexBase = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+4, objectIndexCoords.y), 0));");src.push("ivec4 packedIndexBaseOffset = ivec4(texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+5, objectIndexCoords.y), 0));");src.push("int indexBaseOffset = (packedIndexBaseOffset.r << 24) + (packedIndexBaseOffset.g << 16) + (packedIndexBaseOffset.b << 8) + packedIndexBaseOffset.a;");src.push("int h_index = (polygonIndex - indexBaseOffset) & 4095;");src.push("int v_index = (polygonIndex - indexBaseOffset) >> 12;");src.push("ivec3 vertexIndices = ivec3(texelFetch(uTexturePerPolygonIdIndices, ivec2(h_index, v_index), 0));");src.push("ivec3 uniqueVertexIndexes = vertexIndices + (packedVertexBase.r << 24) + (packedVertexBase.g << 16) + (packedVertexBase.b << 8) + packedVertexBase.a;");src.push("ivec3 indexPositionH = uniqueVertexIndexes & 4095;");src.push("ivec3 indexPositionV = uniqueVertexIndexes >> 12;");src.push("mat4 objectInstanceMatrix = mat4 (texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uTexturePerObjectMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("mat4 objectDecodeAndInstanceMatrix = objectInstanceMatrix * mat4 (texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+0, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+1, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+2, objectIndexCoords.y), 0), texelFetch (uObjectPerObjectPositionsDecodeMatrix, ivec2(objectIndexCoords.x*4+3, objectIndexCoords.y), 0));");src.push("uint solid = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+7, objectIndexCoords.y), 0).r;");// get position
src.push("positions[0] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.r, indexPositionV.r), 0));");src.push("positions[1] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.g, indexPositionV.g), 0));");src.push("positions[2] = vec3(texelFetch(uTexturePerVertexIdCoordinates, ivec2(indexPositionH.b, indexPositionV.b), 0));");// get color
src.push("uvec4 color = texelFetch (uObjectPerObjectColorsAndFlags, ivec2(objectIndexCoords.x*8+0, objectIndexCoords.y), 0);");src.push("if (color.a == 0u) {");src.push("   gl_Position = vec4(3.0, 3.0, 3.0, 1.0);");// Cull vertex
src.push("   return;");src.push("};");// get normal
src.push("vec3 normal = normalize(cross(positions[2] - positions[0], positions[1] - positions[0]));");src.push("vec3 position;");src.push("position = positions[gl_VertexID % 3];");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");// when the geometry is not solid, if needed, flip the triangle winding
src.push("if (solid != 1u) {");src.push("if (isPerspectiveMatrix(projMatrix)) {");src.push("vec3 uCameraEyeRtcInQuantizedSpace = (inverse(sceneModelMatrix * objectDecodeAndInstanceMatrix) * vec4(uCameraEyeRtc, 1)).xyz;");// src.push("vColor = vec4(vec3(1, -1, 0)*dot(normalize(position.xyz - uCameraEyeRtcInQuantizedSpace), normal), 1);")
src.push("if (dot(position.xyz - uCameraEyeRtcInQuantizedSpace, normal) < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("viewNormal = -viewNormal;");src.push("}");src.push("} else {");src.push("vec3 viewNormal = -normalize((transpose(inverse(viewMatrix*objectDecodeAndInstanceMatrix)) * vec4(normal,1)).xyz);");src.push("if (viewNormal.z < 0.0) {");src.push("position = positions[2 - (gl_VertexID % 3)];");src.push("}");src.push("}");src.push("}");src.push("vec4 worldPosition = sceneModelMatrix * (objectDecodeAndInstanceMatrix * vec4(position, 1.0)); ");src.push("vec4 viewPosition = viewMatrix * worldPosition; ");src.push("vec4 clipPos = projMatrix * viewPosition;");if(scene.logarithmicDepthBufferEnabled){src.push("vFragDepth = 1.0 + clipPos.w;");src.push("isPerspective = float (isPerspectiveMatrix(projMatrix));");}src.push("vWorldPosition = worldPosition;");if(clipping){src.push("vFlags2 = flags2.r;");}src.push("gl_Position = remapClipPos(clipPos);");src.push("}");src.push("}");return src;}},{key:"_buildFragmentShader",value:function _buildFragmentShader(){var scene=this._scene;var clipping=scene._sectionPlanesState.getNumAllocatedSectionPlanes()>0;var src=[];src.push('#version 300 es');src.push("// TrianglesDataTexturePickNormalsRenderer fragment shader");src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");src.push("precision highp float;");src.push("precision highp int;");src.push("#else");src.push("precision mediump float;");src.push("precision mediump int;");src.push("#endif");if(scene.logarithmicDepthBufferEnabled){src.push("in float isPerspective;");src.push("uniform float logDepthBufFC;");src.push("in float vFragDepth;");}src.push("in vec4 vWorldPosition;");if(clipping){src.push("flat in uint vFlags2;");for(var _i353=0,len=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i353<len;_i353++){src.push("uniform bool sectionPlaneActive"+_i353+";");src.push("uniform vec3 sectionPlanePos"+_i353+";");src.push("uniform vec3 sectionPlaneDir"+_i353+";");}}src.push("out highp ivec4 outNormal;");src.push("void main(void) {");if(clipping){src.push("  bool clippable = vFlags2 > 0u;");src.push("  if (clippable) {");src.push("  float dist = 0.0;");for(var _i354=0,_len76=scene._sectionPlanesState.getNumAllocatedSectionPlanes();_i354<_len76;_i354++){src.push("if (sectionPlaneActive"+_i354+") {");src.push("   dist += clamp(dot(-sectionPlaneDir"+_i354+".xyz, vWorldPosition.xyz - sectionPlanePos"+_i354+".xyz), 0.0, 1000.0);");src.push("}");}src.push("  if (dist > 0.0) { ");src.push("      discard;");src.push("  }");src.push("}");}if(scene.logarithmicDepthBufferEnabled){src.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;");}src.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );");src.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );");src.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");src.push("  outNormal = ivec4(worldNormal * float(".concat(math.MAX_INT,"), 1.0);"));src.push("}");return src;}},{key:"webglContextRestored",value:function webglContextRestored(){this._program=null;}},{key:"destroy",value:function destroy(){if(this._program){this._program.destroy();}this._program=null;}}]);return DTXTrianglesPickNormalsFlatRenderer;}();/**
 * @private
 */var DTXTrianglesRenderers=/*#__PURE__*/function(){function DTXTrianglesRenderers(scene){_classCallCheck(this,DTXTrianglesRenderers);this._scene=scene;}_createClass(DTXTrianglesRenderers,[{key:"_compile",value:function _compile(){if(this._colorRenderer&&!this._colorRenderer.getValid()){this._colorRenderer.destroy();this._colorRenderer=null;}if(this._colorRendererWithSAO&&!this._colorRendererWithSAO.getValid()){this._colorRendererWithSAO.destroy();this._colorRendererWithSAO=null;}if(this._flatColorRenderer&&!this._flatColorRenderer.getValid()){this._flatColorRenderer.destroy();this._flatColorRenderer=null;}if(this._flatColorRendererWithSAO&&!this._flatColorRendererWithSAO.getValid()){this._flatColorRendererWithSAO.destroy();this._flatColorRendererWithSAO=null;}if(this._colorQualityRendererWithSAO&&!this._colorQualityRendererWithSAO.getValid()){this._colorQualityRendererWithSAO.destroy();this._colorQualityRendererWithSAO=null;}if(this._depthRenderer&&!this._depthRenderer.getValid()){this._depthRenderer.destroy();this._depthRenderer=null;}if(this._normalsRenderer&&!this._normalsRenderer.getValid()){this._normalsRenderer.destroy();this._normalsRenderer=null;}if(this._silhouetteRenderer&&!this._silhouetteRenderer.getValid()){this._silhouetteRenderer.destroy();this._silhouetteRenderer=null;}if(this._edgesRenderer&&!this._edgesRenderer.getValid()){this._edgesRenderer.destroy();this._edgesRenderer=null;}if(this._edgesColorRenderer&&!this._edgesColorRenderer.getValid()){this._edgesColorRenderer.destroy();this._edgesColorRenderer=null;}if(this._pickMeshRenderer&&!this._pickMeshRenderer.getValid()){this._pickMeshRenderer.destroy();this._pickMeshRenderer=null;}if(this._pickDepthRenderer&&!this._pickDepthRenderer.getValid()){this._pickDepthRenderer.destroy();this._pickDepthRenderer=null;}if(this._snapRenderer&&!this._snapRenderer.getValid()){this._snapRenderer.destroy();this._snapRenderer=null;}if(this._snapInitRenderer&&!this._snapInitRenderer.getValid()){this._snapInitRenderer.destroy();this._snapInitRenderer=null;}if(this._pickNormalsRenderer&&this._pickNormalsRenderer.getValid()===false){this._pickNormalsRenderer.destroy();this._pickNormalsRenderer=null;}if(this._pickNormalsFlatRenderer&&this._pickNormalsFlatRenderer.getValid()===false){this._pickNormalsFlatRenderer.destroy();this._pickNormalsFlatRenderer=null;}if(this._occlusionRenderer&&this._occlusionRenderer.getValid()===false){this._occlusionRenderer.destroy();this._occlusionRenderer=null;}}},{key:"eagerCreateRenders",value:function eagerCreateRenders(){// Pre-initialize certain renderers that would otherwise be lazy-initialised
// on user interaction, such as picking or emphasis, so that there is no delay
// when user first begins interacting with the viewer.
if(!this._silhouetteRenderer){// Used for highlighting and selection
this._silhouetteRenderer=new DTXTrianglesSilhouetteRenderer(this._scene);}if(!this._pickMeshRenderer){this._pickMeshRenderer=new DTXTrianglesPickMeshRenderer(this._scene);}if(!this._pickDepthRenderer){this._pickDepthRenderer=new DTXTrianglesPickDepthRenderer(this._scene);}if(!this._pickNormalsRenderer){this._pickNormalsRenderer=new DTXTrianglesPickNormalsFlatRenderer(this._scene);}if(!this._snapRenderer){this._snapRenderer=new DTXTrianglesSnapRenderer(this._scene);}if(!this._snapInitRenderer){this._snapInitRenderer=new DTXTrianglesSnapInitRenderer(this._scene);}if(!this._snapRenderer){this._snapRenderer=new DTXTrianglesSnapRenderer(this._scene);}}},{key:"colorRenderer",get:function get(){if(!this._colorRenderer){this._colorRenderer=new DTXTrianglesColorRenderer(this._scene,false);}return this._colorRenderer;}},{key:"colorRendererWithSAO",get:function get(){if(!this._colorRendererWithSAO){this._colorRendererWithSAO=new DTXTrianglesColorRenderer(this._scene,true);}return this._colorRendererWithSAO;}},{key:"colorQualityRendererWithSAO",get:function get(){// if (!this._colorQualityRendererWithSAO) {
//     this._colorQualityRendererWithSAO = new TrianglesDataTextureColorQualityRenderer(this._scene, true);
// }
return this._colorQualityRendererWithSAO;}},{key:"silhouetteRenderer",get:function get(){if(!this._silhouetteRenderer){this._silhouetteRenderer=new DTXTrianglesSilhouetteRenderer(this._scene);}return this._silhouetteRenderer;}},{key:"depthRenderer",get:function get(){if(!this._depthRenderer){this._depthRenderer=new DTXTrianglesDepthRenderer(this._scene);}return this._depthRenderer;}},{key:"normalsRenderer",get:function get(){if(!this._normalsRenderer){this._normalsRenderer=new DTXTrianglesNormalsRenderer(this._scene);}return this._normalsRenderer;}},{key:"edgesRenderer",get:function get(){if(!this._edgesRenderer){this._edgesRenderer=new DTXTrianglesEdgesRenderer(this._scene);}return this._edgesRenderer;}},{key:"edgesColorRenderer",get:function get(){if(!this._edgesColorRenderer){this._edgesColorRenderer=new DTXTrianglesEdgesColorRenderer(this._scene);}return this._edgesColorRenderer;}},{key:"pickMeshRenderer",get:function get(){if(!this._pickMeshRenderer){this._pickMeshRenderer=new DTXTrianglesPickMeshRenderer(this._scene);}return this._pickMeshRenderer;}},{key:"pickNormalsRenderer",get:function get(){if(!this._pickNormalsRenderer){this._pickNormalsRenderer=new DTXTrianglesPickNormalsFlatRenderer(this._scene);}return this._pickNormalsRenderer;}},{key:"pickNormalsFlatRenderer",get:function get(){if(!this._pickNormalsFlatRenderer){this._pickNormalsFlatRenderer=new DTXTrianglesPickNormalsFlatRenderer(this._scene);}return this._pickNormalsFlatRenderer;}},{key:"pickDepthRenderer",get:function get(){if(!this._pickDepthRenderer){this._pickDepthRenderer=new DTXTrianglesPickDepthRenderer(this._scene);}return this._pickDepthRenderer;}},{key:"snapRenderer",get:function get(){if(!this._snapRenderer){this._snapRenderer=new DTXTrianglesSnapRenderer(this._scene);}return this._snapRenderer;}},{key:"snapInitRenderer",get:function get(){if(!this._snapInitRenderer){this._snapInitRenderer=new DTXTrianglesSnapInitRenderer(this._scene);}return this._snapInitRenderer;}},{key:"occlusionRenderer",get:function get(){if(!this._occlusionRenderer){this._occlusionRenderer=new DTXTrianglesOcclusionRenderer(this._scene);}return this._occlusionRenderer;}},{key:"_destroy",value:function _destroy(){if(this._colorRenderer){this._colorRenderer.destroy();}if(this._colorRendererWithSAO){this._colorRendererWithSAO.destroy();}if(this._flatColorRenderer){this._flatColorRenderer.destroy();}if(this._flatColorRendererWithSAO){this._flatColorRendererWithSAO.destroy();}if(this._colorQualityRendererWithSAO){this._colorQualityRendererWithSAO.destroy();}if(this._depthRenderer){this._depthRenderer.destroy();}if(this._normalsRenderer){this._normalsRenderer.destroy();}if(this._silhouetteRenderer){this._silhouetteRenderer.destroy();}if(this._edgesRenderer){this._edgesRenderer.destroy();}if(this._edgesColorRenderer){this._edgesColorRenderer.destroy();}if(this._pickMeshRenderer){this._pickMeshRenderer.destroy();}if(this._pickDepthRenderer){this._pickDepthRenderer.destroy();}if(this._snapRenderer){this._snapRenderer.destroy();}if(this._snapInitRenderer){this._snapInitRenderer.destroy();}if(this._pickNormalsRenderer){this._pickNormalsRenderer.destroy();}if(this._pickNormalsFlatRenderer){this._pickNormalsFlatRenderer.destroy();}if(this._occlusionRenderer){this._occlusionRenderer.destroy();}}}]);return DTXTrianglesRenderers;}();var cachdRenderers={};/**
 * @private
 */function getRenderers(scene){var sceneId=scene.id;var dataTextureRenderers=cachdRenderers[sceneId];if(!dataTextureRenderers){dataTextureRenderers=new DTXTrianglesRenderers(scene);cachdRenderers[sceneId]=dataTextureRenderers;dataTextureRenderers._compile();dataTextureRenderers.eagerCreateRenders();scene.on("compile",function(){dataTextureRenderers._compile();dataTextureRenderers.eagerCreateRenders();});scene.on("destroyed",function(){delete cachdRenderers[sceneId];dataTextureRenderers._destroy();});}return dataTextureRenderers;}/**
 * @private
 */var DTXTrianglesBuffer=/*#__PURE__*/_createClass(function DTXTrianglesBuffer(){_classCallCheck(this,DTXTrianglesBuffer);this.positionsCompressed=[];this.lenPositionsCompressed=0;this.metallicRoughness=[];this.indices8Bits=[];this.lenIndices8Bits=0;this.indices16Bits=[];this.lenIndices16Bits=0;this.indices32Bits=[];this.lenIndices32Bits=0;this.edgeIndices8Bits=[];this.lenEdgeIndices8Bits=0;this.edgeIndices16Bits=[];this.lenEdgeIndices16Bits=0;this.edgeIndices32Bits=[];this.lenEdgeIndices32Bits=0;this.perObjectColors=[];this.perObjectPickColors=[];this.perObjectSolid=[];this.perObjectOffsets=[];this.perObjectPositionsDecodeMatrices=[];this.perObjectInstancePositioningMatrices=[];this.perObjectVertexBases=[];this.perObjectIndexBaseOffsets=[];this.perObjectEdgeIndexBaseOffsets=[];this.perTriangleNumberPortionId8Bits=[];this.perTriangleNumberPortionId16Bits=[];this.perTriangleNumberPortionId32Bits=[];this.perEdgeNumberPortionId8Bits=[];this.perEdgeNumberPortionId16Bits=[];this.perEdgeNumberPortionId32Bits=[];});// Imports used to complete the JSDocs arguments to methods
/**
 * @private
 */var DTXTrianglesState=/*#__PURE__*/function(){function DTXTrianglesState(){_classCallCheck(this,DTXTrianglesState);/**
         * Texture that holds colors/pickColors/flags/flags2 per-object:
         * - columns: one concept per column => color / pick-color / ...
         * - row: the object Id
         *
         * @type BindableDataTexture
         */this.texturePerObjectColorsAndFlags=null;/**
         * Texture that holds the XYZ offsets per-object:
         * - columns: just 1 column with the XYZ-offset
         * - row: the object Id
         *
         * @type BindableDataTexture
         */this.texturePerObjectOffsets=null;this.texturePerObjectInstanceMatrices=null;/**
         * Texture that holds the objectDecodeAndInstanceMatrix per-object:
         * - columns: each column is one column of the matrix
         * - row: the object Id
         *
         * @type BindableDataTexture
         */this.texturePerObjectPositionsDecodeMatrix=null;/**
         * Texture that holds all the `different-vertices` used by the layer.
         *
         * @type BindableDataTexture
         */this.texturePerVertexIdCoordinates=null;/**
         * Texture that holds the PortionId that corresponds to a given polygon-id.
         *
         * Variant of the texture for 8-bit based polygon-ids.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdPortionIds8Bits=null;/**
         * Texture that holds the PortionId that corresponds to a given polygon-id.
         *
         * Variant of the texture for 16-bit based polygon-ids.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdPortionIds16Bits=null;/**
         * Texture that holds the PortionId that corresponds to a given polygon-id.
         *
         * Variant of the texture for 32-bit based polygon-ids.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdPortionIds32Bits=null;/**
         * Texture that holds the PortionId that corresponds to a given edge-id.
         *
         * Variant of the texture for 8-bit based polygon-ids.
         *
         * @type BindableDataTexture
         */this.texturePerEdgeIdPortionIds8Bits=null;/**
         * Texture that holds the PortionId that corresponds to a given edge-id.
         *
         * Variant of the texture for 16-bit based polygon-ids.
         *
         * @type BindableDataTexture
         */this.texturePerEdgeIdPortionIds16Bits=null;/**
         * Texture that holds the PortionId that corresponds to a given edge-id.
         *
         * Variant of the texture for 32-bit based polygon-ids.
         *
         * @type BindableDataTexture
         */this.texturePerEdgeIdPortionIds32Bits=null;/**
         * Texture that holds the unique-vertex-indices for 8-bit based indices.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdIndices8Bits=null;/**
         * Texture that holds the unique-vertex-indices for 16-bit based indices.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdIndices16Bits=null;/**
         * Texture that holds the unique-vertex-indices for 32-bit based indices.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdIndices32Bits=null;/**
         * Texture that holds the unique-vertex-indices for 8-bit based edge indices.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdEdgeIndices8Bits=null;/**
         * Texture that holds the unique-vertex-indices for 16-bit based edge indices.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdEdgeIndices16Bits=null;/**
         * Texture that holds the unique-vertex-indices for 32-bit based edge indices.
         *
         * @type BindableDataTexture
         */this.texturePerPolygonIdEdgeIndices32Bits=null;/**
         * Texture that holds the model matrices
         * - columns: each column in the texture is a model matrix column.
         * - row: each row is a different model matrix.
         *
         * @type BindableDataTexture
         */this.textureModelMatrices=null;}_createClass(DTXTrianglesState,[{key:"finalize",value:function finalize(){this.indicesPerBitnessTextures={8:this.texturePerPolygonIdIndices8Bits,16:this.texturePerPolygonIdIndices16Bits,32:this.texturePerPolygonIdIndices32Bits};this.indicesPortionIdsPerBitnessTextures={8:this.texturePerPolygonIdPortionIds8Bits,16:this.texturePerPolygonIdPortionIds16Bits,32:this.texturePerPolygonIdPortionIds32Bits};this.edgeIndicesPerBitnessTextures={8:this.texturePerPolygonIdEdgeIndices8Bits,16:this.texturePerPolygonIdEdgeIndices16Bits,32:this.texturePerPolygonIdEdgeIndices32Bits};this.edgeIndicesPortionIdsPerBitnessTextures={8:this.texturePerEdgeIdPortionIds8Bits,16:this.texturePerEdgeIdPortionIds16Bits,32:this.texturePerEdgeIdPortionIds32Bits};}/**
     *
     * @param {Program} glProgram
     * @param {string} objectDecodeMatricesShaderName
     * @param {string} vertexTextureShaderName
     * @param {string} objectAttributesTextureShaderName
     * @param {string} objectMatricesShaderName
     */},{key:"bindCommonTextures",value:function bindCommonTextures(glProgram,objectDecodeMatricesShaderName,vertexTextureShaderName,objectAttributesTextureShaderName,objectMatricesShaderName){this.texturePerObjectPositionsDecodeMatrix.bindTexture(glProgram,objectDecodeMatricesShaderName,1);this.texturePerVertexIdCoordinates.bindTexture(glProgram,vertexTextureShaderName,2);this.texturePerObjectColorsAndFlags.bindTexture(glProgram,objectAttributesTextureShaderName,3);this.texturePerObjectInstanceMatrices.bindTexture(glProgram,objectMatricesShaderName,4);}/**
     *
     * @param {Program} glProgram
     * @param {string} portionIdsShaderName
     * @param {string} polygonIndicesShaderName
     * @param {8|16|32} textureBitness
     */},{key:"bindTriangleIndicesTextures",value:function bindTriangleIndicesTextures(glProgram,portionIdsShaderName,polygonIndicesShaderName,textureBitness){this.indicesPortionIdsPerBitnessTextures[textureBitness].bindTexture(glProgram,portionIdsShaderName,5// webgl texture unit
);this.indicesPerBitnessTextures[textureBitness].bindTexture(glProgram,polygonIndicesShaderName,6// webgl texture unit
);}/**
     *
     * @param {Program} glProgram
     * @param {string} edgePortionIdsShaderName
     * @param {string} edgeIndicesShaderName
     * @param {8|16|32} textureBitness
     */},{key:"bindEdgeIndicesTextures",value:function bindEdgeIndicesTextures(glProgram,edgePortionIdsShaderName,edgeIndicesShaderName,textureBitness){this.edgeIndicesPortionIdsPerBitnessTextures[textureBitness].bindTexture(glProgram,edgePortionIdsShaderName,5// webgl texture unit
);this.edgeIndicesPerBitnessTextures[textureBitness].bindTexture(glProgram,edgeIndicesShaderName,6// webgl texture unit
);}}]);return DTXTrianglesState;}();var dataTextureRamStats={sizeDataColorsAndFlags:0,sizeDataPositionDecodeMatrices:0,sizeDataTextureOffsets:0,sizeDataTexturePositions:0,sizeDataTextureIndices:0,sizeDataTextureEdgeIndices:0,sizeDataTexturePortionIds:0,numberOfGeometries:0,numberOfPortions:0,numberOfLayers:0,numberOfTextures:0,totalPolygons:0,totalPolygons8Bits:0,totalPolygons16Bits:0,totalPolygons32Bits:0,totalEdges:0,totalEdges8Bits:0,totalEdges16Bits:0,totalEdges32Bits:0,cannotCreatePortion:{because10BitsObjectId:0,becauseTextureSize:0},overheadSizeAlignementIndices:0,overheadSizeAlignementEdgeIndices:0};window.printDataTextureRamStats=function(){console.log(JSON.stringify(dataTextureRamStats,null,4));var totalRamSize=0;Object.keys(dataTextureRamStats).forEach(function(key){if(key.startsWith("size")){totalRamSize+=dataTextureRamStats[key];}});console.log("Total size ".concat(totalRamSize," bytes (").concat((totalRamSize/1000/1000).toFixed(2)," MB)"));console.log("Avg bytes / triangle: ".concat((totalRamSize/dataTextureRamStats.totalPolygons).toFixed(2)));var percentualRamStats={};Object.keys(dataTextureRamStats).forEach(function(key){if(key.startsWith("size")){percentualRamStats[key]="".concat((dataTextureRamStats[key]/totalRamSize*100).toFixed(2)," % of total");}});console.log(JSON.stringify({percentualRamUsage:percentualRamStats},null,4));};/**
 * @private
 */var DTXTrianglesTextureFactory=/*#__PURE__*/function(){function DTXTrianglesTextureFactory(){_classCallCheck(this,DTXTrianglesTextureFactory);}/**
     * Enables the currently binded ````WebGLTexture```` to be used as a data texture.
     *
     * @param {WebGL2RenderingContext} gl
     *
     * @private
     */_createClass(DTXTrianglesTextureFactory,[{key:"disableBindedTextureFiltering",value:function disableBindedTextureFiltering(gl){gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);}/**
     * This will generate an RGBA texture for:
     * - colors
     * - pickColors
     * - flags
     * - flags2
     * - vertex bases
     * - vertex base offsets
     *
     * The texture will have:
     * - 4 RGBA columns per row: for each object (pick) color and flags(2)
     * - N rows where N is the number of objects
     *
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<ArrayLike<int>>} colors Array of colors for all objects in the layer
     * @param {ArrayLike<ArrayLike<int>>} pickColors Array of pickColors for all objects in the layer
     * @param {ArrayLike<int>} vertexBases Array of position-index-bases foteh all objects in the layer
     * @param {ArrayLike<int>} indexBaseOffsets For triangles: array of offests between the (gl_VertexID / 3) and the position where the indices start in the texture layer
     * @param {ArrayLike<int>} edgeIndexBaseOffsets For edges: Array of offests between the (gl_VertexID / 2) and the position where the edge indices start in the texture layer
     * @param {ArrayLike<boolean>} solid Array is-solid flag for all objects in the layer
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureForColorsAndFlags",value:function createTextureForColorsAndFlags(gl,colors,pickColors,vertexBases,indexBaseOffsets,edgeIndexBaseOffsets,solid){var numPortions=colors.length;// The number of rows in the texture is the number of
// objects in the layer.
this.numPortions=numPortions;var textureWidth=512*8;var textureHeight=Math.ceil(numPortions/(textureWidth/8));if(textureHeight===0){throw"texture height===0";}// 8 columns per texture row:
// - col0: (RGBA) object color RGBA
// - col1: (packed Uint32 as RGBA) object pick color
// - col2: (packed 4 bytes as RGBA) object flags
// - col3: (packed 4 bytes as RGBA) object flags2
// - col4: (packed Uint32 bytes as RGBA) vertex base
// - col5: (packed Uint32 bytes as RGBA) index base offset
// - col6: (packed Uint32 bytes as RGBA) edge index base offset
// - col7: (packed 4 bytes as RGBA) is-solid flag for objects
var texArray=new Uint8Array(4*textureWidth*textureHeight);dataTextureRamStats.sizeDataColorsAndFlags+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i355=0;_i355<numPortions;_i355++){// object color
texArray.set(colors[_i355],_i355*32+0);texArray.set(pickColors[_i355],_i355*32+4);// object pick color
texArray.set([0,0,0,0],_i355*32+8);// object flags
texArray.set([0,0,0,0],_i355*32+12);// object flags2
// vertex base
texArray.set([vertexBases[_i355]>>24&255,vertexBases[_i355]>>16&255,vertexBases[_i355]>>8&255,vertexBases[_i355]&255],_i355*32+16);// triangles index base offset
texArray.set([indexBaseOffsets[_i355]>>24&255,indexBaseOffsets[_i355]>>16&255,indexBaseOffsets[_i355]>>8&255,indexBaseOffsets[_i355]&255],_i355*32+20);// edge index base offset
texArray.set([edgeIndexBaseOffsets[_i355]>>24&255,edgeIndexBaseOffsets[_i355]>>16&255,edgeIndexBaseOffsets[_i355]>>8&255,edgeIndexBaseOffsets[_i355]&255],_i355*32+24);// is-solid flag
texArray.set([solid[_i355]?1:0,0,0,0],_i355*32+28);}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGBA8UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight,texArray);}/**
     * This will generate a texture for all object offsets.
     *
     * @param {WebGL2RenderingContext} gl
     * @param {int[]} offsets Array of int[3], one XYZ offset array for each object
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureForObjectOffsets",value:function createTextureForObjectOffsets(gl,numOffsets){var textureWidth=512;var textureHeight=Math.ceil(numOffsets/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArray=new Float32Array(3*textureWidth*textureHeight).fill(0);dataTextureRamStats.sizeDataTextureOffsets+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB32F,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB,gl.FLOAT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight,texArray);}/**
     * This will generate a texture for all positions decode matrices in the layer.
     *
     * The texture will have:
     * - 4 RGBA columns per row (each column will contain 4 packed half-float (16 bits) components).
     *   Thus, each row will contain 16 packed half-floats corresponding to a complete positions decode matrix)
     * - N rows where N is the number of objects
     *
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<Matrix4x4>} instanceMatrices Array of geometry instancing matrices for all objects in the layer. Null if the objects are not instanced.
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureForInstancingMatrices",value:function createTextureForInstancingMatrices(gl,instanceMatrices){var numMatrices=instanceMatrices.length;if(numMatrices===0){throw"num instance matrices===0";}// in one row we can fit 512 matrices
var textureWidth=512*4;var textureHeight=Math.ceil(numMatrices/(textureWidth/4));var texArray=new Float32Array(4*textureWidth*textureHeight);// dataTextureRamStats.sizeDataPositionDecodeMatrices += texArray.byteLength;
dataTextureRamStats.numberOfTextures++;for(var _i356=0;_i356<instanceMatrices.length;_i356++){// 4x4 values
texArray.set(instanceMatrices[_i356],_i356*16);}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGBA32F,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGBA,gl.FLOAT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight,texArray);}/**
     * This will generate a texture for all positions decode matrices in the layer.
     *
     * The texture will have:
     * - 4 RGBA columns per row (each column will contain 4 packed half-float (16 bits) components).
     *   Thus, each row will contain 16 packed half-floats corresponding to a complete positions decode matrix)
     * - N rows where N is the number of objects
     *
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<Matrix4x4>} positionDecodeMatrices Array of positions decode matrices for all objects in the layer
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureForPositionsDecodeMatrices",value:function createTextureForPositionsDecodeMatrices(gl,positionDecodeMatrices){var numMatrices=positionDecodeMatrices.length;if(numMatrices===0){throw"num decode+entity matrices===0";}// in one row we can fit 512 matrices
var textureWidth=512*4;var textureHeight=Math.ceil(numMatrices/(textureWidth/4));var texArray=new Float32Array(4*textureWidth*textureHeight);dataTextureRamStats.sizeDataPositionDecodeMatrices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i357=0;_i357<positionDecodeMatrices.length;_i357++){// 4x4 values
texArray.set(positionDecodeMatrices[_i357],_i357*16);}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGBA32F,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGBA,gl.FLOAT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureFor8BitIndices",value:function createTextureFor8BitIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/3/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint8Array(texArraySize);dataTextureRamStats.sizeDataTextureIndices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i358=0,j=0,len=indicesArrays.length;_i358<len;_i358++){var pc=indicesArrays[_i358];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB8UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_BYTE,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureFor16BitIndices",value:function createTextureFor16BitIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/3/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint16Array(texArraySize);dataTextureRamStats.sizeDataTextureIndices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i359=0,j=0,len=indicesArrays.length;_i359<len;_i359++){var pc=indicesArrays[_i359];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_SHORT,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureFor32BitIndices",value:function createTextureFor32BitIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/3/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint32Array(texArraySize);dataTextureRamStats.sizeDataTextureIndices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i360=0,j=0,len=indicesArrays.length;_i360<len;_i360++){var pc=indicesArrays[_i360];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB32UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_INT,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureFor8BitsEdgeIndices",value:function createTextureFor8BitsEdgeIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/2/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*2;var texArray=new Uint8Array(texArraySize);dataTextureRamStats.sizeDataTextureEdgeIndices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i361=0,j=0,len=indicesArrays.length;_i361<len;_i361++){var pc=indicesArrays[_i361];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RG8UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RG_INTEGER,gl.UNSIGNED_BYTE,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureFor16BitsEdgeIndices",value:function createTextureFor16BitsEdgeIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/2/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*2;var texArray=new Uint16Array(texArraySize);dataTextureRamStats.sizeDataTextureEdgeIndices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i362=0,j=0,len=indicesArrays.length;_i362<len;_i362++){var pc=indicesArrays[_i362];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RG16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RG_INTEGER,gl.UNSIGNED_SHORT,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param indicesArrays
     * @param lenIndices
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureFor32BitsEdgeIndices",value:function createTextureFor32BitsEdgeIndices(gl,indicesArrays,lenIndices){if(lenIndices===0){return{texture:null,textureHeight:0};}var textureWidth=4096;var textureHeight=Math.ceil(lenIndices/2/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*2;var texArray=new Uint32Array(texArraySize);dataTextureRamStats.sizeDataTextureEdgeIndices+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i363=0,j=0,len=indicesArrays.length;_i363<len;_i363++){var pc=indicesArrays[_i363];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RG32UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RG_INTEGER,gl.UNSIGNED_INT,texArray,0);this.disableBindedTextureFiltering(gl);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<int>} positionsArrays Arrays of  quantized positions in the layer
     * @param lenPositions
     *
     * This will generate a texture for positions in the layer.
     *
     * The texture will have:
     * - 1024 columns, where each pixel will be a 16-bit-per-component RGB texture, corresponding to the XYZ of the position
     * - a number of rows R where R*1024 is just >= than the number of vertices (positions / 3)
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureForPositions",value:function createTextureForPositions(gl,positionsArrays,lenPositions){var numVertices=lenPositions/3;var textureWidth=4096;var textureHeight=Math.ceil(numVertices/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight*3;var texArray=new Uint16Array(texArraySize);dataTextureRamStats.sizeDataTexturePositions+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;for(var _i364=0,j=0,len=positionsArrays.length;_i364<len;_i364++){var pc=positionsArrays[_i364];texArray.set(pc,j);j+=pc.length;}var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.RGB16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RGB_INTEGER,gl.UNSIGNED_SHORT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}/**
     * @param {WebGL2RenderingContext} gl
     * @param {ArrayLike<int>} portionIdsArray
     *
     * @returns {BindableDataTexture}
     */},{key:"createTextureForPackedPortionIds",value:function createTextureForPackedPortionIds(gl,portionIdsArray){if(portionIdsArray.length===0){return{texture:null,textureHeight:0};}var lenArray=portionIdsArray.length;var textureWidth=4096;var textureHeight=Math.ceil(lenArray/textureWidth);if(textureHeight===0){throw"texture height===0";}var texArraySize=textureWidth*textureHeight;var texArray=new Uint16Array(texArraySize);texArray.set(portionIdsArray,0);dataTextureRamStats.sizeDataTexturePortionIds+=texArray.byteLength;dataTextureRamStats.numberOfTextures++;var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texStorage2D(gl.TEXTURE_2D,1,gl.R16UI,textureWidth,textureHeight);gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,textureWidth,textureHeight,gl.RED_INTEGER,gl.UNSIGNED_SHORT,texArray,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);return new BindableDataTexture(gl,texture,textureWidth,textureHeight);}}]);return DTXTrianglesTextureFactory;}();var configs=new Configs();/**
 * 12-bits allowed for object ids.
 * Limits the per-object texture height in the layer.
 */var MAX_NUMBER_OF_OBJECTS_IN_LAYER=1<<16;/**
 * 4096 is max data texture height.
 * Limits the aggregated geometry texture height in the layer.
 */var MAX_DATA_TEXTURE_HEIGHT=configs.maxDataTextureHeight;/**
 * Align `indices` and `edgeIndices` memory layout to 8 elements.
 *
 * Used as an optimization for the `...portionIds...` texture, so it
 * can just be stored 1 out of 8 `portionIds` corresponding to a given
 * `triangle-index` or `edge-index`.
 */var INDICES_EDGE_INDICES_ALIGNEMENT_SIZE=8;/**
 * Number of maximum allowed per-object flags update per render frame
 * before switching to batch update mode.
 */var MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE=10;var tempMat4a=new Float32Array(16);var tempUint8Array4=new Uint8Array(4);var tempFloat32Array3=new Float32Array(3);var numLayers=0;var DEFAULT_MATRIX$1=math.identityMat4();/**
 * @private
 */var DTXTrianglesLayer=/*#__PURE__*/function(){function DTXTrianglesLayer(model,cfg){_classCallCheck(this,DTXTrianglesLayer);console.info("Creating DTXTrianglesLayer");dataTextureRamStats.numberOfLayers++;this._layerNumber=numLayers++;this.sortId="TriDTX-".concat(this._layerNumber);// State sorting key.
this.layerIndex=cfg.layerIndex;// Index of this TrianglesDataTextureLayer in {@link SceneModel#_layerList}.
this._renderers=getRenderers(model.scene);this.model=model;this._buffer=new DTXTrianglesBuffer();this._dtxState=new DTXTrianglesState();this._dtxTextureFactory=new DTXTrianglesTextureFactory();this._state=new RenderState({origin:math.vec3(cfg.origin),metallicRoughnessBuf:null,textureState:this._dtxState,numIndices8Bits:0,numIndices16Bits:0,numIndices32Bits:0,numEdgeIndices8Bits:0,numEdgeIndices16Bits:0,numEdgeIndices32Bits:0,numVertices:0});this._numPortions=0;// These counts are used to avoid unnecessary render passes
this._numVisibleLayerPortions=0;this._numTransparentLayerPortions=0;this._numXRayedLayerPortions=0;this._numSelectedLayerPortions=0;this._numHighlightedLayerPortions=0;this._numClippableLayerPortions=0;this._numEdgesLayerPortions=0;this._numPickableLayerPortions=0;this._numCulledLayerPortions=0;this._subPortions=[];/**
         * Due to `index rebucketting` process in ```prepareMeshGeometry``` function, it's possible that a single
         * portion is expanded to more than 1 real sub-portion.
         *
         * This Array tracks the mapping between:
         *
         * - external `portionIds` as seen by consumers of this class.
         * - internal `sub-portionIds` actually managed by this class.
         *
         * The outer index of this array is the externally seen `portionId`.
         * The inner value of the array, are `sub-portionIds` corresponding to the `portionId`.
         */this._portionToSubPortionsMap=[];this._bucketGeometries={};this._meshes=[];/**
         * The axis-aligned World-space boundary of this TrianglesDataTextureLayer's positions.
         */this._aabb=math.collapseAABB3();this.aabbDirty=true;/**
         * The number of updates in the current frame;
         */this._numUpdatesInFrame=0;this._finalized=false;}_createClass(DTXTrianglesLayer,[{key:"aabb",get:function get(){if(this.aabbDirty){math.collapseAABB3(this._aabb);for(var _i365=0,len=this._meshes.length;_i365<len;_i365++){math.expandAABB3(this._aabb,this._meshes[_i365].aabb);}this.aabbDirty=false;}return this._aabb;}/**
     * Returns whether the ```TrianglesDataTextureLayer``` has room for more portions.
     *
     * @param {object} portionCfg An object containing the geometrical data (`positions`, `indices`, `edgeIndices`) for the portion.
     * @returns {Boolean} Wheter the requested portion can be created
     */},{key:"canCreatePortion",value:function canCreatePortion(portionCfg){if(this._finalized){throw"Already finalized";}var numNewPortions=portionCfg.buckets.length;if(this._numPortions+numNewPortions>MAX_NUMBER_OF_OBJECTS_IN_LAYER){dataTextureRamStats.cannotCreatePortion.because10BitsObjectId++;}var retVal=this._numPortions+numNewPortions<=MAX_NUMBER_OF_OBJECTS_IN_LAYER;var bucketIndex=0;// TODO: Is this a bug?
var bucketGeometryId=portionCfg.geometryId!==undefined&&portionCfg.geometryId!==null?"".concat(portionCfg.geometryId,"#").concat(bucketIndex):"".concat(portionCfg.id,"#").concat(bucketIndex);var alreadyHasPortionGeometry=this._bucketGeometries[bucketGeometryId];if(!alreadyHasPortionGeometry){var maxIndicesOfAnyBits=Math.max(this._state.numIndices8Bits,this._state.numIndices16Bits,this._state.numIndices32Bits);var numVertices=0;var _numIndices3=0;portionCfg.buckets.forEach(function(bucket){numVertices+=bucket.positionsCompressed.length/3;_numIndices3+=bucket.indices.length/3;});if(this._state.numVertices+numVertices>MAX_DATA_TEXTURE_HEIGHT*4096||maxIndicesOfAnyBits+_numIndices3>MAX_DATA_TEXTURE_HEIGHT*4096){dataTextureRamStats.cannotCreatePortion.becauseTextureSize++;}retVal&&(retVal=this._state.numVertices+numVertices<=MAX_DATA_TEXTURE_HEIGHT*4096&&maxIndicesOfAnyBits+_numIndices3<=MAX_DATA_TEXTURE_HEIGHT*4096);}return retVal;}/**
     * Creates a new portion within this TrianglesDataTextureLayer, returns the new portion ID.
     *
     * Gives the portion the specified geometry, color and matrix.
     *
     * @param mesh The SceneModelMesh that owns the portion
     * @param portionCfg.positionsCompressed Flat float Local-space positionsCompressed array.
     * @param [portionCfg.normals] Flat float normals array.
     * @param [portionCfg.colors] Flat float colors array.
     * @param portionCfg.indices  Flat int indices array.
     * @param [portionCfg.edgeIndices] Flat int edges indices array.
     * @param portionCfg.color Quantized RGB color [0..255,0..255,0..255,0..255]
     * @param portionCfg.metallic Metalness factor [0..255]
     * @param portionCfg.roughness Roughness factor [0..255]
     * @param portionCfg.opacity Opacity [0..255]
     * @param [portionCfg.meshMatrix] Flat float 4x4 matrix - transforms the portion within the coordinate system that's local to the SceneModel
     * @param portionCfg.worldAABB Flat float AABB World-space AABB
     * @param portionCfg.pickColor Quantized pick color
     * @returns {number} Portion ID
     */},{key:"createPortion",value:function createPortion(mesh,portionCfg){var _this68=this;if(this._finalized){throw"Already finalized";}var subPortionIds=[];//   const portionAABB = portionCfg.worldAABB;
portionCfg.buckets.forEach(function(bucket,bucketIndex){var bucketGeometryId=portionCfg.geometryId!==undefined&&portionCfg.geometryId!==null?"".concat(portionCfg.geometryId,"#").concat(bucketIndex):"".concat(portionCfg.id,"#").concat(bucketIndex);var bucketGeometry=_this68._bucketGeometries[bucketGeometryId];if(!bucketGeometry){bucketGeometry=_this68._createBucketGeometry(portionCfg,bucket);_this68._bucketGeometries[bucketGeometryId]=bucketGeometry;}//  const subPortionAABB = math.collapseAABB3(tempAABB3b);
var subPortionId=_this68._createSubPortion(portionCfg,bucketGeometry,bucket);//math.expandAABB3(portionAABB, subPortionAABB);
subPortionIds.push(subPortionId);});var portionId=this._portionToSubPortionsMap.length;this._portionToSubPortionsMap.push(subPortionIds);this.model.numPortions++;this._meshes.push(mesh);return portionId;}},{key:"_createBucketGeometry",value:function _createBucketGeometry(portionCfg,bucket){// Indices alignement
// This will make every mesh consume a multiple of INDICES_EDGE_INDICES_ALIGNEMENT_SIZE
// array items for storing the triangles of the mesh, and it supports:
// - a memory optimization of factor INDICES_EDGE_INDICES_ALIGNEMENT_SIZE
// - in exchange for a small RAM overhead
//   (by adding some padding until a size that is multiple of INDICES_EDGE_INDICES_ALIGNEMENT_SIZE)
if(bucket.indices){var alignedIndicesLen=Math.ceil(bucket.indices.length/3/INDICES_EDGE_INDICES_ALIGNEMENT_SIZE)*INDICES_EDGE_INDICES_ALIGNEMENT_SIZE*3;dataTextureRamStats.overheadSizeAlignementIndices+=2*(alignedIndicesLen-bucket.indices.length);var alignedIndices=new Uint32Array(alignedIndicesLen);alignedIndices.fill(0);alignedIndices.set(bucket.indices);bucket.indices=alignedIndices;}// EdgeIndices alignement
// This will make every mesh consume a multiple of INDICES_EDGE_INDICES_ALIGNEMENT_SIZE
// array items for storing the edges of the mesh, and it supports:
// - a memory optimization of factor INDICES_EDGE_INDICES_ALIGNEMENT_SIZE
// - in exchange for a small RAM overhead
//   (by adding some padding until a size that is multiple of INDICES_EDGE_INDICES_ALIGNEMENT_SIZE)
if(bucket.edgeIndices){var alignedEdgeIndicesLen=Math.ceil(bucket.edgeIndices.length/2/INDICES_EDGE_INDICES_ALIGNEMENT_SIZE)*INDICES_EDGE_INDICES_ALIGNEMENT_SIZE*2;dataTextureRamStats.overheadSizeAlignementEdgeIndices+=2*(alignedEdgeIndicesLen-bucket.edgeIndices.length);var alignedEdgeIndices=new Uint32Array(alignedEdgeIndicesLen);alignedEdgeIndices.fill(0);alignedEdgeIndices.set(bucket.edgeIndices);bucket.edgeIndices=alignedEdgeIndices;}var positionsCompressed=bucket.positionsCompressed;var indices=bucket.indices;var edgeIndices=bucket.edgeIndices;var buffer=this._buffer;buffer.positionsCompressed.push(positionsCompressed);var vertexBase=buffer.lenPositionsCompressed/3;var numVertices=positionsCompressed.length/3;buffer.lenPositionsCompressed+=positionsCompressed.length;var indicesBase;var numTriangles=0;if(indices){numTriangles=indices.length/3;var indicesBuffer;if(numVertices<=1<<8){indicesBuffer=buffer.indices8Bits;indicesBase=buffer.lenIndices8Bits/3;buffer.lenIndices8Bits+=indices.length;}else if(numVertices<=1<<16){indicesBuffer=buffer.indices16Bits;indicesBase=buffer.lenIndices16Bits/3;buffer.lenIndices16Bits+=indices.length;}else{indicesBuffer=buffer.indices32Bits;indicesBase=buffer.lenIndices32Bits/3;buffer.lenIndices32Bits+=indices.length;}indicesBuffer.push(indices);}var edgeIndicesBase;var numEdges=0;if(edgeIndices){numEdges=edgeIndices.length/2;var edgeIndicesBuffer;if(numVertices<=1<<8){edgeIndicesBuffer=buffer.edgeIndices8Bits;edgeIndicesBase=buffer.lenEdgeIndices8Bits/2;buffer.lenEdgeIndices8Bits+=edgeIndices.length;}else if(numVertices<=1<<16){edgeIndicesBuffer=buffer.edgeIndices16Bits;edgeIndicesBase=buffer.lenEdgeIndices16Bits/2;buffer.lenEdgeIndices16Bits+=edgeIndices.length;}else{edgeIndicesBuffer=buffer.edgeIndices32Bits;edgeIndicesBase=buffer.lenEdgeIndices32Bits/2;buffer.lenEdgeIndices32Bits+=edgeIndices.length;}edgeIndicesBuffer.push(edgeIndices);}this._state.numVertices+=numVertices;dataTextureRamStats.numberOfGeometries++;var bucketGeometry={vertexBase:vertexBase,numVertices:numVertices,numTriangles:numTriangles,numEdges:numEdges,indicesBase:indicesBase,edgeIndicesBase:edgeIndicesBase};return bucketGeometry;}},{key:"_createSubPortion",value:function _createSubPortion(portionCfg,bucketGeometry,bucket,subPortionAABB){var color=portionCfg.color;portionCfg.metallic;portionCfg.roughness;var colors=portionCfg.colors;var opacity=portionCfg.opacity;var meshMatrix=portionCfg.meshMatrix;var pickColor=portionCfg.pickColor;var buffer=this._buffer;var state=this._state;buffer.perObjectPositionsDecodeMatrices.push(portionCfg.positionsDecodeMatrix);buffer.perObjectInstancePositioningMatrices.push(meshMatrix||DEFAULT_MATRIX$1);buffer.perObjectSolid.push(!!portionCfg.solid);if(colors){buffer.perObjectColors.push([colors[0]*255,colors[1]*255,colors[2]*255,255]);}else if(color){// Color is pre-quantized by SceneModel
buffer.perObjectColors.push([color[0],color[1],color[2],opacity]);}buffer.perObjectPickColors.push(pickColor);buffer.perObjectVertexBases.push(bucketGeometry.vertexBase);{var currentNumIndices;if(bucketGeometry.numVertices<=1<<8){currentNumIndices=state.numIndices8Bits;}else if(bucketGeometry.numVertices<=1<<16){currentNumIndices=state.numIndices16Bits;}else{currentNumIndices=state.numIndices32Bits;}buffer.perObjectIndexBaseOffsets.push(currentNumIndices/3-bucketGeometry.indicesBase);}{var currentNumEdgeIndices;if(bucketGeometry.numVertices<=1<<8){currentNumEdgeIndices=state.numEdgeIndices8Bits;}else if(bucketGeometry.numVertices<=1<<16){currentNumEdgeIndices=state.numEdgeIndices16Bits;}else{currentNumEdgeIndices=state.numEdgeIndices32Bits;}buffer.perObjectEdgeIndexBaseOffsets.push(currentNumEdgeIndices/2-bucketGeometry.edgeIndicesBase);}var subPortionId=this._subPortions.length;if(bucketGeometry.numTriangles>0){var _numIndices4=bucketGeometry.numTriangles*3;var indicesPortionIdBuffer;if(bucketGeometry.numVertices<=1<<8){indicesPortionIdBuffer=buffer.perTriangleNumberPortionId8Bits;state.numIndices8Bits+=_numIndices4;dataTextureRamStats.totalPolygons8Bits+=bucketGeometry.numTriangles;}else if(bucketGeometry.numVertices<=1<<16){indicesPortionIdBuffer=buffer.perTriangleNumberPortionId16Bits;state.numIndices16Bits+=_numIndices4;dataTextureRamStats.totalPolygons16Bits+=bucketGeometry.numTriangles;}else{indicesPortionIdBuffer=buffer.perTriangleNumberPortionId32Bits;state.numIndices32Bits+=_numIndices4;dataTextureRamStats.totalPolygons32Bits+=bucketGeometry.numTriangles;}dataTextureRamStats.totalPolygons+=bucketGeometry.numTriangles;for(var _i366=0;_i366<bucketGeometry.numTriangles;_i366+=INDICES_EDGE_INDICES_ALIGNEMENT_SIZE){indicesPortionIdBuffer.push(subPortionId);}}if(bucketGeometry.numEdges>0){var numEdgeIndices=bucketGeometry.numEdges*2;var edgeIndicesPortionIdBuffer;if(bucketGeometry.numVertices<=1<<8){edgeIndicesPortionIdBuffer=buffer.perEdgeNumberPortionId8Bits;state.numEdgeIndices8Bits+=numEdgeIndices;dataTextureRamStats.totalEdges8Bits+=bucketGeometry.numEdges;}else if(bucketGeometry.numVertices<=1<<16){edgeIndicesPortionIdBuffer=buffer.perEdgeNumberPortionId16Bits;state.numEdgeIndices16Bits+=numEdgeIndices;dataTextureRamStats.totalEdges16Bits+=bucketGeometry.numEdges;}else{edgeIndicesPortionIdBuffer=buffer.perEdgeNumberPortionId32Bits;state.numEdgeIndices32Bits+=numEdgeIndices;dataTextureRamStats.totalEdges32Bits+=bucketGeometry.numEdges;}dataTextureRamStats.totalEdges+=bucketGeometry.numEdges;for(var _i367=0;_i367<bucketGeometry.numEdges;_i367+=INDICES_EDGE_INDICES_ALIGNEMENT_SIZE){edgeIndicesPortionIdBuffer.push(subPortionId);}}//   buffer.perObjectOffsets.push([0, 0, 0]);
this._subPortions.push({// vertsBase: vertsIndex,
numVertices:bucketGeometry.numTriangles});this._numPortions++;dataTextureRamStats.numberOfPortions++;return subPortionId;}/**
     * Builds data textures from the appended geometries and loads them into the GPU.
     *
     * No more portions can then be created.
     */},{key:"finalize",value:function finalize(){var _this69=this;if(this._finalized){return;}var state=this._state;var textureState=this._dtxState;var gl=this.model.scene.canvas.gl;var buffer=this._buffer;state.gl=gl;textureState.texturePerObjectColorsAndFlags=this._dtxTextureFactory.createTextureForColorsAndFlags(gl,buffer.perObjectColors,buffer.perObjectPickColors,buffer.perObjectVertexBases,buffer.perObjectIndexBaseOffsets,buffer.perObjectEdgeIndexBaseOffsets,buffer.perObjectSolid);textureState.texturePerObjectInstanceMatrices=this._dtxTextureFactory.createTextureForInstancingMatrices(gl,buffer.perObjectInstancePositioningMatrices);textureState.texturePerObjectPositionsDecodeMatrix=this._dtxTextureFactory.createTextureForPositionsDecodeMatrices(gl,buffer.perObjectPositionsDecodeMatrices);textureState.texturePerVertexIdCoordinates=this._dtxTextureFactory.createTextureForPositions(gl,buffer.positionsCompressed,buffer.lenPositionsCompressed);textureState.texturePerPolygonIdPortionIds8Bits=this._dtxTextureFactory.createTextureForPackedPortionIds(gl,buffer.perTriangleNumberPortionId8Bits);textureState.texturePerPolygonIdPortionIds16Bits=this._dtxTextureFactory.createTextureForPackedPortionIds(gl,buffer.perTriangleNumberPortionId16Bits);textureState.texturePerPolygonIdPortionIds32Bits=this._dtxTextureFactory.createTextureForPackedPortionIds(gl,buffer.perTriangleNumberPortionId32Bits);if(buffer.perEdgeNumberPortionId8Bits.length>0){textureState.texturePerEdgeIdPortionIds8Bits=this._dtxTextureFactory.createTextureForPackedPortionIds(gl,buffer.perEdgeNumberPortionId8Bits);}if(buffer.perEdgeNumberPortionId16Bits.length>0){textureState.texturePerEdgeIdPortionIds16Bits=this._dtxTextureFactory.createTextureForPackedPortionIds(gl,buffer.perEdgeNumberPortionId16Bits);}if(buffer.perEdgeNumberPortionId32Bits.length>0){textureState.texturePerEdgeIdPortionIds32Bits=this._dtxTextureFactory.createTextureForPackedPortionIds(gl,buffer.perEdgeNumberPortionId32Bits);}if(buffer.lenIndices8Bits>0){textureState.texturePerPolygonIdIndices8Bits=this._dtxTextureFactory.createTextureFor8BitIndices(gl,buffer.indices8Bits,buffer.lenIndices8Bits);}if(buffer.lenIndices16Bits>0){textureState.texturePerPolygonIdIndices16Bits=this._dtxTextureFactory.createTextureFor16BitIndices(gl,buffer.indices16Bits,buffer.lenIndices16Bits);}if(buffer.lenIndices32Bits>0){textureState.texturePerPolygonIdIndices32Bits=this._dtxTextureFactory.createTextureFor32BitIndices(gl,buffer.indices32Bits,buffer.lenIndices32Bits);}if(buffer.lenEdgeIndices8Bits>0){textureState.texturePerPolygonIdEdgeIndices8Bits=this._dtxTextureFactory.createTextureFor8BitsEdgeIndices(gl,buffer.edgeIndices8Bits,buffer.lenEdgeIndices8Bits);}if(buffer.lenEdgeIndices16Bits>0){textureState.texturePerPolygonIdEdgeIndices16Bits=this._dtxTextureFactory.createTextureFor16BitsEdgeIndices(gl,buffer.edgeIndices16Bits,buffer.lenEdgeIndices16Bits);}if(buffer.lenEdgeIndices32Bits>0){textureState.texturePerPolygonIdEdgeIndices32Bits=this._dtxTextureFactory.createTextureFor32BitsEdgeIndices(gl,buffer.edgeIndices32Bits,buffer.lenEdgeIndices32Bits);}textureState.finalize();// Free up memory
this._buffer=null;this._bucketGeometries={};this._finalized=true;this._deferredSetFlagsDirty=false;//
this._onSceneRendering=this.model.scene.on("rendering",function(){if(_this69._deferredSetFlagsDirty){_this69._uploadDeferredFlags();}_this69._numUpdatesInFrame=0;});}},{key:"isEmpty",value:function isEmpty(){return this._numPortions===0;}},{key:"initFlags",value:function initFlags(portionId,flags,meshTransparent){if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions++;this.model.numCulledLayerPortions++;}if(meshTransparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}var deferred=true;this._setFlags(portionId,flags,meshTransparent,deferred);this._setFlags2(portionId,flags,deferred);}},{key:"flushInitFlags",value:function flushInitFlags(){this._setDeferredFlags();this._setDeferredFlags2();}},{key:"setVisible",value:function setVisible(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.VISIBLE){this._numVisibleLayerPortions++;this.model.numVisibleLayerPortions++;}else{this._numVisibleLayerPortions--;this.model.numVisibleLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setHighlighted",value:function setHighlighted(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.HIGHLIGHTED){this._numHighlightedLayerPortions++;this.model.numHighlightedLayerPortions++;}else{this._numHighlightedLayerPortions--;this.model.numHighlightedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setXRayed",value:function setXRayed(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.XRAYED){this._numXRayedLayerPortions++;this.model.numXRayedLayerPortions++;}else{this._numXRayedLayerPortions--;this.model.numXRayedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setSelected",value:function setSelected(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.SELECTED){this._numSelectedLayerPortions++;this.model.numSelectedLayerPortions++;}else{this._numSelectedLayerPortions--;this.model.numSelectedLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setEdges",value:function setEdges(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.EDGES){this._numEdgesLayerPortions++;this.model.numEdgesLayerPortions++;}else{this._numEdgesLayerPortions--;this.model.numEdgesLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setClippable",value:function setClippable(portionId,flags){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CLIPPABLE){this._numClippableLayerPortions++;this.model.numClippableLayerPortions++;}else{this._numClippableLayerPortions--;this.model.numClippableLayerPortions--;}this._setFlags2(portionId,flags);}/**
     * This will _start_ a "set-flags transaction".
     *
     * After invoking this method, calling setFlags/setFlags2 will not update
     * the colors+flags texture but only store the new flags/flag2 in the
     * colors+flags texture data array.
     *
     * After invoking this method, and when all desired setFlags/setFlags2 have
     * been called on needed portions of the layer, invoke `_uploadDeferredFlags`
     * to actually upload the data array into the texture.
     *
     * In massive "set-flags" scenarios like VFC or LOD mechanisms, the combination of
     * `_beginDeferredFlags` + `_uploadDeferredFlags`brings a speed-up of
     * up to 80x when e.g. objects are massively (un)culled .
     */},{key:"_beginDeferredFlags",value:function _beginDeferredFlags(){this._deferredSetFlagsActive=true;}/**
     * This will _commit_ a "set-flags transaction".
     *
     * Invoking this method will update the colors+flags texture data with new
     * flags/flags2 set since the previous invocation of `_beginDeferredFlags`.
     */},{key:"_uploadDeferredFlags",value:function _uploadDeferredFlags(){this._deferredSetFlagsActive=false;if(!this._deferredSetFlagsDirty){return;}this._deferredSetFlagsDirty=false;var gl=this.model.scene.canvas.gl;var textureState=this._dtxState;gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
0,// xoffset
0,// yoffset
textureState.texturePerObjectColorsAndFlags._textureWidth,// width
textureState.texturePerObjectColorsAndFlags._textureHeight,// width
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,textureState.texturePerObjectColorsAndFlags._textureData);// gl.bindTexture(gl.TEXTURE_2D, textureState.texturePerObjectInstanceMatrices._texture);
// gl.texSubImage2D(
//     gl.TEXTURE_2D,
//     0, // level
//     0, // xoffset
//     0, // yoffset
//     textureState.texturePerObjectInstanceMatrices._textureWidth, // width
//     textureState.texturePerObjectInstanceMatrices._textureHeight, // width
//     gl.RGB,
//     gl.FLOAT,
//     textureState.texturePerObjectInstanceMatrices._textureData
// );
}},{key:"setCulled",value:function setCulled(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.CULLED){this._numCulledLayerPortions+=this._portionToSubPortionsMap[portionId].length;this.model.numCulledLayerPortions++;}else{this._numCulledLayerPortions-=this._portionToSubPortionsMap[portionId].length;this.model.numCulledLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setCollidable",value:function setCollidable(portionId,flags){if(!this._finalized){throw"Not finalized";}}},{key:"setPickable",value:function setPickable(portionId,flags,transparent){if(!this._finalized){throw"Not finalized";}if(flags&ENTITY_FLAGS.PICKABLE){this._numPickableLayerPortions++;this.model.numPickableLayerPortions++;}else{this._numPickableLayerPortions--;this.model.numPickableLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"setColor",value:function setColor(portionId,color){var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i368=0,len=subPortionIds.length;_i368<len;_i368++){this._subPortionSetColor(subPortionIds[_i368],color);}}},{key:"_subPortionSetColor",value:function _subPortionSetColor(subPortionId,color){if(!this._finalized){throw"Not finalized";}// Color
var textureState=this._dtxState;var gl=this.model.scene.canvas.gl;tempUint8Array4[0]=color[0];tempUint8Array4[1]=color[1];tempUint8Array4[2]=color[2];tempUint8Array4[3]=color[3];// object colors
textureState.texturePerObjectColorsAndFlags._textureData.set(tempUint8Array4,subPortionId*32);if(this._deferredSetFlagsActive){console.info("_subPortionSetColor defer");this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE){this._beginDeferredFlags();// Subsequent flags updates now deferred
}console.info("_subPortionSetColor write through");gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*8,// xoffset
Math.floor(subPortionId/512),// yoffset
1,// width
1,//height
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,tempUint8Array4);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"setTransparent",value:function setTransparent(portionId,flags,transparent){if(transparent){this._numTransparentLayerPortions++;this.model.numTransparentLayerPortions++;}else{this._numTransparentLayerPortions--;this.model.numTransparentLayerPortions--;}this._setFlags(portionId,flags,transparent);}},{key:"_setFlags",value:function _setFlags(portionId,flags,transparent){var deferred=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i369=0,len=subPortionIds.length;_i369<len;_i369++){this._subPortionSetFlags(subPortionIds[_i369],flags,transparent,deferred);}}},{key:"_subPortionSetFlags",value:function _subPortionSetFlags(subPortionId,flags,transparent){var deferred=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(!this._finalized){throw"Not finalized";}var visible=!!(flags&ENTITY_FLAGS.VISIBLE);var xrayed=!!(flags&ENTITY_FLAGS.XRAYED);var highlighted=!!(flags&ENTITY_FLAGS.HIGHLIGHTED);var selected=!!(flags&ENTITY_FLAGS.SELECTED);var edges=!!(flags&ENTITY_FLAGS.EDGES);var pickable=!!(flags&ENTITY_FLAGS.PICKABLE);var culled=!!(flags&ENTITY_FLAGS.CULLED);// Color
var f0;if(!visible||culled||xrayed||highlighted&&!this.model.scene.highlightMaterial.glowThrough||selected&&!this.model.scene.selectedMaterial.glowThrough){f0=RENDER_PASSES.NOT_RENDERED;}else{if(transparent){f0=RENDER_PASSES.COLOR_TRANSPARENT;}else{f0=RENDER_PASSES.COLOR_OPAQUE;}}// Silhouette
var f1;if(!visible||culled){f1=RENDER_PASSES.NOT_RENDERED;}else if(selected){f1=RENDER_PASSES.SILHOUETTE_SELECTED;}else if(highlighted){f1=RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;}else if(xrayed){f1=RENDER_PASSES.SILHOUETTE_XRAYED;}else{f1=RENDER_PASSES.NOT_RENDERED;}// Edges
var f2=0;if(!visible||culled){f2=RENDER_PASSES.NOT_RENDERED;}else if(selected){f2=RENDER_PASSES.EDGES_SELECTED;}else if(highlighted){f2=RENDER_PASSES.EDGES_HIGHLIGHTED;}else if(xrayed){f2=RENDER_PASSES.EDGES_XRAYED;}else if(edges){if(transparent){f2=RENDER_PASSES.EDGES_COLOR_TRANSPARENT;}else{f2=RENDER_PASSES.EDGES_COLOR_OPAQUE;}}else{f2=RENDER_PASSES.NOT_RENDERED;}// Pick
var f3=visible&&!culled&&pickable?RENDER_PASSES.PICK:RENDER_PASSES.NOT_RENDERED;var textureState=this._dtxState;var gl=this.model.scene.canvas.gl;tempUint8Array4[0]=f0;tempUint8Array4[1]=f1;tempUint8Array4[2]=f2;tempUint8Array4[3]=f3;// object flags
textureState.texturePerObjectColorsAndFlags._textureData.set(tempUint8Array4,subPortionId*32+8);if(this._deferredSetFlagsActive||deferred){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*8+2,// xoffset
Math.floor(subPortionId/512),// yoffset
1,// width
1,//height
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,tempUint8Array4);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"_setDeferredFlags",value:function _setDeferredFlags(){}},{key:"_setFlags2",value:function _setFlags2(portionId,flags){var deferred=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i370=0,len=subPortionIds.length;_i370<len;_i370++){this._subPortionSetFlags2(subPortionIds[_i370],flags,deferred);}}},{key:"_subPortionSetFlags2",value:function _subPortionSetFlags2(subPortionId,flags){var deferred=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!this._finalized){throw"Not finalized";}var clippable=!!(flags&ENTITY_FLAGS.CLIPPABLE)?255:0;var textureState=this._dtxState;var gl=this.model.scene.canvas.gl;tempUint8Array4[0]=clippable;tempUint8Array4[1]=0;tempUint8Array4[2]=1;tempUint8Array4[3]=2;// object flags2
textureState.texturePerObjectColorsAndFlags._textureData.set(tempUint8Array4,subPortionId*32+12);if(this._deferredSetFlagsActive||deferred){// console.log("_subPortionSetFlags2 set flags defer");
this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectColorsAndFlags._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*8+3,// xoffset
Math.floor(subPortionId/512),// yoffset
1,// width
1,//height
gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,tempUint8Array4);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"_setDeferredFlags2",value:function _setDeferredFlags2(){}},{key:"setOffset",value:function setOffset(portionId,offset){var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i371=0,len=subPortionIds.length;_i371<len;_i371++){this._subPortionSetOffset(subPortionIds[_i371],offset);}}},{key:"_subPortionSetOffset",value:function _subPortionSetOffset(subPortionId,offset){if(!this._finalized){throw"Not finalized";}// if (!this.model.scene.entityOffsetsEnabled) {
//     this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
//     return;
// }
var textureState=this._dtxState;var gl=this.model.scene.canvas.gl;tempFloat32Array3[0]=offset[0];tempFloat32Array3[1]=offset[1];tempFloat32Array3[2]=offset[2];// object offset
textureState.texturePerObjectOffsets._textureData.set(tempFloat32Array3,subPortionId*3);if(this._deferredSetFlagsActive){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectOffsets._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
0,// x offset
subPortionId,// yoffset
1,// width
1,// height
gl.RGB,gl.FLOAT,tempFloat32Array3);// gl.bindTexture (gl.TEXTURE_2D, null);
}},{key:"setMatrix",value:function setMatrix(portionId,matrix){var subPortionIds=this._portionToSubPortionsMap[portionId];for(var _i372=0,len=subPortionIds.length;_i372<len;_i372++){this._subPortionSetMatrix(subPortionIds[_i372],matrix);}}},{key:"_subPortionSetMatrix",value:function _subPortionSetMatrix(subPortionId,matrix){if(!this._finalized){throw"Not finalized";}// if (!this.model.scene.entityMatrixsEnabled) {
//     this.model.error("Entity#matrix not enabled for this Viewer"); // See Viewer entityMatrixsEnabled
//     return;
// }
var textureState=this._dtxState;var gl=this.model.scene.canvas.gl;tempMat4a.set(matrix);textureState.texturePerObjectInstanceMatrices._textureData.set(tempMat4a,subPortionId*16);if(this._deferredSetFlagsActive){this._deferredSetFlagsDirty=true;return;}if(++this._numUpdatesInFrame>=MAX_OBJECT_UPDATES_IN_FRAME_WITHOUT_BATCHED_UPDATE){this._beginDeferredFlags();// Subsequent flags updates now deferred
}gl.bindTexture(gl.TEXTURE_2D,textureState.texturePerObjectInstanceMatrices._texture);gl.texSubImage2D(gl.TEXTURE_2D,0,// level
subPortionId%512*4,// xoffset
Math.floor(subPortionId/512),// yoffset
// 1,
4,// width
1,// height
gl.RGBA,gl.FLOAT,tempMat4a);// gl.bindTexture (gl.TEXTURE_2D, null);
}// ---------------------- COLOR RENDERING -----------------------------------
},{key:"drawColorOpaque",value:function drawColorOpaque(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(frameCtx.withSAO&&this.model.saoEnabled){if(this._renderers.colorRendererWithSAO){this._renderers.colorRendererWithSAO.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}else{if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}}},{key:"_updateBackfaceCull",value:function _updateBackfaceCull(renderFlags,frameCtx){var backfaces=this.model.backfaces||renderFlags.sectioned;if(frameCtx.backfaces!==backfaces){var _gl6=frameCtx.gl;if(backfaces){_gl6.disable(_gl6.CULL_FACE);}else{_gl6.enable(_gl6.CULL_FACE);}frameCtx.backfaces=backfaces;}}},{key:"drawColorTransparent",value:function drawColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===0||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.colorRenderer){this._renderers.colorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_TRANSPARENT);}}// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------
},{key:"drawDepth",value:function drawDepth(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.depthRenderer){this._renderers.depthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);// Assume whatever post-effect uses depth (eg SAO) does not apply to transparent objects
}}},{key:"drawNormals",value:function drawNormals(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numTransparentLayerPortions===this._numPortions||this._numXRayedLayerPortions===this._numPortions){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.normalsRenderer){this._renderers.normalsRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);// Assume whatever post-effect uses normals (eg SAO) does not apply to transparent objects
}}// ---------------------- SILHOUETTE RENDERING -----------------------------------
},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_XRAYED);}}},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);}}},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.silhouetteRenderer){this._renderers.silhouetteRenderer.drawLayer(frameCtx,this,RENDER_PASSES.SILHOUETTE_SELECTED);}}// ---------------------- EDGES RENDERING -----------------------------------
},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(renderFlags,frameCtx){if(this.model.scene.logarithmicDepthBufferEnabled){if(!this.model.scene._loggedWarning){console.log("Edge enhancement for SceneModel data texture layers currently disabled with logarithmic depth buffer");this.model.scene._loggedWarning=true;}return;}if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numEdgesLayerPortions===0){return;}if(this._renderers.edgesColorRenderer){this._renderers.edgesColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_COLOR_OPAQUE);}}},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numEdgesLayerPortions===0||this._numTransparentLayerPortions===0){return;}if(this._renderers.edgesColorRenderer){this._renderers.edgesColorRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_COLOR_TRANSPARENT);}}},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numHighlightedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_HIGHLIGHTED);}}},{key:"drawEdgesSelected",value:function drawEdgesSelected(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numSelectedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_SELECTED);}}},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0||this._numXRayedLayerPortions===0){return;}if(this._renderers.edgesRenderer){this._renderers.edgesRenderer.drawLayer(frameCtx,this,RENDER_PASSES.EDGES_XRAYED);}}// ---------------------- OCCLUSION CULL RENDERING -----------------------------------
},{key:"drawOcclusion",value:function drawOcclusion(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.occlusionRenderer){this._renderers.occlusionRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}// ---------------------- SHADOW BUFFER RENDERING -----------------------------------
},{key:"drawShadow",value:function drawShadow(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.shadowRenderer){this._renderers.shadowRenderer.drawLayer(frameCtx,this,RENDER_PASSES.COLOR_OPAQUE);}}//---- PICKING ----------------------------------------------------------------------------------------------------
},{key:"setPickMatrices",value:function setPickMatrices(pickViewMatrix,pickProjMatrix){// if (this._numVisibleLayerPortions === 0) {
//     return;
// }
// this._dtxState.texturePickCameraMatrices.updateViewMatrix(pickViewMatrix, pickProjMatrix);
}},{key:"drawPickMesh",value:function drawPickMesh(renderFlags,frameCtx){if(this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickMeshRenderer){this._renderers.pickMeshRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickDepths",value:function drawPickDepths(renderFlags,frameCtx){if(this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickDepthRenderer){this._renderers.pickDepthRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnapInit",value:function drawSnapInit(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.snapInitRenderer){this._renderers.snapInitRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawSnap",value:function drawSnap(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.snapRenderer){this._renderers.snapRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"drawPickNormals",value:function drawPickNormals(renderFlags,frameCtx){if(this._numCulledLayerPortions===this._numPortions||this._numVisibleLayerPortions===0){return;}this._updateBackfaceCull(renderFlags,frameCtx);if(this._renderers.pickNormalsRenderer){this._renderers.pickNormalsRenderer.drawLayer(frameCtx,this,RENDER_PASSES.PICK);}}},{key:"destroy",value:function destroy(){if(this._destroyed){return;}var state=this._state;if(state.metallicRoughnessBuf){state.metallicRoughnessBuf.destroy();state.metallicRoughnessBuf=null;}this.model.scene.off(this._onSceneRendering);state.destroy();this._destroyed=true;}}]);return DTXTrianglesLayer;}();/**
 * A texture set within a {@link SceneModel}.
 *
 * * Created with {@link SceneModel#createTextureSet}
 * * Belongs to many {@link SceneModelMesh}es
 * * Stored by ID in {@link SceneModel#textureSets}
 * * Referenced by {@link SceneModelMesh#textureSet}
 */var SceneModelTextureSet=/*#__PURE__*/function(){/**
     * @private
     */function SceneModelTextureSet(cfg){_classCallCheck(this,SceneModelTextureSet);/**
         * Unique ID of this SceneModelTextureSet.
         *
         * The SceneModelTextureSet is registered against this ID in {@link SceneModel#textureSets}.
         */this.id=cfg.id;/**
         * The color texture.
         * @type {SceneModelTexture|*}
         */this.colorTexture=cfg.colorTexture;/**
         * The metallic-roughness texture.
         * @type {SceneModelTexture|*}
         */this.metallicRoughnessTexture=cfg.metallicRoughnessTexture;/**
         * The normal map texture.
         * @type {SceneModelTexture|*}
         */this.normalsTexture=cfg.normalsTexture;/**
         * The emissive color texture.
         * @type {SceneModelTexture|*}
         */this.emissiveTexture=cfg.emissiveTexture;/**
         * The ambient occlusion texture.
         * @type {SceneModelTexture|*}
         */this.occlusionTexture=cfg.occlusionTexture;}/**
     * @private
     */_createClass(SceneModelTextureSet,[{key:"destroy",value:function destroy(){}}]);return SceneModelTextureSet;}();/**
 * A texture within a {@link SceneModelTextureSet}.
 *
 * * Created with {@link SceneModel#createTexture}
 * * Belongs to many {@link SceneModelTextureSet}s
 * * Stored by ID in {@link SceneModel#textures}}
 */var SceneModelTexture=/*#__PURE__*/function(){/**
     * @private
     * @param cfg
     */function SceneModelTexture(cfg){_classCallCheck(this,SceneModelTexture);/**
         * Unique ID of this SceneModelTexture.
         *
         * The SceneModelTexture is registered against this ID in {@link SceneModel#textures}.
         */this.id=cfg.id;/**
         * @private
         */this.texture=cfg.texture;}/**
     * @private
     */_createClass(SceneModelTexture,[{key:"destroy",value:function destroy(){if(this.texture){this.texture.destroy();this.texture=null;}}}]);return SceneModelTexture;}();var Cache$1={enabled:false,files:{},add:function add(key,file){if(this.enabled===false){return;}this.files[key]=file;},get:function get(key){if(this.enabled===false){return;}return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};var LoadingManager=/*#__PURE__*/function(){function LoadingManager(onLoad,onProgress,onError){_classCallCheck(this,LoadingManager);this.isLoading=false;this.itemsLoaded=0;this.itemsTotal=0;this.urlModifier=undefined;this.handlers=[];this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;}_createClass(LoadingManager,[{key:"itemStart",value:function itemStart(url){this.itemsTotal++;if(this.isLoading===false){if(this.onStart!==undefined){this.onStart(url,this.itemsLoaded,this.itemsTotal);}}this.isLoading=true;}},{key:"itemEnd",value:function itemEnd(url){this.itemsLoaded++;if(this.onProgress!==undefined){this.onProgress(url,this.itemsLoaded,this.itemsTotal);}if(this.itemsLoaded===this.itemsTotal){this.isLoading=false;if(this.onLoad!==undefined){this.onLoad();}}}},{key:"itemError",value:function itemError(url){if(this.onError!==undefined){this.onError(url);}}},{key:"resolveURL",value:function resolveURL(url){if(this.urlModifier){return this.urlModifier(url);}return url;}},{key:"setURLModifier",value:function setURLModifier(transform){this.urlModifier=transform;return this;}},{key:"addHandler",value:function addHandler(regex,loader){this.handlers.push(regex,loader);return this;}},{key:"removeHandler",value:function removeHandler(regex){var index=this.handlers.indexOf(regex);if(index!==-1){this.handlers.splice(index,2);}return this;}},{key:"getHandler",value:function getHandler(file){for(var _i373=0,_l2=this.handlers.length;_i373<_l2;_i373+=2){var regex=this.handlers[_i373];var loader=this.handlers[_i373+1];if(regex.global)regex.lastIndex=0;// see #17920
if(regex.test(file)){return loader;}}return null;}}]);return LoadingManager;}();var DefaultLoadingManager=new LoadingManager();var Loader=/*#__PURE__*/function(){function Loader(manager){_classCallCheck(this,Loader);this.manager=manager!==undefined?manager:DefaultLoadingManager;this.crossOrigin='anonymous';this.withCredentials=false;this.path='';this.resourcePath='';this.requestHeader={};}_createClass(Loader,[{key:"load",value:function/* url, onLoad, onProgress, onError */load(){}},{key:"loadAsync",value:function loadAsync(url,onProgress){var scope=this;return new Promise(function(resolve,reject){scope.load(url,resolve,onProgress,reject);});}},{key:"parse",value:function/* data */parse(){}},{key:"setCrossOrigin",value:function setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this;}},{key:"setWithCredentials",value:function setWithCredentials(value){this.withCredentials=value;return this;}},{key:"setPath",value:function setPath(path){this.path=path;return this;}},{key:"setResourcePath",value:function setResourcePath(resourcePath){this.resourcePath=resourcePath;return this;}},{key:"setRequestHeader",value:function setRequestHeader(requestHeader){this.requestHeader=requestHeader;return this;}}]);return Loader;}();var loading={};var FileLoader=/*#__PURE__*/function(_Loader){_inherits(FileLoader,_Loader);var _super111=_createSuper(FileLoader);function FileLoader(manager){_classCallCheck(this,FileLoader);return _super111.call(this,manager);}_createClass(FileLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){var _this70=this;if(url===undefined){url='';}if(this.path!==undefined){url=this.path+url;}url=this.manager.resolveURL(url);var cached=Cache$1.get(url);if(cached!==undefined){this.manager.itemStart(url);core.scheduleTask(function(){if(onLoad){onLoad(cached);}_this70.manager.itemEnd(url);},0);return cached;}if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});var req=new Request(url,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?'include':'same-origin'});var mimeType=this.mimeType;var responseType=this.responseType;fetch(req).then(function(response){if(response.status===200||response.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
if(response.status===0){console.warn('FileLoader: HTTP Status 0 received.');}if(typeof ReadableStream==='undefined'||response.body.getReader===undefined){return response;}var callbacks=loading[url];var reader=response.body.getReader();var contentLength=response.headers.get('Content-Length');var total=contentLength?parseInt(contentLength):0;var lengthComputable=total!==0;var loaded=0;var stream=new ReadableStream({start:function start(controller){readData();function readData(){reader.read().then(function(_ref10){var done=_ref10.done,value=_ref10.value;if(done){controller.close();}else{loaded+=value.byteLength;var event=new ProgressEvent('progress',{lengthComputable:lengthComputable,loaded:loaded,total:total});for(var _i374=0,il=callbacks.length;_i374<il;_i374++){var callback=callbacks[_i374];if(callback.onProgress){callback.onProgress(event);}}controller.enqueue(value);readData();}});}}});return new Response(stream);}else{throw Error("fetch for \"".concat(response.url,"\" responded with ").concat(response.status,": ").concat(response.statusText));}}).then(function(response){switch(responseType){case'arraybuffer':return response.arrayBuffer();case'blob':return response.blob();case'document':return response.text().then(function(text){var parser=new DOMParser();return parser.parseFromString(text,mimeType);});case'json':return response.json();default:if(mimeType===undefined){return response.text();}else{// sniff encoding
var re=/charset="?([^;"\s]*)"?/i;var exec=re.exec(mimeType);var label=exec&&exec[1]?exec[1].toLowerCase():undefined;var decoder=new TextDecoder(label);return response.arrayBuffer().then(function(ab){return decoder.decode(ab);});}}}).then(function(data){// Add to cache only on HTTP success, so that we do not cache
// error response bodies as proper responses to requests.
Cache$1.add(url,data);var callbacks=loading[url];delete loading[url];for(var _i375=0,il=callbacks.length;_i375<il;_i375++){var callback=callbacks[_i375];if(callback.onLoad){callback.onLoad(data);}}})["catch"](function(err){// Abort errors and other errors are handled the same
var callbacks=loading[url];if(callbacks===undefined){// When onLoad was called and url was deleted in `loading`
_this70.manager.itemError(url);throw err;}delete loading[url];for(var _i376=0,il=callbacks.length;_i376<il;_i376++){var callback=callbacks[_i376];if(callback.onError){callback.onError(err);}}_this70.manager.itemError(url);})["finally"](function(){_this70.manager.itemEnd(url);});this.manager.itemStart(url);}},{key:"setResponseType",value:function setResponseType(value){this.responseType=value;return this;}},{key:"setMimeType",value:function setMimeType(value){this.mimeType=value;return this;}}]);return FileLoader;}(Loader);/**
 * @author Deepkolos / https://github.com/deepkolos
 */var WorkerPool$1=/*#__PURE__*/function(){function WorkerPool$1(){var pool=arguments.length>0&&arguments[0]!==undefined?arguments[0]:4;_classCallCheck(this,WorkerPool$1);this.pool=pool;this.queue=[];this.workers=[];this.workersResolve=[];this.workerStatus=0;}_createClass(WorkerPool$1,[{key:"_initWorker",value:function _initWorker(workerId){if(!this.workers[workerId]){var worker=this.workerCreator();worker.addEventListener('message',this._onMessage.bind(this,workerId));this.workers[workerId]=worker;}}},{key:"_getIdleWorker",value:function _getIdleWorker(){for(var _i377=0;_i377<this.pool;_i377++){if(!(this.workerStatus&1<<_i377))return _i377;}return-1;}},{key:"_onMessage",value:function _onMessage(workerId,msg){var resolve=this.workersResolve[workerId];resolve&&resolve(msg);if(this.queue.length){var _this$queue$shift=this.queue.shift(),_resolve=_this$queue$shift.resolve,_msg=_this$queue$shift.msg,transfer=_this$queue$shift.transfer;this.workersResolve[workerId]=_resolve;this.workers[workerId].postMessage(_msg,transfer);}else{this.workerStatus^=1<<workerId;}}},{key:"setWorkerCreator",value:function setWorkerCreator(workerCreator){this.workerCreator=workerCreator;}},{key:"setWorkerLimit",value:function setWorkerLimit(pool){this.pool=pool;}},{key:"postMessage",value:function postMessage(msg,transfer){var _this71=this;return new Promise(function(resolve){var workerId=_this71._getIdleWorker();if(workerId!==-1){_this71._initWorker(workerId);_this71.workerStatus|=1<<workerId;_this71.workersResolve[workerId]=resolve;_this71.workers[workerId].postMessage(msg,transfer);}else{_this71.queue.push({resolve:resolve,msg:msg,transfer:transfer});}});}},{key:"destroy",value:function destroy(){this.workers.forEach(function(worker){return worker.terminate();});this.workersResolve.length=0;this.workers.length=0;this.queue.length=0;this.workerStatus=0;}}]);return WorkerPool$1;}();var KTX2TransferSRGB=2;var KTX2_ALPHA_PREMULTIPLIED=1;var activeTranscoders=0;/**
 * Transcodes texture data from KTX2.
 *
 * ## Overview
 *
 * * Uses the [Basis Universal GPU Texture Codec](https://github.com/BinomialLLC/basis_universal) to
 * transcode [KTX2](https://github.khronos.org/KTX-Specification/) textures.
 * * {@link XKTLoaderPlugin} uses a KTX2TextureTranscoder to load textures in XKT files.
 * * {@link VBOSceneModel} uses a KTX2TextureTranscoder to enable us to add KTX2-encoded textures.
 * * Loads the Basis Codec from [CDN](https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/) by default, but can
 * also be configured to load the Codec from local files.
 * * We also bundle the Basis Codec with the xeokit-sdk npm package, and in the [repository](https://github.com/xeokit/xeokit-sdk/tree/master/dist/basis).
 *
 * ## What is KTX2?
 *
 * A [KTX2](https://github.khronos.org/KTX-Specification/) file stores GPU texture data in the Khronos Texture 2.0 (KTX2) container format. It contains image data for
 * a texture asset compressed with Basis Universal (BasisU) supercompression that can be transcoded to different formats
 * depending on the support provided by the target devices. KTX2 provides a lightweight format for distributing texture
 * assets to GPUs. Due to BasisU compression, KTX2 files can store any image format supported by GPUs.
 *
 * ## Loading XKT files containing KTX2 textures
 *
 * {@link XKTLoaderPlugin} uses a KTX2TextureTranscoder to load textures in XKT files. An XKTLoaderPlugin has its own
 * default KTX2TextureTranscoder, configured to load the Basis Codec from the [CDN](https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/). If we wish, we can override that with our own
 * KTX2TextureTranscoder, configured to load the Codec locally.
 *
 * In the example below, we'll create a {@link Viewer} and add an {@link XKTLoaderPlugin}
 * configured with a KTX2TextureTranscoder. Then we'll use the XKTLoaderPlugin to load an
 * XKT file that contains KTX2 textures, which the plugin will transcode using
 * its KTX2TextureTranscoder.
 *
 * We'll configure our KTX2TextureTranscoder to load the Basis Codec from a local directory. If we were happy with loading the
 * Codec from our [CDN](https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/) (ie. our app will always have an Internet connection) then we could just leave out the
 * KTX2TextureTranscoder altogether, and let the XKTLoaderPlugin use its internal default KTX2TextureTranscoder, which is configured to
 * load the Codec from the CDN. We'll stick with loading our own Codec, in case we want to run our app without an Internet connection.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_Textures_HousePlan"><img src="https://xeokit.github.io/xeokit-sdk/assets/images/xktWithTextures.png"></a>
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_Textures_HousePlan)]
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/" // <------ Path to Basis Universal transcoder
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer, {
 *     textureTranscoder // <<------------- Transcodes KTX2 textures in XKT files
 * });
 *
 * const sceneModel = xktLoader.load({
 *     id: "myModel",
 *     src: "./HousePlan.xkt" // <<------ XKT file with KTX2 textures
 * });
 * ````
 *
 * ## Loading KTX2 files into a VBOSceneModel
 *
 * A {@link SceneModel} that is configured with a KTX2TextureTranscoder will
 * allow us to load textures into it from KTX2-transcoded buffers or files.
 *
 * In the example below, we'll create a {@link Viewer}, containing a {@link VBOSceneModel} configured with a
 * KTX2TextureTranscoder.
 *
 * We'll then programmatically create a simple object within the VBOSceneModel, consisting of
 * a single box mesh with a texture loaded from a KTX2 file, which our VBOSceneModel internally transcodes, using
 * its KTX2TextureTranscoder.
 *
 * As in the previous example, we'll configure our KTX2TextureTranscoder to load the Basis Codec from a local directory.
 *
 * * [Run a similar example](http://localhost:8080/examples/sceneRepresentation_VBOSceneModel_batching_textures_ktx2.html)
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/" // <------ Path to BasisU transcoder module
 * });
 *
 * const vboSceneModel = new VBOSceneModel(viewer.scene, {
 *      id: "myModel",
 *      textureTranscoder // <<-------------------- Configure model with our transcoder
 *  });
 *
 * vboSceneModel.createTexture({
 *      id: "myColorTexture",
 *      src: "../assets/textures/compressed/sample_uastc_zstd.ktx2" // <<----- KTX2 texture asset
 * });
 *
 * vboSceneModel.createTexture({
 *      id: "myMetallicRoughnessTexture",
 *      src: "../assets/textures/alpha/crosshatchAlphaMap.jpg" // <<----- JPEG texture asset
 * });
 *
 * vboSceneModel.createTextureSet({
 *      id: "myTextureSet",
 *      colorTextureId: "myColorTexture",
 *      metallicRoughnessTextureId: "myMetallicRoughnessTexture"
 *  });
 *
 * vboSceneModel.createMesh({
 *      id: "myMesh",
 *      textureSetId: "myTextureSet",
 *      primitive: "triangles",
 *      positions: [1, 1, 1, ...],
 *      normals: [0, 0, 1, 0, ...],
 *      uv: [1, 0, 0, ...],
 *      indices: [0, 1, 2, ...],
 *  });
 *
 * vboSceneModel.createEntity({
 *      id: "myEntity",
 *      meshIds: ["myMesh"]
 *  });
 *
 * vboSceneModel.finalize();
 * ````
 *
 * ## Loading KTX2 ArrayBuffers into a VBOSceneModel
 *
 * A {@link SceneModel} that is configured with a KTX2TextureTranscoder will also allow us to load textures into
 * it from KTX2 ArrayBuffers.
 *
 * In the example below, we'll create a {@link Viewer}, containing a {@link VBOSceneModel} configured with a
 * KTX2TextureTranscoder.
 *
 * We'll then programmatically create a simple object within the VBOSceneModel, consisting of
 * a single mesh with a texture loaded from a KTX2 ArrayBuffer, which our VBOSceneModel internally transcodes, using
 * its KTX2TextureTranscoder.
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/" // <------ Path to BasisU transcoder module
 * });
 *
 * const vboSceneModel = new VBOSceneModel(viewer.scene, {
 *      id: "myModel",
 *      textureTranscoder // <<-------------------- Configure model with our transcoder
 * });
 *
 * utils.loadArraybuffer("../assets/textures/compressed/sample_uastc_zstd.ktx2",(arrayBuffer) => {
 *
 *     vboSceneModel.createTexture({
 *         id: "myColorTexture",
 *         buffers: [arrayBuffer] // <<----- KTX2 texture asset
 *     });
 *
 *     vboSceneModel.createTexture({
 *         id: "myMetallicRoughnessTexture",
 *         src: "../assets/textures/alpha/crosshatchAlphaMap.jpg" // <<----- JPEG texture asset
 *     });
 *
 *     vboSceneModel.createTextureSet({
 *        id: "myTextureSet",
 *        colorTextureId: "myColorTexture",
 *        metallicRoughnessTextureId: "myMetallicRoughnessTexture"
 *     });
 *
 *     vboSceneModel.createMesh({
 *          id: "myMesh",
 *          textureSetId: "myTextureSet",
 *          primitive: "triangles",
 *          positions: [1, 1, 1, ...],
 *          normals: [0, 0, 1, 0, ...],
 *          uv: [1, 0, 0, ...],
 *          indices: [0, 1, 2, ...],
 *     });
 *
 *     vboSceneModel.createEntity({
 *         id: "myEntity",
 *         meshIds: ["myMesh"]
 *     });
 *
 *     vboSceneModel.finalize();
 * });
 * ````
 *
 * @implements {TextureTranscoder}
 */var KTX2TextureTranscoder=/*#__PURE__*/function(){/**
     * Creates a new KTX2TextureTranscoder.
     *
     * @param {Viewer} viewer The Viewer that our KTX2TextureTranscoder will be used with. This KTX2TextureTranscoder
     * must only be used to transcode textures for this Viewer. This is because the Viewer's capabilities will decide
     * what target GPU formats this KTX2TextureTranscoder will transcode to.
     * @param {String} [transcoderPath="https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/"] Path to the Basis
     * transcoder module that internally does the heavy lifting for our KTX2TextureTranscoder. If we omit this configuration,
     * then our KTX2TextureTranscoder will load it from ````https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/```` by
     * default. Therefore, make sure your application is connected to the internet if you wish to use the default transcoder path.
     * @param {Number} [workerLimit] The maximum number of Workers to use for transcoding.
     */function KTX2TextureTranscoder(_ref11){var viewer=_ref11.viewer,transcoderPath=_ref11.transcoderPath,workerLimit=_ref11.workerLimit;_classCallCheck(this,KTX2TextureTranscoder);this._transcoderPath=transcoderPath||"https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/";this._transcoderBinary=null;this._transcoderPending=null;this._workerPool=new WorkerPool$1();this._workerSourceURL='';if(workerLimit){this._workerPool.setWorkerLimit(workerLimit);}var viewerCapabilities=viewer.capabilities;this._workerConfig={astcSupported:viewerCapabilities.astcSupported,etc1Supported:viewerCapabilities.etc1Supported,etc2Supported:viewerCapabilities.etc2Supported,dxtSupported:viewerCapabilities.dxtSupported,bptcSupported:viewerCapabilities.bptcSupported,pvrtcSupported:viewerCapabilities.pvrtcSupported};this._supportedFileTypes=["xkt2"];}_createClass(KTX2TextureTranscoder,[{key:"_init",value:function _init(){var _this72=this;if(!this._transcoderPending){var jsLoader=new FileLoader();jsLoader.setPath(this._transcoderPath);jsLoader.setWithCredentials(this.withCredentials);var jsContent=jsLoader.loadAsync('basis_transcoder.js');var binaryLoader=new FileLoader();binaryLoader.setPath(this._transcoderPath);binaryLoader.setResponseType('arraybuffer');binaryLoader.setWithCredentials(this.withCredentials);var binaryContent=binaryLoader.loadAsync('basis_transcoder.wasm');this._transcoderPending=Promise.all([jsContent,binaryContent]).then(function(_ref12){var _ref13=_slicedToArray(_ref12,2),jsContent=_ref13[0],binaryContent=_ref13[1];var fn=KTX2TextureTranscoder.BasisWorker.toString();var body=['/* constants */','let _EngineFormat = '+JSON.stringify(KTX2TextureTranscoder.EngineFormat),'let _TranscoderFormat = '+JSON.stringify(KTX2TextureTranscoder.TranscoderFormat),'let _BasisFormat = '+JSON.stringify(KTX2TextureTranscoder.BasisFormat),'/* basis_transcoder.js */',jsContent,'/* worker */',fn.substring(fn.indexOf('{')+1,fn.lastIndexOf('}'))].join('\n');_this72._workerSourceURL=URL.createObjectURL(new Blob([body]));_this72._transcoderBinary=binaryContent;_this72._workerPool.setWorkerCreator(function(){var worker=new Worker(_this72._workerSourceURL);var transcoderBinary=_this72._transcoderBinary.slice(0);worker.postMessage({type:'init',config:_this72._workerConfig,transcoderBinary:transcoderBinary},[transcoderBinary]);return worker;});});if(activeTranscoders>0){console.warn('KTX2TextureTranscoder: Multiple active KTX2TextureTranscoder may cause performance issues.'+' Use a single KTX2TextureTranscoder instance, or call .dispose() on old instances.');}activeTranscoders++;}return this._transcoderPending;}/**
     * Transcodes texture data from transcoded buffers into a {@link Texture2D}.
     *
     * @param {ArrayBuffer[]} buffers Transcoded texture data. Given as an array of buffers so that we can support multi-image textures, such as cube maps.
     * @param {*} config Transcoding options.
     * @param {Texture2D} texture The texture to load.
     * @returns {Promise} Resolves when the texture has loaded.
     */},{key:"transcode",value:function transcode(buffers,texture){var _this73=this;var config=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return new Promise(function(resolve,reject){var taskConfig=config;_this73._init().then(function(){return _this73._workerPool.postMessage({type:'transcode',buffers:buffers,taskConfig:taskConfig},buffers);}).then(function(e){var transcodeResult=e.data;var mipmaps=transcodeResult.mipmaps,width=transcodeResult.width,height=transcodeResult.height,format=transcodeResult.format,type=transcodeResult.type,error=transcodeResult.error,dfdTransferFn=transcodeResult.dfdTransferFn,dfdFlags=transcodeResult.dfdFlags;if(type==='error'){return reject(error);}texture.setCompressedData({mipmaps:mipmaps,props:{format:format,minFilter:mipmaps.length===1?LinearFilter:LinearMipmapLinearFilter,magFilter:mipmaps.length===1?LinearFilter:LinearMipmapLinearFilter,encoding:dfdTransferFn===KTX2TransferSRGB?sRGBEncoding:LinearEncoding,premultiplyAlpha:!!(dfdFlags&KTX2_ALPHA_PREMULTIPLIED)}});resolve();});});}/**
     * Destroys this KTX2TextureTranscoder
     */},{key:"destroy",value:function destroy(){URL.revokeObjectURL(this._workerSourceURL);this._workerPool.destroy();activeTranscoders--;}}]);return KTX2TextureTranscoder;}();/**
 * @private
 */KTX2TextureTranscoder.BasisFormat={ETC1S:0,UASTC_4x4:1};/**
 * @private
 */KTX2TextureTranscoder.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16};/**
 * @private
 */KTX2TextureTranscoder.EngineFormat={RGBAFormat:RGBAFormat,RGBA_ASTC_4x4_Format:RGBA_ASTC_4x4_Format,RGBA_BPTC_Format:RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format:RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format:RGBA_S3TC_DXT5_Format,RGB_ETC1_Format:RGB_ETC1_Format,RGB_ETC2_Format:RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format:RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format:RGB_S3TC_DXT1_Format};/* WEB WORKER */ /**
 * @private
 * @constructor
 */KTX2TextureTranscoder.BasisWorker=function(){var config;var transcoderPending;var BasisModule;var EngineFormat=_EngineFormat;// eslint-disable-line no-undef
var TranscoderFormat=_TranscoderFormat;// eslint-disable-line no-undef
var BasisFormat=_BasisFormat;// eslint-disable-line no-undef
self.addEventListener('message',function(e){var message=e.data;switch(message.type){case'init':config=message.config;init(message.transcoderBinary);break;case'transcode':transcoderPending.then(function(){try{var _transcode=transcode(message.buffers[0]),width=_transcode.width,height=_transcode.height,hasAlpha=_transcode.hasAlpha,mipmaps=_transcode.mipmaps,format=_transcode.format,dfdTransferFn=_transcode.dfdTransferFn,dfdFlags=_transcode.dfdFlags;var buffers=[];for(var _i378=0;_i378<mipmaps.length;++_i378){buffers.push(mipmaps[_i378].data.buffer);}self.postMessage({type:'transcode',id:message.id,width:width,height:height,hasAlpha:hasAlpha,mipmaps:mipmaps,format:format,dfdTransferFn:dfdTransferFn,dfdFlags:dfdFlags},buffers);}catch(error){console.error("[KTX2TextureTranscoder.BasisWorker]: ".concat(error));self.postMessage({type:'error',id:message.id,error:error.message});}});break;}});function init(wasmBinary){transcoderPending=new Promise(function(resolve){BasisModule={wasmBinary:wasmBinary,onRuntimeInitialized:resolve};BASIS(BasisModule);// eslint-disable-line no-undef
}).then(function(){BasisModule.initializeBasis();if(BasisModule.KTX2File===undefined){console.warn('KTX2TextureTranscoder: Please update Basis Universal transcoder.');}});}function transcode(buffer){var ktx2File=new BasisModule.KTX2File(new Uint8Array(buffer));function cleanup(){ktx2File.close();ktx2File["delete"]();}if(!ktx2File.isValid()){cleanup();throw new Error('KTX2TextureTranscoder: Invalid or unsupported .ktx2 file');}var basisFormat=ktx2File.isUASTC()?BasisFormat.UASTC_4x4:BasisFormat.ETC1S;var width=ktx2File.getWidth();var height=ktx2File.getHeight();var levels=ktx2File.getLevels();var hasAlpha=ktx2File.getHasAlpha();var dfdTransferFn=ktx2File.getDFDTransferFunc();var dfdFlags=ktx2File.getDFDFlags();var _getTranscoderFormat=getTranscoderFormat(basisFormat,width,height,hasAlpha),transcoderFormat=_getTranscoderFormat.transcoderFormat,engineFormat=_getTranscoderFormat.engineFormat;if(!width||!height||!levels){cleanup();throw new Error('KTX2TextureTranscoder: Invalid texture');}if(!ktx2File.startTranscoding()){cleanup();throw new Error('KTX2TextureTranscoder: .startTranscoding failed');}var mipmaps=[];for(var mip=0;mip<levels;mip++){var levelInfo=ktx2File.getImageLevelInfo(mip,0,0);var mipWidth=levelInfo.origWidth;var mipHeight=levelInfo.origHeight;var dst=new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip,0,0,transcoderFormat));var status=ktx2File.transcodeImage(dst,mip,0,0,transcoderFormat,0,-1,-1);if(!status){cleanup();throw new Error('KTX2TextureTranscoder: .transcodeImage failed.');}mipmaps.push({data:dst,width:mipWidth,height:mipHeight});}cleanup();return{width:width,height:height,hasAlpha:hasAlpha,mipmaps:mipmaps,format:engineFormat,dfdTransferFn:dfdTransferFn,dfdFlags:dfdFlags};}// Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),
// device capabilities, and texture dimensions. The list below ranks the formats separately
// for ETC1S and UASTC.
//
// In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at
// significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently
// chooses RGBA32 only as a last resort and does not expose that option to the caller.
var FORMAT_OPTIONS=[{"if":'astcSupported',basisFormat:[BasisFormat.UASTC_4x4],transcoderFormat:[TranscoderFormat.ASTC_4x4,TranscoderFormat.ASTC_4x4],engineFormat:[EngineFormat.RGBA_ASTC_4x4_Format,EngineFormat.RGBA_ASTC_4x4_Format],priorityETC1S:Infinity,priorityUASTC:1,needsPowerOfTwo:false},{"if":'bptcSupported',basisFormat:[BasisFormat.ETC1S,BasisFormat.UASTC_4x4],transcoderFormat:[TranscoderFormat.BC7_M5,TranscoderFormat.BC7_M5],engineFormat:[EngineFormat.RGBA_BPTC_Format,EngineFormat.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:false},{"if":'dxtSupported',basisFormat:[BasisFormat.ETC1S,BasisFormat.UASTC_4x4],transcoderFormat:[TranscoderFormat.BC1,TranscoderFormat.BC3],engineFormat:[EngineFormat.RGB_S3TC_DXT1_Format,EngineFormat.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:false},{"if":'etc2Supported',basisFormat:[BasisFormat.ETC1S,BasisFormat.UASTC_4x4],transcoderFormat:[TranscoderFormat.ETC1,TranscoderFormat.ETC2],engineFormat:[EngineFormat.RGB_ETC2_Format,EngineFormat.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:false},{"if":'etc1Supported',basisFormat:[BasisFormat.ETC1S,BasisFormat.UASTC_4x4],transcoderFormat:[TranscoderFormat.ETC1],engineFormat:[EngineFormat.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:false},{"if":'pvrtcSupported',basisFormat:[BasisFormat.ETC1S,BasisFormat.UASTC_4x4],transcoderFormat:[TranscoderFormat.PVRTC1_4_RGB,TranscoderFormat.PVRTC1_4_RGBA],engineFormat:[EngineFormat.RGB_PVRTC_4BPPV1_Format,EngineFormat.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:true}];var ETC1S_OPTIONS=FORMAT_OPTIONS.sort(function(a,b){return a.priorityETC1S-b.priorityETC1S;});var UASTC_OPTIONS=FORMAT_OPTIONS.sort(function(a,b){return a.priorityUASTC-b.priorityUASTC;});function getTranscoderFormat(basisFormat,width,height,hasAlpha){var transcoderFormat;var engineFormat;var options=basisFormat===BasisFormat.ETC1S?ETC1S_OPTIONS:UASTC_OPTIONS;for(var _i379=0;_i379<options.length;_i379++){var opt=options[_i379];if(!config[opt["if"]])continue;if(!opt.basisFormat.includes(basisFormat))continue;if(hasAlpha&&opt.transcoderFormat.length<2)continue;if(opt.needsPowerOfTwo&&!(isPowerOfTwo(width)&&isPowerOfTwo(height)))continue;transcoderFormat=opt.transcoderFormat[hasAlpha?1:0];engineFormat=opt.engineFormat[hasAlpha?1:0];return{transcoderFormat:transcoderFormat,engineFormat:engineFormat};}console.warn('KTX2TextureTranscoder: No suitable compressed texture format found. Decoding to RGBA32.');transcoderFormat=TranscoderFormat.RGBA32;engineFormat=EngineFormat.RGBAFormat;return{transcoderFormat:transcoderFormat,engineFormat:engineFormat};}function isPowerOfTwo(value){if(value<=2)return true;return(value&value-1)===0&&value!==0;}};var cachedTranscoders={};/**
 * Returns a new {@link KTX2TextureTranscoder}.
 *
 * The ````transcoderPath```` config will be set to: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/"
 *
 * @private
 */function getKTX2TextureTranscoder(viewer){var sceneId=viewer.scene.id;var transcoder=cachedTranscoders[sceneId];if(!transcoder){transcoder=new KTX2TextureTranscoder({viewer:viewer});cachedTranscoders[sceneId]=transcoder;viewer.scene.on("destroyed",function(){delete cachedTranscoders[sceneId];transcoder.destroy();});}return transcoder;}/**
 * @author https://github.com/tmarti, with support from https://tribia.com/
 * @license MIT
 *
 * This file takes a geometry given by { positionsCompressed, indices }, and returns
 * equivalent { positionsCompressed, indices } arrays but which only contain unique
 * positionsCompressed.
 *
 * The time is O(N logN) with the number of positionsCompressed due to a pre-sorting
 * step, but is much more GC-friendly and actually faster than the classic O(N)
 * approach based in keeping a hash-based LUT to identify unique positionsCompressed.
 */var comparePositions=null;function compareVertex(a,b){var res;for(var _i380=0;_i380<3;_i380++){if(0!==(res=comparePositions[a*3+_i380]-comparePositions[b*3+_i380])){return res;}}return 0;}var seqInit=null;function setMaxNumberOfPositions(maxPositions){if(seqInit!==null&&seqInit.length>=maxPositions){return;}seqInit=new Uint32Array(maxPositions);for(var _i381=0;_i381<maxPositions;_i381++){seqInit[_i381]=_i381;}}/**
 * This function obtains unique positionsCompressed in the provided object
 * .positionsCompressed array and calculates an index mapping, which is then
 * applied to the provided object .indices and .edgeindices.
 *
 * The input object items are not modified, and instead new set
 * of positionsCompressed, indices and edgeIndices with the applied optimization
 * are returned.
 *
 * The algorithm, instead of being based in a hash-like LUT for
 * identifying unique positionsCompressed, is based in pre-sorting the input
 * positionsCompressed...
 *
 * (it's possible to define a _"consistent ordering"_ for the positionsCompressed
 *  as positionsCompressed are quantized and thus not suffer from float number
 *  comparison artifacts)
 *
 * ... so same positionsCompressed are adjacent in the sorted array, and then
 * it's easy to scan linearly the sorted array. During the linear run,
 * we will know that we found a different position because the comparison
 * function will return != 0 between current and previous element.
 *
 * During this linear traversal of the array, a `unique counter` is used
 * in order to calculate the mapping between original indices and unique
 * indices.
 *
 * @param {{positionsCompressed: number[],indices: number[], edgeIndices: number[]}} mesh The input mesh to process, with `positionsCompressed`, `indices` and `edgeIndices` keys.
 *
 * @returns {[Uint16Array, Uint32Array, Uint32Array]} An array with 3 elements: 0 => the uniquified positionsCompressed; 1 and 2 => the remapped edges and edgeIndices arrays
 */function uniquifyPositions(mesh){var _positions=mesh.positionsCompressed;var _indices=mesh.indices;var _edgeIndices=mesh.edgeIndices;setMaxNumberOfPositions(_positions.length/3);var seq=seqInit.slice(0,_positions.length/3);var remappings=seqInit.slice(0,_positions.length/3);comparePositions=_positions;seq.sort(compareVertex);var uniqueIdx=0;remappings[seq[0]]=0;for(var _i382=1,len=seq.length;_i382<len;_i382++){if(0!==compareVertex(seq[_i382],seq[_i382-1])){uniqueIdx++;}remappings[seq[_i382]]=uniqueIdx;}var numUniquePositions=uniqueIdx+1;var newPositions=new Uint16Array(numUniquePositions*3);uniqueIdx=0;newPositions[uniqueIdx*3+0]=_positions[seq[0]*3+0];newPositions[uniqueIdx*3+1]=_positions[seq[0]*3+1];newPositions[uniqueIdx*3+2]=_positions[seq[0]*3+2];for(var _i383=1,_len77=seq.length;_i383<_len77;_i383++){if(0!==compareVertex(seq[_i383],seq[_i383-1])){uniqueIdx++;newPositions[uniqueIdx*3+0]=_positions[seq[_i383]*3+0];newPositions[uniqueIdx*3+1]=_positions[seq[_i383]*3+1];newPositions[uniqueIdx*3+2]=_positions[seq[_i383]*3+2];}remappings[seq[_i383]]=uniqueIdx;}comparePositions=null;var newIndices=new Uint32Array(_indices.length);for(var _i384=0,_len78=_indices.length;_i384<_len78;_i384++){newIndices[_i384]=remappings[_indices[_i384]];}var newEdgeIndices=new Uint32Array(_edgeIndices.length);for(var _i385=0,_len79=_edgeIndices.length;_i385<_len79;_i385++){newEdgeIndices[_i385]=remappings[_edgeIndices[_i385]];}return[newPositions,newIndices,newEdgeIndices];}/**
 * @author https://github.com/tmarti, with support from https://tribia.com/
 * @license MIT
 **/var MAX_RE_BUCKET_FAN_OUT=8;var bucketsForIndices=null;function compareBuckets(a,b){var aa=a*3;var bb=b*3;var aa1,aa2,aa3,bb1,bb2,bb3;var minBucketA=Math.min(aa1=bucketsForIndices[aa],aa2=bucketsForIndices[aa+1],aa3=bucketsForIndices[aa+2]);var minBucketB=Math.min(bb1=bucketsForIndices[bb],bb2=bucketsForIndices[bb+1],bb3=bucketsForIndices[bb+2]);if(minBucketA!==minBucketB){return minBucketA-minBucketB;}var maxBucketA=Math.max(aa1,aa2,aa3);var maxBucketB=Math.max(bb1,bb2,bb3);if(maxBucketA!==maxBucketB){return maxBucketA-maxBucketB;}return 0;}function preSortIndices(indices,bitsPerBucket){var seq=new Int32Array(indices.length/3);for(var _i386=0,len=seq.length;_i386<len;_i386++){seq[_i386]=_i386;}bucketsForIndices=new Int32Array(indices.length);for(var _i387=0,_len80=indices.length;_i387<_len80;_i387++){bucketsForIndices[_i387]=indices[_i387]>>bitsPerBucket;}seq.sort(compareBuckets);var sortedIndices=new Int32Array(indices.length);for(var _i388=0,_len81=seq.length;_i388<_len81;_i388++){sortedIndices[_i388*3+0]=indices[seq[_i388]*3+0];sortedIndices[_i388*3+1]=indices[seq[_i388]*3+1];sortedIndices[_i388*3+2]=indices[seq[_i388]*3+2];}return sortedIndices;}var compareEdgeIndices=null;function compareIndices(a,b){var retVal=compareEdgeIndices[a*2]-compareEdgeIndices[b*2];if(retVal!==0){return retVal;}return compareEdgeIndices[a*2+1]-compareEdgeIndices[b*2+1];}function preSortEdgeIndices(edgeIndices){if((edgeIndices||[]).length===0){return[];}var seq=new Int32Array(edgeIndices.length/2);for(var _i389=0,len=seq.length;_i389<len;_i389++){seq[_i389]=_i389;}for(var _i390=0,_len82=edgeIndices.length;_i390<_len82;_i390+=2){if(edgeIndices[_i390]>edgeIndices[_i390+1]){var tmp=edgeIndices[_i390];edgeIndices[_i390]=edgeIndices[_i390+1];edgeIndices[_i390+1]=tmp;}}compareEdgeIndices=new Int32Array(edgeIndices);seq.sort(compareIndices);var sortedEdgeIndices=new Int32Array(edgeIndices.length);for(var _i391=0,_len83=seq.length;_i391<_len83;_i391++){sortedEdgeIndices[_i391*2+0]=edgeIndices[seq[_i391]*2+0];sortedEdgeIndices[_i391*2+1]=edgeIndices[seq[_i391]*2+1];}return sortedEdgeIndices;}/**
 * @param {{positionsCompressed: number[], indices: number[], edgeIndices: number[]}} mesh 
 * @param {number} bitsPerBucket 
 * @param {boolean} checkResult 
 * 
 * @returns {{positionsCompressed: number[], indices: number[], edgeIndices: number[]}[]}
 */function rebucketPositions(mesh,bitsPerBucket){var checkResult=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var positionsCompressed=mesh.positionsCompressed||[];var indices=preSortIndices(mesh.indices||[],bitsPerBucket);var edgeIndices=preSortEdgeIndices(mesh.edgeIndices||[]);function edgeSearch(el0,el1){// Code adapted from https://stackoverflow.com/questions/22697936/binary-search-in-javascript
if(el0>el1){var tmp=el0;el0=el1;el1=tmp;}function compare_fn(a,b){if(a!==el0){return el0-a;}if(b!==el1){return el1-b;}return 0;}var m=0;var n=(edgeIndices.length>>1)-1;while(m<=n){var k=n+m>>1;var cmp=compare_fn(edgeIndices[k*2],edgeIndices[k*2+1]);if(cmp>0){m=k+1;}else if(cmp<0){n=k-1;}else{return k;}}return-m-1;}var alreadyOutputEdgeIndices=new Int32Array(edgeIndices.length/2);alreadyOutputEdgeIndices.fill(0);var numPositions=positionsCompressed.length/3;if(numPositions>(1<<bitsPerBucket)*MAX_RE_BUCKET_FAN_OUT){return[mesh];}var bucketIndicesRemap=new Int32Array(numPositions);bucketIndicesRemap.fill(-1);var buckets=[];function addEmptyBucket(){bucketIndicesRemap.fill(-1);var newBucket={positionsCompressed:[],indices:[],edgeIndices:[],maxNumPositions:(1<<bitsPerBucket)-bitsPerBucket,numPositions:0,bucketNumber:buckets.length};buckets.push(newBucket);return newBucket;}var currentBucket=addEmptyBucket();for(var _i392=0,len=indices.length;_i392<len;_i392+=3){var additonalPositionsInBucket=0;var ii0=indices[_i392];var ii1=indices[_i392+1];var ii2=indices[_i392+2];if(bucketIndicesRemap[ii0]===-1){additonalPositionsInBucket++;}if(bucketIndicesRemap[ii1]===-1){additonalPositionsInBucket++;}if(bucketIndicesRemap[ii2]===-1){additonalPositionsInBucket++;}if(additonalPositionsInBucket+currentBucket.numPositions>currentBucket.maxNumPositions){currentBucket=addEmptyBucket();}if(currentBucket.bucketNumber>MAX_RE_BUCKET_FAN_OUT){return[mesh];}if(bucketIndicesRemap[ii0]===-1){bucketIndicesRemap[ii0]=currentBucket.numPositions++;currentBucket.positionsCompressed.push(positionsCompressed[ii0*3]);currentBucket.positionsCompressed.push(positionsCompressed[ii0*3+1]);currentBucket.positionsCompressed.push(positionsCompressed[ii0*3+2]);}if(bucketIndicesRemap[ii1]===-1){bucketIndicesRemap[ii1]=currentBucket.numPositions++;currentBucket.positionsCompressed.push(positionsCompressed[ii1*3]);currentBucket.positionsCompressed.push(positionsCompressed[ii1*3+1]);currentBucket.positionsCompressed.push(positionsCompressed[ii1*3+2]);}if(bucketIndicesRemap[ii2]===-1){bucketIndicesRemap[ii2]=currentBucket.numPositions++;currentBucket.positionsCompressed.push(positionsCompressed[ii2*3]);currentBucket.positionsCompressed.push(positionsCompressed[ii2*3+1]);currentBucket.positionsCompressed.push(positionsCompressed[ii2*3+2]);}currentBucket.indices.push(bucketIndicesRemap[ii0]);currentBucket.indices.push(bucketIndicesRemap[ii1]);currentBucket.indices.push(bucketIndicesRemap[ii2]);// Check possible edge1
var edgeIndex=void 0;if((edgeIndex=edgeSearch(ii0,ii1))>=0){if(alreadyOutputEdgeIndices[edgeIndex]===0){alreadyOutputEdgeIndices[edgeIndex]=1;currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex*2]]);currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex*2+1]]);}}if((edgeIndex=edgeSearch(ii0,ii2))>=0){if(alreadyOutputEdgeIndices[edgeIndex]===0){alreadyOutputEdgeIndices[edgeIndex]=1;currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex*2]]);currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex*2+1]]);}}if((edgeIndex=edgeSearch(ii1,ii2))>=0){if(alreadyOutputEdgeIndices[edgeIndex]===0){alreadyOutputEdgeIndices[edgeIndex]=1;currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex*2]]);currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex*2+1]]);}}}var prevBytesPerIndex=bitsPerBucket/8*2;var newBytesPerIndex=bitsPerBucket/8;var originalSize=positionsCompressed.length*2+(indices.length+edgeIndices.length)*prevBytesPerIndex;var newSize=0;var newPositions=-positionsCompressed.length/3;buckets.forEach(function(bucket){newSize+=bucket.positionsCompressed.length*2+(bucket.indices.length+bucket.edgeIndices.length)*newBytesPerIndex;newPositions+=bucket.positionsCompressed.length/3;});if(newSize>originalSize){return[mesh];}if(checkResult){doCheckResult(buckets,mesh);}return buckets;}function doCheckResult(buckets,mesh){var meshDict={};var edgesDict={};var edgeIndicesCount=0;buckets.forEach(function(bucket){var indices=bucket.indices;var edgeIndices=bucket.edgeIndices;var positionsCompressed=bucket.positionsCompressed;for(var _i393=0,len=indices.length;_i393<len;_i393+=3){var key=positionsCompressed[indices[_i393]*3]+"_"+positionsCompressed[indices[_i393]*3+1]+"_"+positionsCompressed[indices[_i393]*3+2]+"/"+positionsCompressed[indices[_i393+1]*3]+"_"+positionsCompressed[indices[_i393+1]*3+1]+"_"+positionsCompressed[indices[_i393+1]*3+2]+"/"+positionsCompressed[indices[_i393+2]*3]+"_"+positionsCompressed[indices[_i393+2]*3+1]+"_"+positionsCompressed[indices[_i393+2]*3+2];meshDict[key]=true;}edgeIndicesCount+=bucket.edgeIndices.length/2;for(var _i394=0,_len84=edgeIndices.length;_i394<_len84;_i394+=2){var _key5=positionsCompressed[edgeIndices[_i394]*3]+"_"+positionsCompressed[edgeIndices[_i394]*3+1]+"_"+positionsCompressed[edgeIndices[_i394]*3+2]+"/"+positionsCompressed[edgeIndices[_i394+1]*3]+"_"+positionsCompressed[edgeIndices[_i394+1]*3+1]+"_"+positionsCompressed[edgeIndices[_i394+1]*3+2]+"/";edgesDict[_key5]=true;}});{var indices=mesh.indices;mesh.edgeIndices;var positionsCompressed=mesh.positionsCompressed;for(var _i395=0,len=indices.length;_i395<len;_i395+=3){var key=positionsCompressed[indices[_i395]*3]+"_"+positionsCompressed[indices[_i395]*3+1]+"_"+positionsCompressed[indices[_i395]*3+2]+"/"+positionsCompressed[indices[_i395+1]*3]+"_"+positionsCompressed[indices[_i395+1]*3+1]+"_"+positionsCompressed[indices[_i395+1]*3+2]+"/"+positionsCompressed[indices[_i395+2]*3]+"_"+positionsCompressed[indices[_i395+2]*3+1]+"_"+positionsCompressed[indices[_i395+2]*3+2];if(!(key in meshDict)){console.log("Not found "+key);throw"Ohhhh!";}}//  for (var i = 0, len = edgeIndices.length; i < len; i+=2)
//  {
//      var key = positionsCompressed[edgeIndices[i]*3] + "_" + positionsCompressed[edgeIndices[i]*3+1] + "_" + positionsCompressed[edgeIndices[i]*3+2] + "/" +
//                positionsCompressed[edgeIndices[i+1]*3] + "_" + positionsCompressed[edgeIndices[i+1]*3+1] + "_" + positionsCompressed[edgeIndices[i+1]*3+2] + "/";
//      if (!(key in edgesDict)) {
//          var key2 = edgeIndices[i] + "_" + edgeIndices[i+1];
//          console.log ("   - Not found " + key);
//          console.log ("   - Not found " + key2);
//         //  throw "Ohhhh2!";
//      }
//  }
}}var angleAxis=math.vec4(4);var q1=math.vec4();var q2=math.vec4();var xAxis=math.vec3([1,0,0]);var yAxis=math.vec3([0,1,0]);var zAxis=math.vec3([0,0,1]);math.vec3(3);math.vec3(3);var identityMat=math.identityMat4();/**
 * A dynamically-updatable transform within a {@link SceneModel}.
 *
 * * Can be composed into hierarchies
 * * Shared by multiple {@link SceneModelMesh}es
 * * Created with {@link SceneModel#createTransform}
 * * Stored by ID in {@link SceneModel#transforms}
 * * Referenced by {@link SceneModelMesh#transform}
 */var SceneModelTransform=/*#__PURE__*/function(){/**
     * @private
     */function SceneModelTransform(cfg){_classCallCheck(this,SceneModelTransform);this._model=cfg.model;/**
         * Unique ID of this SceneModelTransform.
         *
         * The SceneModelTransform is registered against this ID in {@link SceneModel#transforms}.
         */this.id=cfg.id;this._parentTransform=cfg.parent;this._childTransforms=[];this._meshes=[];this._scale=new Float32Array([1,1,1]);this._quaternion=math.identityQuaternion(new Float32Array(4));this._rotation=new Float32Array(3);this._position=new Float32Array(3);this._localMatrix=math.identityMat4(new Float32Array(16));this._worldMatrix=math.identityMat4(new Float32Array(16));this._localMatrixDirty=true;this._worldMatrixDirty=true;if(cfg.matrix){this.matrix=cfg.matrix;}else{this.scale=cfg.scale;this.position=cfg.position;if(cfg.quaternion);else{this.rotation=cfg.rotation;}}if(cfg.parent){cfg.parent._addChildTransform(this);}}_createClass(SceneModelTransform,[{key:"_addChildTransform",value:function _addChildTransform(childTransform){this._childTransforms.push(childTransform);childTransform._parentTransform=this;childTransform._setWorldMatrixDirty();childTransform._setAABBDirty();}},{key:"_addMesh",value:function _addMesh(mesh){this._meshes.push(mesh);mesh.transform=this;// childTransform._setWorldMatrixDirty();
// childTransform._setAABBDirty();
}/**
     * The optional parent SceneModelTransform.
     *
     * @type {SceneModelTransform}
     */},{key:"parentTransform",get:function get(){return this._parentTransform;}/**
     * The {@link SceneModelMesh}es transformed by this SceneModelTransform.
     *
     * @returns {[]}
     */},{key:"meshes",get:function get(){return this._meshes;}/**
     * Sets the SceneModelTransform's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */},{key:"position",get:/**
     * Gets the SceneModelTransform's translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */function get(){return this._position;}/**
     * Sets the SceneModelTransform's rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._position.set(value||[0,0,0]);this._setLocalMatrixDirty();this._model.glRedraw();}},{key:"rotation",get:/**
     * Gets the SceneModelTransform's rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */function get(){return this._rotation;}/**
     * Sets the SceneModelTransform's rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._rotation.set(value||[0,0,0]);math.eulerToQuaternion(this._rotation,"XYZ",this._quaternion);this._setLocalMatrixDirty();this._model.glRedraw();}},{key:"quaternion",get:/**
     * Gets the SceneModelTransform's rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */function get(){return this._quaternion;}/**
     * Sets the SceneModelTransform's scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._quaternion.set(value||[0,0,0,1]);math.quaternionToEuler(this._quaternion,"XYZ",this._rotation);this._setLocalMatrixDirty();this._model.glRedraw();}},{key:"scale",get:/**
     * Gets the SceneModelTransform's scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */function get(){return this._scale;}/**
     * Sets the SceneModelTransform's transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._scale.set(value||[1,1,1]);this._setLocalMatrixDirty();this._model.glRedraw();}},{key:"matrix",get:/**
     * Gets the SceneModelTransform's transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */function get(){if(this._localMatrixDirty){if(!this._localMatrix){this._localMatrix=math.identityMat4();}math.composeMat4(this._position,this._quaternion,this._scale,this._localMatrix);this._localMatrixDirty=false;}return this._localMatrix;}/**
     * Gets the SceneModelTransform's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */,set:function set(value){if(!this._localMatrix){this._localMatrix=math.identityMat4();}this._localMatrix.set(value||identityMat);math.decomposeMat4(this._localMatrix,this._position,this._quaternion,this._scale);this._localMatrixDirty=false;this._transformDirty();this._model.glRedraw();}},{key:"worldMatrix",get:function get(){if(this._worldMatrixDirty){this._buildWorldMatrix();}return this._worldMatrix;}/**
     * Rotates the SceneModelTransform about the given axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotate",value:function rotate(axis,angle){angleAxis[0]=axis[0];angleAxis[1]=axis[1];angleAxis[2]=axis[2];angleAxis[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis,q1);math.mulQuaternions(this.quaternion,q1,q2);this.quaternion=q2;this._setLocalMatrixDirty();this._model.glRedraw();return this;}/**
     * Rotates the SceneModelTransform about the given World-space axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateOnWorldAxis",value:function rotateOnWorldAxis(axis,angle){angleAxis[0]=axis[0];angleAxis[1]=axis[1];angleAxis[2]=axis[2];angleAxis[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis,q1);math.mulQuaternions(q1,this.quaternion,q1);//this.quaternion.premultiply(q1);
return this;}/**
     * Rotates the SceneModelTransform about the local X-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateX",value:function rotateX(angle){return this.rotate(xAxis,angle);}/**
     * Rotates the SceneModelTransform about the local Y-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateY",value:function rotateY(angle){return this.rotate(yAxis,angle);}/**
     * Rotates the SceneModelTransform about the local Z-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */},{key:"rotateZ",value:function rotateZ(angle){return this.rotate(zAxis,angle);}/**
     * Translates the SceneModelTransform along the local axis by the given increment.
     *
     * @param {Number[]} axis Normalized local space 3D vector along which to translate.
     * @param {Number} distance Distance to translate along  the vector.
     */},{key:"translate",value:function translate(axis){this._position[0]+=axis[0];this._position[1]+=axis[1];this._position[2]+=axis[2];this._setLocalMatrixDirty();this._model.glRedraw();return this;}/**
     * Translates the SceneModelTransform along the local X-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the X-axis.
     */},{key:"translateX",value:function translateX(distance){this._position[0]+=distance;this._setLocalMatrixDirty();this._model.glRedraw();return this;}/**
     * Translates the SceneModelTransform along the local Y-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Y-axis.
     */},{key:"translateY",value:function translateY(distance){this._position[1]+=distance;this._setLocalMatrixDirty();this._model.glRedraw();return this;}/**
     * Translates the SceneModelTransform along the local Z-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Z-axis.
     */},{key:"translateZ",value:function translateZ(distance){this._position[2]+=distance;this._setLocalMatrixDirty();this._model.glRedraw();return this;}},{key:"_setLocalMatrixDirty",value:function _setLocalMatrixDirty(){this._localMatrixDirty=true;this._transformDirty();}},{key:"_transformDirty",value:function _transformDirty(){this._worldMatrixDirty=true;for(var _i396=0,len=this._childTransforms.length;_i396<len;_i396++){var childTransform=this._childTransforms[_i396];childTransform._transformDirty();if(childTransform._meshes&&childTransform._meshes.length>0){var meshes=childTransform._meshes;for(var j=0,lenj=meshes.length;j<lenj;j++){meshes[j]._transformDirty();}}}if(this._meshes&&this._meshes.length>0){var _meshes=this._meshes;for(var _j3=0,_lenj2=_meshes.length;_j3<_lenj2;_j3++){_meshes[_j3]._transformDirty();}}}},{key:"_buildWorldMatrix",value:function _buildWorldMatrix(){var localMatrix=this.matrix;if(!this._parentTransform){for(var _i397=0,len=localMatrix.length;_i397<len;_i397++){this._worldMatrix[_i397]=localMatrix[_i397];}}else{math.mulMat4(this._parentTransform.worldMatrix,localMatrix,this._worldMatrix);}this._worldMatrixDirty=false;}},{key:"_setSubtreeAABBsDirty",value:function _setSubtreeAABBsDirty(sceneTransform){sceneTransform._aabbDirty=true;if(sceneTransform._childTransforms){for(var _i398=0,len=sceneTransform._childTransforms.length;_i398<len;_i398++){this._setSubtreeAABBsDirty(sceneTransform._childTransforms[_i398]);}}}}]);return SceneModelTransform;}();var tempVec3a$a=math.vec3();var tempOBB3=math.OBB3();var DEFAULT_SCALE=math.vec3([1,1,1]);var DEFAULT_POSITION=math.vec3([0,0,0]);var DEFAULT_ROTATION=math.vec3([0,0,0]);var DEFAULT_QUATERNION=math.identityQuaternion();var DEFAULT_MATRIX=math.identityMat4();var DEFAULT_COLOR_TEXTURE_ID="defaultColorTexture";var DEFAULT_METAL_ROUGH_TEXTURE_ID="defaultMetalRoughTexture";var DEFAULT_NORMALS_TEXTURE_ID="defaultNormalsTexture";var DEFAULT_EMISSIVE_TEXTURE_ID="defaultEmissiveTexture";var DEFAULT_OCCLUSION_TEXTURE_ID="defaultOcclusionTexture";var DEFAULT_TEXTURE_SET_ID="defaultTextureSet";var defaultCompressedColor=new Uint8Array([255,255,255]);var VBO_INSTANCED=0;var VBO_BATCHED=1;var DTX=2;/**
 * @desc A high-performance model representation for efficient rendering and low memory usage.
 *
 * # Examples
 *
 * Internally, SceneModel uses a combination of several different techniques to render and represent
 * the different parts of a typical model. Each of the live examples at these links is designed to "unit test" one of these
 * techniques, in isolation. If some bug occurs in SceneModel, we use these tests to debug, but they also
 * serve to demonstrate how to use the capabilities of SceneModel programmatically.
 *
 * * [Loading building models into SceneModels](/examples/buildings)
 * * [Loading city models into SceneModels](/examples/cities)
 * * [Loading LiDAR scans into SceneModels](/examples/lidar)
 * * [Loading CAD models into SceneModels](/examples/cad)
 * * [SceneModel feature tests](/examples/scenemodel)
 *
 * # Overview
 *
 * While xeokit's standard [scene graph](https://github.com/xeokit/xeokit-sdk/wiki/Scene-Graphs) is great for gizmos and medium-sized models, it doesn't scale up to millions of objects in terms of memory and rendering efficiency.
 *
 * For huge models, we have the ````SceneModel```` representation, which is optimized to pack large amounts of geometry into memory and render it efficiently using WebGL.
 *
 * ````SceneModel```` is the default model representation loaded by  (at least) {@link GLTFLoaderPlugin}, {@link XKTLoaderPlugin} and  {@link WebIFCLoaderPlugin}.
 *
 * In this tutorial you'll learn how to use ````SceneModel```` to create high-detail content programmatically. Ordinarily you'd be learning about ````SceneModel```` if you were writing your own model loader plugins.
 *
 * # Contents
 *
 * - [SceneModel](#DataTextureSceneModel)
 * - [GPU-Resident Geometry](#gpu-resident-geometry)
 * - [Picking](#picking)
 * - [Example 1: Geometry Instancing](#example-1--geometry-instancing)
 * - [Finalizing a SceneModel](#finalizing-a-DataTextureSceneModel)
 * - [Finding Entities](#finding-entities)
 * - [Example 2: Geometry Batching](#example-2--geometry-batching)
 * - [Classifying with Metadata](#classifying-with-metadata)
 * - [Querying Metadata](#querying-metadata)
 * - [Metadata Structure](#metadata-structure)
 * - [RTC Coordinates](#rtc-coordinates-for-double-precision)
 *   - [Example 3: RTC Coordinates with Geometry Instancing](#example-2--rtc-coordinates-with-geometry-instancing)
 *   - [Example 4: RTC Coordinates with Geometry Batching](#example-2--rtc-coordinates-with-geometry-batching)
 *
 * ## SceneModel
 *
 * ````SceneModel```` uses two rendering techniques internally:
 *
 * 1. ***Geometry batching*** for unique geometries, combining those into a single WebGL geometry buffer, to render in one draw call, and
 * 2. ***geometry instancing*** for geometries that are shared by multiple meshes, rendering all instances of each shared geometry in one draw call.
 *
 * <br>
 * These techniques come with certain limitations:
 *
 * * Non-realistic rendering - while scene graphs can use xeokit's full set of material workflows, ````SceneModel```` uses simple Lambertian shading without textures.
 * * Static transforms - transforms within a ````SceneModel```` are static and cannot be dynamically translated, rotated and scaled the way {@link Node}s and {@link Mesh}es in scene graphs can.
 * * Immutable model representation - while scene graph {@link Node}s and
 * {@link Mesh}es can be dynamically plugged together, ````SceneModel```` is immutable,
 * since it packs its geometries into buffers and instanced arrays.
 *
 * ````SceneModel````'s API allows us to exploit batching and instancing, while exposing its elements as
 * abstract {@link Entity} types.
 *
 * {@link Entity} is the abstract base class for
 * the various xeokit components that represent models, objects, or anonymous visible elements. An Entity has a unique ID and can be
 * individually shown, hidden, selected, highlighted, ghosted, culled, picked and clipped, and has its own World-space boundary.
 *
 * * A ````SceneModel```` is an {@link Entity} that represents a model.
 * * A ````SceneModel```` represents each of its objects with an {@link Entity}.
 * * Each {@link Entity} has one or more meshes that define its shape.
 * * Each mesh has either its own unique geometry, or shares a geometry with other meshes.
 *
 * ## GPU-Resident Geometry
 *
 * For a low memory footprint, ````SceneModel```` stores its geometries in GPU memory only, compressed (quantized) as integers. Unfortunately, GPU-resident geometry is
 * not readable by JavaScript.
 *
 *
 * ## Example 1: Geometry Instancing
 *
 * In the example below, we'll use a ````SceneModel````
 * to build a simple table model using geometry instancing.
 *
 * We'll start by adding a reusable box-shaped geometry to our ````SceneModel````.
 *
 * Then, for each object in our model we'll add an {@link Entity}
 * that has a mesh that instances our box geometry, transforming and coloring the instance.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneModel_instancing)
 *
 * ````javascript
 * import {Viewer, SceneModel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * // Build a SceneModel representing a table
 * // with four legs, using geometry instancing
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *     id: "table",
 *     isModel: true, // <--- Registers SceneModel in viewer.scene.models
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * // Create a reusable geometry within the SceneModel
 * // We'll instance this geometry by five meshes
 *
 * sceneModel.createGeometry({
 *
 *     id: "myBoxGeometry",
 *
 *     // The primitive type - allowed values are "points", "lines" and "triangles".
 *     // See the OpenGL/WebGL specification docs
 *     // for how the coordinate arrays are supposed to be laid out.
 *     primitive: "triangles",
 *
 *     // The vertices - eight for our cube, each
 *     // one spanning three array elements for X,Y and Z
 *     positions: [
 *          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
 *          1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v1 right
 *          1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v1-v6-v1 top
 *          -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
 *          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // v7-v4-v3-v2 bottom
 *          1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v1 back
 *     ],
 *
 *     // Normal vectors, one for each vertex
 *     normals: [
 *         0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v1-v2-v3 front
 *         1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right
 *         0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v0-v5-v6-v1 top
 *         -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v1-v6-v7-v2 left
 *         0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v7-v4-v3-v2 bottom
 *         0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 // v4-v7-v6-v5 back
 *     ],
 *
 *     // Indices - these organise the positions and and normals
 *     // into geometric primitives in accordance with the "primitive" parameter,
 *     // in this case a set of three indices for each triangle.
 *     //
 *     // Note that each triangle is specified in counter-clockwise winding order.
 *     //
 *     indices: [
 *         0, 1, 2, 0, 2, 3, // front
 *         4, 5, 6, 4, 6, 7, // right
 *         8, 9, 10, 8, 10, 11, // top
 *         12, 13, 14, 12, 14, 15, // left
 *         16, 17, 18, 16, 18, 19, // bottom
 *         20, 21, 22, 20, 22, 23
 *     ]
 * });
 *
 * // Red table leg
 *
 * sceneModel.createMesh({
 *     id: "redLegMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: "redLeg",
 *     meshIds: ["redLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Green table leg
 *
 * sceneModel.createMesh({
 *     id: "greenLegMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: "greenLeg",
 *     meshIds: ["greenLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Blue table leg
 *
 * sceneModel.createMesh({
 *     id: "blueLegMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: "blueLeg",
 *     meshIds: ["blueLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Yellow table leg
 *
 * sceneModel.createMesh({
 *      id: "yellowLegMesh",
 *      geometryId: "myBoxGeometry",
 *      position: [-4, -6, 4],
 *      scale: [1, 3, 1],
 *      rotation: [0, 0, 0],
 *      color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: "yellowLeg",
 *     meshIds: ["yellowLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Purple table top
 *
 * sceneModel.createMesh({
 *     id: "purpleTableTopMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: "purpleTableTop",
 *     meshIds: ["purpleTableTopMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *  ````
 *
 * ## Finalizing a SceneModel
 *
 * Before we can view and interact with our ````SceneModel````, we need to **finalize** it. Internally, this causes the ````SceneModel```` to build the
 * vertex buffer objects (VBOs) that support our geometry instances. When using geometry batching (see next example),
 * this causes ````SceneModel```` to build the VBOs that combine the batched geometries. Note that you can do both instancing and
 * batching within the same ````SceneModel````.
 *
 * Once finalized, we can't add anything more to our ````SceneModel````.
 *
 * ```` javascript
 * SceneModel.finalize();
 * ````
 *
 * ## Finding Entities
 *
 * As mentioned earlier, {@link Entity} is
 * the abstract base class for components that represent models, objects, or just
 * anonymous visible elements.
 *
 * Since we created configured our ````SceneModel```` with ````isModel: true````,
 * we're able to find it as an Entity by ID in ````viewer.scene.models````. Likewise, since
 * we configured each of its Entities with ````isObject: true````, we're able to
 * find them in  ````viewer.scene.objects````.
 *
 *
 * ````javascript
 * // Get the whole table model Entity
 * const table = viewer.scene.models["table"];
 *
 *  // Get some leg object Entities
 * const redLeg = viewer.scene.objects["redLeg"];
 * const greenLeg = viewer.scene.objects["greenLeg"];
 * const blueLeg = viewer.scene.objects["blueLeg"];
 * ````
 *
 * ## Example 2: Geometry Batching
 *
 * Let's once more use a ````SceneModel````
 * to build the simple table model, this time exploiting geometry batching.
 *
 *  [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneModel_batching)
 *
 * ````javascript
 * import {Viewer, SceneModel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * // Create a SceneModel representing a table with four legs, using geometry batching
 * const sceneModel = new SceneModel(viewer.scene, {
 *     id: "table",
 *     isModel: true,  // <--- Registers SceneModel in viewer.scene.models
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * // Red table leg
 *
 * sceneModel.createMesh({
 *     id: "redLegMesh",
 *
 *     // Geometry arrays are same as for the earlier batching example
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: "redLeg",
 *     meshIds: ["redLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Green table leg
 *
 * sceneModel.createMesh({
 *     id: "greenLegMesh",
 *     primitive: "triangles",
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     id: "greenLeg",
 *     meshIds: ["greenLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Blue table leg
 *
 * sceneModel.createMesh({
 *     id: "blueLegMesh",
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: "blueLeg",
 *     meshIds: ["blueLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Yellow table leg object
 *
 * sceneModel.createMesh({
 *     id: "yellowLegMesh",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: "yellowLeg",
 *     meshIds: ["yellowLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Purple table top
 *
 * sceneModel.createMesh({
 *     id: "purpleTableTopMesh",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     id: "purpleTableTop",
 *     meshIds: ["purpleTableTopMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Finalize the SceneModel.
 *
 * SceneModel.finalize();
 *
 * // Find BigModelNodes by their model and object IDs
 *
 * // Get the whole table model
 * const table = viewer.scene.models["table"];
 *
 * // Get some leg objects
 * const redLeg = viewer.scene.objects["redLeg"];
 * const greenLeg = viewer.scene.objects["greenLeg"];
 * const blueLeg = viewer.scene.objects["blueLeg"];
 * ````
 *
 * ## Classifying with Metadata
 *
 * In the previous examples, we used ````SceneModel```` to build
 * two versions of the same table model, to demonstrate geometry batching and geometry instancing.
 *
 * We'll now classify our {@link Entity}s with metadata. This metadata
 * will work the same for both our examples, since they create the exact same structure of {@link Entity}s
 * to represent their models and objects. The abstract Entity type is, after all, intended to provide an abstract interface through which differently-implemented scene content can be accessed uniformly.
 *
 * To create the metadata, we'll create a {@link MetaModel} for our model,
 * with a {@link MetaObject} for each of it's objects. The MetaModel and MetaObjects
 * get the same IDs as the {@link Entity}s that represent their model and objects within our scene.
 *
 * ```` javascript
 * const furnitureMetaModel = viewer.metaScene.createMetaModel("furniture", {         // Creates a MetaModel in the MetaScene
 *
 *      "projectId": "myTableProject",
 *      "revisionId": "V1.0",
 *
 *      "metaObjects": [
 *          {                               // Creates a MetaObject in the MetaModel
 *              "id": "table",
 *              "name": "Table",            // Same ID as an object Entity
 *              "type": "furniture",        // Arbitrary type, could be IFC type
 *              "properties": {             // Arbitrary properties, could be IfcPropertySet
 *                  "cost": "200"
 *              }
 *          },
 *          {
 *              "id": "redLeg",
 *              "name": "Red table Leg",
 *              "type": "leg",
 *              "parent": "table",           // References first MetaObject as parent
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "greenLeg",           // Node with corresponding id does not need to exist
 *              "name": "Green table leg",  // and MetaObject does not need to exist for Node with an id
 *              "type": "leg",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "blueLeg",
 *              "name": "Blue table leg",
 *              "type": "leg",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "yellowLeg",
 *              "name": "Yellow table leg",
 *              "type": "leg",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "tableTop",
 *              "name": "Purple table top",
 *              "type": "surface",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "formica",
 *                  "width": "60",
 *                  "depth": "60",
 *                  "thickness": "5"
 *              }
 *          }
 *      ]
 *  });
 * ````
 *
 * ## Querying Metadata
 *
 * Having created and classified our model (either the instancing or batching example), we can now find the {@link MetaModel}
 * and {@link MetaObject}s using the IDs of their
 * corresponding {@link Entity}s.
 *
 * ````JavaScript
 * const furnitureMetaModel = scene.metaScene.metaModels["furniture"];
 *
 * const redLegMetaObject = scene.metaScene.metaObjects["redLeg"];
 * ````
 *
 * In the snippet below, we'll log metadata on each {@link Entity} we click on:
 *
 * ````JavaScript
 * viewer.scene.input.on("mouseclicked", function (coords) {
 *
 *      const hit = viewer.scene.pick({
 *          canvasPos: coords
 *      });
 *
 *      if (hit) {
 *          const entity = hit.entity;
 *          const metaObject = viewer.metaScene.metaObjects[entity.id];
 *          if (metaObject) {
 *              console.log(JSON.stringify(metaObject.getJSON(), null, "\t"));
 *          }
 *      }
 *  });
 * ````
 *
 * ## Metadata Structure
 *
 * The {@link MetaModel}
 * organizes its {@link MetaObject}s in
 * a tree that describes their structural composition:
 *
 * ````JavaScript
 * // Get metadata on the root object
 * const tableMetaObject = furnitureMetaModel.rootMetaObject;
 *
 * // Get metadata on the leg objects
 * const redLegMetaObject = tableMetaObject.children[0];
 * const greenLegMetaObject = tableMetaObject.children[1];
 * const blueLegMetaObject = tableMetaObject.children[2];
 * const yellowLegMetaObject = tableMetaObject.children[3];
 * ````
 *
 * Given an {@link Entity}, we can find the object or model of which it is a part, or the objects that comprise it. We can also generate UI
 * components from the metadata, such as the tree view demonstrated in [this demo](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_glTF_OTCConferenceCenter).
 *
 * This hierarchy allows us to express the hierarchical structure of a model while representing it in
 * various ways in the 3D scene (such as with ````SceneModel````, which
 * has a non-hierarchical scene representation).
 *
 * Note also that a {@link MetaObject} does not need to have a corresponding
 * {@link Entity} and vice-versa.
 *
 * # RTC Coordinates for Double Precision
 *
 * ````SceneModel```` can emulate 64-bit precision on GPUs using relative-to-center (RTC) coordinates.
 *
 * Consider a model that contains many small objects, but with such large spatial extents that 32 bits of GPU precision (accurate to ~7 digits) will not be sufficient to render all of the the objects without jittering.
 *
 * To prevent jittering, we could spatially subdivide the objects into "tiles". Each tile would have a center position, and the positions of the objects within the tile would be relative to that center ("RTC coordinates").
 *
 * While the center positions of the tiles would be 64-bit values, the object positions only need to be 32-bit.
 *
 * Internally, when rendering an object with RTC coordinates, xeokit first temporarily translates the camera viewing matrix by the object's tile's RTC center, on the CPU, using 64-bit math.
 *
 * Then xeokit loads the viewing matrix into its WebGL shaders, where math happens at 32-bit precision. Within the shaders, the matrix is effectively down-cast to 32-bit precision, and the object's 32-bit vertex positions are transformed by the matrix.
 *
 * We see no jittering, because with RTC a detectable loss of GPU accuracy only starts happening to objects as they become very distant from the camera viewpoint, at which point they are too small to be discernible anyway.
 *
 * ## RTC Coordinates with Geometry Instancing
 *
 * To use RTC with ````SceneModel```` geometry instancing, we specify an RTC center for the geometry via its ````origin```` parameter. Then ````SceneModel```` assumes that all meshes that instance that geometry are within the same RTC coordinate system, ie. the meshes ````position```` and ````rotation```` properties are assumed to be relative to the geometry's ````origin````.
 *
 * For simplicity, our example's meshes all instance the same geometry. Therefore, our example model has only one RTC center.
 *
 * Note that the axis-aligned World-space boundary (AABB) of our model is ````[-6, -9, -6, 1000000006, -2.5, 1000000006]````.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneModel_batching)
 *
 * ````javascript
 * const origin = [100000000, 0, 100000000];
 *
 * sceneModel.createGeometry({
 *     id: "box",
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg1",
 *     geometryId: "box",
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg1"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg2",
 *     geometryId: "box",
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg2"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg3",
 *     geometryId: "box",
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg3"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg4",
 *     geometryId: "box",
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg4"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "top",
 *     geometryId: "box",
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0],
 *     origin: origin
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["top"],
 *     isObject: true
 * });
 * ````
 *
 * ## RTC Coordinates with Geometry Batching
 *
 * To use RTC with ````SceneModel```` geometry batching, we specify an RTC center (````origin````) for each mesh. For performance, we try to have as many meshes share the same value for ````origin```` as possible. Each mesh's ````positions````, ````position```` and ````rotation```` properties are assumed to be relative to ````origin````.
 *
 * For simplicity, the meshes in our example all share the same RTC center.
 *
 * The axis-aligned World-space boundary (AABB) of our model is ````[-6, -9, -6, 1000000006, -2.5, 1000000006]````.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneModel_batching)
 *
 * ````javascript
 * const origin = [100000000, 0, 100000000];
 *
 * sceneModel.createMesh({
 *     id: "leg1",
 *     origin: origin, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg1"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg2",
 *     origin: origin, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg2"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg3",
 *     origin: origin, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg3"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg4",
 *     origin: origin, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg4"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "top",
 *     origin: origin, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["top"],
 *     isObject: true
 * });
 * ````
 *
 * ## Positioning at World-space coordinates
 *
 * To position a SceneModel at given double-precision World coordinates, we can
 * configure the ````origin```` of the SceneModel itself. The ````origin```` is a double-precision
 * 3D World-space position at which the SceneModel will be located.
 *
 * Note that ````position```` is a single-precision offset relative to ````origin````.
 *
 * ````javascript
 * const origin = [100000000, 0, 100000000];
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *     id: "table",
 *     isModel: true,
 *     origin: origin, // Everything in this SceneModel is relative to this RTC center
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * sceneModel.createGeometry({
 *     id: "box",
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg1",
 *     geometryId: "box",
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg1"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg2",
 *     geometryId: "box",
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg2"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg3",
 *     geometryId: "box",
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg3"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "leg4",
 *     geometryId: "box",
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["leg4"],
 *     isObject: true
 * });
 *
 * sceneModel.createMesh({
 *     id: "top",
 *     geometryId: "box",
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * sceneModel.createEntity({
 *     meshIds: ["top"],
 *     isObject: true
 * });
 * ````
 *
 * # Textures
 *
 * ## Loading KTX2 Texture Files into a SceneModel
 *
 * A {@link SceneModel} that is configured with a {@link KTX2TextureTranscoder} will
 * allow us to load textures into it from KTX2 buffers or files.
 *
 * In the example below, we'll create a {@link Viewer}, containing a {@link SceneModel} configured with a
 * {@link KTX2TextureTranscoder}. We'll then programmatically create a simple object within the SceneModel, consisting of
 * a single mesh with a texture loaded from a KTX2 file, which our SceneModel internally transcodes, using
 * its {@link KTX2TextureTranscoder}. Note how we configure our {@link KTX2TextureTranscoder} with a path to the Basis Universal
 * transcoder WASM module.
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/" // <------ Path to BasisU transcoder module
 * });
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *      id: "myModel",
 *      textureTranscoder // <<-------------------- Configure model with our transcoder
 *  });
 *
 * sceneModel.createTexture({
 *      id: "myColorTexture",
 *      src: "../assets/textures/compressed/sample_uastc_zstd.ktx2" // <<----- KTX2 texture asset
 * });
 *
 * sceneModel.createTexture({
 *      id: "myMetallicRoughnessTexture",
 *      src: "../assets/textures/alpha/crosshatchAlphaMap.jpg" // <<----- JPEG texture asset
 * });
 *
 * sceneModel.createTextureSet({
 *      id: "myTextureSet",
 *      colorTextureId: "myColorTexture",
 *      metallicRoughnessTextureId: "myMetallicRoughnessTexture"
 *  });
 *
 * sceneModel.createMesh({
 *      id: "myMesh",
 *      textureSetId: "myTextureSet",
 *      primitive: "triangles",
 *      positions: [1, 1, 1, ...],
 *      normals: [0, 0, 1, 0, ...],
 *      uv: [1, 0, 0, ...],
 *      indices: [0, 1, 2, ...],
 *  });
 *
 * sceneModel.createEntity({
 *      id: "myEntity",
 *      meshIds: ["myMesh"]
 *  });
 *
 * sceneModel.finalize();
 * ````
 *
 * ## Loading KTX2 Textures from ArrayBuffers into a SceneModel
 *
 * A SceneModel that is configured with a {@link KTX2TextureTranscoder} will allow us to load textures into
 * it from KTX2 ArrayBuffers.
 *
 * In the example below, we'll create a {@link Viewer}, containing a {@link SceneModel} configured with a
 * {@link KTX2TextureTranscoder}. We'll then programmatically create a simple object within the SceneModel, consisting of
 * a single mesh with a texture loaded from a KTX2 ArrayBuffer, which our SceneModel internally transcodes, using
 * its {@link KTX2TextureTranscoder}.
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/" // <------ Path to BasisU transcoder module
 * });
 *
 * const sceneModel = new SceneModel(viewer.scene, {
 *      id: "myModel",
 *      textureTranscoder // <<-------------------- Configure model with our transcoder
 * });
 *
 * utils.loadArraybuffer("../assets/textures/compressed/sample_uastc_zstd.ktx2",(arrayBuffer) => {
 *
 *     sceneModel.createTexture({
 *         id: "myColorTexture",
 *         buffers: [arrayBuffer] // <<----- KTX2 texture asset
 *     });
 *
 *     sceneModel.createTexture({
 *         id: "myMetallicRoughnessTexture",
 *         src: "../assets/textures/alpha/crosshatchAlphaMap.jpg" // <<----- JPEG texture asset
 *     });
 *
 *     sceneModel.createTextureSet({
 *        id: "myTextureSet",
 *        colorTextureId: "myColorTexture",
 *        metallicRoughnessTextureId: "myMetallicRoughnessTexture"
 *     });
 *
 *     sceneModel.createMesh({
 *          id: "myMesh",
 *          textureSetId: "myTextureSet",
 *          primitive: "triangles",
 *          positions: [1, 1, 1, ...],
 *          normals: [0, 0, 1, 0, ...],
 *          uv: [1, 0, 0, ...],
 *          indices: [0, 1, 2, ...],
 *     });
 *
 *     sceneModel.createEntity({
 *         id: "myEntity",
 *         meshIds: ["myMesh"]
 *     });
 *
 *     sceneModel.finalize();
 * });
 * ````
 *
 * @implements {Entity}
 */var SceneModel=/*#__PURE__*/function(_Component27){_inherits(SceneModel,_Component27);var _super112=_createSuper(SceneModel);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent scene, generated automatically when omitted.
     * @param {Boolean} [cfg.isModel] Specify ````true```` if this SceneModel represents a model, in which case the SceneModel will be registered by {@link SceneModel#id} in {@link Scene#models} and may also have a corresponding {@link MetaModel} with matching {@link MetaModel#id}, registered by that ID in {@link MetaScene#metaModels}.
     * @param {Number[]} [cfg.origin=[0,0,0]] World-space double-precision 3D origin.
     * @param {Number[]} [cfg.position=[0,0,0]] Local, single-precision 3D position, relative to the origin parameter.
     * @param {Number[]} [cfg.scale=[1,1,1]] Local scale.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1] Local modelling transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [cfg.visible=true] Indicates if the SceneModel is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the SceneModel is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the SceneModel is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the SceneModel is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the SceneModel is initially included in boundary calculations.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the SceneModel is initially xrayed.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the SceneModel is initially highlighted.
     * @param {Boolean} [cfg.selected=false] Indicates if the SceneModel is initially selected.
     * @param {Boolean} [cfg.edges=false] Indicates if the SceneModel's edges are initially emphasized.
     * @param {Number[]} [cfg.colorize=[1.0,1.0,1.0]] SceneModel's initial RGB colorize color, multiplies by the rendered fragment colors.
     * @param {Number} [cfg.opacity=1.0] SceneModel's initial opacity factor, multiplies by the rendered fragment alpha.
     * @param {Number} [cfg.backfaces=false] When we set this ````true````, then we force rendering of backfaces for this SceneModel. When
     * we leave this ````false````, then we allow the Viewer to decide when to render backfaces. In that case, the
     * Viewer will hide backfaces on watertight meshes, show backfaces on open meshes, and always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     * @param {Boolean} [cfg.saoEnabled=true] Indicates if Scalable Ambient Obscurance (SAO) will apply to this SceneModel. SAO is configured by the Scene's {@link SAO} component.
     * @param {Boolean} [cfg.pbrEnabled=true] Indicates if physically-based rendering (PBR) will apply to the SceneModel when {@link Scene#pbrEnabled} is ````true````.
     * @param {Boolean} [cfg.colorTextureEnabled=true] Indicates if base color textures will be rendered for the SceneModel when {@link Scene#colorTextureEnabled} is ````true````.
     * @param {Number} [cfg.edgeThreshold=10] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Number} [cfg.maxGeometryBatchSize=50000000] Maximum geometry batch size, as number of vertices. This is optionally supplied
     * to limit the size of the batched geometry arrays that SceneModel internally creates for batched geometries.
     * A lower value means less heap allocation/de-allocation while creating/loading batched geometries, but more draw calls and
     * slower rendering speed. A high value means larger heap allocation/de-allocation while creating/loading, but less draw calls
     * and faster rendering speed. It's recommended to keep this somewhere roughly between ````50000```` and ````50000000```.
     * @param {TextureTranscoder} [cfg.textureTranscoder] Transcoder that will be used internally by {@link SceneModel#createTexture}
     * to convert transcoded texture data. Only required when we'll be providing transcoded data
     * to {@link SceneModel#createTexture}. We assume that all transcoded texture data added to a  ````SceneModel````
     * will then in a format supported by this transcoder.
     * @param {Boolean} [cfg.dtxEnabled=true] When ````true```` (default) use data textures (DTX), where appropriate, to
     * represent the returned model. Set false to always use vertex buffer objects (VBOs). Note that DTX is only applicable
     * to non-textured triangle meshes, and that VBOs are always used for meshes that have textures, line segments, or point
     * primitives. Only works while {@link DTX#enabled} is also ````true````.
     */function SceneModel(owner){var _this74;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SceneModel);_this74=_super112.call(this,owner,cfg);_this74._dtxEnabled=_this74.scene.dtxEnabled&&cfg.dtxEnabled!==false;_this74._enableVertexWelding=false;// Not needed for most objects, and very expensive, so disabled
_this74._enableIndexBucketing=false;// Until fixed: https://github.com/xeokit/xeokit-sdk/issues/1204
_this74._vboBatchingLayerScratchMemory=getScratchMemory();_this74._textureTranscoder=cfg.textureTranscoder||getKTX2TextureTranscoder(_this74.scene.viewer);_this74._maxGeometryBatchSize=cfg.maxGeometryBatchSize;_this74._aabb=math.collapseAABB3();_this74._aabbDirty=true;_this74._quantizationRanges={};_this74._vboInstancingLayers={};_this74._vboBatchingLayers={};_this74._dtxLayers={};_this74._meshList=[];_this74.layerList=[];// For GL state efficiency when drawing, InstancingLayers are in first part, BatchingLayers are in second
_this74._entityList=[];_this74._geometries={};_this74._dtxBuckets={};// Geometries with optimizations used for data texture representation
_this74._textures={};_this74._textureSets={};_this74._transforms={};_this74._meshes={};_this74._unusedMeshes={};_this74._entities={};/** @private **/_this74.renderFlags=new RenderFlags();/**
         * @private
         */_this74.numGeometries=0;// Number of geometries created with createGeometry()
// These counts are used to avoid unnecessary render passes
// They are incremented or decremented exclusively by BatchingLayer and InstancingLayer
/**
         * @private
         */_this74.numPortions=0;/**
         * @private
         */_this74.numVisibleLayerPortions=0;/**
         * @private
         */_this74.numTransparentLayerPortions=0;/**
         * @private
         */_this74.numXRayedLayerPortions=0;/**
         * @private
         */_this74.numHighlightedLayerPortions=0;/**
         * @private
         */_this74.numSelectedLayerPortions=0;/**
         * @private
         */_this74.numEdgesLayerPortions=0;/**
         * @private
         */_this74.numPickableLayerPortions=0;/**
         * @private
         */_this74.numClippableLayerPortions=0;/**
         * @private
         */_this74.numCulledLayerPortions=0;_this74.numEntities=0;_this74._numTriangles=0;_this74._numLines=0;_this74._numPoints=0;_this74._edgeThreshold=cfg.edgeThreshold||10;// Build static matrix
_this74._origin=math.vec3(cfg.origin||[0,0,0]);_this74._position=math.vec3(cfg.position||[0,0,0]);_this74._rotation=math.vec3(cfg.rotation||[0,0,0]);_this74._quaternion=math.vec4(cfg.quaternion||[0,0,0,1]);_this74._conjugateQuaternion=math.vec4(cfg.quaternion||[0,0,0,1]);if(cfg.rotation){math.eulerToQuaternion(_this74._rotation,"XYZ",_this74._quaternion);}_this74._scale=math.vec3(cfg.scale||[1,1,1]);_this74._worldRotationMatrix=math.mat4();_this74._worldRotationMatrixConjugate=math.mat4();_this74._matrix=math.mat4();_this74._matrixDirty=true;_this74._rebuildMatrices();_this74._worldNormalMatrix=math.mat4();math.inverseMat4(_this74._matrix,_this74._worldNormalMatrix);math.transposeMat4(_this74._worldNormalMatrix);if(cfg.matrix||cfg.position||cfg.rotation||cfg.scale||cfg.quaternion){_this74._viewMatrix=math.mat4();_this74._viewNormalMatrix=math.mat4();_this74._viewMatrixDirty=true;_this74._matrixNonIdentity=true;}_this74._opacity=1.0;_this74._colorize=[1,1,1];_this74._saoEnabled=cfg.saoEnabled!==false;_this74._pbrEnabled=cfg.pbrEnabled!==false;_this74._colorTextureEnabled=cfg.colorTextureEnabled!==false;_this74._isModel=cfg.isModel;if(_this74._isModel){_this74.scene._registerModel(_assertThisInitialized(_this74));}_this74._onCameraViewMatrix=_this74.scene.camera.on("matrix",function(){_this74._viewMatrixDirty=true;});_this74._meshesWithDirtyMatrices=[];_this74._numMeshesWithDirtyMatrices=0;_this74._onTick=_this74.scene.on("tick",function(){while(_this74._numMeshesWithDirtyMatrices>0){_this74._meshesWithDirtyMatrices[--_this74._numMeshesWithDirtyMatrices]._updateMatrix();}});_this74._createDefaultTextureSet();_this74.visible=cfg.visible;_this74.culled=cfg.culled;_this74.pickable=cfg.pickable;_this74.clippable=cfg.clippable;_this74.collidable=cfg.collidable;_this74.castsShadow=cfg.castsShadow;_this74.receivesShadow=cfg.receivesShadow;_this74.xrayed=cfg.xrayed;_this74.highlighted=cfg.highlighted;_this74.selected=cfg.selected;_this74.edges=cfg.edges;_this74.colorize=cfg.colorize;_this74.opacity=cfg.opacity;_this74.backfaces=cfg.backfaces;return _this74;}_createClass(SceneModel,[{key:"_meshMatrixDirty",value:function _meshMatrixDirty(mesh){this._meshesWithDirtyMatrices[this._numMeshesWithDirtyMatrices++]=mesh;}},{key:"_createDefaultTextureSet",value:function _createDefaultTextureSet(){// Every SceneModelMesh gets at least the default TextureSet,
// which contains empty default textures filled with color
var defaultColorTexture=new SceneModelTexture({id:DEFAULT_COLOR_TEXTURE_ID,texture:new Texture2D({gl:this.scene.canvas.gl,preloadColor:[1,1,1,1]// [r, g, b, a]})
})});var defaultMetalRoughTexture=new SceneModelTexture({id:DEFAULT_METAL_ROUGH_TEXTURE_ID,texture:new Texture2D({gl:this.scene.canvas.gl,preloadColor:[0,1,1,1]// [unused, roughness, metalness, unused]
})});var defaultNormalsTexture=new SceneModelTexture({id:DEFAULT_NORMALS_TEXTURE_ID,texture:new Texture2D({gl:this.scene.canvas.gl,preloadColor:[0,0,0,0]// [x, y, z, unused] - these must be zeros
})});var defaultEmissiveTexture=new SceneModelTexture({id:DEFAULT_EMISSIVE_TEXTURE_ID,texture:new Texture2D({gl:this.scene.canvas.gl,preloadColor:[0,0,0,1]// [x, y, z, unused]
})});var defaultOcclusionTexture=new SceneModelTexture({id:DEFAULT_OCCLUSION_TEXTURE_ID,texture:new Texture2D({gl:this.scene.canvas.gl,preloadColor:[1,1,1,1]// [x, y, z, unused]
})});this._textures[DEFAULT_COLOR_TEXTURE_ID]=defaultColorTexture;this._textures[DEFAULT_METAL_ROUGH_TEXTURE_ID]=defaultMetalRoughTexture;this._textures[DEFAULT_NORMALS_TEXTURE_ID]=defaultNormalsTexture;this._textures[DEFAULT_EMISSIVE_TEXTURE_ID]=defaultEmissiveTexture;this._textures[DEFAULT_OCCLUSION_TEXTURE_ID]=defaultOcclusionTexture;this._textureSets[DEFAULT_TEXTURE_SET_ID]=new SceneModelTextureSet({id:DEFAULT_TEXTURE_SET_ID,model:this,colorTexture:defaultColorTexture,metallicRoughnessTexture:defaultMetalRoughTexture,normalsTexture:defaultNormalsTexture,emissiveTexture:defaultEmissiveTexture,occlusionTexture:defaultOcclusionTexture});}//------------------------------------------------------------------------------------------------------------------
// SceneModel members
//------------------------------------------------------------------------------------------------------------------
/**
     * Returns true to indicate that this Component is a SceneModel.
     * @type {Boolean}
     */},{key:"isPerformanceModel",get:function get(){return true;}/**
     * The {@link SceneModelTransform}s in this SceneModel.
     *
     * Each {#link SceneModelTransform} is stored here against its {@link SceneModelTransform.id}.
     *
     * @returns {*|{}}
     */},{key:"transforms",get:function get(){return this._transforms;}/**
     * The {@link SceneModelTexture}s in this SceneModel.
     *
     * * Each {@link SceneModelTexture} is created with {@link SceneModel.createTexture}.
     * * Each {@link SceneModelTexture} is stored here against its {@link SceneModelTexture.id}.
     *
     * @returns {*|{}}
     */},{key:"textures",get:function get(){return this._textures;}/**
     * The {@link SceneModelTextureSet}s in this SceneModel.
     *
     * Each {@link SceneModelTextureSet} is stored here against its {@link SceneModelTextureSet.id}.
     *
     * @returns {*|{}}
     */},{key:"textureSets",get:function get(){return this._textureSets;}/**
     * The {@link SceneModelMesh}es in this SceneModel.
     *
     * Each {@SceneModelMesh} is stored here against its {@link SceneModelMesh.id}.
     *
     * @returns {*|{}}
     */},{key:"meshes",get:function get(){return this._meshes;}/**
     * The {@link SceneModelEntity}s in this SceneModel.
     *
     * Each {#link SceneModelEntity} in this SceneModel that represents an object is
     * stored here against its {@link SceneModelTransform.id}.
     *
     * @returns {*|{}}
     */},{key:"objects",get:function get(){return this._entities;}/**
     * Gets the 3D World-space origin for this SceneModel.
     *
     * Each {@link SceneModelMesh.origin}, if supplied, is relative to this origin.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Float64Array}
     */},{key:"origin",get:function get(){return this._origin;}/**
     * Sets the SceneModel's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */},{key:"position",get:/**
     * Gets the SceneModel's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */function get(){return this._position;}/**
     * Sets the SceneModel's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._position.set(value||[0,0,0]);this._setWorldMatrixDirty();this._sceneModelDirty();this.glRedraw();}},{key:"rotation",get:/**
     * Gets the SceneModel's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */function get(){return this._rotation;}/**
     * Sets the SceneModel's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */,set:function set(value){this._rotation.set(value||[0,0,0]);math.eulerToQuaternion(this._rotation,"XYZ",this._quaternion);this._setWorldMatrixDirty();this._sceneModelDirty();this.glRedraw();}},{key:"quaternion",get:/**
     * Gets the SceneModel's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */function get(){return this._quaternion;}/**
     * Sets the SceneModel's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     * @deprecated
     */,set:function set(value){this._quaternion.set(value||[0,0,0,1]);math.quaternionToEuler(this._quaternion,"XYZ",this._rotation);this._setWorldMatrixDirty();this._sceneModelDirty();this.glRedraw();}},{key:"scale",get:/**
     * Gets the SceneModel's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     * @deprecated
     */function get(){return this._scale;}/**
     * Sets the SceneModel's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */,set:function set(value){// NOP - deprecated
}},{key:"matrix",get:/**
     * Gets the SceneModel's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */function get(){if(this._matrixDirty){this._rebuildMatrices();}return this._matrix;}/**
     * Gets the SceneModel's local modeling rotation transform matrix.
     *
     * @type {Number[]}
     */,set:function set(value){this._matrix.set(value||DEFAULT_MATRIX);math.quaternionToRotationMat4(this._quaternion,this._worldRotationMatrix);math.conjugateQuaternion(this._quaternion,this._conjugateQuaternion);math.quaternionToRotationMat4(this._quaternion,this._worldRotationMatrixConjugate);this._matrix.set(this._worldRotationMatrix);math.translateMat4v(this._position,this._matrix);this._matrixDirty=false;this._setWorldMatrixDirty();this._sceneModelDirty();this.glRedraw();}},{key:"rotationMatrix",get:function get(){if(this._matrixDirty){this._rebuildMatrices();}return this._worldRotationMatrix;}},{key:"_rebuildMatrices",value:function _rebuildMatrices(){if(this._matrixDirty){math.quaternionToRotationMat4(this._quaternion,this._worldRotationMatrix);math.conjugateQuaternion(this._quaternion,this._conjugateQuaternion);math.quaternionToRotationMat4(this._quaternion,this._worldRotationMatrixConjugate);this._matrix.set(this._worldRotationMatrix);math.translateMat4v(this._position,this._matrix);this._matrixDirty=false;}}/**
     * Gets the conjugate of the SceneModel's local modeling rotation transform matrix.
     *
     * This is used for RTC view matrix management in renderers.
     *
     * @type {Number[]}
     */},{key:"rotationMatrixConjugate",get:function get(){if(this._matrixDirty){this._rebuildMatrices();}return this._worldRotationMatrixConjugate;}},{key:"_setWorldMatrixDirty",value:function _setWorldMatrixDirty(){this._matrixDirty=true;this._aabbDirty=true;}},{key:"_transformDirty",value:function _transformDirty(){this._matrixDirty=true;this._aabbDirty=true;this.scene._aabbDirty=true;}},{key:"_sceneModelDirty",value:function _sceneModelDirty(){this.scene._aabbDirty=true;this._aabbDirty=true;this.scene._aabbDirty=true;this._matrixDirty=true;for(var _i399=0,len=this._entityList.length;_i399<len;_i399++){this._entityList[_i399]._sceneModelDirty();// Entities need to retransform their World AABBs by SceneModel's worldMatrix
}}/**
     * Gets the SceneModel's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */},{key:"worldMatrix",get:function get(){return this.matrix;}/**
     * Gets the SceneModel's World normal matrix.
     *
     * @type {Number[]}
     */},{key:"worldNormalMatrix",get:function get(){return this._worldNormalMatrix;}/**
     * Called by private renderers in ./lib, returns the view matrix with which to
     * render this SceneModel. The view matrix is the concatenation of the
     * Camera view matrix with the Performance model's world (modeling) matrix.
     *
     * @private
     */},{key:"viewMatrix",get:function get(){if(!this._viewMatrix){return this.scene.camera.viewMatrix;}if(this._matrixDirty){this._rebuildMatrices();this._viewMatrixDirty=true;}if(this._viewMatrixDirty){math.mulMat4(this.scene.camera.viewMatrix,this._matrix,this._viewMatrix);math.inverseMat4(this._viewMatrix,this._viewNormalMatrix);math.transposeMat4(this._viewNormalMatrix);this._viewMatrixDirty=false;}return this._viewMatrix;}/**
     * Called by private renderers in ./lib, returns the view normal matrix with which to render this SceneModel.
     *
     * @private
     */},{key:"viewNormalMatrix",get:function get(){if(!this._viewNormalMatrix){return this.scene.camera.viewNormalMatrix;}if(this._matrixDirty){this._rebuildMatrices();this._viewMatrixDirty=true;}if(this._viewMatrixDirty){math.mulMat4(this.scene.camera.viewMatrix,this._matrix,this._viewMatrix);math.inverseMat4(this._viewMatrix,this._viewNormalMatrix);math.transposeMat4(this._viewNormalMatrix);this._viewMatrixDirty=false;}math.inverseMat4(this._viewMatrix,this._viewNormalMatrix);math.transposeMat4(this._viewNormalMatrix);return this._viewNormalMatrix;}/**
     * Sets if backfaces are rendered for this SceneModel.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */},{key:"backfaces",get:function get(){return this._backfaces;}/**
     * Sets if backfaces are rendered for this SceneModel.
     *
     * Default is ````false````.
     *
     * When we set this ````true````, then backfaces are always rendered for this SceneModel.
     *
     * When we set this ````false````, then we allow the Viewer to decide whether to render backfaces. In this case,
     * the Viewer will:
     *
     *  * hide backfaces on watertight meshes,
     *  * show backfaces on open meshes, and
     *  * always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     *
     * @type {Boolean}
     */,set:function set(backfaces){backfaces=!!backfaces;this._backfaces=backfaces;this.glRedraw();}/**
     * Gets the list of {@link SceneModelEntity}s within this SceneModel.
     *
     * @returns {SceneModelEntity[]}
     */},{key:"entityList",get:function get(){return this._entityList;}/**
     * Returns true to indicate that SceneModel is an {@link Entity}.
     * @type {Boolean}
     */},{key:"isEntity",get:function get(){return true;}/**
     * Returns ````true```` if this SceneModel represents a model.
     *
     * When ````true```` the SceneModel will be registered by {@link SceneModel#id} in
     * {@link Scene#models} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.
     *
     * @type {Boolean}
     */},{key:"isModel",get:function get(){return this._isModel;}//------------------------------------------------------------------------------------------------------------------
// SceneModel members
//------------------------------------------------------------------------------------------------------------------
/**
     * Returns ````false```` to indicate that SceneModel never represents an object.
     *
     * @type {Boolean}
     */},{key:"isObject",get:function get(){return false;}/**
     * Gets the SceneModel's World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */},{key:"aabb",get:function get(){if(this._aabbDirty){math.collapseAABB3(this._aabb);for(var _i400=0,len=this._entityList.length;_i400<len;_i400++){math.expandAABB3(this._aabb,this._entityList[_i400].aabb);}this._aabbDirty=false;}return this._aabb;}/**
     * The approximate number of triangle primitives in this SceneModel.
     *
     * @type {Number}
     */},{key:"numTriangles",get:function get(){return this._numTriangles;}//------------------------------------------------------------------------------------------------------------------
// Entity members
//------------------------------------------------------------------------------------------------------------------
/**
     * The approximate number of line primitives in this SceneModel.
     *
     * @type {Number}
     */},{key:"numLines",get:function get(){return this._numLines;}/**
     * The approximate number of point primitives in this SceneModel.
     *
     * @type {Number}
     */},{key:"numPoints",get:function get(){return this._numPoints;}/**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are visible.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is ````true```` and {@link SceneModel#culled} is ````false````.
     *
     * @type {Boolean}
     */},{key:"visible",get:function get(){return this.numVisibleLayerPortions>0;}/**
     * Sets if this SceneModel is visible.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is ````true```` and {@link SceneModel#culled} is ````false````.
     **
     * @type {Boolean}
     */,set:function set(visible){visible=visible!==false;this._visible=visible;for(var _i401=0,len=this._entityList.length;_i401<len;_i401++){this._entityList[_i401].visible=visible;}this.glRedraw();}/**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are xrayed.
     *
     * @type {Boolean}
     */},{key:"xrayed",get:function get(){return this.numXRayedLayerPortions>0;}/**
     * Sets if all {@link SceneModelEntity}s in this SceneModel are xrayed.
     *
     * @type {Boolean}
     */,set:function set(xrayed){xrayed=!!xrayed;this._xrayed=xrayed;for(var _i402=0,len=this._entityList.length;_i402<len;_i402++){this._entityList[_i402].xrayed=xrayed;}this.glRedraw();}/**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are highlighted.
     *
     * @type {Boolean}
     */},{key:"highlighted",get:function get(){return this.numHighlightedLayerPortions>0;}/**
     * Sets if all {@link SceneModelEntity}s in this SceneModel are highlighted.
     *
     * @type {Boolean}
     */,set:function set(highlighted){highlighted=!!highlighted;this._highlighted=highlighted;for(var _i403=0,len=this._entityList.length;_i403<len;_i403++){this._entityList[_i403].highlighted=highlighted;}this.glRedraw();}/**
     * Gets if any {@link SceneModelEntity}s in this SceneModel are selected.
     *
     * @type {Boolean}
     */},{key:"selected",get:function get(){return this.numSelectedLayerPortions>0;}/**
     * Sets if all {@link SceneModelEntity}s in this SceneModel are selected.
     *
     * @type {Boolean}
     */,set:function set(selected){selected=!!selected;this._selected=selected;for(var _i404=0,len=this._entityList.length;_i404<len;_i404++){this._entityList[_i404].selected=selected;}this.glRedraw();}/**
     * Gets if any {@link SceneModelEntity}s in this SceneModel have edges emphasised.
     *
     * @type {Boolean}
     */},{key:"edges",get:function get(){return this.numEdgesLayerPortions>0;}/**
     * Sets if all {@link SceneModelEntity}s in this SceneModel have edges emphasised.
     *
     * @type {Boolean}
     */,set:function set(edges){edges=!!edges;this._edges=edges;for(var _i405=0,len=this._entityList.length;_i405<len;_i405++){this._entityList[_i405].edges=edges;}this.glRedraw();}/**
     * Gets if this SceneModel is culled from view.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is true and {@link SceneModel#culled} is false.
     *
     * @type {Boolean}
     */},{key:"culled",get:function get(){return this._culled;}/**
     * Sets if this SceneModel is culled from view.
     *
     * The SceneModel is only rendered when {@link SceneModel#visible} is true and {@link SceneModel#culled} is false.
     *
     * @type {Boolean}
     */,set:function set(culled){culled=!!culled;this._culled=culled;for(var _i406=0,len=this._entityList.length;_i406<len;_i406++){this._entityList[_i406].culled=culled;}this.glRedraw();}/**
     * Gets if {@link SceneModelEntity}s in this SceneModel are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */},{key:"clippable",get:function get(){return this._clippable;}/**
     * Sets if {@link SceneModelEntity}s in this SceneModel are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */,set:function set(clippable){clippable=clippable!==false;this._clippable=clippable;for(var _i407=0,len=this._entityList.length;_i407<len;_i407++){this._entityList[_i407].clippable=clippable;}this.glRedraw();}/**
     * Gets if this SceneModel is collidable.
     *
     * @type {Boolean}
     */},{key:"collidable",get:function get(){return this._collidable;}/**
     * Sets if {@link SceneModelEntity}s in this SceneModel are collidable.
     *
     * @type {Boolean}
     */,set:function set(collidable){collidable=collidable!==false;this._collidable=collidable;for(var _i408=0,len=this._entityList.length;_i408<len;_i408++){this._entityList[_i408].collidable=collidable;}}/**
     * Gets if this SceneModel is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */},{key:"pickable",get:function get(){return this.numPickableLayerPortions>0;}/**
     * Sets if {@link SceneModelEntity}s in this SceneModel are pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */,set:function set(pickable){pickable=pickable!==false;this._pickable=pickable;for(var _i409=0,len=this._entityList.length;_i409<len;_i409++){this._entityList[_i409].pickable=pickable;}}/**
     * Gets the RGB colorize color for this SceneModel.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */},{key:"colorize",get:function get(){return this._colorize;}/**
     * Sets the RGB colorize color for this SceneModel.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */,set:function set(colorize){this._colorize=colorize;for(var _i410=0,len=this._entityList.length;_i410<len;_i410++){this._entityList[_i410].colorize=colorize;}}/**
     * Gets this SceneModel's opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */},{key:"opacity",get:function get(){return this._opacity;}/**
     * Sets the opacity factor for this SceneModel.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(opacity){this._opacity=opacity;for(var _i411=0,len=this._entityList.length;_i411<len;_i411++){this._entityList[_i411].opacity=opacity;}}/**
     * Gets if this SceneModel casts a shadow.
     *
     * @type {Boolean}
     */},{key:"castsShadow",get:function get(){return this._castsShadow;}/**
     * Sets if this SceneModel casts a shadow.
     *
     * @type {Boolean}
     */,set:function set(castsShadow){castsShadow=castsShadow!==false;if(castsShadow!==this._castsShadow){this._castsShadow=castsShadow;this.glRedraw();}}/**
     * Sets if this SceneModel can have shadow cast upon it.
     *
     * @type {Boolean}
     */},{key:"receivesShadow",get:function get(){return this._receivesShadow;}/**
     * Sets if this SceneModel can have shadow cast upon it.
     *
     * @type {Boolean}
     */,set:function set(receivesShadow){receivesShadow=receivesShadow!==false;if(receivesShadow!==this._receivesShadow){this._receivesShadow=receivesShadow;this.glRedraw();}}/**
     * Gets if Scalable Ambient Obscurance (SAO) will apply to this SceneModel.
     *
     * SAO is configured by the Scene's {@link SAO} component.
     *
     *  Only works when {@link SAO#enabled} is also true.
     *
     * @type {Boolean}
     */},{key:"saoEnabled",get:function get(){return this._saoEnabled;}/**
     * Gets if physically-based rendering (PBR) is enabled for this SceneModel.
     *
     * Only works when {@link Scene#pbrEnabled} is also true.
     *
     * @type {Boolean}
     */},{key:"pbrEnabled",get:function get(){return this._pbrEnabled;}/**
     * Gets if color textures are enabled for this SceneModel.
     *
     * Only works when {@link Scene#colorTextureEnabled} is also true.
     *
     * @type {Boolean}
     */},{key:"colorTextureEnabled",get:function get(){return this._colorTextureEnabled;}/**
     * Returns true to indicate that SceneModel is implements {@link Drawable}.
     *
     * @type {Boolean}
     */},{key:"isDrawable",get:function get(){return true;}/** @private */},{key:"isStateSortable",get:function get(){return false;}/**
     * Configures the appearance of xrayed {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#xrayMaterial}.
     *
     * @type {EmphasisMaterial}
     */},{key:"xrayMaterial",get:function get(){return this.scene.xrayMaterial;}/**
     * Configures the appearance of highlighted {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#highlightMaterial}.
     *
     * @type {EmphasisMaterial}
     */},{key:"highlightMaterial",get:function get(){return this.scene.highlightMaterial;}/**
     * Configures the appearance of selected {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#selectedMaterial}.
     *
     * @type {EmphasisMaterial}
     */},{key:"selectedMaterial",get:function get(){return this.scene.selectedMaterial;}/**
     * Configures the appearance of edges of {@link SceneModelEntity}s within this SceneModel.
     *
     * This is the {@link Scene#edgeMaterial}.
     *
     * @type {EdgeMaterial}
     */},{key:"edgeMaterial",get:function get(){return this.scene.edgeMaterial;}//------------------------------------------------------------------------------------------------------------------
// Drawable members
//------------------------------------------------------------------------------------------------------------------
/**
     * Called by private renderers in ./lib, returns the picking view matrix with which to
     * ray-pick on this SceneModel.
     *
     * @private
     */},{key:"getPickViewMatrix",value:function getPickViewMatrix(pickViewMatrix){if(!this._viewMatrix){return pickViewMatrix;}return this._viewMatrix;}/**
     *
     * @param cfg
     */},{key:"createQuantizationRange",value:function createQuantizationRange(cfg){if(cfg.id===undefined||cfg.id===null){this.error("[createQuantizationRange] Config missing: id");return;}if(cfg.aabb){this.error("[createQuantizationRange] Config missing: aabb");return;}if(this._quantizationRanges[cfg.id]){this.error("[createQuantizationRange] QuantizationRange already created: "+cfg.id);return;}this._quantizationRanges[cfg.id]={id:cfg.id,aabb:cfg.aabb,matrix:createPositionsDecodeMatrix(cfg.aabb,math.mat4())};}/**
     * Creates a reusable geometry within this SceneModel.
     *
     * We can then supply the geometry ID to {@link SceneModel#createMesh} when we want to create meshes that
     * instance the geometry.
     *
     * @param {*} cfg Geometry properties.
     * @param {String|Number} cfg.id Mandatory ID for the geometry, to refer to with {@link SceneModel#createMesh}.
     * @param {String} cfg.primitive The primitive type. Accepted values are 'points', 'lines', 'triangles', 'solid' and 'surface'.
     * @param {Number[]} [cfg.positions] Flat array of uncompressed 3D vertex positions positions. Required for all primitive types. Overridden by ````positionsCompressed````.
     * @param {Number[]} [cfg.positionsCompressed] Flat array of quantized 3D vertex positions. Overrides ````positions````, and must be accompanied by ````positionsDecodeMatrix````.
     * @param {Number[]} [cfg.positionsDecodeMatrix] A 4x4 matrix for decompressing ````positionsCompressed````. Must be accompanied by ````positionsCompressed````.
     * @param {Number[]} [cfg.normals] Flat array of normal vectors. Only used with "triangles", "solid" and "surface" primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.normalsCompressed] Flat array of oct-encoded normal vectors. Overrides ````normals````. Only used with "triangles", "solid" and "surface" primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.colors] Flat array of uncompressed RGBA vertex colors, as float values in range ````[0..1]````. Ignored when ````geometryId```` is given. Overridden by ````color```` and ````colorsCompressed````.
     * @param {Number[]} [cfg.colorsCompressed] Flat array of compressed RGBA vertex colors, as unsigned short integers in range ````[0..255]````. Ignored when ````geometryId```` is given. Overrides ````colors```` and is overridden by ````color````.
     * @param {Number[]} [cfg.uv] Flat array of uncompressed vertex UV coordinates. Only used with "triangles", "solid" and "surface" primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvCompressed] Flat array of compressed vertex UV coordinates. Only used with "triangles", "solid" and "surface" primitives. Overrides ````uv````. Must be accompanied by ````uvDecodeMatrix````. Only used with "triangles", "solid" and "surface" primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvDecodeMatrix] A 3x3 matrix for decompressing ````uvCompressed````.
     * @param {Number[]} [cfg.indices] Array of primitive connectivity indices. Not required for `points` primitives.
     * @param {Number[]} [cfg.edgeIndices] Array of edge line indices. Used only with 'triangles', 'solid' and 'surface' primitives. Automatically generated internally if not supplied, using the optional ````edgeThreshold```` given to the ````SceneModel```` constructor.
     */},{key:"createGeometry",value:function createGeometry(cfg){if(cfg.id===undefined||cfg.id===null){this.error("[createGeometry] Config missing: id");return;}if(this._geometries[cfg.id]){this.error("[createGeometry] Geometry already created: "+cfg.id);return;}if(cfg.primitive===undefined||cfg.primitive===null){cfg.primitive="triangles";}if(cfg.primitive!=="points"&&cfg.primitive!=="lines"&&cfg.primitive!=="triangles"&&cfg.primitive!=="solid"&&cfg.primitive!=="surface"){this.error("[createGeometry] Unsupported value for 'primitive': '".concat(cfg.primitive,"' - supported values are 'points', 'lines', 'triangles', 'solid' and 'surface'. Defaulting to 'triangles'."));return;}if(!cfg.positions&&!cfg.positionsCompressed&&!cfg.buckets){this.error("[createGeometry] Param expected: `positions`,  `positionsCompressed' or 'buckets");return null;}if(cfg.positionsCompressed&&!cfg.positionsDecodeMatrix&&!cfg.positionsDecodeBoundary){this.error("[createGeometry] Param expected: `positionsDecodeMatrix` or 'positionsDecodeBoundary' (required for `positionsCompressed')");return null;}if(cfg.positionsDecodeMatrix&&cfg.positionsDecodeBoundary){this.error("[createGeometry] Only one of these params expected: `positionsDecodeMatrix` or 'positionsDecodeBoundary' (required for `positionsCompressed')");return null;}if(cfg.uvCompressed&&!cfg.uvDecodeMatrix){this.error("[createGeometry] Param expected: `uvDecodeMatrix` (required for `uvCompressed')");return null;}if(!cfg.buckets&&!cfg.indices&&(cfg.primitive==="triangles"||cfg.primitive==="solid"||cfg.primitive==="surface")){var numPositions=(cfg.positions||cfg.positionsCompressed).length/3;cfg.indices=this._createDefaultIndices(numPositions);}if(!cfg.buckets&&!cfg.indices&&cfg.primitive!=="points"){this.error("[createGeometry] Param expected: indices (required for '".concat(cfg.primitive,"' primitive type)"));return null;}if(cfg.positionsDecodeBoundary){cfg.positionsDecodeMatrix=createPositionsDecodeMatrix(cfg.positionsDecodeBoundary,math.mat4());}if(cfg.positions){var aabb=math.collapseAABB3();cfg.positionsDecodeMatrix=math.mat4();math.expandAABB3Points3(aabb,cfg.positions);cfg.positionsCompressed=quantizePositions(cfg.positions,aabb,cfg.positionsDecodeMatrix);cfg.aabb=aabb;}else if(cfg.positionsCompressed){var _aabb=math.collapseAABB3();cfg.positionsDecodeMatrix=new Float64Array(cfg.positionsDecodeMatrix);cfg.positionsCompressed=new Uint16Array(cfg.positionsCompressed);math.expandAABB3Points3(_aabb,cfg.positionsCompressed);geometryCompressionUtils.decompressAABB(_aabb,cfg.positionsDecodeMatrix);cfg.aabb=_aabb;}else if(cfg.buckets){var _aabb2=math.collapseAABB3();this._dtxBuckets[cfg.id]=cfg.buckets;for(var _i412=0,len=cfg.buckets.length;_i412<len;_i412++){var bucket=cfg.buckets[_i412];if(bucket.positions){math.expandAABB3Points3(_aabb2,bucket.positions);}else if(bucket.positionsCompressed){math.expandAABB3Points3(_aabb2,bucket.positionsCompressed);}}if(cfg.positionsDecodeMatrix){geometryCompressionUtils.decompressAABB(_aabb2,cfg.positionsDecodeMatrix);}cfg.aabb=_aabb2;}if(cfg.colorsCompressed&&cfg.colorsCompressed.length>0){cfg.colorsCompressed=new Uint8Array(cfg.colorsCompressed);}else if(cfg.colors&&cfg.colors.length>0){var colors=cfg.colors;var colorsCompressed=new Uint8Array(colors.length);for(var _i413=0,_len85=colors.length;_i413<_len85;_i413++){colorsCompressed[_i413]=colors[_i413]*255;}cfg.colorsCompressed=colorsCompressed;}if(!cfg.buckets&&!cfg.edgeIndices&&(cfg.primitive==="triangles"||cfg.primitive==="solid"||cfg.primitive==="surface")){if(cfg.positions){cfg.edgeIndices=buildEdgeIndices(cfg.positions,cfg.indices,null,5.0);}else{cfg.edgeIndices=buildEdgeIndices(cfg.positionsCompressed,cfg.indices,cfg.positionsDecodeMatrix,2.0);}}if(cfg.uv){var bounds=geometryCompressionUtils.getUVBounds(cfg.uv);var result=geometryCompressionUtils.compressUVs(cfg.uv,bounds.min,bounds.max);cfg.uvCompressed=result.quantized;cfg.uvDecodeMatrix=result.decodeMatrix;}else if(cfg.uvCompressed){cfg.uvCompressed=new Uint16Array(cfg.uvCompressed);cfg.uvDecodeMatrix=new Float64Array(cfg.uvDecodeMatrix);}if(cfg.normals){// HACK
cfg.normals=null;}this._geometries[cfg.id]=cfg;this._numTriangles+=cfg.indices?Math.round(cfg.indices.length/3):0;this.numGeometries++;}/**
     * Creates a texture within this SceneModel.
     *
     * We can then supply the texture ID to {@link SceneModel#createTextureSet} when we want to create texture sets that use the texture.
     *
     * @param {*} cfg Texture properties.
     * @param {String|Number} cfg.id Mandatory ID for the texture, to refer to with {@link SceneModel#createTextureSet}.
     * @param {String} [cfg.src] Image file for the texture. Assumed to be transcoded if not having a recognized image file
     * extension (jpg, jpeg, png etc.). If transcoded, then assumes ````SceneModel```` is configured with a {@link TextureTranscoder}.
     * @param {ArrayBuffer[]} [cfg.buffers] Transcoded texture data. Assumes ````SceneModel```` is
     * configured with a {@link TextureTranscoder}. This parameter is given as an array of buffers so we can potentially support multi-image textures, such as cube maps.
     * @param {HTMLImageElement} [cfg.image] HTML Image object to load into this texture. Overrides ````src```` and ````buffers````. Never transcoded.
     * @param {Number} [cfg.minFilter=LinearMipmapLinearFilter] How the texture is sampled when a texel covers less than one pixel.
     * Supported values are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter}, {@link NearestMipMapNearestFilter}, {@link NearestMipMapLinearFilter} and {@link LinearMipMapLinearFilter}.
     * @param {Number} [cfg.magFilter=LinearFilter] How the texture is sampled when a texel covers more than one pixel. Supported values are {@link LinearFilter} and {@link NearestFilter}.
     * @param {Number} [cfg.wrapS=RepeatWrapping] Wrap parameter for texture coordinate *S*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.
     * @param {Number} [cfg.wrapT=RepeatWrapping] Wrap parameter for texture coordinate *T*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}..
     * @param {Number} [cfg.wrapR=RepeatWrapping] Wrap parameter for texture coordinate *R*. Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.
     * @param {Boolean} [cfg.flipY=false] Flips this Texture's source data along its vertical axis when ````true````.
     * @param  {Number} [cfg.encoding=LinearEncoding] Encoding format. Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.
     */},{key:"createTexture",value:function createTexture(cfg){var _this75=this;var textureId=cfg.id;if(textureId===undefined||textureId===null){this.error("[createTexture] Config missing: id");return;}if(this._textures[textureId]){this.error("[createTexture] Texture already created: "+textureId);return;}if(!cfg.src&&!cfg.image&&!cfg.buffers){this.error("[createTexture] Param expected: `src`, `image' or 'buffers'");return null;}var minFilter=cfg.minFilter||LinearMipmapLinearFilter;if(minFilter!==LinearFilter&&minFilter!==LinearMipMapNearestFilter&&minFilter!==LinearMipmapLinearFilter&&minFilter!==NearestMipMapLinearFilter&&minFilter!==NearestMipMapNearestFilter){this.error("[createTexture] Unsupported value for 'minFilter' - \n            supported values are LinearFilter, LinearMipMapNearestFilter, NearestMipMapNearestFilter, \n            NearestMipMapLinearFilter and LinearMipmapLinearFilter. Defaulting to LinearMipmapLinearFilter.");minFilter=LinearMipmapLinearFilter;}var magFilter=cfg.magFilter||LinearFilter;if(magFilter!==LinearFilter&&magFilter!==NearestFilter){this.error("[createTexture] Unsupported value for 'magFilter' - supported values are LinearFilter and NearestFilter. Defaulting to LinearFilter.");magFilter=LinearFilter;}var wrapS=cfg.wrapS||RepeatWrapping;if(wrapS!==ClampToEdgeWrapping&&wrapS!==MirroredRepeatWrapping&&wrapS!==RepeatWrapping){this.error("[createTexture] Unsupported value for 'wrapS' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.");wrapS=RepeatWrapping;}var wrapT=cfg.wrapT||RepeatWrapping;if(wrapT!==ClampToEdgeWrapping&&wrapT!==MirroredRepeatWrapping&&wrapT!==RepeatWrapping){this.error("[createTexture] Unsupported value for 'wrapT' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.");wrapT=RepeatWrapping;}var wrapR=cfg.wrapR||RepeatWrapping;if(wrapR!==ClampToEdgeWrapping&&wrapR!==MirroredRepeatWrapping&&wrapR!==RepeatWrapping){this.error("[createTexture] Unsupported value for 'wrapR' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping.");wrapR=RepeatWrapping;}var encoding=cfg.encoding||LinearEncoding;if(encoding!==LinearEncoding&&encoding!==sRGBEncoding){this.error("[createTexture] Unsupported value for 'encoding' - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding.");encoding=LinearEncoding;}var texture=new Texture2D({gl:this.scene.canvas.gl,minFilter:minFilter,magFilter:magFilter,wrapS:wrapS,wrapT:wrapT,wrapR:wrapR,// flipY: cfg.flipY,
encoding:encoding});if(cfg.preloadColor){texture.setPreloadColor(cfg.preloadColor);}if(cfg.image){// Ignore transcoder for Images
var _image2=cfg.image;_image2.crossOrigin="Anonymous";texture.setImage(_image2,{minFilter:minFilter,magFilter:magFilter,wrapS:wrapS,wrapT:wrapT,wrapR:wrapR,flipY:cfg.flipY,encoding:encoding});}else if(cfg.src){var ext=cfg.src.split('.').pop();switch(ext){// Don't transcode recognized image file types
case"jpeg":case"jpg":case"png":case"gif":var _image3=new Image();_image3.onload=function(){texture.setImage(_image3,{minFilter:minFilter,magFilter:magFilter,wrapS:wrapS,wrapT:wrapT,wrapR:wrapR,flipY:cfg.flipY,encoding:encoding});_this75.glRedraw();};_image3.src=cfg.src;// URL or Base64 string
break;default:// Assume other file types need transcoding
if(!this._textureTranscoder){this.error("[createTexture] Can't create texture from 'src' - SceneModel needs to be configured with a TextureTranscoder for this file type ('".concat(ext,"')"));}else{utils.loadArraybuffer(cfg.src,function(arrayBuffer){if(!arrayBuffer.byteLength){_this75.error("[createTexture] Can't create texture from 'src': file data is zero length");return;}_this75._textureTranscoder.transcode([arrayBuffer],texture).then(function(){_this75.glRedraw();});},function(errMsg){this.error("[createTexture] Can't create texture from 'src': ".concat(errMsg));});}break;}}else if(cfg.buffers){// Buffers implicitly require transcoding
if(!this._textureTranscoder){this.error("[createTexture] Can't create texture from 'buffers' - SceneModel needs to be configured with a TextureTranscoder for this option");}else{this._textureTranscoder.transcode(cfg.buffers,texture).then(function(){_this75.glRedraw();});}}this._textures[textureId]=new SceneModelTexture({id:textureId,texture:texture});}/**
     * Creates a texture set within this SceneModel.
     *
     * * Stores the new {@link SceneModelTextureSet} in {@link SceneModel#textureSets}.
     *
     * A texture set is a collection of textures that can be shared among meshes. We can then supply the texture set
     * ID to {@link SceneModel#createMesh} when we want to create meshes that use the texture set.
     *
     * The textures can work as a texture atlas, where each mesh can have geometry UVs that index
     * a different part of the textures. This allows us to minimize the number of textures in our models, which
     * means faster rendering.
     *
     * @param {*} cfg Texture set properties.
     * @param {String|Number} cfg.id Mandatory ID for the texture set, to refer to with {@link SceneModel#createMesh}.
     * @param {*} [cfg.colorTextureId] ID of *RGBA* base color texture, with color in *RGB* and alpha in *A*.
     * @param {*} [cfg.metallicRoughnessTextureId] ID of *RGBA* metal-roughness texture, with the metallic factor in *R*, and roughness factor in *G*.
     * @param {*} [cfg.normalsTextureId] ID of *RGBA* normal map texture, with normal map vectors in *RGB*.
     * @param {*} [cfg.emissiveTextureId] ID of *RGBA* emissive map texture, with emissive color in *RGB*.
     * @param {*} [cfg.occlusionTextureId] ID of *RGBA* occlusion map texture, with occlusion factor in *R*.
     * @returns {SceneModelTransform} The new texture set.
     */},{key:"createTextureSet",value:function createTextureSet(cfg){var textureSetId=cfg.id;if(textureSetId===undefined||textureSetId===null){this.error("[createTextureSet] Config missing: id");return;}if(this._textureSets[textureSetId]){this.error("[createTextureSet] Texture set already created: ".concat(textureSetId));return;}var colorTexture;if(cfg.colorTextureId!==undefined&&cfg.colorTextureId!==null){colorTexture=this._textures[cfg.colorTextureId];if(!colorTexture){this.error("[createTextureSet] Texture not found: ".concat(cfg.colorTextureId," - ensure that you create it first with createTexture()"));return;}}else{colorTexture=this._textures[DEFAULT_COLOR_TEXTURE_ID];}var metallicRoughnessTexture;if(cfg.metallicRoughnessTextureId!==undefined&&cfg.metallicRoughnessTextureId!==null){metallicRoughnessTexture=this._textures[cfg.metallicRoughnessTextureId];if(!metallicRoughnessTexture){this.error("[createTextureSet] Texture not found: ".concat(cfg.metallicRoughnessTextureId," - ensure that you create it first with createTexture()"));return;}}else{metallicRoughnessTexture=this._textures[DEFAULT_METAL_ROUGH_TEXTURE_ID];}var normalsTexture;if(cfg.normalsTextureId!==undefined&&cfg.normalsTextureId!==null){normalsTexture=this._textures[cfg.normalsTextureId];if(!normalsTexture){this.error("[createTextureSet] Texture not found: ".concat(cfg.normalsTextureId," - ensure that you create it first with createTexture()"));return;}}else{normalsTexture=this._textures[DEFAULT_NORMALS_TEXTURE_ID];}var emissiveTexture;if(cfg.emissiveTextureId!==undefined&&cfg.emissiveTextureId!==null){emissiveTexture=this._textures[cfg.emissiveTextureId];if(!emissiveTexture){this.error("[createTextureSet] Texture not found: ".concat(cfg.emissiveTextureId," - ensure that you create it first with createTexture()"));return;}}else{emissiveTexture=this._textures[DEFAULT_EMISSIVE_TEXTURE_ID];}var occlusionTexture;if(cfg.occlusionTextureId!==undefined&&cfg.occlusionTextureId!==null){occlusionTexture=this._textures[cfg.occlusionTextureId];if(!occlusionTexture){this.error("[createTextureSet] Texture not found: ".concat(cfg.occlusionTextureId," - ensure that you create it first with createTexture()"));return;}}else{occlusionTexture=this._textures[DEFAULT_OCCLUSION_TEXTURE_ID];}var textureSet=new SceneModelTextureSet({id:textureSetId,model:this,colorTexture:colorTexture,metallicRoughnessTexture:metallicRoughnessTexture,normalsTexture:normalsTexture,emissiveTexture:emissiveTexture,occlusionTexture:occlusionTexture});this._textureSets[textureSetId]=textureSet;return textureSet;}/**
     * Creates a new {@link SceneModelTransform} within this SceneModel.
     *
     * * Stores the new {@link SceneModelTransform} in {@link SceneModel#transforms}.
     * * Can be connected into hierarchies
     * * Each {@link SceneModelTransform} can be used by unlimited {@link SceneModelMesh}es
     *
     * @param {*} cfg Transform creation parameters.
     * @param {String} cfg.id Mandatory ID for the new transform. Must not clash with any existing components within the {@link Scene}.
     * @param {String} [cfg.parentTransformId] ID of a parent transform, previously created with {@link SceneModel#createTextureSet}.
     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position of the mesh. Overridden by ````transformId````.
     * @param {Number[]} [cfg.scale=[1,1,1]] Scale of the transform.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Rotation of the transform as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Modelling transform matrix. Overrides the ````position````, ````scale```` and ````rotation```` parameters.
     * @returns {SceneModelTransform} The new transform.
     */},{key:"createTransform",value:function createTransform(cfg){if(cfg.id===undefined||cfg.id===null){this.error("[createTransform] SceneModel.createTransform() config missing: id");return;}if(this._transforms[cfg.id]){this.error("[createTransform] SceneModel already has a transform with this ID: ".concat(cfg.id));return;}var parentTransform;if(this.parentTransformId){parentTransform=this._transforms[cfg.parentTransformId];if(!parentTransform){this.error("[createTransform] SceneModel.createTransform() config missing: id");return;}}var transform=new SceneModelTransform({id:cfg.id,model:this,parentTransform:parentTransform,matrix:cfg.matrix,position:cfg.position,scale:cfg.scale,rotation:cfg.rotation,quaternion:cfg.quaternion});this._transforms[transform.id]=transform;return transform;}/**
     * Creates a new {@link SceneModelMesh} within this SceneModel.
     *
     * * It prepares and saves data for a SceneModelMesh {@link SceneModel#meshes} creation. SceneModelMesh will be created only once the SceneModelEntity (which references this particular SceneModelMesh) will be created.
     * * The SceneModelMesh can either define its own geometry or share it with other SceneModelMeshes. To define own geometry, provide the
     * various geometry arrays to this method. To share a geometry, provide the ID of a geometry created earlier
     * with {@link SceneModel#createGeometry}.
     * * If you accompany the arrays with an  ````origin````, then ````createMesh()```` will assume
     * that the geometry ````positions```` are in relative-to-center (RTC) coordinates, with ````origin```` being the
     * origin of their RTC coordinate system.
     *
     * @param {object} cfg Object properties.
     * @param {String} cfg.id Mandatory ID for the new mesh. Must not clash with any existing components within the {@link Scene}.
     * @param {String|Number} [cfg.textureSetId] ID of a {@link SceneModelTextureSet} previously created with {@link SceneModel#createTextureSet}.
     * @param {String|Number} [cfg.transformId] ID of a {@link SceneModelTransform} to instance, previously created with {@link SceneModel#createTransform}. Overrides all other transform parameters given to this method.
     * @param {String|Number} [cfg.geometryId] ID of a geometry to instance, previously created with {@link SceneModel#createGeometry}. Overrides all other geometry parameters given to this method.
     * @param {String} cfg.primitive The primitive type. Accepted values are 'points', 'lines', 'triangles', 'solid' and 'surface'.
     * @param {Number[]} [cfg.positions] Flat array of uncompressed 3D vertex positions positions. Required for all primitive types. Overridden by ````positionsCompressed````.
     * @param {Number[]} [cfg.positionsCompressed] Flat array of quantized 3D vertex positions. Overrides ````positions````, and must be accompanied by ````positionsDecodeMatrix````.
     * @param {Number[]} [cfg.positionsDecodeMatrix] A 4x4 matrix for decompressing ````positionsCompressed````. Must be accompanied by ````positionsCompressed````.
     * @param {Number[]} [cfg.normals] Flat array of normal vectors. Only used with "triangles", "solid" and "surface" primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.normalsCompressed] Flat array of oct-encoded normal vectors. Overrides ````normals````. Only used with "triangles", "solid" and "surface" primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.colors] Flat array of uncompressed RGBA vertex colors, as float values in range ````[0..1]````. Ignored when ````geometryId```` is given. Overridden by ````color```` and ````colorsCompressed````.
     * @param {Number[]} [cfg.colorsCompressed] Flat array of compressed RGBA vertex colors, as unsigned short integers in range ````[0..255]````. Ignored when ````geometryId```` is given. Overrides ````colors```` and is overridden by ````color````.
     * @param {Number[]} [cfg.uv] Flat array of uncompressed vertex UV coordinates. Only used with "triangles", "solid" and "surface" primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvCompressed] Flat array of compressed vertex UV coordinates. Only used with "triangles", "solid" and "surface" primitives. Overrides ````uv````. Must be accompanied by ````uvDecodeMatrix````. Only used with "triangles", "solid" and "surface" primitives. Required for textured rendering.
     * @param {Number[]} [cfg.uvDecodeMatrix] A 3x3 matrix for decompressing ````uvCompressed````.
     * @param {Number[]} [cfg.indices] Array of primitive connectivity indices. Not required for `points` primitives.
     * @param {Number[]} [cfg.edgeIndices] Array of edge line indices. Used only with 'triangles', 'solid' and 'surface' primitives. Automatically generated internally if not supplied, using the optional ````edgeThreshold```` given to the ````SceneModel```` constructor.
     * @param {Number[]} [cfg.origin] Optional geometry origin, relative to {@link SceneModel#origin}. When this is given, then ````positions```` are assumed to be relative to this.
     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position of the mesh. Overridden by ````transformId````.
     * @param {Number[]} [cfg.scale=[1,1,1]] Scale of the mesh.  Overridden by ````transformId````.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Rotation of the mesh as Euler angles given in degrees, for each of the X, Y and Z axis.  Overridden by ````transformId````.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Mesh modelling transform matrix. Overrides the ````position````, ````scale```` and ````rotation```` parameters. Also  overridden by ````transformId````.
     * @param {Number[]} [cfg.color=[1,1,1]] RGB color in range ````[0..1, 0..1, 0..1]````. Overridden by texture set ````colorTexture````. Overrides ````colors```` and ````colorsCompressed````.
     * @param {Number} [cfg.opacity=1] Opacity in range ````[0..1]````. Overridden by texture set ````colorTexture````.
     * @param {Number} [cfg.metallic=0] Metallic factor in range ````[0..1]````. Overridden by texture set ````metallicRoughnessTexture````.
     * @param {Number} [cfg.roughness=1] Roughness factor in range ````[0..1]````. Overridden by texture set ````metallicRoughnessTexture````.
     * @returns {SceneModelMesh} The new mesh.
     */},{key:"createMesh",value:function createMesh(cfg){if(cfg.id===undefined||cfg.id===null){this.error("[createMesh] SceneModel.createMesh() config missing: id");return false;}if(this._meshes[cfg.id]){this.error("[createMesh] SceneModel already has a mesh with this ID: ".concat(cfg.id));return false;}var instancing=cfg.geometryId!==undefined;var batching=!instancing;if(batching){// Batched geometry
if(cfg.primitive===undefined||cfg.primitive===null){cfg.primitive="triangles";}if(cfg.primitive!=="points"&&cfg.primitive!=="lines"&&cfg.primitive!=="triangles"&&cfg.primitive!=="solid"&&cfg.primitive!=="surface"){this.error("Unsupported value for 'primitive': '".concat(primitive,"'  ('geometryId' is absent) - supported values are 'points', 'lines', 'triangles', 'solid' and 'surface'."));return false;}if(!cfg.positions&&!cfg.positionsCompressed&&!cfg.buckets){this.error("Param expected: 'positions',  'positionsCompressed' or `buckets`  ('geometryId' is absent)");return false;}if(cfg.positions&&(cfg.positionsDecodeMatrix||cfg.positionsDecodeBoundary)){this.error("Illegal params: 'positions' not expected with 'positionsDecodeMatrix'/'positionsDecodeBoundary' ('geometryId' is absent)");return false;}if(cfg.positionsCompressed&&!cfg.positionsDecodeMatrix&&!cfg.positionsDecodeBoundary){this.error("Param expected: 'positionsCompressed' should be accompanied by 'positionsDecodeMatrix'/'positionsDecodeBoundary' ('geometryId' is absent)");return false;}if(cfg.uvCompressed&&!cfg.uvDecodeMatrix){this.error("Param expected: 'uvCompressed' should be accompanied by `uvDecodeMatrix` ('geometryId' is absent)");return false;}if(!cfg.buckets&&!cfg.indices&&(cfg.primitive==="triangles"||cfg.primitive==="solid"||cfg.primitive==="surface")){var numPositions=(cfg.positions||cfg.positionsCompressed).length/3;cfg.indices=this._createDefaultIndices(numPositions);}if(!cfg.buckets&&!cfg.indices&&cfg.primitive!=="points"){cfg.indices=this._createDefaultIndices(numIndices);this.error("Param expected: indices (required for '".concat(cfg.primitive,"' primitive type)"));return false;}if((cfg.matrix||cfg.position||cfg.rotation||cfg.scale)&&(cfg.positionsCompressed||cfg.positionsDecodeBoundary)){this.error("Unexpected params: 'matrix', 'rotation', 'scale', 'position' not allowed with 'positionsCompressed'");return false;}var useDTX=!!this._dtxEnabled&&(cfg.primitive==="triangles"||cfg.primitive==="solid"||cfg.primitive==="surface")&&!cfg.textureSetId;cfg.origin=cfg.origin?math.addVec3(this._origin,cfg.origin,math.vec3()):this._origin;// MATRIX - optional for batching
if(cfg.matrix){cfg.meshMatrix=cfg.matrix;}else if(cfg.scale||cfg.rotation||cfg.position){var _scale3=cfg.scale||DEFAULT_SCALE;var _position=cfg.position||DEFAULT_POSITION;var rotation=cfg.rotation||DEFAULT_ROTATION;math.eulerToQuaternion(rotation,"XYZ",DEFAULT_QUATERNION);cfg.meshMatrix=math.composeMat4(_position,DEFAULT_QUATERNION,_scale3,math.mat4());}if(cfg.positionsDecodeBoundary){cfg.positionsDecodeMatrix=createPositionsDecodeMatrix(cfg.positionsDecodeBoundary,math.mat4());}if(useDTX){// DTX
cfg.type=DTX;// NPR
cfg.color=cfg.color?new Uint8Array([Math.floor(cfg.color[0]*255),Math.floor(cfg.color[1]*255),Math.floor(cfg.color[2]*255)]):defaultCompressedColor;cfg.opacity=cfg.opacity!==undefined&&cfg.opacity!==null?Math.floor(cfg.opacity*255):255;// RTC
if(cfg.positions){var rtcCenter=math.vec3();var rtcPositions=[];var rtcNeeded=worldToRTCPositions(cfg.positions,rtcPositions,rtcCenter);if(rtcNeeded){cfg.positions=rtcPositions;cfg.origin=math.addVec3(cfg.origin,rtcCenter,rtcCenter);}}// COMPRESSION
if(cfg.positions){var aabb=math.collapseAABB3();cfg.positionsDecodeMatrix=math.mat4();math.expandAABB3Points3(aabb,cfg.positions);cfg.positionsCompressed=quantizePositions(cfg.positions,aabb,cfg.positionsDecodeMatrix);cfg.aabb=aabb;}else if(cfg.positionsCompressed){var _aabb3=math.collapseAABB3();math.expandAABB3Points3(_aabb3,cfg.positionsCompressed);geometryCompressionUtils.decompressAABB(_aabb3,cfg.positionsDecodeMatrix);cfg.aabb=_aabb3;}if(cfg.buckets){var _aabb4=math.collapseAABB3();for(var _i414=0,len=cfg.buckets.length;_i414<len;_i414++){var bucket=cfg.buckets[_i414];if(bucket.positions){math.expandAABB3Points3(_aabb4,bucket.positions);}else if(bucket.positionsCompressed){math.expandAABB3Points3(_aabb4,bucket.positionsCompressed);}}if(cfg.positionsDecodeMatrix){geometryCompressionUtils.decompressAABB(_aabb4,cfg.positionsDecodeMatrix);}cfg.aabb=_aabb4;}if(cfg.meshMatrix){math.AABB3ToOBB3(cfg.aabb,tempOBB3);math.transformOBB3(cfg.meshMatrix,tempOBB3);math.OBB3ToAABB3(tempOBB3,cfg.aabb);}// EDGES
if(!cfg.buckets&&!cfg.edgeIndices&&(cfg.primitive==="triangles"||cfg.primitive==="solid"||cfg.primitive==="surface")){if(cfg.positions){// Faster
cfg.edgeIndices=buildEdgeIndices(cfg.positions,cfg.indices,null,2.0);}else{cfg.edgeIndices=buildEdgeIndices(cfg.positionsCompressed,cfg.indices,cfg.positionsDecodeMatrix,2.0);}}// BUCKETING
if(!cfg.buckets){cfg.buckets=createDTXBuckets(cfg,this._enableVertexWelding&&this._enableIndexBucketing);}}else{// VBO
cfg.type=VBO_BATCHED;// PBR
cfg.color=cfg.color?new Uint8Array([Math.floor(cfg.color[0]*255),Math.floor(cfg.color[1]*255),Math.floor(cfg.color[2]*255)]):[255,255,255];cfg.opacity=cfg.opacity!==undefined&&cfg.opacity!==null?Math.floor(cfg.opacity*255):255;cfg.metallic=cfg.metallic!==undefined&&cfg.metallic!==null?Math.floor(cfg.metallic*255):0;cfg.roughness=cfg.roughness!==undefined&&cfg.roughness!==null?Math.floor(cfg.roughness*255):255;// RTC
if(cfg.positions){var _rtcPositions=[];var _rtcNeeded=worldToRTCPositions(cfg.positions,_rtcPositions,tempVec3a$a);if(_rtcNeeded){cfg.positions=_rtcPositions;cfg.origin=math.addVec3(cfg.origin,tempVec3a$a,math.vec3());}}if(cfg.positions){var _aabb5=math.collapseAABB3();if(cfg.meshMatrix){math.transformPositions3(cfg.meshMatrix,cfg.positions,cfg.positions);cfg.meshMatrix=null;// Positions now baked, don't need any more
}math.expandAABB3Points3(_aabb5,cfg.positions);cfg.aabb=_aabb5;}else{var _aabb6=math.collapseAABB3();math.expandAABB3Points3(_aabb6,cfg.positionsCompressed);geometryCompressionUtils.decompressAABB(_aabb6,cfg.positionsDecodeMatrix);cfg.aabb=_aabb6;}if(cfg.meshMatrix){math.AABB3ToOBB3(cfg.aabb,tempOBB3);math.transformOBB3(cfg.meshMatrix,tempOBB3);math.OBB3ToAABB3(tempOBB3,cfg.aabb);}// EDGES
if(!cfg.buckets&&!cfg.edgeIndices&&(cfg.primitive==="triangles"||cfg.primitive==="solid"||cfg.primitive==="surface")){if(cfg.positions){cfg.edgeIndices=buildEdgeIndices(cfg.positions,cfg.indices,null,2.0);}else{cfg.edgeIndices=buildEdgeIndices(cfg.positionsCompressed,cfg.indices,cfg.positionsDecodeMatrix,2.0);}}// TEXTURE
// cfg.textureSetId = cfg.textureSetId || DEFAULT_TEXTURE_SET_ID;
if(cfg.textureSetId){cfg.textureSet=this._textureSets[cfg.textureSetId];if(!cfg.textureSet){this.error("[createMesh] Texture set not found: ".concat(cfg.textureSetId," - ensure that you create it first with createTextureSet()"));return false;}}}}else{// INSTANCING
if(cfg.positions||cfg.positionsCompressed||cfg.indices||cfg.edgeIndices||cfg.normals||cfg.normalsCompressed||cfg.uv||cfg.uvCompressed||cfg.positionsDecodeMatrix){this.error("Mesh geometry parameters not expected when instancing a geometry (not expected: positions, positionsCompressed, indices, edgeIndices, normals, normalsCompressed, uv, uvCompressed, positionsDecodeMatrix)");return false;}cfg.geometry=this._geometries[cfg.geometryId];if(!cfg.geometry){this.error("[createMesh] Geometry not found: ".concat(cfg.geometryId," - ensure that you create it first with createGeometry()"));return false;}cfg.origin=cfg.origin?math.addVec3(this._origin,cfg.origin,math.vec3()):this._origin;cfg.positionsDecodeMatrix=cfg.geometry.positionsDecodeMatrix;if(cfg.transformId){// TRANSFORM
cfg.transform=this._transforms[cfg.transformId];if(!cfg.transform){this.error("[createMesh] Transform not found: ".concat(cfg.transformId," - ensure that you create it first with createTransform()"));return false;}cfg.aabb=cfg.geometry.aabb;}else{// MATRIX
if(cfg.matrix){cfg.meshMatrix=cfg.matrix.slice();}else{var _scale4=cfg.scale||DEFAULT_SCALE;var _position2=cfg.position||DEFAULT_POSITION;var _rotation=cfg.rotation||DEFAULT_ROTATION;math.eulerToQuaternion(_rotation,"XYZ",DEFAULT_QUATERNION);cfg.meshMatrix=math.composeMat4(_position2,DEFAULT_QUATERNION,_scale4,math.mat4());}math.AABB3ToOBB3(cfg.geometry.aabb,tempOBB3);math.transformOBB3(cfg.meshMatrix,tempOBB3);cfg.aabb=math.OBB3ToAABB3(tempOBB3,math.AABB3());}var _useDTX=!!this._dtxEnabled&&(cfg.geometry.primitive==="triangles"||cfg.geometry.primitive==="solid"||cfg.geometry.primitive==="surface")&&!cfg.textureSetId;if(_useDTX){// DTX
cfg.type=DTX;// NPR
cfg.color=cfg.color?new Uint8Array([Math.floor(cfg.color[0]*255),Math.floor(cfg.color[1]*255),Math.floor(cfg.color[2]*255)]):defaultCompressedColor;cfg.opacity=cfg.opacity!==undefined&&cfg.opacity!==null?Math.floor(cfg.opacity*255):255;// BUCKETING - lazy generated, reused
var buckets=this._dtxBuckets[cfg.geometryId];if(!buckets){buckets=createDTXBuckets(cfg.geometry,this._enableVertexWelding,this._enableIndexBucketing);this._dtxBuckets[cfg.geometryId]=buckets;}cfg.buckets=buckets;}else{// VBO
cfg.type=VBO_INSTANCED;// PBR
cfg.color=cfg.color?new Uint8Array([Math.floor(cfg.color[0]*255),Math.floor(cfg.color[1]*255),Math.floor(cfg.color[2]*255)]):defaultCompressedColor;cfg.opacity=cfg.opacity!==undefined&&cfg.opacity!==null?Math.floor(cfg.opacity*255):255;cfg.metallic=cfg.metallic!==undefined&&cfg.metallic!==null?Math.floor(cfg.metallic*255):0;cfg.roughness=cfg.roughness!==undefined&&cfg.roughness!==null?Math.floor(cfg.roughness*255):255;// TEXTURE
if(cfg.textureSetId){cfg.textureSet=this._textureSets[cfg.textureSetId];// if (!cfg.textureSet) {
//     this.error(`[createMesh] Texture set not found: ${cfg.textureSetId} - ensure that you create it first with createTextureSet()`);
//     return false;
// }
}}}cfg.numPrimitives=this._getNumPrimitives(cfg);return this._createMesh(cfg);}},{key:"_createMesh",value:function _createMesh(cfg){var mesh=new SceneModelMesh(this,cfg.id,cfg.color,cfg.opacity,cfg.transform,cfg.textureSet);mesh.pickId=this.scene._renderer.getPickID(mesh);var pickId=mesh.pickId;var a=pickId>>24&0xFF;var b=pickId>>16&0xFF;var g=pickId>>8&0xFF;var r=pickId&0xFF;cfg.pickColor=new Uint8Array([r,g,b,a]);// Quantized pick color
cfg.solid=cfg.primitive==="solid";mesh.origin=math.vec3(cfg.origin);switch(cfg.type){case DTX:mesh.layer=this._getDTXLayer(cfg);mesh.aabb=cfg.aabb;break;case VBO_BATCHED:mesh.layer=this._getVBOBatchingLayer(cfg);mesh.aabb=cfg.aabb;break;case VBO_INSTANCED:mesh.layer=this._getVBOInstancingLayer(cfg);mesh.aabb=cfg.aabb;break;}if(cfg.transform){cfg.meshMatrix=cfg.transform.worldMatrix;}mesh.portionId=mesh.layer.createPortion(mesh,cfg);this._meshes[cfg.id]=mesh;this._unusedMeshes[cfg.id]=mesh;this._meshList.push(mesh);return mesh;}},{key:"_getNumPrimitives",value:function _getNumPrimitives(cfg){var countIndices=0;var primitive=cfg.geometry?cfg.geometry.primitive:cfg.primitive;switch(primitive){case"triangles":case"solid":case"surface":switch(cfg.type){case DTX:for(var _i415=0,len=cfg.buckets.length;_i415<len;_i415++){countIndices+=cfg.buckets[_i415].indices.length;}break;case VBO_BATCHED:countIndices+=cfg.indices.length;break;case VBO_INSTANCED:countIndices+=cfg.geometry.indices.length;break;}return Math.round(countIndices/3);case"points":switch(cfg.type){case DTX:for(var _i416=0,_len86=cfg.buckets.length;_i416<_len86;_i416++){countIndices+=cfg.buckets[_i416].positionsCompressed.length;}break;case VBO_BATCHED:countIndices+=cfg.positions?cfg.positions.length:cfg.positionsCompressed.length;break;case VBO_INSTANCED:var geometry=cfg.geometry;countIndices+=geometry.positions?geometry.positions.length:geometry.positionsCompressed.length;break;}return Math.round(countIndices);case"lines":case"line-strip":switch(cfg.type){case DTX:for(var _i417=0,_len87=cfg.buckets.length;_i417<_len87;_i417++){countIndices+=cfg.buckets[_i417].indices.length;}break;case VBO_BATCHED:countIndices+=cfg.indices.length;break;case VBO_INSTANCED:countIndices+=cfg.geometry.indices.length;break;}return Math.round(countIndices/2);}return 0;}},{key:"_getDTXLayer",value:function _getDTXLayer(cfg){var origin=cfg.origin;var primitive=cfg.geometry?cfg.geometry.primitive:cfg.primitive;var layerId=".".concat(primitive,".").concat(Math.round(origin[0]),".").concat(Math.round(origin[1]),".").concat(Math.round(origin[2]));var dtxLayer=this._dtxLayers[layerId];if(dtxLayer){if(!dtxLayer.canCreatePortion(cfg)){dtxLayer.finalize();delete this._dtxLayers[layerId];dtxLayer=null;}else{return dtxLayer;}}switch(primitive){case"triangles":case"solid":case"surface":dtxLayer=new DTXTrianglesLayer(this,{layerIndex:0,origin:origin});// layerIndex is set in #finalize()
break;case"lines":dtxLayer=new DTXLinesLayer(this,{layerIndex:0,origin:origin});// layerIndex is set in #finalize()
break;default:return;}this._dtxLayers[layerId]=dtxLayer;this.layerList.push(dtxLayer);return dtxLayer;}},{key:"_getVBOBatchingLayer",value:function _getVBOBatchingLayer(cfg){var model=this;var origin=cfg.origin;var positionsDecodeHash=cfg.positionsDecodeMatrix||cfg.positionsDecodeBoundary?this._createHashStringFromMatrix(cfg.positionsDecodeMatrix||cfg.positionsDecodeBoundary):"-";var textureSetId=cfg.textureSetId||"-";var layerId="".concat(Math.round(origin[0]),".").concat(Math.round(origin[1]),".").concat(Math.round(origin[2]),".").concat(cfg.primitive,".").concat(positionsDecodeHash,".").concat(textureSetId);var vboBatchingLayer=this._vboBatchingLayers[layerId];if(vboBatchingLayer){return vboBatchingLayer;}var textureSet=cfg.textureSet;while(!vboBatchingLayer){switch(cfg.primitive){case"triangles":// console.info(`[SceneModel ${this.id}]: creating TrianglesBatchingLayer`);
vboBatchingLayer=new VBOBatchingTrianglesLayer({model:model,textureSet:textureSet,layerIndex:0,// This is set in #finalize()
scratchMemory:this._vboBatchingLayerScratchMemory,positionsDecodeMatrix:cfg.positionsDecodeMatrix,// Can be undefined
uvDecodeMatrix:cfg.uvDecodeMatrix,// Can be undefined
origin:origin,maxGeometryBatchSize:this._maxGeometryBatchSize,solid:cfg.primitive==="solid",autoNormals:true});break;case"solid":// console.info(`[SceneModel ${this.id}]: creating TrianglesBatchingLayer`);
vboBatchingLayer=new VBOBatchingTrianglesLayer({model:model,textureSet:textureSet,layerIndex:0,// This is set in #finalize()
scratchMemory:this._vboBatchingLayerScratchMemory,positionsDecodeMatrix:cfg.positionsDecodeMatrix,// Can be undefined
uvDecodeMatrix:cfg.uvDecodeMatrix,// Can be undefined
origin:origin,maxGeometryBatchSize:this._maxGeometryBatchSize,solid:cfg.primitive==="solid",autoNormals:true});break;case"surface":// console.info(`[SceneModel ${this.id}]: creating TrianglesBatchingLayer`);
vboBatchingLayer=new VBOBatchingTrianglesLayer({model:model,textureSet:textureSet,layerIndex:0,// This is set in #finalize()
scratchMemory:this._vboBatchingLayerScratchMemory,positionsDecodeMatrix:cfg.positionsDecodeMatrix,// Can be undefined
uvDecodeMatrix:cfg.uvDecodeMatrix,// Can be undefined
origin:origin,maxGeometryBatchSize:this._maxGeometryBatchSize,solid:cfg.primitive==="solid",autoNormals:true});break;case"lines":// console.info(`[SceneModel ${this.id}]: creating VBOBatchingLinesLayer`);
vboBatchingLayer=new VBOBatchingLinesLayer({model:model,layerIndex:0,// This is set in #finalize()
scratchMemory:this._vboBatchingLayerScratchMemory,positionsDecodeMatrix:cfg.positionsDecodeMatrix,// Can be undefined
uvDecodeMatrix:cfg.uvDecodeMatrix,// Can be undefined
origin:origin,maxGeometryBatchSize:this._maxGeometryBatchSize});break;case"points":// console.info(`[SceneModel ${this.id}]: creating VBOBatchingPointsLayer`);
vboBatchingLayer=new VBOBatchingPointsLayer({model:model,layerIndex:0,// This is set in #finalize()
scratchMemory:this._vboBatchingLayerScratchMemory,positionsDecodeMatrix:cfg.positionsDecodeMatrix,// Can be undefined
uvDecodeMatrix:cfg.uvDecodeMatrix,// Can be undefined
origin:origin,maxGeometryBatchSize:this._maxGeometryBatchSize});break;}var lenPositions=cfg.positionsCompressed?cfg.positionsCompressed.length:cfg.positions.length;var canCreatePortion=cfg.primitive==="points"?vboBatchingLayer.canCreatePortion(lenPositions):vboBatchingLayer.canCreatePortion(lenPositions,cfg.indices.length);if(!canCreatePortion){vboBatchingLayer.finalize();delete this._vboBatchingLayers[layerId];vboBatchingLayer=null;}}this._vboBatchingLayers[layerId]=vboBatchingLayer;this.layerList.push(vboBatchingLayer);return vboBatchingLayer;}},{key:"_createHashStringFromMatrix",value:function _createHashStringFromMatrix(matrix){var matrixString=matrix.join('');var hash=0;for(var _i418=0;_i418<matrixString.length;_i418++){var _char=matrixString.charCodeAt(_i418);hash=(hash<<5)-hash+_char;hash|=0;// Convert to 32-bit integer
}var hashString=(hash>>>0).toString(16);return hashString;}},{key:"_getVBOInstancingLayer",value:function _getVBOInstancingLayer(cfg){var model=this;var origin=cfg.origin;var textureSetId=cfg.textureSetId||"-";var geometryId=cfg.geometryId;var layerId="".concat(Math.round(origin[0]),".").concat(Math.round(origin[1]),".").concat(Math.round(origin[2]),".").concat(textureSetId,".").concat(geometryId);var vboInstancingLayer=this._vboInstancingLayers[layerId];if(vboInstancingLayer){return vboInstancingLayer;}var textureSet=cfg.textureSet;var geometry=cfg.geometry;while(!vboInstancingLayer){switch(geometry.primitive){case"triangles":// console.info(`[SceneModel ${this.id}]: creating TrianglesInstancingLayer`);
vboInstancingLayer=new VBOInstancingTrianglesLayer({model:model,textureSet:textureSet,geometry:geometry,origin:origin,layerIndex:0,solid:false});break;case"solid":// console.info(`[SceneModel ${this.id}]: creating TrianglesInstancingLayer`);
vboInstancingLayer=new VBOInstancingTrianglesLayer({model:model,textureSet:textureSet,geometry:geometry,origin:origin,layerIndex:0,solid:true});break;case"surface":// console.info(`[SceneModel ${this.id}]: creating TrianglesInstancingLayer`);
vboInstancingLayer=new VBOInstancingTrianglesLayer({model:model,textureSet:textureSet,geometry:geometry,origin:origin,layerIndex:0,solid:false});break;case"lines":// console.info(`[SceneModel ${this.id}]: creating VBOInstancingLinesLayer`);
vboInstancingLayer=new VBOInstancingLinesLayer({model:model,textureSet:textureSet,geometry:geometry,origin:origin,layerIndex:0});break;case"points":// console.info(`[SceneModel ${this.id}]: creating PointsInstancingLayer`);
vboInstancingLayer=new VBOInstancingPointsLayer({model:model,textureSet:textureSet,geometry:geometry,origin:origin,layerIndex:0});break;}// const lenPositions = geometry.positionsCompressed.length;
// if (!vboInstancingLayer.canCreatePortion(lenPositions, geometry.indices.length)) { // FIXME: indices should be optional
//     vboInstancingLayer.finalize();
//     delete this._vboInstancingLayers[layerId];
//     vboInstancingLayer = null;
// }
}this._vboInstancingLayers[layerId]=vboInstancingLayer;this.layerList.push(vboInstancingLayer);return vboInstancingLayer;}/**
     * Creates a {@link SceneModelEntity} within this SceneModel.
     *
     * * Gives the SceneModelEntity one or more {@link SceneModelMesh}es previously created with
     * {@link SceneModel#createMesh}. A SceneModelMesh can only belong to one SceneModelEntity, so you'll get an
     * error if you try to reuse a mesh among multiple SceneModelEntitys.
     * * The SceneModelEntity can have a {@link SceneModelTextureSet}, previously created with
     * {@link SceneModel#createTextureSet}. A SceneModelTextureSet can belong to multiple SceneModelEntitys.
     * * The SceneModelEntity can have a geometry, previously created with
     * {@link SceneModel#createTextureSet}. A geometry is a "virtual component" and can belong to multiple SceneModelEntitys.
     *
     * @param {Object} cfg SceneModelEntity configuration.
     * @param {String} cfg.id Optional ID for the new SceneModelEntity. Must not clash with any existing components within the {@link Scene}.
     * @param {String[]} cfg.meshIds IDs of one or more meshes created previously with {@link SceneModel@createMesh}.
     * @param {Boolean} [cfg.isObject] Set ````true```` if the {@link SceneModelEntity} represents an object, in which case it will be registered by {@link SceneModelEntity#id} in {@link Scene#objects} and can also have a corresponding {@link MetaObject} with matching {@link MetaObject#id}, registered by that ID in {@link MetaScene#metaObjects}.
     * @param {Boolean} [cfg.visible=true] Indicates if the SceneModelEntity is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the SceneModelEntity is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the SceneModelEntity is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the SceneModelEntity is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the SceneModelEntity is initially included in boundary calculations.
     * @param {Boolean} [cfg.castsShadow=true] Indicates if the SceneModelEntity initially casts shadows.
     * @param {Boolean} [cfg.receivesShadow=true]  Indicates if the SceneModelEntity initially receives shadows.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the SceneModelEntity is initially xrayed. XRayed appearance is configured by {@link SceneModel#xrayMaterial}.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the SceneModelEntity is initially highlighted. Highlighted appearance is configured by {@link SceneModel#highlightMaterial}.
     * @param {Boolean} [cfg.selected=false] Indicates if the SceneModelEntity is initially selected. Selected appearance is configured by {@link SceneModel#selectedMaterial}.
     * @param {Boolean} [cfg.edges=false] Indicates if the SceneModelEntity's edges are initially emphasized. Edges appearance is configured by {@link SceneModel#edgeMaterial}.
     * @returns {SceneModelEntity} The new SceneModelEntity.
     */},{key:"createEntity",value:function createEntity(cfg){if(cfg.id===undefined){cfg.id=math.createUUID();}else if(this.scene.components[cfg.id]){this.error("Scene already has a Component with this ID: ".concat(cfg.id," - will assign random ID"));cfg.id=math.createUUID();}if(cfg.meshIds===undefined){this.error("Config missing: meshIds");return;}var flags=0;if(this._visible&&cfg.visible!==false){flags=flags|ENTITY_FLAGS.VISIBLE;}if(this._pickable&&cfg.pickable!==false){flags=flags|ENTITY_FLAGS.PICKABLE;}if(this._culled&&cfg.culled!==false){flags=flags|ENTITY_FLAGS.CULLED;}if(this._clippable&&cfg.clippable!==false){flags=flags|ENTITY_FLAGS.CLIPPABLE;}if(this._collidable&&cfg.collidable!==false){flags=flags|ENTITY_FLAGS.COLLIDABLE;}if(this._edges&&cfg.edges!==false){flags=flags|ENTITY_FLAGS.EDGES;}if(this._xrayed&&cfg.xrayed!==false){flags=flags|ENTITY_FLAGS.XRAYED;}if(this._highlighted&&cfg.highlighted!==false){flags=flags|ENTITY_FLAGS.HIGHLIGHTED;}if(this._selected&&cfg.selected!==false){flags=flags|ENTITY_FLAGS.SELECTED;}cfg.flags=flags;this._createEntity(cfg);}},{key:"_createEntity",value:function _createEntity(cfg){var meshes=[];for(var _i419=0,len=cfg.meshIds.length;_i419<len;_i419++){var meshId=cfg.meshIds[_i419];var _mesh2=this._meshes[meshId];// Trying to get already created mesh
if(!_mesh2){// Checks if there is already created mesh for this meshId
this.error("Mesh with this ID not found: \"".concat(meshId,"\" - ignoring this mesh"));// There is no such cfg
continue;}if(_mesh2.parent){this.error("Mesh with ID \"".concat(meshId,"\" already belongs to object with ID \"").concat(_mesh2.parent.id,"\" - ignoring this mesh"));continue;}meshes.push(_mesh2);delete this._unusedMeshes[meshId];}var lodCullable=true;var entity=new SceneModelEntity(this,cfg.isObject,cfg.id,meshes,cfg.flags,lodCullable);// Internally sets SceneModelEntity#parent to this SceneModel
this._entityList.push(entity);this._entities[cfg.id]=entity;this.numEntities++;}/**
     * Finalizes this SceneModel.
     *
     * Once finalized, you can't add anything more to this SceneModel.
     */},{key:"finalize",value:function finalize(){if(this.destroyed){return;}this._createDummyEntityForUnusedMeshes();for(var _i420=0,len=this.layerList.length;_i420<len;_i420++){var layer=this.layerList[_i420];layer.finalize();}this._geometries={};this._dtxBuckets={};this._textures={};this._textureSets={};this._dtxLayers={};this._vboInstancingLayers={};this._vboBatchingLayers={};for(var _i421=0,_len88=this._entityList.length;_i421<_len88;_i421++){var entity=this._entityList[_i421];entity._finalize();}for(var _i422=0,_len89=this._entityList.length;_i422<_len89;_i422++){var _entity=this._entityList[_i422];_entity._finalize2();}// Sort layers to reduce WebGL shader switching when rendering them
this.layerList.sort(function(a,b){if(a.sortId<b.sortId){return-1;}if(a.sortId>b.sortId){return 1;}return 0;});for(var _i423=0,_len90=this.layerList.length;_i423<_len90;_i423++){var _layer=this.layerList[_i423];_layer.layerIndex=_i423;}this.glRedraw();this.scene._aabbDirty=true;this._viewMatrixDirty=true;this._matrixDirty=true;this._aabbDirty=true;this._setWorldMatrixDirty();this._sceneModelDirty();this.position=this._position;}/** @private */},{key:"stateSortCompare",value:function stateSortCompare(drawable1,drawable2){}/** @private */},{key:"rebuildRenderFlags",value:function rebuildRenderFlags(){this.renderFlags.reset();this._updateRenderFlagsVisibleLayers();if(this.renderFlags.numLayers>0&&this.renderFlags.numVisibleLayers===0){this.renderFlags.culled=true;return;}this._updateRenderFlags();}/**
     * @private
     */},{key:"_updateRenderFlagsVisibleLayers",value:function _updateRenderFlagsVisibleLayers(){var renderFlags=this.renderFlags;renderFlags.numLayers=this.layerList.length;renderFlags.numVisibleLayers=0;for(var layerIndex=0,len=this.layerList.length;layerIndex<len;layerIndex++){var layer=this.layerList[layerIndex];var layerVisible=this._getActiveSectionPlanesForLayer(layer);if(layerVisible){renderFlags.visibleLayers[renderFlags.numVisibleLayers++]=layerIndex;}}}/** @private */},{key:"_createDummyEntityForUnusedMeshes",value:function _createDummyEntityForUnusedMeshes(){var unusedMeshIds=Object.keys(this._unusedMeshes);if(unusedMeshIds.length>0){var entityId="".concat(this.id,"-dummyEntityForUnusedMeshes");this.warn("Creating dummy SceneModelEntity \"".concat(entityId,"\" for unused SceneMeshes: [").concat(unusedMeshIds.join(","),"]"));this.createEntity({id:entityId,meshIds:unusedMeshIds,isObject:true});}this._unusedMeshes={};}},{key:"_getActiveSectionPlanesForLayer",value:function _getActiveSectionPlanesForLayer(layer){var renderFlags=this.renderFlags;var sectionPlanes=this.scene._sectionPlanesState.sectionPlanes;var numSectionPlanes=sectionPlanes.length;var baseIndex=layer.layerIndex*numSectionPlanes;if(numSectionPlanes>0){for(var _i424=0;_i424<numSectionPlanes;_i424++){var sectionPlane=sectionPlanes[_i424];if(!sectionPlane.active){renderFlags.sectionPlanesActivePerLayer[baseIndex+_i424]=false;}else{renderFlags.sectionPlanesActivePerLayer[baseIndex+_i424]=true;renderFlags.sectioned=true;}}}return true;}},{key:"_updateRenderFlags",value:function _updateRenderFlags(){if(this.numVisibleLayerPortions===0){return;}if(this.numCulledLayerPortions===this.numPortions){return;}var renderFlags=this.renderFlags;renderFlags.colorOpaque=this.numTransparentLayerPortions<this.numPortions;if(this.numTransparentLayerPortions>0){renderFlags.colorTransparent=true;}if(this.numXRayedLayerPortions>0){var xrayMaterial=this.scene.xrayMaterial._state;if(xrayMaterial.fill){if(xrayMaterial.fillAlpha<1.0){renderFlags.xrayedSilhouetteTransparent=true;}else{renderFlags.xrayedSilhouetteOpaque=true;}}if(xrayMaterial.edges){if(xrayMaterial.edgeAlpha<1.0){renderFlags.xrayedEdgesTransparent=true;}else{renderFlags.xrayedEdgesOpaque=true;}}}if(this.numEdgesLayerPortions>0){var edgeMaterial=this.scene.edgeMaterial._state;if(edgeMaterial.edges){renderFlags.edgesOpaque=this.numTransparentLayerPortions<this.numPortions;if(this.numTransparentLayerPortions>0){renderFlags.edgesTransparent=true;}}}if(this.numSelectedLayerPortions>0){var selectedMaterial=this.scene.selectedMaterial._state;if(selectedMaterial.fill){if(selectedMaterial.fillAlpha<1.0){renderFlags.selectedSilhouetteTransparent=true;}else{renderFlags.selectedSilhouetteOpaque=true;}}if(selectedMaterial.edges){if(selectedMaterial.edgeAlpha<1.0){renderFlags.selectedEdgesTransparent=true;}else{renderFlags.selectedEdgesOpaque=true;}}}if(this.numHighlightedLayerPortions>0){var highlightMaterial=this.scene.highlightMaterial._state;if(highlightMaterial.fill){if(highlightMaterial.fillAlpha<1.0){renderFlags.highlightedSilhouetteTransparent=true;}else{renderFlags.highlightedSilhouetteOpaque=true;}}if(highlightMaterial.edges){if(highlightMaterial.edgeAlpha<1.0){renderFlags.highlightedEdgesTransparent=true;}else{renderFlags.highlightedEdgesOpaque=true;}}}}// -------------- RENDERING ---------------------------------------------------------------------------------------
/** @private */},{key:"drawColorOpaque",value:function drawColorOpaque(frameCtx){var renderFlags=this.renderFlags;for(var _i425=0,len=renderFlags.visibleLayers.length;_i425<len;_i425++){var layerIndex=renderFlags.visibleLayers[_i425];this.layerList[layerIndex].drawColorOpaque(renderFlags,frameCtx);}}/** @private */},{key:"drawColorTransparent",value:function drawColorTransparent(frameCtx){var renderFlags=this.renderFlags;for(var _i426=0,len=renderFlags.visibleLayers.length;_i426<len;_i426++){var layerIndex=renderFlags.visibleLayers[_i426];this.layerList[layerIndex].drawColorTransparent(renderFlags,frameCtx);}}/** @private */},{key:"drawDepth",value:function drawDepth(frameCtx){// Dedicated to SAO because it skips transparent objects
var renderFlags=this.renderFlags;for(var _i427=0,len=renderFlags.visibleLayers.length;_i427<len;_i427++){var layerIndex=renderFlags.visibleLayers[_i427];this.layerList[layerIndex].drawDepth(renderFlags,frameCtx);}}/** @private */},{key:"drawNormals",value:function drawNormals(frameCtx){// Dedicated to SAO because it skips transparent objects
var renderFlags=this.renderFlags;for(var _i428=0,len=renderFlags.visibleLayers.length;_i428<len;_i428++){var layerIndex=renderFlags.visibleLayers[_i428];this.layerList[layerIndex].drawNormals(renderFlags,frameCtx);}}/** @private */},{key:"drawSilhouetteXRayed",value:function drawSilhouetteXRayed(frameCtx){var renderFlags=this.renderFlags;for(var _i429=0,len=renderFlags.visibleLayers.length;_i429<len;_i429++){var layerIndex=renderFlags.visibleLayers[_i429];this.layerList[layerIndex].drawSilhouetteXRayed(renderFlags,frameCtx);}}/** @private */},{key:"drawSilhouetteHighlighted",value:function drawSilhouetteHighlighted(frameCtx){var renderFlags=this.renderFlags;for(var _i430=0,len=renderFlags.visibleLayers.length;_i430<len;_i430++){var layerIndex=renderFlags.visibleLayers[_i430];this.layerList[layerIndex].drawSilhouetteHighlighted(renderFlags,frameCtx);}}/** @private */},{key:"drawSilhouetteSelected",value:function drawSilhouetteSelected(frameCtx){var renderFlags=this.renderFlags;for(var _i431=0,len=renderFlags.visibleLayers.length;_i431<len;_i431++){var layerIndex=renderFlags.visibleLayers[_i431];this.layerList[layerIndex].drawSilhouetteSelected(renderFlags,frameCtx);}}/** @private */},{key:"drawEdgesColorOpaque",value:function drawEdgesColorOpaque(frameCtx){var renderFlags=this.renderFlags;for(var _i432=0,len=renderFlags.visibleLayers.length;_i432<len;_i432++){var layerIndex=renderFlags.visibleLayers[_i432];this.layerList[layerIndex].drawEdgesColorOpaque(renderFlags,frameCtx);}}/** @private */},{key:"drawEdgesColorTransparent",value:function drawEdgesColorTransparent(frameCtx){var renderFlags=this.renderFlags;for(var _i433=0,len=renderFlags.visibleLayers.length;_i433<len;_i433++){var layerIndex=renderFlags.visibleLayers[_i433];this.layerList[layerIndex].drawEdgesColorTransparent(renderFlags,frameCtx);}}/** @private */},{key:"drawEdgesXRayed",value:function drawEdgesXRayed(frameCtx){var renderFlags=this.renderFlags;for(var _i434=0,len=renderFlags.visibleLayers.length;_i434<len;_i434++){var layerIndex=renderFlags.visibleLayers[_i434];this.layerList[layerIndex].drawEdgesXRayed(renderFlags,frameCtx);}}/** @private */},{key:"drawEdgesHighlighted",value:function drawEdgesHighlighted(frameCtx){var renderFlags=this.renderFlags;for(var _i435=0,len=renderFlags.visibleLayers.length;_i435<len;_i435++){var layerIndex=renderFlags.visibleLayers[_i435];this.layerList[layerIndex].drawEdgesHighlighted(renderFlags,frameCtx);}}/** @private */},{key:"drawEdgesSelected",value:function drawEdgesSelected(frameCtx){var renderFlags=this.renderFlags;for(var _i436=0,len=renderFlags.visibleLayers.length;_i436<len;_i436++){var layerIndex=renderFlags.visibleLayers[_i436];this.layerList[layerIndex].drawEdgesSelected(renderFlags,frameCtx);}}/**
     * @private
     */},{key:"drawOcclusion",value:function drawOcclusion(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i437=0,len=renderFlags.visibleLayers.length;_i437<len;_i437++){var layerIndex=renderFlags.visibleLayers[_i437];this.layerList[layerIndex].drawOcclusion(renderFlags,frameCtx);}}/**
     * @private
     */},{key:"drawShadow",value:function drawShadow(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i438=0,len=renderFlags.visibleLayers.length;_i438<len;_i438++){var layerIndex=renderFlags.visibleLayers[_i438];this.layerList[layerIndex].drawShadow(renderFlags,frameCtx);}}/** @private */},{key:"setPickMatrices",value:function setPickMatrices(pickViewMatrix,pickProjMatrix){if(this._numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i439=0,len=renderFlags.visibleLayers.length;_i439<len;_i439++){var layerIndex=renderFlags.visibleLayers[_i439];var layer=this.layerList[layerIndex];if(layer.setPickMatrices){layer.setPickMatrices(pickViewMatrix,pickProjMatrix);}}}/** @private */},{key:"drawPickMesh",value:function drawPickMesh(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i440=0,len=renderFlags.visibleLayers.length;_i440<len;_i440++){var layerIndex=renderFlags.visibleLayers[_i440];this.layerList[layerIndex].drawPickMesh(renderFlags,frameCtx);}}/**
     * Called by SceneModelMesh.drawPickDepths()
     * @private
     */},{key:"drawPickDepths",value:function drawPickDepths(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i441=0,len=renderFlags.visibleLayers.length;_i441<len;_i441++){var layerIndex=renderFlags.visibleLayers[_i441];this.layerList[layerIndex].drawPickDepths(renderFlags,frameCtx);}}/**
     * Called by SceneModelMesh.drawPickNormals()
     * @private
     */},{key:"drawPickNormals",value:function drawPickNormals(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i442=0,len=renderFlags.visibleLayers.length;_i442<len;_i442++){var layerIndex=renderFlags.visibleLayers[_i442];this.layerList[layerIndex].drawPickNormals(renderFlags,frameCtx);}}/**
     * @private
     */},{key:"drawSnapInit",value:function drawSnapInit(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i443=0,len=renderFlags.visibleLayers.length;_i443<len;_i443++){var layerIndex=renderFlags.visibleLayers[_i443];var layer=this.layerList[layerIndex];if(layer.drawSnapInit){frameCtx.snapPickOrigin=[0,0,0];frameCtx.snapPickCoordinateScale=[1,1,1];frameCtx.snapPickLayerNumber++;layer.drawSnapInit(renderFlags,frameCtx);frameCtx.snapPickLayerParams[frameCtx.snapPickLayerNumber]={origin:frameCtx.snapPickOrigin.slice(),coordinateScale:frameCtx.snapPickCoordinateScale.slice()};}}}/**
     * @private
     */},{key:"drawSnap",value:function drawSnap(frameCtx){if(this.numVisibleLayerPortions===0){return;}var renderFlags=this.renderFlags;for(var _i444=0,len=renderFlags.visibleLayers.length;_i444<len;_i444++){var layerIndex=renderFlags.visibleLayers[_i444];var layer=this.layerList[layerIndex];if(layer.drawSnap){frameCtx.snapPickOrigin=[0,0,0];frameCtx.snapPickCoordinateScale=[1,1,1];frameCtx.snapPickLayerNumber++;layer.drawSnap(renderFlags,frameCtx);frameCtx.snapPickLayerParams[frameCtx.snapPickLayerNumber]={origin:frameCtx.snapPickOrigin.slice(),coordinateScale:frameCtx.snapPickCoordinateScale.slice()};}}}/**
     * Destroys this SceneModel.
     */},{key:"destroy",value:function destroy(){for(var layerId in this._vboBatchingLayers){if(this._vboBatchingLayers.hasOwnProperty(layerId)){this._vboBatchingLayers[layerId].destroy();}}this._vboBatchingLayers={};for(var _layerId in this._vboInstancingLayers){if(this._vboInstancingLayers.hasOwnProperty(_layerId)){this._vboInstancingLayers[_layerId].destroy();}}this._vboInstancingLayers={};this.scene.camera.off(this._onCameraViewMatrix);this.scene.off(this._onTick);for(var _i445=0,len=this.layerList.length;_i445<len;_i445++){this.layerList[_i445].destroy();}this.layerList=[];for(var _i446=0,_len91=this._entityList.length;_i446<_len91;_i446++){this._entityList[_i446]._destroy();}// Object.entries(this._geometries).forEach(([id, geometry]) => {
//     geometry.destroy();
// });
this._geometries={};this._dtxBuckets={};this._textures={};this._textureSets={};this._meshes={};this._entities={};this.scene._aabbDirty=true;if(this._isModel){this.scene._deregisterModel(this);}putScratchMemory();_get(_getPrototypeOf(SceneModel.prototype),"destroy",this).call(this);}}]);return SceneModel;}(Component);/**
 * This function applies two steps to the provided mesh geometry data:
 *
 * - 1st, it reduces its `.positions` to unique positions, thus removing duplicate vertices. It will adjust the `.indices` and `.edgeIndices` array accordingly to the unique `.positions`.
 *
 * - 2nd, it tries to do an optimization called `index rebucketting`
 *
 *   _Rebucketting minimizes the amount of RAM usage for a given mesh geometry by trying do demote its needed index bitness._
 *
 *   - _for 32 bit indices, will try to demote them to 16 bit indices_
 *   - _for 16 bit indices, will try to demote them to 8 bits indices_
 *   - _8 bits indices are kept as-is_
 *
 *   The fact that 32/16/8 bits are needed for indices, depends on the number of maximumm indexable vertices within the mesh geometry: this is, the number of vertices in the mesh geometry.
 *
 * The function returns the same provided input `geometry`, enrichened with the additional key `.preparedBukets`.
 *
 * @param {object} geometry The mesh information containing `.positions`, `.indices`, `.edgeIndices` arrays.
 *
 * @param enableVertexWelding
 * @param enableIndexBucketing
 * @returns {object} The mesh information enrichened with `.buckets` key.
 */function createDTXBuckets(geometry,enableVertexWelding,enableIndexBucketing){var uniquePositionsCompressed,uniqueIndices,uniqueEdgeIndices;if(enableVertexWelding||enableIndexBucketing){// Expensive - careful!
var _uniquifyPositions=uniquifyPositions({positionsCompressed:geometry.positionsCompressed,indices:geometry.indices,edgeIndices:geometry.edgeIndices});var _uniquifyPositions2=_slicedToArray(_uniquifyPositions,3);uniquePositionsCompressed=_uniquifyPositions2[0];uniqueIndices=_uniquifyPositions2[1];uniqueEdgeIndices=_uniquifyPositions2[2];}else{uniquePositionsCompressed=geometry.positionsCompressed;uniqueIndices=geometry.indices;uniqueEdgeIndices=geometry.edgeIndices;}var buckets;if(enableIndexBucketing){var numUniquePositions=uniquePositionsCompressed.length/3;buckets=rebucketPositions({positionsCompressed:uniquePositionsCompressed,indices:uniqueIndices,edgeIndices:uniqueEdgeIndices},numUniquePositions>1<<16?16:8// true
);}else{buckets=[{positionsCompressed:uniquePositionsCompressed,indices:uniqueIndices,edgeIndices:uniqueEdgeIndices}];}return buckets;}/**
 * A set of 3D line segments.
 *
 * * Creates a set of 3D line segments.
 * * Registered by {@link LineSet#id} in {@link Scene#lineSets}.
 * * Configure color using the {@link LinesMaterial} located at {@link Scene#linesMaterial}.
 * * {@link BCFViewpointsPlugin} will save and load Linesets in BCF viewpoints.
 *
 * ## Usage
 *
 * In the example below, we'll load the Schependomlaan model, then use
 * a ````LineSet```` to show a grid underneath the model.
 *
 * [<img src="http://xeokit.github.io/xeokit-sdk/assets/images/LineSet_grid.png">](/examples/#LineSet_grid)
 *
 * [[Run this example](/examples/#LineSet_grid)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, LineSet, buildGridGeometry} from "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/xeokit-sdk.es.min.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 *  });
 *
 * const camera = viewer.camera;
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "../assets/models/xkt/v8/ifc/Schependomlaan.ifc.xkt",
 *      position: [0,1,0],
 *      edges: true,
 *      saoEnabled: true
 *  });
 *
 * const geometryArrays = buildGridGeometry({
 *      size: 100,
 *      divisions: 30
 *  });
 *
 * new LineSet(viewer.scene, {
 *      positions: geometryArrays.positions,
 *      indices: geometryArrays.indices
 * });
 * ````
 */var LineSet=/*#__PURE__*/function(_Component28){_inherits(LineSet,_Component28);var _super113=_createSuper(LineSet);/**
     * Creates a new LineSet.
     *
     * Registers the LineSet in {@link Scene#lineSets}; causes Scene to fire a "lineSetCreated" event.
     *
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this ````LineSet```` as well.
     * @param {*} [cfg]  ````LineSet```` configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} cfg.positions World-space 3D vertex positions.
     * @param {Number[]} [cfg.indices] Indices to connect ````positions```` into line segments. Note that these are separate line segments, not a polyline.
     * @param {Number[]} [cfg.color=[0,0,0]] The color of this ````LineSet````. This is both emissive and diffuse.
     * @param {Boolean} [cfg.visible=true] Indicates whether or not this ````LineSet```` is visible.
     * @param {Number} [cfg.opacity=1.0] ````LineSet````'s initial opacity factor.
     */function LineSet(owner){var _this76;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,LineSet);_this76=_super113.call(this,owner,cfg);_this76._positions=cfg.positions||[];if(cfg.indices){_this76._indices=cfg.indices;}else{_this76._indices=[];for(var _i447=0,len=_this76._positions.length/3-1;_i447<len;_i447+=2){_this76._indices.push(_i447);_this76._indices.push(_i447+1);}}_this76._sceneModel=new SceneModel(_assertThisInitialized(_this76),{isModel:false// Don't register in Scene.models
});_this76._sceneModel.createMesh({id:"linesMesh",primitive:"lines",positions:_this76._positions,indices:_this76._indices});_this76._sceneModel.createEntity({meshIds:["linesMesh"],visible:cfg.visible,clippable:cfg.clippable,collidable:cfg.collidable});_this76._sceneModel.finalize();_this76.scene._lineSetCreated(_assertThisInitialized(_this76));return _this76;}/**
     * Sets if this ````LineSet```` is visible.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} visible Set ````true```` to make this ````LineSet```` visible.
     */_createClass(LineSet,[{key:"visible",get:/**
     * Gets if this ````LineSet```` is visible.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */function get(){return this._sceneModel.visible;}/**
     * Gets the 3D World-space vertex positions of the lines in this ````LineSet````.
     *
     * @returns {Number[]}
     */,set:function set(visible){this._sceneModel.visible=visible;}},{key:"positions",get:function get(){return this._positions;}/**
     * Gets the vertex indices of the lines in this ````LineSet````.
     *
     * @returns {Number[]}
     */},{key:"indices",get:function get(){return this._indices;}/**
     * Destroys this ````LineSet````.
     *
     * Removes the ```LineSet```` from {@link Scene#lineSets}; causes Scene to fire a "lineSetDestroyed" event.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(LineSet.prototype),"destroy",this).call(this);// destroyes _sceneModel
this.scene._lineSetDestroyed(this);}}]);return LineSet;}(Component);var tempVec3$5=math.vec3();var tempVec3a$9=math.vec3();var tempVec3b$6=math.vec3();var tempVec3c$4=math.vec3();/**
 * {@link Viewer} plugin that saves and loads BCF viewpoints as JSON objects.
 *
 * [<img src="http://xeokit.github.io/xeokit-sdk/assets/images/BCFViewpointsPlugin.png">](/examples/#BCF_SaveViewpoint)
 *
 * * [[Example 1: Saving viewer state to a BCF viewpoint](https://xeokit.github.io/xeokit-sdk/examples/#BCF_SaveViewpoint)]
 * * [[Example 2: Loading viewer state from a BCF viewpoint](https://xeokit.github.io/xeokit-sdk/examples/#BCF_LoadViewpoint)]
 *
 * ## Overview
 *
 * BCF is an open standard that enables workflow communications between BIM software tools. An XML schema, called
 * Building Collaboration Format (BCF), encodes messages that inform one BIM tool of issues found by another.
 *
 * A BCF viewpoint captures a viewpoint of a model that highlights an issue. The viewpoint can then be loaded by another
 * viewer to examine the issue.
 *
 * Using this plugin, a xeokit {@link Viewer} can exchange BCF-encoded viewpoints with other BIM software,
 * allowing us to use the Viewer to report and view issues in BIM models.
 *
 * This plugin's viewpoints conform to the <a href="https://github.com/buildingSMART/BCF-API">BCF Version 2.1</a> specification.
 *
 * ## Supported BCF Elements
 *
 * BCFViewpointsPlugin saves and loads the following state in BCF viewpoints:
 *
 * * {@link Camera} position, orientation and projection
 * * {@link Entity} visibilities and selection states
 * * {@link SectionPlane}s to slice the model
 * * {@link LineSet}s to show 3D lines
 * * {@link Bitmap}s to show images
 *
 * ## Saving a BCF Viewpoint
 *
 * In the example below we'll create a {@link Viewer}, load an ````.XKT```` model into it using an {@link XKTLoaderPlugin},
 * slice the model in half using a {@link SectionPlanesPlugin}, create a grid ground plane using a {@link LineSet} and a 2D
 * plan view using a {@link Bitmap}, then use a {@link BCFViewpointsPlugin#getViewpoint}
 * to save a viewpoint to JSON, which we'll log to the JavaScript developer console.
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BCF_SaveViewpoint)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, SectionPlanesPlugin,
 *      LineSet, Bitmap, buildGridGeometry, BCFViewpointsPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // Set camera position and orientation
 * viewer.scene.camera.eye = [-48.93, 54.54, 50.41];
 * viewer.scene.camera.look = [0.55, -0.61, -0.55];
 * viewer.scene.camera.up = [0, -1, 0];
 * viewer.scene.camera.perspective.fov = 60;
 *
 * // Add a XKTLoaderPlugin
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * // Add a SectionPlanesPlugin
 * const sectionPlanes = new SectionPlanesPlugin(viewer);
 *
 * // Add a BCFViewpointsPlugin
 * const bcfViewpoints = new BCFViewpointsPlugin(viewer);
 *
 * // Load an .XKT model
 * const modelNode = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true // Emphasise edges
 * });
 *
 * // Slice it in half
 * sectionPlanes.createSectionPlane({
 *      id: "myClip",
 *      pos: [0, 0, 0],
 *      dir: [0.5, 0.0, 0.5]
 * });
 *
 * // Create a bitmap
 * const bitmap = new Bitmap(viewer.scene, {
 *     src: "../assets/images/schependomlaanPlanView.png",
 *      visible: true,
 *      height: 24.0,
 *      pos: [-15, 0, -10],
 *      normal: [0, -1, 0],
 *      up: [0, 0, 1],
 *      collidable: false,
 *      opacity: 1.0,
 *      clippable: false,
 *      pickable: true
 *  });
 *
 * // Create a grid ground plane
 * const geometryArrays = buildGridGeometry({
 *      size: 60,
 *      divisions: 10
 *  });
 *
 * new LineSet(viewer.scene, {
 *      positions: geometryArrays.positions,
 *      indices: geometryArrays.indices,
 *      position: [10,0,10],
 *      clippable: false
 *  });
 *
 * // When model is loaded, select some objects and capture a BCF viewpoint to the console
 * modelNode.on("loaded", () => {
 *
 *      const scene = viewer.scene;
 *
 *      scene.setObjectsSelected([
 *          "3b2U496P5Ebhz5FROhTwFH",
 *          "2MGtJUm9nD$Re1_MDIv0g2",
 *          "3IbuwYOm5EV9Q6cXmwVWqd",
 *          "3lhisrBxL8xgLCRdxNG$2v",
 *          "1uDn0xT8LBkP15zQc9MVDW"
 *      ], true);
 *
 *      const viewpoint = bcfViewpoints.getViewpoint();
 *      const viewpointStr = JSON.stringify(viewpoint, null, 4);
 *
 *      console.log(viewpointStr);
 * });
 * ````
 *
 * The saved BCF viewpoint would look something like below. Note that some elements are truncated for brevity.
 *
 * ````json
 * {
 *      "perspective_camera": {
 *          "camera_view_point": { "x": -48.93, "y": 54.54, "z": 50.41 },
 *          "camera_direction": { "x": 0.55, "y": -0.61, "z": -0.55},
 *          "camera_up_vector": { "x": 0.37, "y": -0.41, "z": 0.83 },
 *          "field_of_view": 60.0
 *      },
 *      "lines": [{
 *          "start_point": { "x": 1.0, "y": 1.0, "z": 1.0 },
 *          "end_point": { "x": 0.0, "y": 0.0, "z": 0.0 },
 *          //...(truncated)
 *      }],
 *      "bitmaps": [{
 *          "bitmap_type": "png",
 *          "bitmap_data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB9AAAAdp...", //...(truncated)
 *          "location": { "x": -15, "y": 10, "z": 0 },
 *          "normal": { "x": 0, "y": 0, "z": -1 },
 *          "up": { "x": 0, "y": -1, "z": 0 },
 *          "height": 24
 *      }],
 *      "clipping_planes": [{
 *          "location": { "x": 0.0, "y": 0.0, "z": 0.0 },
 *          "direction": { "x": 0.5, "y": 0.0, "z": 0.5 }
 *      }],
 *      "snapshot": {
 *          "snapshot_type": "png",
 *          "snapshot_data": "data:image/png;base64,......"
 *      },
 *      "components": {
 *          "visibility": {
 *              "default_visibility": false,
 *              "exceptions": [{
 *                      "ifc_guid": "4$cshxZO9AJBebsni$z9Yk",
 *                      "originating_system": "xeokit.io",
 *                      "authoring_tool_id": "xeokit/v3.2"
 *                  },
 *                  //...
 *              ]
 *          },
 *          "selection": [{
 *                  "ifc_guid": "4$cshxZO9AJBebsni$z9Yk",
 *              },
 *              //...
 *          ]
 *      }
 * }
 * ````
 *
 * ## Saving View Setup Hints
 *
 * BCFViewpointsPlugin can optionally save hints in the viewpoint, which indicate how to set up the view when
 * loading it again.
 *
 * Here's the {@link BCFViewpointsPlugin#getViewpoint} call again, this time saving some hints:
 *
 * ````javascript
 * const viewpoint = bcfViewpoints.getViewpoint({ // Options
 *     spacesVisible: true, // Force IfcSpace types visible in the viewpoint (default is false)
 *     spaceBoundariesVisible: false, // Show IfcSpace boundaries in the viewpoint (default is false)
 *     openingsVisible: true // Force IfcOpening types visible in the viewpoint (default is false)
 * });
 * ````
 *
 * ## Loading a BCF Viewpoint
 *
 * Assuming that we have our BCF viewpoint in a JSON object, let's now restore it with {@link BCFViewpointsPlugin#setViewpoint}:
 *
 * ````javascript
 * bcfViewpoints.setViewpoint(viewpoint);
 * ````
 *
 * ## Handling BCF Incompatibility with xeokit's Camera
 *
 * xeokit's {@link Camera#look} is the current 3D *point-of-interest* (POI).
 *
 * A BCF viewpoint, however, has a direction vector instead of a POI, and so {@link BCFViewpointsPlugin#getViewpoint} saves
 * xeokit's POI as a normalized vector from {@link Camera#eye} to {@link Camera#look}, which unfortunately loses
 * that positional information. Loading the viewpoint with {@link BCFViewpointsPlugin#setViewpoint} will restore {@link Camera#look} to
 * the viewpoint's camera position, offset by the normalized vector.
 *
 * As shown below, providing a ````rayCast```` option to ````setViewpoint```` will set {@link Camera#look} to the closest
 * surface intersection on the direction vector. Internally, ````setViewpoint```` supports this option by firing a ray
 * along the vector, and if that hits an {@link Entity}, sets {@link Camera#look} to ray's intersection point with the
 * Entity's surface.
 *
 * ````javascript
 * bcfViewpoints.setViewpoint(viewpoint, {
 *      rayCast: true // <<--------------- Attempt to set Camera#look to surface intersection point (default)
 * });
 * ````
 *
 * ## Dealing With Loaded Models that are not in the Viewpoint
 *
 * If, for example, we load model "duplex", hide some objects, then save a BCF viewpoint with
 * ````BCFViewpointsPlugin#getViewpoint````, then load another model, "schependomlaan", then load the viewpoint again
 * with ````BCFViewpointsPlugin#setViewpoint````, then sometimes all of the objects in model "schependomlaan" become
 * visible, along with the visible objects in the viewpoint, which belong to model "duplex".
 *
 * The reason is that, when saving a BCF viewpoint, BCF logic works like the following pseudo code:
 *
 * ````
 * If numVisibleObjects < numInvisibleObjects
 *      save IDs of visible objects in BCF
 *      exceptions = "visible objects"
 * else
 *      save IDS of invisible objects in BCF
 *      exceptions = "invisible objects"
 * ````
 *
 * When loading the viewpoint again:
 *
 * ````
 * If exceptions = "visible objects"
 *      hide all objects
 *      show visible objects in BCF
 * else
 *      show all objects
 *      hide invisible objects in BCF
 * ````
 *
 * When the exception is "visible objects", loading the viewpoint shows all the objects in the first, which includes
 * objects in "schependomlaan", which can be confusing, because those were not even loaded when we first
 * saved the viewpoint..
 *
 * To solve this, we can supply a ````defaultInvisible```` option to {@link BCFViewpointsPlugin#getViewpoint}, which
 * will force the plugin to save the IDs of all visible objects while making invisible objects the exception.
 *
 * That way, when we load the viewpoint again, after loading model "schependomlaan", the plugin will hide all objects
 * in the scene first (which will include objects belonging to model "schependomlaan"), then make the objects in the
 * viewpoint visible (which will only be those of object "duplex").
 *
 * ````javascript
 * const viewpoint = bcfViewpoints.getViewpoint({ // Options
 *     //..
 *     defaultInvisible: true
 * });
 * ````
 *
 * [[Run an example](/examples/#BCF_LoadViewpoint_defaultInvisible)]
 *
 * ## Behaviour with XKTLoaderPlugin globalizeObjectIds
 *
 * Whenever we use {@link XKTLoaderPlugin} to load duplicate copies of the same model, after configuring
 * {@link XKTLoaderPlugin#globalizeObjectIds} ````true```` to avoid ````Entity```` ID clashes, this has consequences
 * for BCF viewpoints created by {@link BCFViewpointsPlugin#getViewpoint}.
 *
 * When no duplicate copies of a model are loaded like this, viewpoints created by {@link BCFViewpointsPlugin#getViewpoint} will
 * continue to load as usual in other BIM viewers. Conversely, a viewpoint created for a single model in other BIM viewers
 * will continue to load as usual with ````BCFViewpointsPlugin````.
 *
 * When duplicate copies of a model are loaded, however, viewpoints created by {@link BCFViewpointsPlugin#getViewpoint}
 * will contain certain changes that will affect the viewpoint's portability, however. Such viewpoints will
 * use ````authoring_tool_id```` fields to save the globalized ````Entity#id```` values, which enables the viewpoints to
 * capture the states of the individual ````Entitys```` that represent the duplicate IFC elements. Take a look at the
 * following two examples to learn more.
 *
 * * [Example: Saving a BCF viewpoint containing duplicate models](https://xeokit.github.io/xeokit-sdk/examples/#BCF_SaveViewpoint_MultipleModels)
 * * [Example: Loading a BCF viewpoint containing duplicate models](https://xeokit.github.io/xeokit-sdk/examples/#BCF_LoadViewpoint_MultipleModels)
 *
 * **Caveat:** when loading a BCF viewpoint, we always assume that we have loaded in our target BIM viewer the same models that were
 * loaded in the viewpoint's original authoring application when the viewpoint was created.  In the case of multi-model
 * viewpoints, the target BIM viewer, whether it be xeokit or another BIM viewer, will need to first have those exact
 * models loaded, with their objects having globalized IDs, following the same prefixing scheme we're using in
 * xeokit. Then, the viewpoint's ````authoring_tool_id```` fields will be able to resolve to their objects within the
 * target viewer.
 *
 * @class BCFViewpointsPlugin
 */var BCFViewpointsPlugin=/*#__PURE__*/function(_Plugin4){_inherits(BCFViewpointsPlugin,_Plugin4);var _super114=_createSuper(BCFViewpointsPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="BCFViewpoints"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} [cfg.originatingSystem] Identifies the originating system for BCF records.
     * @param {String} [cfg.authoringTool] Identifies the authoring tool for BCF records.
     */function BCFViewpointsPlugin(viewer){var _this77;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,BCFViewpointsPlugin);_this77=_super114.call(this,"BCFViewpoints",viewer,cfg);/**
         * Identifies the originating system to include in BCF viewpoints saved by this plugin.
         * @property originatingSystem
         * @type {string}
         */_this77.originatingSystem=cfg.originatingSystem||"xeokit.io";/**
         * Identifies the authoring tool to include in BCF viewpoints saved by this plugin.
         * @property authoringTool
         * @type {string}
         */_this77.authoringTool=cfg.authoringTool||"xeokit.io";return _this77;}/**
     * Saves viewer state to a BCF viewpoint.
     *
     * See ````BCFViewpointsPlugin```` class comments for more info.
     *
     * @param {*} [options] Options for getting the viewpoint.
     * @param {Boolean} [options.spacesVisible=false] Indicates whether ````IfcSpace```` types should be forced visible in the viewpoint.
     * @param {Boolean} [options.openingsVisible=false] Indicates whether ````IfcOpening```` types should be forced visible in the viewpoint.
     * @param {Boolean} [options.spaceBoundariesVisible=false] Indicates whether the boundaries of ````IfcSpace```` types should be visible in the viewpoint.
     * @param {Boolean} [options.spacesTranslucent=false] Indicates whether ````IfcSpace```` types should be forced translucent in the viewpoint.
     * @param {Boolean} [options.spaceBoundariesTranslucent=false] Indicates whether the boundaries of ````IfcSpace```` types should be forced translucent in the viewpoint.
     * @param {Boolean} [options.openingsTranslucent=true] Indicates whether ````IfcOpening```` types should be forced translucent in the viewpoint.
     * @param {Boolean} [options.snapshot=true] Indicates whether the snapshot should be included in the viewpoint.
     * @param {Boolean} [options.defaultInvisible=false] When ````true````, will save the default visibility of all objects
     * as ````false````. This means that when we load the viewpoint again, and there are additional models loaded that
     * were not saved in the viewpoint, those models will be hidden when we load the viewpoint, and that only the
     * objects in the viewpoint will be visible.
     * @param {Boolean} [options.reverseClippingPlanes=false] When ````true````, clipping planes are reversed (https://github.com/buildingSMART/BCF-XML/issues/193)
     * @returns {*} BCF JSON viewpoint object
     */_createClass(BCFViewpointsPlugin,[{key:"getViewpoint",value:function getViewpoint(){var _this78=this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var scene=this.viewer.scene;var camera=scene.camera;var realWorldOffset=scene.realWorldOffset;var reverseClippingPlanes=options.reverseClippingPlanes===true;var bcfViewpoint={};// Camera
var lookDirection=math.normalizeVec3(math.subVec3(camera.look,camera.eye,math.vec3()));var eye=camera.eye;var up=camera.up;if(camera.yUp){// BCF is Z up
lookDirection=YToZ(lookDirection);eye=YToZ(eye);up=YToZ(up);}var camera_view_point=xyzArrayToObject(math.addVec3(eye,realWorldOffset));if(camera.projection==="ortho"){bcfViewpoint.orthogonal_camera={camera_view_point:camera_view_point,camera_direction:xyzArrayToObject(lookDirection),camera_up_vector:xyzArrayToObject(up),view_to_world_scale:camera.ortho.scale};}else{bcfViewpoint.perspective_camera={camera_view_point:camera_view_point,camera_direction:xyzArrayToObject(lookDirection),camera_up_vector:xyzArrayToObject(up),field_of_view:camera.perspective.fov};}// Section planes
var sectionPlanes=scene.sectionPlanes;for(var id in sectionPlanes){if(sectionPlanes.hasOwnProperty(id)){var sectionPlane=sectionPlanes[id];if(!sectionPlane.active){continue;}var location=sectionPlane.pos;var _direction=void 0;if(reverseClippingPlanes){_direction=math.negateVec3(sectionPlane.dir,math.vec3());}else{_direction=sectionPlane.dir;}if(camera.yUp){// BCF is Z up
location=YToZ(location);_direction=YToZ(_direction);}math.addVec3(location,realWorldOffset);location=xyzArrayToObject(location);_direction=xyzArrayToObject(_direction);if(!bcfViewpoint.clipping_planes){bcfViewpoint.clipping_planes=[];}bcfViewpoint.clipping_planes.push({location:location,direction:_direction});}}// Lines
var lineSets=scene.lineSets;for(var _id2 in lineSets){if(lineSets.hasOwnProperty(_id2)){var lineSet=lineSets[_id2];if(!bcfViewpoint.lines){bcfViewpoint.lines=[];}var positions=lineSet.positions;var indices=lineSet.indices;for(var _i448=0,len=indices.length/2;_i448<len;_i448++){var _a5=indices[_i448*2];var b=indices[_i448*2+1];bcfViewpoint.lines.push({start_point:{x:positions[_a5*3+0],y:positions[_a5*3+1],z:positions[_a5*3+2]},end_point:{x:positions[b*3+0],y:positions[b*3+1],z:positions[b*3+2]}});}}}// Bitmaps
var bitmaps=scene.bitmaps;for(var _id3 in bitmaps){if(bitmaps.hasOwnProperty(_id3)){var bitmap=bitmaps[_id3];var _location=bitmap.pos;var normal=bitmap.normal;var _up=bitmap.up;if(camera.yUp){// BCF is Z up
_location=YToZ(_location);normal=YToZ(normal);_up=YToZ(_up);}math.addVec3(_location,realWorldOffset);if(!bcfViewpoint.bitmaps){bcfViewpoint.bitmaps=[];}bcfViewpoint.bitmaps.push({bitmap_type:bitmap.type,bitmap_data:bitmap.imageData,location:xyzArrayToObject(_location),normal:xyzArrayToObject(normal),up:xyzArrayToObject(_up),height:bitmap.height});}}// Entity states
bcfViewpoint.components={visibility:{view_setup_hints:{spaces_visible:!!options.spacesVisible,space_boundaries_visible:!!options.spaceBoundariesVisible,openings_visible:!!options.openingsVisible,spaces_translucent:!!options.spaces_translucent,space_boundaries_translucent:!!options.space_boundaries_translucent,openings_translucent:!!options.openings_translucent}}};var opacityObjectIds=new Set(scene.opacityObjectIds);var xrayedObjectIds=new Set(scene.xrayedObjectIds);var colorizedObjectIds=new Set(scene.colorizedObjectIds);var coloringMap=Object.values(scene.objects).filter(function(entity){return opacityObjectIds.has(entity.id)||colorizedObjectIds.has(entity.id)||xrayedObjectIds.has(entity.id);}).reduce(function(coloringMap,entity){var color=colorizeToRGB(entity.colorize);var alpha;if(entity.xrayed){if(scene.xrayMaterial.fillAlpha===0.0&&scene.xrayMaterial.edgeAlpha!==0.0){// BCF can't deal with edges. If xRay is implemented only with edges, set an arbitrary opacity
alpha=0.1;}else{alpha=scene.xrayMaterial.fillAlpha;}alpha=Math.round(alpha*255).toString(16).padStart(2,"0");color=alpha+color;}else if(opacityObjectIds.has(entity.id)){alpha=Math.round(entity.opacity*255).toString(16).padStart(2,"0");color=alpha+color;}if(!coloringMap[color]){coloringMap[color]=[];}var objectId=entity.id;var originalSystemId=entity.originalSystemId;var component={ifc_guid:originalSystemId,originating_system:_this78.originatingSystem};if(originalSystemId!==objectId){component.authoring_tool_id=objectId;}coloringMap[color].push(component);return coloringMap;},{});var coloringArray=Object.entries(coloringMap).map(function(_ref14){var _ref15=_slicedToArray(_ref14,2),color=_ref15[0],components=_ref15[1];return{color:color,components:components};});bcfViewpoint.components.coloring=coloringArray;var objectIds=scene.objectIds;var visibleObjects=scene.visibleObjects;var visibleObjectIds=scene.visibleObjectIds;var invisibleObjectIds=objectIds.filter(function(id){return!visibleObjects[id];});var selectedObjectIds=scene.selectedObjectIds;if(options.defaultInvisible||visibleObjectIds.length<invisibleObjectIds.length){bcfViewpoint.components.visibility.exceptions=this._createBCFComponents(visibleObjectIds);bcfViewpoint.components.visibility.default_visibility=false;}else{bcfViewpoint.components.visibility.exceptions=this._createBCFComponents(invisibleObjectIds);bcfViewpoint.components.visibility.default_visibility=true;}bcfViewpoint.components.selection=this._createBCFComponents(selectedObjectIds);bcfViewpoint.components.translucency=this._createBCFComponents(scene.xrayedObjectIds);if(options.snapshot!==false){bcfViewpoint.snapshot={snapshot_type:"png",snapshot_data:this.viewer.getSnapshot({format:"png"})};}return bcfViewpoint;}},{key:"_createBCFComponents",value:function _createBCFComponents(objectIds){var scene=this.viewer.scene;var components=[];for(var _i449=0,len=objectIds.length;_i449<len;_i449++){var objectId=objectIds[_i449];var entity=scene.objects[objectId];if(entity){var component={ifc_guid:entity.originalSystemId,originating_system:this.originatingSystem};if(entity.originalSystemId!==objectId){component.authoring_tool_id=objectId;}components.push(component);}}return components;}/**
     * Sets viewer state to the given BCF viewpoint.
     *
     * Note that xeokit's {@link Camera#look} is the **point-of-interest**, whereas the BCF ````camera_direction```` is a
     * direction vector. Therefore, when loading a BCF viewpoint, we set {@link Camera#look} to the absolute position
     * obtained by offsetting the BCF ````camera_view_point````  along ````camera_direction````.
     *
     * When loading a viewpoint, we also have the option to find {@link Camera#look} as the closest point of intersection
     * (on the surface of any visible and pickable {@link Entity}) with a 3D ray fired from ````camera_view_point```` in
     * the direction of ````camera_direction````.
     *
     * @param {*} bcfViewpoint  BCF JSON viewpoint object,
     * shows default visible entities and restores camera to initial default position.
     * @param {*} [options] Options for setting the viewpoint.
     * @param {Boolean} [options.rayCast=true] When ````true```` (default), will attempt to set {@link Camera#look} to the closest
     * point of surface intersection with a ray fired from the BCF ````camera_view_point```` in the direction of ````camera_direction````.
     * @param {Boolean} [options.immediate=true] When ````true```` (default), immediately set camera position.
     * @param {Boolean} [options.duration] Flight duration in seconds.  Overrides {@link CameraFlightAnimation#duration}. Only applies when ````immediate```` is ````false````.
     * @param {Boolean} [options.reset=true] When ````true```` (default), set {@link Entity#xrayed} and {@link Entity#highlighted} ````false```` on all scene objects.
     * @param {Boolean} [options.reverseClippingPlanes=false] When ````true````, clipping planes are reversed (https://github.com/buildingSMART/BCF-XML/issues/193)
     * @param {Boolean} [options.updateCompositeObjects=false] When ````true````, then when visibility and selection updates refer to composite objects (eg. an IfcBuildingStorey),
     * then this method will apply the updates to objects within those composites.
     */},{key:"setViewpoint",value:function setViewpoint(bcfViewpoint){var _this79=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!bcfViewpoint){return;}var viewer=this.viewer;var scene=viewer.scene;var camera=scene.camera;var rayCast=options.rayCast!==false;var immediate=options.immediate!==false;var reset=options.reset!==false;var realWorldOffset=scene.realWorldOffset;var reverseClippingPlanes=options.reverseClippingPlanes===true;scene.clearSectionPlanes();if(bcfViewpoint.clipping_planes&&bcfViewpoint.clipping_planes.length>0){bcfViewpoint.clipping_planes.forEach(function(e){var pos=xyzObjectToArray(e.location,tempVec3$5);var dir=xyzObjectToArray(e.direction,tempVec3$5);if(reverseClippingPlanes){math.negateVec3(dir);}math.subVec3(pos,realWorldOffset);if(camera.yUp){pos=ZToY(pos);dir=ZToY(dir);}new SectionPlane(scene,{pos:pos,dir:dir});});}scene.clearLines();if(bcfViewpoint.lines&&bcfViewpoint.lines.length>0){var positions=[];var indices=[];var _i450=0;bcfViewpoint.lines.forEach(function(e){if(!e.start_point){return;}if(!e.end_point){return;}positions.push(e.start_point.x);positions.push(e.start_point.y);positions.push(e.start_point.z);positions.push(e.end_point.x);positions.push(e.end_point.y);positions.push(e.end_point.z);indices.push(_i450++);indices.push(_i450++);});new LineSet(scene,{positions:positions,indices:indices,clippable:false,collidable:true});}scene.clearBitmaps();if(bcfViewpoint.bitmaps&&bcfViewpoint.bitmaps.length>0){bcfViewpoint.bitmaps.forEach(function(e){var bitmap_type=e.bitmap_type||"jpg";// "jpg" | "png"
var bitmap_data=e.bitmap_data;// base64
var location=xyzObjectToArray(e.location,tempVec3a$9);var normal=xyzObjectToArray(e.normal,tempVec3b$6);var up=xyzObjectToArray(e.up,tempVec3c$4);var height=e.height||1;if(!bitmap_type){return;}if(!bitmap_data){return;}if(!location){return;}if(!normal){return;}if(!up){return;}if(camera.yUp){location=ZToY(location);normal=ZToY(normal);up=ZToY(up);}new Bitmap(scene,{src:bitmap_data,type:bitmap_type,pos:location,normal:normal,up:up,clippable:false,collidable:true,height:height});});}if(reset){scene.setObjectsXRayed(scene.xrayedObjectIds,false);scene.setObjectsHighlighted(scene.highlightedObjectIds,false);scene.setObjectsSelected(scene.selectedObjectIds,false);}if(bcfViewpoint.components){if(bcfViewpoint.components.visibility){if(!bcfViewpoint.components.visibility.default_visibility){scene.setObjectsVisible(scene.objectIds,false);if(bcfViewpoint.components.visibility.exceptions){bcfViewpoint.components.visibility.exceptions.forEach(function(component){return _this79._withBCFComponent(options,component,function(entity){return entity.visible=true;});});}}else{scene.setObjectsVisible(scene.objectIds,true);if(bcfViewpoint.components.visibility.exceptions){bcfViewpoint.components.visibility.exceptions.forEach(function(component){return _this79._withBCFComponent(options,component,function(entity){return entity.visible=false;});});}}var view_setup_hints=bcfViewpoint.components.visibility.view_setup_hints;if(view_setup_hints){if(view_setup_hints.spaces_visible===false){scene.setObjectsVisible(viewer.metaScene.getObjectIDsByType("IfcSpace"),true);}if(view_setup_hints.spaces_translucent!==undefined){scene.setObjectsXRayed(viewer.metaScene.getObjectIDsByType("IfcSpace"),true);}if(view_setup_hints.space_boundaries_visible!==undefined);if(view_setup_hints.openings_visible===false){scene.setObjectsVisible(viewer.metaScene.getObjectIDsByType("IfcOpening"),true);}if(view_setup_hints.space_boundaries_translucent!==undefined);if(view_setup_hints.openings_translucent!==undefined){scene.setObjectsXRayed(viewer.metaScene.getObjectIDsByType("IfcOpening"),true);}}}if(bcfViewpoint.components.selection){scene.setObjectsSelected(scene.selectedObjectIds,false);bcfViewpoint.components.selection.forEach(function(component){return _this79._withBCFComponent(options,component,function(entity){return entity.selected=true;});});}if(bcfViewpoint.components.translucency){scene.setObjectsXRayed(scene.xrayedObjectIds,false);bcfViewpoint.components.translucency.forEach(function(component){return _this79._withBCFComponent(options,component,function(entity){return entity.xrayed=true;});});}if(bcfViewpoint.components.coloring){bcfViewpoint.components.coloring.forEach(function(coloring){var color=coloring.color;var alpha=0;var alphaDefined=false;if(color.length===8){alpha=parseInt(color.substring(0,2),16)/256;if(alpha<=1.0&&alpha>=0.95){alpha=1.0;}color=color.substring(2);alphaDefined=true;}var colorize=[parseInt(color.substring(0,2),16)/256,parseInt(color.substring(2,4),16)/256,parseInt(color.substring(4,6),16)/256];coloring.components.map(function(component){return _this79._withBCFComponent(options,component,function(entity){entity.colorize=colorize;if(alphaDefined){entity.opacity=alpha;}});});});}}if(bcfViewpoint.perspective_camera||bcfViewpoint.orthogonal_camera){var eye;var look;var up;var projection;if(bcfViewpoint.perspective_camera){eye=xyzObjectToArray(bcfViewpoint.perspective_camera.camera_view_point,tempVec3$5);look=xyzObjectToArray(bcfViewpoint.perspective_camera.camera_direction,tempVec3$5);up=xyzObjectToArray(bcfViewpoint.perspective_camera.camera_up_vector,tempVec3$5);camera.perspective.fov=bcfViewpoint.perspective_camera.field_of_view;projection="perspective";}else{eye=xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_view_point,tempVec3$5);look=xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_direction,tempVec3$5);up=xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_up_vector,tempVec3$5);camera.ortho.scale=bcfViewpoint.orthogonal_camera.view_to_world_scale;projection="ortho";}math.subVec3(eye,realWorldOffset);if(camera.yUp){eye=ZToY(eye);look=ZToY(look);up=ZToY(up);}if(rayCast){var hit=scene.pick({pickSurface:true,// <<------ This causes picking to find the intersection point on the entity
origin:eye,direction:look});look=hit?hit.worldPos:math.addVec3(eye,look,tempVec3$5);}else{look=math.addVec3(eye,look,tempVec3$5);}if(immediate){camera.eye=eye;camera.look=look;camera.up=up;camera.projection=projection;}else{viewer.cameraFlight.flyTo({eye:eye,look:look,up:up,duration:options.duration,projection:projection});}}}},{key:"_withBCFComponent",value:function _withBCFComponent(options,component,callback){var viewer=this.viewer;var scene=viewer.scene;if(component.authoring_tool_id&&component.originating_system===this.originatingSystem){var id=component.authoring_tool_id;var entity=scene.objects[id];if(entity){callback(entity);return;}if(options.updateCompositeObjects){var metaObject=viewer.metaScene.metaObjects[id];if(metaObject){scene.withObjects(viewer.metaScene.getObjectIDsInSubtree(id),callback);return;}}}if(component.ifc_guid){var originalSystemId=component.ifc_guid;var _entity2=scene.objects[originalSystemId];if(_entity2){callback(_entity2);return;}if(options.updateCompositeObjects){var _metaObject=viewer.metaScene.metaObjects[originalSystemId];if(_metaObject){scene.withObjects(viewer.metaScene.getObjectIDsInSubtree(originalSystemId),callback);return;}}Object.keys(scene.models).forEach(function(modelId){var id=math.globalizeObjectId(modelId,originalSystemId);var entity=scene.objects[id];if(entity){callback(entity);return;}if(options.updateCompositeObjects){var _metaObject2=viewer.metaScene.metaObjects[id];if(_metaObject2){scene.withObjects(viewer.metaScene.getObjectIDsInSubtree(id),callback);}}});}}/**
     * Destroys this BCFViewpointsPlugin.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(BCFViewpointsPlugin.prototype),"destroy",this).call(this);}}]);return BCFViewpointsPlugin;}(Plugin);function xyzArrayToObject(arr){return{"x":arr[0],"y":arr[1],"z":arr[2]};}function xyzObjectToArray(xyz,arry){arry=new Float64Array(3);arry[0]=xyz.x;arry[1]=xyz.y;arry[2]=xyz.z;return arry;}function YToZ(vec){return new Float64Array([vec[0],-vec[2],vec[1]]);}function ZToY(vec){return new Float64Array([vec[0],vec[2],-vec[1]]);}function colorizeToRGB(color){var rgb="";rgb+=Math.round(color[0]*255).toString(16).padStart(2,"0");rgb+=Math.round(color[1]*255).toString(16).padStart(2,"0");rgb+=Math.round(color[2]*255).toString(16).padStart(2,"0");return rgb;}var distVec3=math.vec3();var lengthWire=function lengthWire(x1,y1,x2,y2){var a=x1-x2;var b=y1-y2;return Math.sqrt(a*a+b*b);};/**
 * @desc Measures the distance between two 3D points.
 *
 * See {@link DistanceMeasurementsPlugin} for more info.
 */var DistanceMeasurement=/*#__PURE__*/function(_Component29){_inherits(DistanceMeasurement,_Component29);var _super115=_createSuper(DistanceMeasurement);/**
     * @private
     */function DistanceMeasurement(plugin){var _this80;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,DistanceMeasurement);_this80=_super115.call(this,plugin.viewer.scene,cfg);/**
         * The {@link DistanceMeasurementsPlugin} that owns this DistanceMeasurement.
         * @type {DistanceMeasurementsPlugin}
         */_this80.plugin=plugin;_this80._container=cfg.container;if(!_this80._container){throw"config missing: container";}_this80._eventSubs={};var scene=_this80.plugin.viewer.scene;_this80._originMarker=new Marker(scene,cfg.origin);_this80._targetMarker=new Marker(scene,cfg.target);_this80._originWorld=math.vec3();_this80._targetWorld=math.vec3();_this80._wp=new Float64Array(24);_this80._vp=new Float64Array(24);_this80._pp=new Float64Array(24);_this80._cp=new Float64Array(8);_this80._xAxisLabelCulled=false;_this80._yAxisLabelCulled=false;_this80._zAxisLabelCulled=false;_this80._color=cfg.color||_this80.plugin.defaultColor;var onMouseOver=cfg.onMouseOver?function(event){cfg.onMouseOver(event,_assertThisInitialized(_this80));_this80.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mouseover',event));}:null;var onMouseLeave=cfg.onMouseLeave?function(event){cfg.onMouseLeave(event,_assertThisInitialized(_this80));_this80.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mouseleave',event));}:null;var onMouseDown=function onMouseDown(event){_this80.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mousedown',event));};var onMouseUp=function onMouseUp(event){_this80.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mouseup',event));};var onMouseMove=function onMouseMove(event){_this80.plugin.viewer.scene.canvas.canvas.dispatchEvent(new MouseEvent('mousemove',event));};var onContextMenu=cfg.onContextMenu?function(event){cfg.onContextMenu(event,_assertThisInitialized(_this80));}:null;var onMouseWheel=function onMouseWheel(event){_this80.plugin.viewer.scene.canvas.canvas.dispatchEvent(new WheelEvent('wheel',event));};_this80._originDot=new Dot(_this80._container,{fillColor:_this80._color,zIndex:plugin.zIndex!==undefined?plugin.zIndex+2:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._targetDot=new Dot(_this80._container,{fillColor:_this80._color,zIndex:plugin.zIndex!==undefined?plugin.zIndex+2:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._lengthWire=new Wire(_this80._container,{color:_this80._color,thickness:2,thicknessClickable:6,zIndex:plugin.zIndex!==undefined?plugin.zIndex+1:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._xAxisWire=new Wire(_this80._container,{color:"#FF0000",thickness:1,thicknessClickable:6,zIndex:plugin.zIndex!==undefined?plugin.zIndex+1:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._yAxisWire=new Wire(_this80._container,{color:"green",thickness:1,thicknessClickable:6,zIndex:plugin.zIndex!==undefined?plugin.zIndex+1:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._zAxisWire=new Wire(_this80._container,{color:"blue",thickness:1,thicknessClickable:6,zIndex:plugin.zIndex!==undefined?plugin.zIndex+1:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._lengthLabel=new Label(_this80._container,{fillColor:_this80._color,prefix:"",text:"",zIndex:plugin.zIndex!==undefined?plugin.zIndex+4:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._xAxisLabel=new Label(_this80._container,{fillColor:"red",prefix:"X",text:"",zIndex:plugin.zIndex!==undefined?plugin.zIndex+3:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._yAxisLabel=new Label(_this80._container,{fillColor:"green",prefix:"Y",text:"",zIndex:plugin.zIndex!==undefined?plugin.zIndex+3:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._zAxisLabel=new Label(_this80._container,{fillColor:"blue",prefix:"Z",text:"",zIndex:plugin.zIndex!==undefined?plugin.zIndex+3:undefined,onMouseOver:onMouseOver,onMouseLeave:onMouseLeave,onMouseWheel:onMouseWheel,onMouseDown:onMouseDown,onMouseUp:onMouseUp,onMouseMove:onMouseMove,onContextMenu:onContextMenu});_this80._wpDirty=false;_this80._vpDirty=false;_this80._cpDirty=false;_this80._sectionPlanesDirty=true;_this80._visible=false;_this80._originVisible=false;_this80._targetVisible=false;_this80._wireVisible=false;_this80._axisVisible=false;_this80._xAxisVisible=false;_this80._yAxisVisible=false;_this80._zAxisVisible=false;_this80._axisEnabled=true;_this80._labelsVisible=false;_this80._labelsOnWires=false;_this80._clickable=false;_this80._originMarker.on("worldPos",function(value){_this80._originWorld.set(value||[0,0,0]);_this80._wpDirty=true;_this80._needUpdate(0);// No lag
});_this80._targetMarker.on("worldPos",function(value){_this80._targetWorld.set(value||[0,0,0]);_this80._wpDirty=true;_this80._needUpdate(0);// No lag
});_this80._onViewMatrix=scene.camera.on("viewMatrix",function(){_this80._vpDirty=true;_this80._needUpdate(0);// No lag
});_this80._onProjMatrix=scene.camera.on("projMatrix",function(){_this80._cpDirty=true;_this80._needUpdate();});_this80._onCanvasBoundary=scene.canvas.on("boundary",function(){_this80._cpDirty=true;_this80._needUpdate(0);// No lag
});_this80._onMetricsUnits=scene.metrics.on("units",function(){_this80._cpDirty=true;_this80._needUpdate();});_this80._onMetricsScale=scene.metrics.on("scale",function(){_this80._cpDirty=true;_this80._needUpdate();});_this80._onMetricsOrigin=scene.metrics.on("origin",function(){_this80._cpDirty=true;_this80._needUpdate();});_this80._onSectionPlaneUpdated=scene.on("sectionPlaneUpdated",function(){_this80._sectionPlanesDirty=true;_this80._needUpdate();});_this80.approximate=cfg.approximate;_this80.visible=cfg.visible;_this80.originVisible=cfg.originVisible;_this80.targetVisible=cfg.targetVisible;_this80.wireVisible=cfg.wireVisible;_this80.axisVisible=cfg.axisVisible;_this80.xAxisVisible=cfg.xAxisVisible;_this80.yAxisVisible=cfg.yAxisVisible;_this80.zAxisVisible=cfg.zAxisVisible;_this80.labelsVisible=cfg.labelsVisible;_this80.labelsOnWires=cfg.labelsOnWires;return _this80;}_createClass(DistanceMeasurement,[{key:"_update",value:function _update(){if(!this._visible){return;}var scene=this.plugin.viewer.scene;if(this._wpDirty){this._wp[0]=this._originWorld[0];this._wp[1]=this._originWorld[1];this._wp[2]=this._originWorld[2];this._wp[3]=1.0;this._wp[4]=this._targetWorld[0];this._wp[5]=this._originWorld[1];this._wp[6]=this._originWorld[2];this._wp[7]=1.0;this._wp[8]=this._targetWorld[0];this._wp[9]=this._targetWorld[1];this._wp[10]=this._originWorld[2];this._wp[11]=1.0;this._wp[12]=this._targetWorld[0];this._wp[13]=this._targetWorld[1];this._wp[14]=this._targetWorld[2];this._wp[15]=1.0;this._wpDirty=false;this._vpDirty=true;}if(this._vpDirty){math.transformPositions4(scene.camera.viewMatrix,this._wp,this._vp);this._vp[3]=1.0;this._vp[7]=1.0;this._vp[11]=1.0;this._vp[15]=1.0;this._vpDirty=false;this._cpDirty=true;}if(this._sectionPlanesDirty){if(this._isSliced(this._originWorld)||this._isSliced(this._targetWorld)){this._xAxisLabel.setCulled(true);this._yAxisLabel.setCulled(true);this._zAxisLabel.setCulled(true);this._lengthLabel.setCulled(true);this._xAxisWire.setCulled(true);this._yAxisWire.setCulled(true);this._zAxisWire.setCulled(true);this._lengthWire.setCulled(true);this._originDot.setCulled(true);this._targetDot.setCulled(true);return;}else{this._xAxisLabel.setCulled(false);this._yAxisLabel.setCulled(false);this._zAxisLabel.setCulled(false);this._lengthLabel.setCulled(false);this._xAxisWire.setCulled(false);this._yAxisWire.setCulled(false);this._zAxisWire.setCulled(false);this._lengthWire.setCulled(false);this._originDot.setCulled(false);this._targetDot.setCulled(false);}this._sectionPlanesDirty=true;}var near=-0.3;var vpz1=this._originMarker.viewPos[2];var vpz2=this._targetMarker.viewPos[2];if(vpz1>near||vpz2>near){this._xAxisLabel.setCulled(true);this._yAxisLabel.setCulled(true);this._zAxisLabel.setCulled(true);this._lengthLabel.setCulled(true);this._xAxisWire.setVisible(false);this._yAxisWire.setVisible(false);this._zAxisWire.setVisible(false);this._lengthWire.setVisible(false);this._originDot.setVisible(false);this._targetDot.setVisible(false);return;}if(this._cpDirty){math.transformPositions4(scene.camera.project.matrix,this._vp,this._pp);var pp=this._pp;var cp=this._cp;var canvas=scene.canvas.canvas;var offsets=canvas.getBoundingClientRect();var containerOffsets=this._container.getBoundingClientRect();var top=offsets.top-containerOffsets.top;var left=offsets.left-containerOffsets.left;var aabb=scene.canvas.boundary;var canvasWidth=aabb[2];var canvasHeight=aabb[3];var j=0;var metrics=this.plugin.viewer.scene.metrics;var _scale5=metrics.scale;var units=metrics.units;var unitInfo=metrics.unitsInfo[units];var unitAbbrev=unitInfo.abbrev;for(var i=0,len=pp.length;i<len;i+=4){cp[j]=left+Math.floor((1+pp[i+0]/pp[i+3])*canvasWidth/2);cp[j+1]=top+Math.floor((1-pp[i+1]/pp[i+3])*canvasHeight/2);j+=2;}this._originDot.setPos(cp[0],cp[1]);this._targetDot.setPos(cp[6],cp[7]);this._lengthWire.setStartAndEnd(cp[0],cp[1],cp[6],cp[7]);this._xAxisWire.setStartAndEnd(cp[0],cp[1],cp[2],cp[3]);this._yAxisWire.setStartAndEnd(cp[2],cp[3],cp[4],cp[5]);this._zAxisWire.setStartAndEnd(cp[4],cp[5],cp[6],cp[7]);if(!this.labelsVisible){this._lengthLabel.setCulled(true);this._xAxisLabel.setCulled(true);this._yAxisLabel.setCulled(true);this._zAxisLabel.setCulled(true);}else{this._lengthLabel.setPosOnWire(cp[0],cp[1],cp[6],cp[7]);if(this.labelsOnWires){this._xAxisLabel.setPosOnWire(cp[0],cp[1],cp[2],cp[3]);this._yAxisLabel.setPosOnWire(cp[2],cp[3],cp[4],cp[5]);this._zAxisLabel.setPosOnWire(cp[4],cp[5],cp[6],cp[7]);}else{var labelOffset=35;var currentLabelOffset=labelOffset;this._xAxisLabel.setPosOnWire(cp[0],cp[1]+currentLabelOffset,cp[6],cp[7]+currentLabelOffset);currentLabelOffset+=labelOffset;this._yAxisLabel.setPosOnWire(cp[0],cp[1]+currentLabelOffset,cp[6],cp[7]+currentLabelOffset);currentLabelOffset+=labelOffset;this._zAxisLabel.setPosOnWire(cp[0],cp[1]+currentLabelOffset,cp[6],cp[7]+currentLabelOffset);}var tilde=this._approximate?" ~ ":" = ";this._length=Math.abs(math.lenVec3(math.subVec3(this._targetWorld,this._originWorld,distVec3)));this._lengthLabel.setText(tilde+(this._length*_scale5).toFixed(2)+unitAbbrev);var xAxisCanvasLength=Math.abs(lengthWire(cp[0],cp[1],cp[2],cp[3]));var yAxisCanvasLength=Math.abs(lengthWire(cp[2],cp[3],cp[4],cp[5]));var zAxisCanvasLength=Math.abs(lengthWire(cp[4],cp[5],cp[6],cp[7]));var labelMinAxisLength=this.plugin.labelMinAxisLength;if(this.labelsOnWires){this._xAxisLabelCulled=xAxisCanvasLength<labelMinAxisLength;this._yAxisLabelCulled=yAxisCanvasLength<labelMinAxisLength;this._zAxisLabelCulled=zAxisCanvasLength<labelMinAxisLength;}else{this._xAxisLabelCulled=false;this._yAxisLabelCulled=false;this._zAxisLabelCulled=false;}if(!this._xAxisLabelCulled){this._xAxisLabel.setText(tilde+Math.abs((this._targetWorld[0]-this._originWorld[0])*_scale5).toFixed(2)+unitAbbrev);this._xAxisLabel.setCulled(!this.axisVisible);}else{this._xAxisLabel.setCulled(true);}if(!this._yAxisLabelCulled){this._yAxisLabel.setText(tilde+Math.abs((this._targetWorld[1]-this._originWorld[1])*_scale5).toFixed(2)+unitAbbrev);this._yAxisLabel.setCulled(!this.axisVisible);}else{this._yAxisLabel.setCulled(true);}if(!this._zAxisLabelCulled){this._zAxisLabel.setText(tilde+Math.abs((this._targetWorld[2]-this._originWorld[2])*_scale5).toFixed(2)+unitAbbrev);this._zAxisLabel.setCulled(!this.axisVisible);}else{this._zAxisLabel.setCulled(true);}}// this._xAxisLabel.setVisible(this.axisVisible && this.xAxisVisible);
// this._yAxisLabel.setVisible(this.axisVisible && this.yAxisVisible);
// this._zAxisLabel.setVisible(this.axisVisible && this.zAxisVisible);
// this._lengthLabel.setVisible(false);
this._originDot.setVisible(this._visible&&this._originVisible);this._targetDot.setVisible(this._visible&&this._targetVisible);this._xAxisWire.setVisible(this.axisVisible&&this.xAxisVisible);this._yAxisWire.setVisible(this.axisVisible&&this.yAxisVisible);this._zAxisWire.setVisible(this.axisVisible&&this.zAxisVisible);this._lengthWire.setVisible(this.wireVisible);this._lengthLabel.setCulled(!this.wireVisible);this._cpDirty=false;}}},{key:"_isSliced",value:function _isSliced(positions){var sectionPlanes=this.scene._sectionPlanesState.sectionPlanes;for(var _i451=0,len=sectionPlanes.length;_i451<len;_i451++){var sectionPlane=sectionPlanes[_i451];if(math.planeClipsPositions3(sectionPlane.pos,sectionPlane.dir,positions,4)){return true;}}return false;}/**
     * Sets whether this DistanceMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */},{key:"approximate",get:/**
     * Gets whether this DistanceMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */function get(){return this._approximate;}/**
     * Gets the origin {@link Marker}.
     *
     * @type {Marker}
     */,set:function set(approximate){approximate=approximate!==false;if(this._approximate===approximate){return;}this._approximate=approximate;this._cpDirty=true;this._needUpdate(0);}},{key:"origin",get:function get(){return this._originMarker;}/**
     * Gets the target {@link Marker}.
     *
     * @type {Marker}
     */},{key:"target",get:function get(){return this._targetMarker;}/**
     * Gets the World-space direct point-to-point distance between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     *
     * @type {Number}
     */},{key:"length",get:function get(){this._update();var scale=this.plugin.viewer.scene.metrics.scale;return this._length*scale;}},{key:"color",get:function get(){return this._color;},set:function set(value){this._color=value;this._originDot.setFillColor(value);this._targetDot.setFillColor(value);this._lengthWire.setColor(value);this._lengthLabel.setFillColor(value);}/**
     * Sets whether this DistanceMeasurement is visible or not.
     *
     * @type {Boolean}
     */},{key:"visible",get:/**
     * Gets whether this DistanceMeasurement is visible or not.
     *
     * @type {Boolean}
     */function get(){return this._visible;}/**
     * Sets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultVisible;this._visible=value;this._originDot.setVisible(this._visible&&this._originVisible);this._targetDot.setVisible(this._visible&&this._targetVisible);this._lengthWire.setVisible(this._visible&&this._wireVisible);this._lengthLabel.setVisible(this._visible&&this._wireVisible);var xAxisVisible=this._visible&&this._axisVisible&&this._xAxisVisible;var yAxisVisible=this._visible&&this._axisVisible&&this._yAxisVisible;var zAxisVisible=this._visible&&this._axisVisible&&this._zAxisVisible;this._xAxisWire.setVisible(xAxisVisible);this._yAxisWire.setVisible(yAxisVisible);this._zAxisWire.setVisible(zAxisVisible);this._xAxisLabel.setVisible(xAxisVisible&&!this._xAxisLabelCulled);this._yAxisLabel.setVisible(yAxisVisible&&!this._yAxisLabelCulled);this._zAxisLabel.setVisible(zAxisVisible&&!this._zAxisLabelCulled);this._cpDirty=true;this._needUpdate();}},{key:"originVisible",get:/**
     * Gets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */function get(){return this._originVisible;}/**
     * Sets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultOriginVisible;this._originVisible=value;this._originDot.setVisible(this._visible&&this._originVisible);}},{key:"targetVisible",get:/**
     * Gets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */function get(){return this._targetVisible;}/**
     * Sets if the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are enabled.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultTargetVisible;this._targetVisible=value;this._targetDot.setVisible(this._visible&&this._targetVisible);}},{key:"axisEnabled",get:/**
     * Gets if the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are enabled.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */function get(){return this._axisEnabled;}/**
     * Sets if the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultAxisVisible;this._axisEnabled=value;var axisVisible=this._visible&&this._axisVisible&&this._axisEnabled;this._xAxisWire.setVisible(axisVisible&&this._xAxisVisible);this._yAxisWire.setVisible(axisVisible&&this._yAxisVisible);this._zAxisWire.setVisible(axisVisible&&this._zAxisVisible);this._xAxisLabel.setVisible(axisVisible&&!this._xAxisLabelCulled&&this._xAxisVisible);this._yAxisLabel.setVisible(axisVisible&&!this._yAxisLabelCulled&&this._xAxisVisible);this._zAxisLabel.setVisible(axisVisible&&!this._zAxisLabelCulled&&this._xAxisVisible);this._cpDirty=true;this._needUpdate();}},{key:"axisVisible",get:/**
     * Gets if the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */function get(){return this._axisVisible;}/**
     * Sets if the X-axis-aligned wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultAxisVisible;this._axisVisible=value;var axisVisible=this._visible&&this._axisVisible&&this._axisEnabled;this._xAxisWire.setVisible(axisVisible&&this._xAxisVisible);this._yAxisWire.setVisible(axisVisible&&this._yAxisVisible);this._zAxisWire.setVisible(axisVisible&&this._zAxisVisible);this._xAxisLabel.setVisible(axisVisible&&!this._xAxisLabelCulled&&this._xAxisVisible);this._yAxisLabel.setVisible(axisVisible&&!this._yAxisLabelCulled&&this._yAxisVisible);this._zAxisLabel.setVisible(axisVisible&&!this._zAxisLabelCulled&&this._zAxisVisible);this._cpDirty=true;this._needUpdate();}},{key:"xAxisVisible",get:/**
     * Gets if the X-axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */function get(){return this._xAxisVisible;}/**
     * Sets if the Y-axis-aligned wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultAxisVisible;this._xAxisVisible=value;var axisVisible=this._visible&&this._axisVisible&&this._xAxisVisible&&this._axisEnabled;this._xAxisWire.setVisible(axisVisible);this._xAxisLabel.setVisible(axisVisible&&!this._xAxisLabelCulled);this._cpDirty=true;this._needUpdate();}},{key:"yAxisVisible",get:/**
     * Gets if the Y-axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */function get(){return this._yAxisVisible;}/**
     * Sets if the Z-axis-aligned wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultAxisVisible;this._yAxisVisible=value;var axisVisible=this._visible&&this._axisVisible&&this._yAxisVisible&&this._axisEnabled;this._yAxisWire.setVisible(axisVisible);this._yAxisLabel.setVisible(axisVisible&&!this._yAxisLabelCulled);this._cpDirty=true;this._needUpdate();}},{key:"zAxisVisible",get:/**
     * Gets if the Z-axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * Wires are only shown if enabled and visible.
     *
     * @type {Boolean}
     */function get(){return this._zAxisVisible;}/**
     * Sets if the direct point-to-point wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultAxisVisible;this._zAxisVisible=value;var axisVisible=this._visible&&this._axisVisible&&this._zAxisVisible&&this._axisEnabled;this._zAxisWire.setVisible(axisVisible);this._zAxisLabel.setVisible(axisVisible&&!this._zAxisLabelCulled);this._cpDirty=true;this._needUpdate();}},{key:"wireVisible",get:/**
     * Gets if the direct point-to-point wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * @type {Boolean}
     */function get(){return this._wireVisible;}/**
     * Sets if the labels are visible.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultWireVisible;this._wireVisible=value;var wireVisible=this._visible&&this._wireVisible;this._lengthLabel.setVisible(wireVisible);this._lengthWire.setVisible(wireVisible);}},{key:"labelsVisible",get:/**
     * Gets if the labels are visible.
     *
     * @type {Boolean}
     */function get(){return this._labelsVisible;}/**
     * Sets if labels should be positioned on the wires.
     *
     * @type {Boolean}
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultLabelsVisible;this._labelsVisible=value;var labelsVisible=this._visible&&this._labelsVisible;this._xAxisLabel.setVisible(labelsVisible&&!this._xAxisLabelCulled&&this._clickable&&this._axisEnabled);this._yAxisLabel.setVisible(labelsVisible&&!this._yAxisLabelCulled&&this._clickable&&this._axisEnabled);this._zAxisLabel.setVisible(labelsVisible&&!this._zAxisLabelCulled&&this._clickable&&this._axisEnabled);this._lengthLabel.setVisible(labelsVisible);this._cpDirty=true;this._needUpdate();}},{key:"labelsOnWires",get:/**
     * Gets if labels should be positioned on the wires.
     *
     * @type {Boolean}
     */function get(){return this._labelsOnWires;}/**
     * Sets if this DistanceMeasurement appears highlighted.
     * @param highlighted
     */,set:function set(value){value=value!==undefined?Boolean(value):this.plugin.defaultLabelsOnWires;this._labelsOnWires=value;}},{key:"setHighlighted",value:function setHighlighted(highlighted){this._originDot.setHighlighted(highlighted);this._targetDot.setHighlighted(highlighted);this._xAxisWire.setHighlighted(highlighted);this._yAxisWire.setHighlighted(highlighted);this._zAxisWire.setHighlighted(highlighted);this._xAxisLabel.setHighlighted(highlighted);this._yAxisLabel.setHighlighted(highlighted);this._zAxisLabel.setHighlighted(highlighted);this._lengthWire.setHighlighted(highlighted);this._lengthLabel.setHighlighted(highlighted);}/**
     * Sets if the wires, dots ad labels will fire "mouseOver" "mouseLeave" and "contextMenu" events, or ignore mouse events altogether.
     *
     * @type {Boolean}
     */},{key:"clickable",get:/**
     * Gets if the wires, dots ad labels will fire "mouseOver" "mouseLeave" and "contextMenu" events.
     *
     * @type {Boolean}
     */function get(){return this._clickable;}/**
     * @private
     */,set:function set(value){value=!!value;this._clickable=value;this._originDot.setClickable(this._clickable);this._targetDot.setClickable(this._clickable);this._xAxisWire.setClickable(this._clickable);this._yAxisWire.setClickable(this._clickable);this._zAxisWire.setClickable(this._clickable);this._lengthWire.setClickable(this._clickable);this._xAxisLabel.setClickable(this._clickable);this._yAxisLabel.setClickable(this._clickable);this._zAxisLabel.setClickable(this._clickable);this._lengthLabel.setClickable(this._clickable);}},{key:"destroy",value:function destroy(){var scene=this.plugin.viewer.scene;var metrics=scene.metrics;if(this._onViewMatrix){scene.camera.off(this._onViewMatrix);}if(this._onProjMatrix){scene.camera.off(this._onProjMatrix);}if(this._onCanvasBoundary){scene.canvas.off(this._onCanvasBoundary);}if(this._onMetricsUnits){metrics.off(this._onMetricsUnits);}if(this._onMetricsScale){metrics.off(this._onMetricsScale);}if(this._onMetricsOrigin){metrics.off(this._onMetricsOrigin);}if(this._onSectionPlaneUpdated){scene.off(this._onSectionPlaneUpdated);}this._originDot.destroy();this._targetDot.destroy();this._xAxisWire.destroy();this._yAxisWire.destroy();this._zAxisWire.destroy();this._lengthLabel.destroy();this._xAxisLabel.destroy();this._yAxisLabel.destroy();this._zAxisLabel.destroy();this._lengthWire.destroy();_get(_getPrototypeOf(DistanceMeasurement.prototype),"destroy",this).call(this);}}]);return DistanceMeasurement;}(Component);/**
 * Creates {@link DistanceMeasurement}s in a {@link DistanceMeasurementsPlugin} from user input.
 *
 * @interface
 * @abstract
 */var DistanceMeasurementsControl=/*#__PURE__*/function(_Component30){_inherits(DistanceMeasurementsControl,_Component30);var _super116=_createSuper(DistanceMeasurementsControl);function DistanceMeasurementsControl(){_classCallCheck(this,DistanceMeasurementsControl);return _super116.apply(this,arguments);}_createClass(DistanceMeasurementsControl,[{key:"active",get:/**
     * Gets if this DistanceMeasurementsControl is currently active, where it is responding to input.
     *
     * @returns {boolean} True if this DistanceMeasurementsControl is active.
     * @abstract
     */function get(){}/**
     * Sets whether snap-to-vertex and snap-to-edge are enabled for this DistanceMeasurementsControl.
     *
     * This is `true` by default.
     *
     * Internally, this deactivates then activates the DistanceMeasurementsControl when changed, which means that
     * it will destroy any DistanceMeasurements currently under construction, and incurs some overhead, since it unbinds
     * and rebinds various input handlers.
     *
     * @param {boolean} snapping Whether to enable snap-to-vertex and snap-edge for this DistanceMeasurementsControl.
     */},{key:"snapping",get:/**
     * Gets whether snap-to-vertex and snap-to-edge are enabled for this DistanceMeasurementsControl.
     *
     * This is `true` by default.
     *
     * @returns {boolean} Whether snap-to-vertex and snap-to-edge are enabled for this DistanceMeasurementsControl.
     */function get(){return true;}/**
     * Activates this DistanceMeasurementsControl, ready to respond to input.
     *
     * @abstract
     */,set:function set(snapping){}},{key:"activate",value:function activate(){}/**
     * Deactivates this DistanceMeasurementsControl, making it unresponsive to input.
     *
     * Destroys any {@link DistanceMeasurement} under construction by this DistanceMeasurementsControl.
     *
     * @abstract
     */},{key:"deactivate",value:function deactivate(){}/**
     * Resets this DistanceMeasurementsControl.
     *
     * Destroys any {@link DistanceMeasurement} under construction by this DistanceMeasurementsControl.
     *
     * Does nothing if the DistanceMeasurementsControl is not active.
     *
     * @abstract
     */},{key:"reset",value:function reset(){}/**
     * Destroys this DistanceMeasurementsControl.
     *
     * Destroys any {@link DistanceMeasurement} under construction by this DistanceMeasurementsControl.
     *
     * @abstract
     */},{key:"destroy",value:function destroy(){}}]);return DistanceMeasurementsControl;}(Component);var MOUSE_FIRST_CLICK_EXPECTED=0;/**
 * Creates {@link DistanceMeasurement}s in a {@link DistanceMeasurementsPlugin} from mouse input.
 *
 * ## Usage
 *
 * [[Run example](/examples/measurement/#distance_createWithMouse_snapping)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin, DistanceMeasurementsMouseControl, PointerLens} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 * });
 *
 * viewer.camera.eye = [-3.93, 2.85, 27.01];
 * viewer.camera.look = [4.40, 3.72, 8.89];
 * viewer.camera.up = [-0.01, 0.99, 0.039];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const sceneModel = xktLoader.load({
 *     id: "myModel",
 *     src: "Duplex.xkt"
 * });
 *
 * const distanceMeasurements = new DistanceMeasurementsPlugin(viewer);
 *
 * const distanceMeasurementsControl  = new DistanceMeasurementsMouseControl(DistanceMeasurements, {
 *     pointerLens: new PointerLens(viewer)
 * })
 *
 * distanceMeasurementsControl.snapping = true;
 *
 * distanceMeasurementsControl.activate();
 * ````
 */var DistanceMeasurementsMouseControl=/*#__PURE__*/function(_DistanceMeasurements){_inherits(DistanceMeasurementsMouseControl,_DistanceMeasurements);var _super117=_createSuper(DistanceMeasurementsMouseControl);/**
     * Creates a DistanceMeasurementsMouseControl bound to the given DistanceMeasurementsPlugin.
     *
     * @param {DistanceMeasurementsPlugin} distanceMeasurementsPlugin The AngleMeasurementsPlugin to control.
     * @param [cfg] Configuration
     * @param {PointerLens} [cfg.pointerLens] A PointerLens to use to provide a magnified view of the cursor when snapping is enabled.
     * @param {boolean} [cfg.snapping=true] Whether to initially enable snap-to-vertex and snap-to-edge for this DistanceMeasurementsMouseControl.
     */function DistanceMeasurementsMouseControl(distanceMeasurementsPlugin){var _this81;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,DistanceMeasurementsMouseControl);_this81=_super117.call(this,distanceMeasurementsPlugin.viewer.scene);_this81.pointerLens=cfg.pointerLens;_this81._active=false;_this81._currentDistanceMeasurement=null;_this81._currentDistanceMeasurementInitState={wireVisible:null,axisVisible:null,xAxisVisible:null,yaxisVisible:null,zAxisVisible:null,targetVisible:null};_this81._initMarkerDiv();_this81._onCameraControlHoverSnapOrSurface=null;_this81._onCameraControlHoverSnapOrSurfaceOff=null;_this81._onMouseDown=null;_this81._onMouseUp=null;_this81._onCanvasTouchStart=null;_this81._onCanvasTouchEnd=null;_this81._snapping=cfg.snapping!==false;_this81._mouseState=MOUSE_FIRST_CLICK_EXPECTED;_this81._attachPlugin(distanceMeasurementsPlugin,cfg);return _this81;}_createClass(DistanceMeasurementsMouseControl,[{key:"_initMarkerDiv",value:function _initMarkerDiv(){var markerDiv=document.createElement('div');markerDiv.setAttribute('id','myMarkerDiv');var canvas=this.scene.canvas.canvas;canvas.parentNode.insertBefore(markerDiv,canvas);markerDiv.style.background="black";markerDiv.style.border="2px solid blue";markerDiv.style.borderRadius="10px";markerDiv.style.width="5px";markerDiv.style.height="5px";markerDiv.style.top="-200px";markerDiv.style.left="-200px";markerDiv.style.margin="0 0";markerDiv.style.zIndex="100";markerDiv.style.position="absolute";markerDiv.style.pointerEvents="none";this._markerDiv=markerDiv;}},{key:"_destroyMarkerDiv",value:function _destroyMarkerDiv(){if(this._markerDiv){var element=document.getElementById('myMarkerDiv');element.parentNode.removeChild(element);this._markerDiv=null;}}},{key:"_attachPlugin",value:function _attachPlugin(distanceMeasurementsPlugin){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};/**
         * The {@link DistanceMeasurementsPlugin} that owns this DistanceMeasurementsMouseControl.
         * @type {DistanceMeasurementsPlugin}
         */this.distanceMeasurementsPlugin=distanceMeasurementsPlugin;/**
         * The {@link DistanceMeasurementsPlugin} that owns this DistanceMeasurementsMouseControl.
         * @type {DistanceMeasurementsPlugin}
         */this.plugin=distanceMeasurementsPlugin;}/**
     * Gets if this DistanceMeasurementsMouseControl is currently active, where it is responding to input.
     *
     * @returns {boolean} True if this DistanceMeasurementsMouseControl is active.
     */},{key:"active",get:function get(){return this._active;}/**
     * Sets whether snap-to-vertex and snap-to-edge are enabled for this DistanceMeasurementsMouseControl.
     *
     * This is `true` by default.
     *
     * Internally, this deactivates then activates the DistanceMeasurementsMouseControl when changed, which means that
     * it will destroy any DistanceMeasurements currently under construction, and incurs some overhead, since it unbinds
     * and rebinds various input handlers.
     *
     * @param {boolean} snapping Whether to enable snap-to-vertex and snap-edge for this DistanceMeasurementsMouseControl.
     */},{key:"snapping",get:/**
     * Gets whether snap-to-vertex and snap-to-edge are enabled for this DistanceMeasurementsMouseControl.
     *
     * This is `true` by default.
     *
     * @returns {boolean} Whether snap-to-vertex and snap-to-edge are enabled for this DistanceMeasurementsMouseControl.
     */function get(){return this._snapping;}/**
     * Activates this DistanceMeasurementsMouseControl, ready to respond to input.
     */,set:function set(snapping){if(snapping!==this._snapping){this._snapping=snapping;this.deactivate();this.activate();}else{this._snapping=snapping;}}},{key:"activate",value:function activate(){var _this82=this;if(this._active){return;}if(!this._markerDiv){this._initMarkerDiv();}this.fire("activated",true);var distanceMeasurementsPlugin=this.distanceMeasurementsPlugin;var scene=this.scene;var cameraControl=distanceMeasurementsPlugin.viewer.cameraControl;var canvas=scene.canvas.canvas;scene.input;var mouseHovering=false;var pointerWorldPos=math.vec3();var pointerCanvasPos=math.vec2();var pointerDownCanvasX;var pointerDownCanvasY;var clickTolerance=20;var hoveredEntity=null;this._mouseState=MOUSE_FIRST_CLICK_EXPECTED;var getTop=function getTop(el){return el.offsetTop+(el.offsetParent&&getTop(el.offsetParent));};var getLeft=function getLeft(el){return el.offsetLeft+(el.offsetParent&&getLeft(el.offsetParent));};this._onCameraControlHoverSnapOrSurface=cameraControl.on(this._snapping?"hoverSnapOrSurface":"hoverSurface",function(event){var canvasPos=event.snappedCanvasPos||event.canvasPos;mouseHovering=true;pointerWorldPos.set(event.worldPos);pointerCanvasPos.set(event.canvasPos);if(_this82._mouseState===MOUSE_FIRST_CLICK_EXPECTED){_this82._markerDiv.style.left="".concat(getLeft(canvas)+canvasPos[0]-5,"px");_this82._markerDiv.style.top="".concat(getTop(canvas)+canvasPos[1]-5,"px");_this82._markerDiv.style.background="pink";if(event.snappedToVertex||event.snappedToEdge){if(_this82.pointerLens){_this82.pointerLens.visible=true;_this82.pointerLens.canvasPos=event.canvasPos;_this82.pointerLens.snappedCanvasPos=event.snappedCanvasPos||event.canvasPos;_this82.pointerLens.snapped=true;}_this82._markerDiv.style.background="greenyellow";_this82._markerDiv.style.border="2px solid green";}else{if(_this82.pointerLens){_this82.pointerLens.visible=true;_this82.pointerLens.canvasPos=event.canvasPos;_this82.pointerLens.snappedCanvasPos=event.canvasPos;_this82.pointerLens.snapped=false;}_this82._markerDiv.style.background="pink";_this82._markerDiv.style.border="2px solid red";}hoveredEntity=event.entity;}else{_this82._markerDiv.style.left="-10000px";_this82._markerDiv.style.top="-10000px";}canvas.style.cursor="pointer";if(_this82._currentDistanceMeasurement){_this82._currentDistanceMeasurement.wireVisible=_this82._currentDistanceMeasurementInitState.wireVisible;_this82._currentDistanceMeasurement.axisVisible=_this82._currentDistanceMeasurementInitState.axisVisible&&_this82.distanceMeasurementsPlugin.defaultAxisVisible;_this82._currentDistanceMeasurement.xAxisVisible=_this82._currentDistanceMeasurementInitState.xAxisVisible&&_this82.distanceMeasurementsPlugin.defaultXAxisVisible;_this82._currentDistanceMeasurement.yAxisVisible=_this82._currentDistanceMeasurementInitState.yAxisVisible&&_this82.distanceMeasurementsPlugin.defaultYAxisVisible;_this82._currentDistanceMeasurement.zAxisVisible=_this82._currentDistanceMeasurementInitState.zAxisVisible&&_this82.distanceMeasurementsPlugin.defaultZAxisVisible;_this82._currentDistanceMeasurement.targetVisible=_this82._currentDistanceMeasurementInitState.targetVisible;_this82._currentDistanceMeasurement.target.worldPos=pointerWorldPos.slice();_this82._markerDiv.style.left="-10000px";_this82._markerDiv.style.top="-10000px";}});canvas.addEventListener('mousedown',this._onMouseDown=function(e){if(e.which!==1){return;}pointerDownCanvasX=e.clientX;pointerDownCanvasY=e.clientY;});canvas.addEventListener("mouseup",this._onMouseUp=function(e){if(e.which!==1){return;}if(e.clientX>pointerDownCanvasX+clickTolerance||e.clientX<pointerDownCanvasX-clickTolerance||e.clientY>pointerDownCanvasY+clickTolerance||e.clientY<pointerDownCanvasY-clickTolerance){return;}if(_this82._currentDistanceMeasurement){if(mouseHovering){_this82._currentDistanceMeasurement.target.entity=hoveredEntity;hoveredEntity=null;_this82._currentDistanceMeasurement.clickable=true;_this82.distanceMeasurementsPlugin.fire("measurementEnd",_this82._currentDistanceMeasurement);_this82._currentDistanceMeasurement=null;}else{_this82._currentDistanceMeasurement.destroy();_this82.distanceMeasurementsPlugin.fire("measurementCancel",_this82._currentDistanceMeasurement);_this82._currentDistanceMeasurement=null;hoveredEntity=null;}}else{if(mouseHovering){_this82._currentDistanceMeasurement=distanceMeasurementsPlugin.createMeasurement({id:math.createUUID(),origin:{worldPos:pointerWorldPos.slice()},target:{worldPos:pointerWorldPos.slice()},approximate:true});_this82._currentDistanceMeasurementInitState.axisVisible=_this82._currentDistanceMeasurement.axisVisible&&_this82.distanceMeasurementsPlugin.defaultAxisVisible;_this82._currentDistanceMeasurementInitState.xAxisVisible=_this82._currentDistanceMeasurement.xAxisVisible&&_this82.distanceMeasurementsPlugin.defaultXAxisVisible;_this82._currentDistanceMeasurementInitState.yAxisVisible=_this82._currentDistanceMeasurement.yAxisVisible&&_this82.distanceMeasurementsPlugin.defaultYAxisVisible;_this82._currentDistanceMeasurementInitState.zAxisVisible=_this82._currentDistanceMeasurement.zAxisVisible&&_this82.distanceMeasurementsPlugin.defaultZAxisVisible;_this82._currentDistanceMeasurementInitState.wireVisible=_this82._currentDistanceMeasurement.wireVisible;_this82._currentDistanceMeasurementInitState.targetVisible=_this82._currentDistanceMeasurement.targetVisible;_this82._currentDistanceMeasurement.clickable=false;_this82._currentDistanceMeasurement.origin.entity=hoveredEntity;hoveredEntity=null;_this82.fire("measurementStart",_this82._currentDistanceMeasurement);}}});this._onCameraControlHoverSnapOrSurfaceOff=cameraControl.on(this._snapping?"hoverSnapOrSurfaceOff":"hoverOff",function(event){if(_this82.pointerLens){_this82.pointerLens.visible=true;_this82.pointerLens.canvasPos=event.canvasPos;_this82.pointerLens.snappedCanvasPos=event.snappedCanvasPos||event.canvasPos;}mouseHovering=false;_this82._markerDiv.style.left="-100px";_this82._markerDiv.style.top="-100px";if(_this82._currentDistanceMeasurement){_this82._currentDistanceMeasurement.wireVisible=false;_this82._currentDistanceMeasurement.targetVisible=false;_this82._currentDistanceMeasurement.axisVisible=false;}canvas.style.cursor="default";});this._active=true;}/**
     * Deactivates this DistanceMeasurementsMouseControl, making it unresponsive to input.
     *
     * Destroys any {@link DistanceMeasurement} under construction by this DistanceMeasurementsMouseControl.
     */},{key:"deactivate",value:function deactivate(){if(!this._active){return;}this.fire("activated",false);if(this.pointerLens){this.pointerLens.visible=false;}if(this._markerDiv){this._destroyMarkerDiv();}this.reset();var canvas=this.scene.canvas.canvas;canvas.removeEventListener("mousedown",this._onMouseDown);canvas.removeEventListener("mouseup",this._onMouseUp);var cameraControl=this.distanceMeasurementsPlugin.viewer.cameraControl;cameraControl.off(this._onCameraControlHoverSnapOrSurface);cameraControl.off(this._onCameraControlHoverSnapOrSurfaceOff);if(this._currentDistanceMeasurement){this.distanceMeasurementsPlugin.fire("measurementCancel",this._currentDistanceMeasurement);this._currentDistanceMeasurement.destroy();this._currentDistanceMeasurement=null;}this._active=false;}/**
     * Resets this DistanceMeasurementsMouseControl.
     *
     * Destroys any {@link DistanceMeasurement} under construction by this DistanceMeasurementsMouseControl.
     *
     * Does nothing if the DistanceMeasurementsMouseControl is not active.
     */},{key:"reset",value:function reset(){if(!this._active){return;}this._destroyMarkerDiv();this._initMarkerDiv();if(this._currentDistanceMeasurement){this.distanceMeasurementsPlugin.fire("measurementCancel",this._currentDistanceMeasurement);this._currentDistanceMeasurement.destroy();this._currentDistanceMeasurement=null;}}/**
     * Destroys this DistanceMeasurementsMouseControl.
     *
     * Destroys any {@link DistanceMeasurement} under construction by this DistanceMeasurementsMouseControl.
     */},{key:"destroy",value:function destroy(){this.deactivate();_get(_getPrototypeOf(DistanceMeasurementsMouseControl.prototype),"destroy",this).call(this);}}]);return DistanceMeasurementsMouseControl;}(DistanceMeasurementsControl);/**
 * {@link Viewer} plugin for measuring point-to-point distances.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/63047331-867a0a80-bed4-11e9-892f-398740013c5f.gif">](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_createWithMouse)
 *
 * * [[Example 1: Model with distance measurements](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_modelWithMeasurements)]
 * * [[Example 2: Create distance measurements with mouse](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_createWithMouse)]
 * * [[Example 3: Configuring units and scale](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_unitsAndScale)
 *
 * ## Overview
 *
 * * A {@link DistanceMeasurement} represents a point-to-point measurement between two 3D points on one or two {@link Entity}s.
 * * As shown on the screen capture above, a DistanceMeasurement has one wire (light blue) that shows the direct point-to-point measurement,
 * and three more wires (red, green and blue) that show the distance on each of the World-space X, Y and Z axis.
 * * Create DistanceMeasurements programmatically with {@link DistanceMeasurementsPlugin#createMeasurement}.
 * * Create DistanceMeasurements interactively using a {@link DistanceMeasurementsControl}.
 * * Existing DistanceMeasurements are registered by ID in {@link DistanceMeasurementsPlugin#measurements}.
 * * Destroy DistanceMeasurements using {@link DistanceMeasurementsPlugin#destroyMeasurement}.
 * * Configure global measurement units and scale via {@link Metrics}, located at {@link Scene#metrics}.
 *
 * ## Example 1: Creating DistanceMeasurements Programmatically
 *
 * In our first example, we'll use an {@link XKTLoaderPlugin} to load a model, and then use a DistanceMeasurementsPlugin to programmatically create two {@link DistanceMeasurement}s.
 *
 * Note how each DistanceMeasurement has ````origin```` and ````target```` endpoints, which each indicate a 3D World-space
 * position on the surface of an {@link Entity}. The endpoints can be attached to the same Entity, or to different Entitys.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/measurements/#distance_modelWithMeasurements)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const distanceMeasurements = new DistanceMeasurementsPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const myMeasurement1 = distanceMeasurements.createMeasurement({
 *          id: "distanceMeasurement1",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [4.738, 3.172, 17.768]
 *          },
 *          visible: true,
 *          wireVisible: true
 *      });
 *
 *      const myMeasurement2 = distanceMeasurements.createMeasurement({
 *          id: "distanceMeasurement2",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *              worldPos: [0.436, 0.001, 22.135]
 *          },
 *          visible: true,
 *          wireVisible: true
 *      });
 * });
 * ````
 *
 * ## Example 2: Creating DistanceMeasurements with Mouse Input
 *
 * In our second example, we'll use an {@link XKTLoaderPlugin} to load a model, then we'll use a
 * {@link DistanceMeasurementsMouseControl} to interactively create {@link DistanceMeasurement}s with mouse input.
 *
 * After we've activated the DistanceMeasurementsMouseControl, the first click on any {@link Entity} begins constructing a DistanceMeasurement, fixing its
 * origin to that Entity. The next click on any Entity will complete the DistanceMeasurement, fixing its target to that second Entity.
 *
 * The DistanceMeasurementsMouseControl will then wait for the next click on any Entity, to begin constructing
 * another DistanceMeasurement, and so on, until deactivated again.
 *
 * [[Run example](/examples/measurement/#distance_createWithMouse)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin, DistanceMeasurementsMouseControl, PointerLens} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const distanceMeasurements = new DistanceMeasurementsPlugin(viewer);
 *
 * const distanceMeasurementsControl  = new DistanceMeasurementsMouseControl(distanceMeasurements, {
 *     pointerLens : new PointerLens(viewer)
 * })
 *
 * distanceMeasurementsControl.snapToVertex = true;
 * distanceMeasurementsControl.snapToEdge = true;
 *
 * distanceMeasurementsControl.activate();
 *
 * const model = xktLoader.load({
 *     src: "./models/xkt/duplex/duplex.xkt"
 * });
 * ````
 *
 * ## Example 3: Configuring Measurement Units and Scale
 *
 * In our third example, we'll use the  {@link Scene}'s {@link Metrics} to set the global unit of measurement to ````"meters"````. We'll also specify that a unit within the World-space coordinate system represents ten meters.
 *
 * The wires belonging to our DistanceMeasurements show their lengths in Real-space coordinates, in the current unit of measurement. They will dynamically update as we set these configurations.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_unitsAndScale)]
 *
 * ````JavaScript
 * const metrics = viewer.scene.metrics;

 * metrics.units = "meters";
 * metrics.scale = 10.0;
 * ````
 *
 * ## Example 4: Attaching Mouse Handlers
 *
 * In our fourth example, we'll attach event handlers to our plugin, to catch when the user
 * hovers or right-clicks over our measurements.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_modelWithMeasurements)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin, DistanceMeasurementsMouseControl, PointerLens} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const distanceMeasurements = new DistanceMeasurementsPlugin(viewer);
 *
 * const distanceMeasurementsControl  = new DistanceMeasurementsMouseControl(distanceMeasurements, {
 *     pointerLens : new PointerLens(viewer)
 * })
 *
 * distanceMeasurementsControl.snapToVertex = true;
 * distanceMeasurementsControl.snapToEdge = true;
 *
 * distanceMeasurementsControl.activate();
 *
 * distanceMeasurements.on("mouseOver", (e) => {
 *     e.measurement.setHighlighted(true);
 * });
 *
 * distanceMeasurements.on("mouseLeave", (e) => {
 *     e.measurement.setHighlighted(false);
 * });
 *
 * distanceMeasurements.on("contextMenu", (e) => {
 *     // Show context menu
 *     e.event.preventDefault();
 * });
 *
 * const model = xktLoader.load({
 *      src: "Duplex.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const myMeasurement1 = distanceMeasurements.createMeasurement({
 *          id: "distanceMeasurement1",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [4.738, 3.172, 17.768]
 *          },
 *          visible: true,
 *          wireVisible: true
 *      });
 *
 *      const myMeasurement2 = distanceMeasurements.createMeasurement({
 *          id: "distanceMeasurement2",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *              worldPos: [0.436, 0.001, 22.135]
 *          },
 *          visible: true,
 *          wireVisible: true
 *      });
 * });
 * ````
 */var DistanceMeasurementsPlugin=/*#__PURE__*/function(_Plugin5){_inherits(DistanceMeasurementsPlugin,_Plugin5);var _super118=_createSuper(DistanceMeasurementsPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} [cfg]  Plugin configuration.
     * @param {String} [cfg.id="DistanceMeasurements"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Number} [cfg.labelMinAxisLength=25] The minimum length, in pixels, of an axis wire beyond which its label is shown.
     * @param {HTMLElement} [cfg.container] Container DOM element for markers and labels. Defaults to ````document.body````.
     * @param {boolean} [cfg.defaultVisible=true] The default value of the DistanceMeasurements `visible` property.
     * @param {boolean} [cfg.defaultOriginVisible=true] The default value of the DistanceMeasurements `originVisible` property.
     * @param {boolean} [cfg.defaultTargetVisible=true] The default value of the DistanceMeasurements `targetVisible` property.
     * @param {boolean} [cfg.defaultWireVisible=true] The default value of the DistanceMeasurements `wireVisible` property.
     * @param {boolean} [cfg.defaultLabelsVisible=true] The default value of the DistanceMeasurements `labelsVisible` property.
     * @param {boolean} [cfg.defaultAxisVisible=true] The default value of the DistanceMeasurements `axisVisible` property.
     * @param {boolean} [cfg.defaultXAxisVisible=true] The default value of the DistanceMeasurements `xAxisVisible` property.
     * @param {boolean} [cfg.defaultYAxisVisible=true] The default value of the DistanceMeasurements `yAxisVisible` property.
     * @param {boolean} [cfg.defaultZAxisVisible=true] The default value of the DistanceMeasurements `zAxisVisible` property.
     * @param {string} [cfg.defaultColor=#00BBFF] The default color of the length dots, wire and label.
     * @param {number} [cfg.zIndex] If set, the wires, dots and labels will have this zIndex (+1 for dots and +2 for labels).
     * @param {boolean} [cfg.defaultLabelsOnWires=true] The default value of the DistanceMeasurements `labelsOnWires` property.
     * @param {PointerCircle} [cfg.pointerLens] A PointerLens to help the user position the pointer. This can be shared with other plugins.
     */function DistanceMeasurementsPlugin(viewer){var _this83;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,DistanceMeasurementsPlugin);_this83=_super118.call(this,"DistanceMeasurements",viewer);_this83._pointerLens=cfg.pointerLens;_this83._container=cfg.container||document.body;_this83._defaultControl=null;_this83._measurements={};_this83.labelMinAxisLength=cfg.labelMinAxisLength;_this83.defaultVisible=cfg.defaultVisible!==false;_this83.defaultOriginVisible=cfg.defaultOriginVisible!==false;_this83.defaultTargetVisible=cfg.defaultTargetVisible!==false;_this83.defaultWireVisible=cfg.defaultWireVisible!==false;_this83.defaultLabelsVisible=cfg.defaultLabelsVisible!==false;_this83.defaultAxisVisible=cfg.defaultAxisVisible!==false;_this83.defaultXAxisVisible=cfg.defaultXAxisVisible!==false;_this83.defaultYAxisVisible=cfg.defaultYAxisVisible!==false;_this83.defaultZAxisVisible=cfg.defaultZAxisVisible!==false;_this83.defaultColor=cfg.defaultColor!==undefined?cfg.defaultColor:"#00BBFF";_this83.zIndex=cfg.zIndex||10000;_this83.defaultLabelsOnWires=cfg.defaultLabelsOnWires!==false;_this83._onMouseOver=function(event,measurement){_this83.fire("mouseOver",{plugin:_assertThisInitialized(_this83),distanceMeasurement:measurement,measurement:measurement,event:event});};_this83._onMouseLeave=function(event,measurement){_this83.fire("mouseLeave",{plugin:_assertThisInitialized(_this83),distanceMeasurement:measurement,measurement:measurement,event:event});};_this83._onContextMenu=function(event,measurement){_this83.fire("contextMenu",{plugin:_assertThisInitialized(_this83),distanceMeasurement:measurement,measurement:measurement,event:event});};return _this83;}/**
     * Gets the plugin's HTML container element, if any.
     * @returns {*|HTMLElement|HTMLElement}
     */_createClass(DistanceMeasurementsPlugin,[{key:"getContainerElement",value:function getContainerElement(){return this._container;}/**
     * @private
     */},{key:"send",value:function send(name,value){}/**
     * Gets the PointerLens attached to this DistanceMeasurementsPlugin.
     * @returns {PointerCircle}
     */},{key:"pointerLens",get:function get(){return this._pointerLens;}/**
     * Gets the default {@link DistanceMeasurementsControl}.
     *
     * @type {DistanceMeasurementsControl}
     * @deprecated
     */},{key:"control",get:function get(){if(!this._defaultControl){this._defaultControl=new DistanceMeasurementsMouseControl(this,{});}return this._defaultControl;}/**
     * Gets the existing {@link DistanceMeasurement}s, each mapped to its {@link DistanceMeasurement#id}.
     *
     * @type {{String:DistanceMeasurement}}
     */},{key:"measurements",get:function get(){return this._measurements;}/**
     * Sets the minimum length, in pixels, of an axis wire beyond which its label is shown.
     *
     * The axis wire's label is not shown when its length is less than this value.
     *
     * This is ````25```` pixels by default.
     *
     * Must not be less than ````1````.
     *
     * @type {number}
     */},{key:"labelMinAxisLength",get:/**
     * Gets the minimum length, in pixels, of an axis wire beyond which its label is shown.
     * @returns {number}
     */function get(){return this._labelMinAxisLength;}/**
     * Creates a {@link DistanceMeasurement}.
     *
     * The DistanceMeasurement is then registered by {@link DistanceMeasurement#id} in {@link DistanceMeasurementsPlugin#measurements}.
     *
     * @param {Object} params {@link DistanceMeasurement} configuration.
     * @param {String} params.id Unique ID to assign to {@link DistanceMeasurement#id}. The DistanceMeasurement will be registered by this in {@link DistanceMeasurementsPlugin#measurements} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.
     * @param {Number[]} params.origin.worldPos Origin World-space 3D position.
     * @param {Entity} params.origin.entity Origin Entity.
     * @param {Number[]} params.target.worldPos Target World-space 3D position.
     * @param {Entity} params.target.entity Target Entity.
     * @param {Boolean} [params.visible=true] Whether to initially show the {@link DistanceMeasurement}.
     * @param {Boolean} [params.originVisible=true] Whether to initially show the {@link DistanceMeasurement} origin.
     * @param {Boolean} [params.targetVisible=true] Whether to initially show the {@link DistanceMeasurement} target.
     * @param {Boolean} [params.wireVisible=true] Whether to initially show the direct point-to-point wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @param {Boolean} [params.axisVisible=true] Whether to initially show the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @param {Boolean} [params.xAxisVisible=true] Whether to initially show the X-axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @param {Boolean} [params.yAxisVisible=true] Whether to initially show the Y-axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @param {Boolean} [params.zAxisVisible=true] Whether to initially show the Z-axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @param {Boolean} [params.labelsVisible=true] Whether to initially show the labels.
     * @param {string} [params.color] The color of the length dot, wire and label.
     * @param {Boolean} [params.labelsOnWires=true] Determines if labels will be set on wires or one below the other.
     * @returns {DistanceMeasurement} The new {@link DistanceMeasurement}.
     */,set:function set(labelMinAxisLength){if(labelMinAxisLength<1){this.error("labelMinAxisLength must be >= 1; defaulting to 25");labelMinAxisLength=25;}this._labelMinAxisLength=labelMinAxisLength||25;}},{key:"createMeasurement",value:function createMeasurement(){var _this84=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(this.viewer.scene.components[params.id]){this.error("Viewer scene component with this ID already exists: "+params.id);delete params.id;}var origin=params.origin;var target=params.target;var measurement=new DistanceMeasurement(this,{id:params.id,plugin:this,container:this._container,origin:{entity:origin.entity,worldPos:origin.worldPos},target:{entity:target.entity,worldPos:target.worldPos},visible:params.visible,wireVisible:params.wireVisible,axisVisible:params.axisVisible!==false&&this.defaultAxisVisible!==false,xAxisVisible:params.xAxisVisible!==false&&this.defaultXAxisVisible!==false,yAxisVisible:params.yAxisVisible!==false&&this.defaultYAxisVisible!==false,zAxisVisible:params.zAxisVisible!==false&&this.defaultZAxisVisible!==false,labelsVisible:params.labelsVisible!==false&&this.defaultLabelsVisible!==false,originVisible:params.originVisible,targetVisible:params.targetVisible,color:params.color,labelsOnWires:params.labelsOnWires!==false&&this.defaultLabelsOnWires!==false,onMouseOver:this._onMouseOver,onMouseLeave:this._onMouseLeave,onContextMenu:this._onContextMenu});this._measurements[measurement.id]=measurement;measurement.on("destroyed",function(){delete _this84._measurements[measurement.id];});this.fire("measurementCreated",measurement);return measurement;}/**
     * Destroys a {@link DistanceMeasurement}.
     *
     * @param {String} id ID of DistanceMeasurement to destroy.
     */},{key:"destroyMeasurement",value:function destroyMeasurement(id){var measurement=this._measurements[id];if(!measurement){this.log("DistanceMeasurement not found: "+id);return;}measurement.destroy();this.fire("measurementDestroyed",measurement);}/**
     * Shows all or hides the angle label of each {@link DistanceMeasurement}.
     *
     * @param {Boolean} labelsShown Whether or not to show the labels.
     */},{key:"setLabelsShown",value:function setLabelsShown(labelsShown){for(var _i452=0,_Object$entries2=Object.entries(this.measurements);_i452<_Object$entries2.length;_i452++){var _Object$entries2$_i=_slicedToArray(_Object$entries2[_i452],2),key=_Object$entries2$_i[0],measurement=_Object$entries2$_i[1];measurement.labelShown=labelsShown;}}/**
     * Shows all or hides the axis wires of each {@link DistanceMeasurement}.
     *
     * @param {Boolean} labelsShown Whether or not to show the axis wires.
     */},{key:"setAxisVisible",value:function setAxisVisible(axisVisible){for(var _i453=0,_Object$entries3=Object.entries(this.measurements);_i453<_Object$entries3.length;_i453++){var _Object$entries3$_i=_slicedToArray(_Object$entries3[_i453],2),key=_Object$entries3$_i[0],measurement=_Object$entries3$_i[1];measurement.axisVisible=axisVisible;}this.defaultAxisVisible=axisVisible;}/**
     * Gets if the axis wires of each {@link DistanceMeasurement} are visible.
     *
     * @returns {Boolean} Whether or not the axis wires are visible.
     */},{key:"getAxisVisible",value:function getAxisVisible(){return this.defaultAxisVisible;}/**
     * Destroys all {@link DistanceMeasurement}s.
     */},{key:"clear",value:function clear(){var ids=Object.keys(this._measurements);for(var i=0,len=ids.length;i<len;i++){this.destroyMeasurement(ids[i]);}}/**
     * Destroys this DistanceMeasurementsPlugin.
     *
     * Destroys all {@link DistanceMeasurement}s first.
     */},{key:"destroy",value:function destroy(){this.clear();_get(_getPrototypeOf(DistanceMeasurementsPlugin.prototype),"destroy",this).call(this);}}]);return DistanceMeasurementsPlugin;}(Plugin);/**
 * {@link Viewer} plugin that makes interaction smoother with large models, by temporarily switching
 * the Viewer to faster, lower-quality rendering modes whenever we interact.
 *
 * [<img src="https://xeokit.io/img/docs/FastNavPlugin/FastNavPlugin.gif">](https://xeokit.github.io/xeokit-sdk/examples/#performance_FastNavPlugin)
 *
 * FastNavPlugin works by hiding specified Viewer rendering features, and optionally scaling the Viewer's canvas
 * resolution, whenever we interact with the Viewer. Then, once we've finished interacting, FastNavPlugin restores those
 * rendering features and the original canvas scale, after a configured delay.
 *
 * Depending on how we configure FastNavPlugin, we essentially switch to a smooth-rendering low-quality view while
 * interacting, then return to the normal higher-quality view after we stop, following an optional delay.
 *
 * Down-scaling the canvas resolution gives particularly good results. For example, scaling by ````0.5```` means that
 * we're rendering a quarter of the pixels while interacting, which can make the Viewer noticeably smoother with big models.
 *
 * The screen capture above shows FastNavPlugin in action. In this example, whenever we move the Camera or resize the Canvas,
 * FastNavPlugin switches off enhanced edges and ambient shadows (SAO), and down-scales the canvas, making it slightly
 * blurry. When ````0.5```` seconds passes with no interaction, the plugin shows edges and SAO again, and restores the
 * original canvas scale.
 *
 * # Usage
 *
 * In the example below, we'll create a {@link Viewer}, add a {@link FastNavPlugin}, then use an {@link XKTLoaderPlugin} to load a model.
 *
 * Whenever we interact with the Viewer, our FastNavPlugin will:
 *
 * * hide edges,
 * * hide ambient shadows (SAO),
 * * hide physically-based materials (switching to non-PBR),
 * * hide transparent objects, and
 * * scale the canvas resolution by 0.5, causing the GPU to render 75% less pixels.
 * <br>
 *
 * We'll also configure a 0.5 second delay before we transition back to high-quality each time we stop ineracting, so that we're
 * not continually flipping between low and high quality as we interact. Since we're only rendering ambient shadows when not interacting, we'll also treat ourselves
 * to expensive, high-quality SAO settings, that we wouldn't normally configure for an interactive SAO effect.
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#performance_FastNavPlugin)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, FastNavPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer with PBR and SAO enabled
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true,
 *      pbr: true,                          // Enable physically-based rendering for Viewer
 *      sao: true                           // Enable ambient shadows for Viewer
 *  });
 *
 * viewer.scene.camera.eye = [-66.26, 105.84, -281.92];
 * viewer.scene.camera.look = [42.45, 49.62, -43.59];
 * viewer.scene.camera.up = [0.05, 0.95, 0.15];
 *
 * // Higher-quality SAO settings
 *
 * viewer.scene.sao.enabled = true;
 * viewer.scene.sao.numSamples = 60;
 * viewer.scene.sao.kernelRadius = 170;
 *
 * // Install a FastNavPlugin
 *
 * new FastNavPlugin(viewer, {
 *      hideEdges: true,                // Don't show edges while we interact (default is true)
 *      hideSAO: true,                  // Don't show ambient shadows while we interact (default is true)
 *      hideColorTexture: true,        // No color textures while we interact (default is true)
 *      hidePBR: true,                  // No physically-based rendering while we interact (default is true)
 *      hideTransparentObjects: true,   // Hide transparent objects while we interact (default is false)
 *      scaleCanvasResolution: true,    // Scale canvas resolution while we interact (default is false)
 *      defaultScaleCanvasResolutionFactor: 1.0, // Factor by which we scale canvas resolution when we stop interacting (default is 1.0)
 *      scaleCanvasResolutionFactor: 0.5,  // Factor by which we scale canvas resolution when we interact (default is 0.6)
 *      delayBeforeRestore: true,       // When we stop interacting, delay before restoring normal render (default is true)
 *      delayBeforeRestoreSeconds: 0.5  // The delay duration, in seconds (default is 0.5)
 * });
 *
 * // Load a BIM model from XKT
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/HolterTower.xkt",
 *      sao: true,                          // Enable ambient shadows for this model
 *      pbr: true                           // Enable physically-based rendering for this model
 * });
 * ````
 *
 * @class FastNavPlugin
 */var FastNavPlugin=/*#__PURE__*/function(_Plugin6){_inherits(FastNavPlugin,_Plugin6);var _super119=_createSuper(FastNavPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg FastNavPlugin configuration.
     * @param {String} [cfg.id="FastNav"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Boolean} [cfg.hideColorTexture=true] Whether to temporarily hide color textures whenever we interact with the Viewer.
     * @param {Boolean} [cfg.hidePBR=true] Whether to temporarily hide physically-based rendering (PBR) whenever we interact with the Viewer.
     * @param {Boolean} [cfg.hideSAO=true] Whether to temporarily hide scalable ambient occlusion (SAO) whenever we interact with the Viewer.
     * @param {Boolean} [cfg.hideEdges=true] Whether to temporarily hide edges whenever we interact with the Viewer.
     * @param {Boolean} [cfg.hideTransparentObjects=false] Whether to temporarily hide transparent objects whenever we interact with the Viewer.
     * @param {Number} [cfg.scaleCanvasResolution=false] Whether to temporarily down-scale the canvas resolution whenever we interact with the Viewer.
     * @param {Number} [cfg.defaultScaleCanvasResolutionFactor=0.6] The factor by which we downscale the canvas resolution whenever we stop interacting with the Viewer.
     * @param {Number} [cfg.scaleCanvasResolutionFactor=0.6] The factor by which we downscale the canvas resolution whenever we interact with the Viewer.
     * @param {Boolean} [cfg.delayBeforeRestore=true] Whether to temporarily have a delay before restoring normal rendering after we stop interacting with the Viewer.
     * @param {Number} [cfg.delayBeforeRestoreSeconds=0.5] Delay in seconds before restoring normal rendering after we stop interacting with the Viewer.
     */function FastNavPlugin(viewer){var _this85;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,FastNavPlugin);_this85=_super119.call(this,"FastNav",viewer);_this85._hideColorTexture=cfg.hideColorTexture!==false;_this85._hidePBR=cfg.hidePBR!==false;_this85._hideSAO=cfg.hideSAO!==false;_this85._hideEdges=cfg.hideEdges!==false;_this85._hideTransparentObjects=!!cfg.hideTransparentObjects;_this85._scaleCanvasResolution=!!cfg.scaleCanvasResolution;_this85._defaultScaleCanvasResolutionFactor=cfg.defaultScaleCanvasResolutionFactor||1.0;_this85._scaleCanvasResolutionFactor=cfg.scaleCanvasResolutionFactor||0.6;_this85._delayBeforeRestore=cfg.delayBeforeRestore!==false;_this85._delayBeforeRestoreSeconds=cfg.delayBeforeRestoreSeconds||0.5;var timer=_this85._delayBeforeRestoreSeconds*1000;var fastMode=false;var switchToLowQuality=function switchToLowQuality(){timer=_this85._delayBeforeRestoreSeconds*1000;if(!fastMode){viewer.scene._renderer.setColorTextureEnabled(!_this85._hideColorTexture);viewer.scene._renderer.setPBREnabled(!_this85._hidePBR);viewer.scene._renderer.setSAOEnabled(!_this85._hideSAO);viewer.scene._renderer.setTransparentEnabled(!_this85._hideTransparentObjects);viewer.scene._renderer.setEdgesEnabled(!_this85._hideEdges);if(_this85._scaleCanvasResolution){viewer.scene.canvas.resolutionScale=_this85._scaleCanvasResolutionFactor;}else{viewer.scene.canvas.resolutionScale=_this85._defaultScaleCanvasResolutionFactor;}fastMode=true;}};var switchToHighQuality=function switchToHighQuality(){viewer.scene.canvas.resolutionScale=_this85._defaultScaleCanvasResolutionFactor;viewer.scene._renderer.setEdgesEnabled(true);viewer.scene._renderer.setColorTextureEnabled(true);viewer.scene._renderer.setPBREnabled(true);viewer.scene._renderer.setSAOEnabled(true);viewer.scene._renderer.setTransparentEnabled(true);fastMode=false;};_this85._onCanvasBoundary=viewer.scene.canvas.on("boundary",switchToLowQuality);_this85._onCameraMatrix=viewer.scene.camera.on("matrix",switchToLowQuality);_this85._onSceneTick=viewer.scene.on("tick",function(tickEvent){if(!fastMode){return;}timer-=tickEvent.deltaTime;if(!_this85._delayBeforeRestore||timer<=0){switchToHighQuality();}});var down=false;_this85._onSceneMouseDown=viewer.scene.input.on("mousedown",function(){down=true;});_this85._onSceneMouseUp=viewer.scene.input.on("mouseup",function(){down=false;});_this85._onSceneMouseMove=viewer.scene.input.on("mousemove",function(){if(!down){return;}switchToLowQuality();});return _this85;}/**
     * Gets whether to temporarily hide color textures whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @return {Boolean} ````true```` if hiding color textures.
     */_createClass(FastNavPlugin,[{key:"hideColorTexture",get:function get(){return this._hideColorTexture;}/**
     * Sets whether to temporarily hide color textures whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @param {Boolean} hideColorTexture ````true```` to hide color textures.
     */,set:function set(hideColorTexture){this._hideColorTexture=hideColorTexture;}/**
     * Gets whether to temporarily hide physically-based rendering (PBR) whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @return {Boolean} ````true```` if hiding PBR.
     */},{key:"hidePBR",get:function get(){return this._hidePBR;}/**
     * Sets whether to temporarily hide physically-based rendering (PBR) whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @param {Boolean} hidePBR ````true```` to hide PBR.
     */,set:function set(hidePBR){this._hidePBR=hidePBR;}/**
     * Gets whether to temporarily hide scalable ambient shadows (SAO) whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @return {Boolean} ````true```` if hiding SAO.
     */},{key:"hideSAO",get:function get(){return this._hideSAO;}/**
     * Sets whether to temporarily hide scalable ambient shadows (SAO) whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @param {Boolean} hideSAO ````true```` to hide SAO.
     */,set:function set(hideSAO){this._hideSAO=hideSAO;}/**
     * Gets whether to temporarily hide edges whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @return {Boolean}  ````true```` if hiding edges.
     */},{key:"hideEdges",get:function get(){return this._hideEdges;}/**
     * Sets whether to temporarily hide edges whenever we interact with the Viewer.
     *
     * Default is ````true````.
     *
     * @param {Boolean} hideEdges ````true```` to hide edges.
     */,set:function set(hideEdges){this._hideEdges=hideEdges;}/**
     * Gets whether to temporarily hide transparent objects whenever we interact with the Viewer.
     *
     * Does not hide X-rayed, selected, highlighted objects.
     *
     * Default is ````false````.
     *
     * @return {Boolean} ````true```` if hiding transparent objects.
     */},{key:"hideTransparentObjects",get:function get(){return this._hideTransparentObjects;}/**
     * Sets whether to temporarily hide transparent objects whenever we interact with the Viewer.
     *
     * Does not hide X-rayed, selected, highlighted objects.
     *
     * Default is ````false````.
     *
     * @param {Boolean} hideTransparentObjects ````true```` to hide transparent objects.
     */,set:function set(hideTransparentObjects){this._hideTransparentObjects=hideTransparentObjects!==false;}/**
     * Gets whether to temporarily scale the canvas resolution whenever we interact with the Viewer.
     *
     * Default is ````false````.
     *
     * The scaling factor is configured via {@link FastNavPlugin#scaleCanvasResolutionFactor}.
     *
     * @return {Boolean} ````true```` if scaling the canvas resolution.
     */},{key:"scaleCanvasResolution",get:function get(){return this._scaleCanvasResolution;}/**
     * Sets the factor to which we restore the canvas resolution scale when we stop interacting with the viewer.
     *
     * Default is ````false````.
     *
     * The scaling factor is configured via {@link FastNavPlugin#scaleCanvasResolutionFactor}.
     *
     * @param {Boolean} scaleCanvasResolution ````true```` to scale the canvas resolution.
     */,set:function set(scaleCanvasResolution){this._scaleCanvasResolution=scaleCanvasResolution;}/**
     * Gets the factor to which we restore the canvas resolution scale when we stop interacting with the viewer.
     *
     * Default is ````1.0````.
     *
     * Enable canvas resolution scaling by setting {@link FastNavPlugin#scaleCanvasResolution} ````true````.
     *
     * @return {Number} Factor by scale canvas resolution when we stop interacting with the viewer.
     */},{key:"defaultScaleCanvasResolutionFactor",get:function get(){return this._defaultScaleCanvasResolutionFactor;}/**
     * Sets the factor to which we restore the canvas resolution scale when we stop interacting with the viewer.
     *
     * Accepted range is ````[0.0 .. 1.0]````.
     *
     * Default is ````1.0````.
     *
     * Enable canvas resolution scaling by setting {@link FastNavPlugin#scaleCanvasResolution} ````true````.
     *
     * @param {Number} defaultScaleCanvasResolutionFactor Factor by scale canvas resolution when we stop interacting with the viewer.
     */,set:function set(defaultScaleCanvasResolutionFactor){this._defaultScaleCanvasResolutionFactor=defaultScaleCanvasResolutionFactor||1.0;}/**
     * Gets the factor by which we temporarily scale the canvas resolution when we interact with the viewer.
     *
     * Default is ````0.6````.
     *
     * Enable canvas resolution scaling by setting {@link FastNavPlugin#scaleCanvasResolution} ````true````.
     *
     * @return {Number} Factor by which we scale the canvas resolution.
     */},{key:"scaleCanvasResolutionFactor",get:function get(){return this._scaleCanvasResolutionFactor;}/**
     * Sets the factor by which we temporarily scale the canvas resolution when we interact with the viewer.
     *
     * Accepted range is ````[0.0 .. 1.0]````.
     *
     * Default is ````0.6````.
     *
     * Enable canvas resolution scaling by setting {@link FastNavPlugin#scaleCanvasResolution} ````true````.
     *
     * @param {Number} scaleCanvasResolutionFactor Factor by which we scale the canvas resolution.
     */,set:function set(scaleCanvasResolutionFactor){this._scaleCanvasResolutionFactor=scaleCanvasResolutionFactor||0.6;}/**
     * Gets whether to have a delay before restoring normal rendering after we stop interacting with the Viewer.
     *
     * The delay duration is configured via {@link FastNavPlugin#delayBeforeRestoreSeconds}.
     *
     * Default is ````true````.
     *
     * @return {Boolean} Whether to have a delay.
     */},{key:"delayBeforeRestore",get:function get(){return this._delayBeforeRestore;}/**
     * Sets whether to have a delay before restoring normal rendering after we stop interacting with the Viewer.
     *
     * The delay duration is configured via {@link FastNavPlugin#delayBeforeRestoreSeconds}.
     *
     * Default is ````true````.
     *
     * @param {Boolean} delayBeforeRestore Whether to have a delay.
     */,set:function set(delayBeforeRestore){this._delayBeforeRestore=delayBeforeRestore;}/**
     * Gets the delay before restoring normal rendering after we stop interacting with the Viewer.
     *
     * The delay is enabled when {@link FastNavPlugin#delayBeforeRestore} is ````true````.
     *
     * Default is ````0.5```` seconds.
     *
     * @return {Number} Delay in seconds.
     */},{key:"delayBeforeRestoreSeconds",get:function get(){return this._delayBeforeRestoreSeconds;}/**
     * Sets the delay before restoring normal rendering after we stop interacting with the Viewer.
     *
     * The delay is enabled when {@link FastNavPlugin#delayBeforeRestore} is ````true````.
     *
     * Default is ````0.5```` seconds.
     *
     * @param {Number} delayBeforeRestoreSeconds Delay in seconds.
     */,set:function set(delayBeforeRestoreSeconds){this._delayBeforeRestoreSeconds=delayBeforeRestoreSeconds!==null&&delayBeforeRestoreSeconds!==undefined?delayBeforeRestoreSeconds:0.5;}/**
     * @private
     */},{key:"send",value:function send(name,value){}/**
     * Destroys this plugin.
     */},{key:"destroy",value:function destroy(){this.viewer.scene.camera.off(this._onCameraMatrix);this.viewer.scene.canvas.off(this._onCanvasBoundary);this.viewer.scene.input.off(this._onSceneMouseDown);this.viewer.scene.input.off(this._onSceneMouseUp);this.viewer.scene.input.off(this._onSceneMouseMove);this.viewer.scene.off(this._onSceneTick);_get(_getPrototypeOf(FastNavPlugin.prototype),"destroy",this).call(this);}}]);return FastNavPlugin;}(Plugin);/**
 * Default data access strategy for {@link GLTFLoaderPlugin}.
 *
 * This just loads assets using XMLHttpRequest.
 */var GLTFDefaultDataSource=/*#__PURE__*/function(){function GLTFDefaultDataSource(){_classCallCheck(this,GLTFDefaultDataSource);}/**
     * Gets metamodel JSON.
     *
     * @param {String|Number} metaModelSrc Identifies the metamodel JSON asset.
     * @param {Function} ok Fired on successful loading of the metamodel JSON asset.
     * @param {Function} error Fired on error while loading the metamodel JSON asset.
     */_createClass(GLTFDefaultDataSource,[{key:"getMetaModel",value:function getMetaModel(metaModelSrc,ok,error){utils.loadJSON(metaModelSrc,function(json){ok(json);},function(errMsg){error(errMsg);});}/**
     * Gets glTF JSON.
     *
     * @param {String|Number} glTFSrc Identifies the glTF JSON asset.
     * @param {Function} ok Fired on successful loading of the glTF JSON asset.
     * @param {Function} error Fired on error while loading the glTF JSON asset.
     */},{key:"getGLTF",value:function getGLTF(glTFSrc,ok,error){utils.loadArraybuffer(glTFSrc,function(gltf){ok(gltf);},function(errMsg){error(errMsg);});}/**
     * Gets binary glTF file.
     *
     * @param {String|Number} glbSrc Identifies the .glb asset.
     * @param {Function} ok Fired on successful loading of the .glb asset.
     * @param {Function} error Fired on error while loading the .glb asset.
     */},{key:"getGLB",value:function getGLB(glbSrc,ok,error){utils.loadArraybuffer(glbSrc,function(arraybuffer){ok(arraybuffer);},function(errMsg){error(errMsg);});}/**
     * Gets glTF binary attachment.
     *
     * Note that this method requires the source of the glTF JSON asset. This is because the binary attachment
     * source could be relative to the glTF source, IE. it may not be a global ID.
     *
     * @param {String|Number} glTFSrc Identifies the glTF JSON asset.
     * @param {String|Number} binarySrc Identifies the glTF binary asset.
     * @param {Function} ok Fired on successful loading of the glTF binary asset.
     * @param {Function} error Fired on error while loading the glTF binary asset.
     */},{key:"getArrayBuffer",value:function getArrayBuffer(glTFSrc,binarySrc,ok,error){loadArraybuffer(glTFSrc,binarySrc,function(arrayBuffer){ok(arrayBuffer);},function(errMsg){error(errMsg);});}}]);return GLTFDefaultDataSource;}();function loadArraybuffer(glTFSrc,binarySrc,ok,err){// Check for data: URI
var defaultCallback=function defaultCallback(){};ok=ok||defaultCallback;err=err||defaultCallback;var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=binarySrc.match(dataUriRegex);if(dataUriRegexResult){// Safari can't handle data URIs through XMLHttpRequest
var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64){data=window.atob(data);}try{var buffer=new ArrayBuffer(data.length);var view=new Uint8Array(buffer);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}core.scheduleTask(function(){ok(buffer);});}catch(error){core.scheduleTask(function(){err(error);});}}else{var basePath=getBasePath$1(glTFSrc);var url=basePath+binarySrc;var request=new XMLHttpRequest();request.open('GET',url,true);request.responseType='arraybuffer';request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){ok(request.response);}else{err('loadArrayBuffer error : '+request.response);}}};request.send(null);}}function getBasePath$1(src){var i=src.lastIndexOf("/");return i!==0?src.substring(0,i+1):"";}/**
 * @desc Localization service for a {@link Viewer}.
 *
 * * A LocaleService is a container of string translations ("messages") for various locales.
 * * A {@link Viewer} has its own default LocaleService at {@link Viewer#localeService}.
 * * We can replace that with our own LocaleService, or a custom subclass, via the Viewer's constructor.
 * * Viewer plugins that need localized translations will attempt to them for the currently active locale from the LocaleService.
 * * Whenever we switch the LocaleService to a different locale, plugins will automatically refresh their translations for that locale.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} that uses an {@link XKTLoaderPlugin} to load a BIM model, and a
 * {@link NavCubePlugin}, which shows a camera navigation cube in the corner of the canvas.
 *
 * We'll also configure our Viewer with our own LocaleService instance, configured with English, Mori and French
 * translations for our NavCubePlugin.
 *
 * We could instead have just used the Viewer's default LocaleService, but this example demonstrates how we might
 * configure the Viewer our own custom LocaleService subclass.
 *
 * The translations fetched by our NavCubePlugin will be:
 *
 *  * "NavCube.front"
 *  * "NavCube.back"
 *  * "NavCube.top"
 *  * "NavCube.bottom"
 *  * "NavCube.left"
 *  * "NavCube.right"
 *
 * <br>
 * These are paths that resolve to our translations for the currently active locale, and are hard-coded within
 * the NavCubePlugin.
 *
 * For example, if  the LocaleService's locale is set to "fr", then the path "NavCube.back" will drill down
 * into ````messages->fr->NavCube->front```` and fetch "Arrire".
 *
 * If we didn't provide that particular translation in our LocaleService, or any translations for that locale,
 * then the NavCubePlugin will just fall back on its own default hard-coded translation, which in this case is "BACK".
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#localization_NavCubePlugin)]
 *
 * ````javascript
 * import {Viewer, LocaleService, NavCubePlugin, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *
 *      canvasId: "myCanvas",
 *
 *      localeService: new LocaleService({
 *          messages: {
 *              "en": { // English
 *                  "NavCube": {
 *                      "front": "Front",
 *                      "back": "Back",
 *                      "top": "Top",
 *                      "bottom": "Bottom",
 *                      "left": "Left",
 *                      "right": "Right"
 *                  }
 *              },
 *              "mi": { // Mori
 *                  "NavCube": {
 *                      "front": "Mua",
 *                      "back": "Tuar",
 *                      "top": "Runga",
 *                      "bottom": "Raro",
 *                      "left": "Mau",
 *                      "right": "Tika"
 *                  }
 *              },
 *              "fr": { // Francais
 *                  "NavCube": {
 *                      "front": "Avant",
 *                      "back": "Arrire",
 *                      "top": "Suprieur",
 *                      "bottom": "Infrieur",
 *                      "left": "Gauche",
 *                      "right": "Droit"
 *                  }
 *              }
 *          },
 *          locale: "en"
 *      })
 *  });
 *
 * viewer.camera.eye = [-3.93, 2.85, 27.01];
 * viewer.camera.look = [4.40, 3.72, 8.89];
 * viewer.camera.up = [-0.01, 0.99, 0.03];
 *
 * const navCubePlugin = new NavCubePlugin(viewer, {
 *      canvasID: "myNavCubeCanvas"
 *  });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Duplex.ifc.xkt",
 *     edges: true
 * });
 * ````
 *
 * We can dynamically switch our Viewer to a different locale at any time, which will update the text on the
 * faces of our NavCube:
 *
 * ````javascript
 * viewer.localeService.locale = "mi"; // Switch to Mori
 * ````
 *
 * We can load new translations at any time:
 *
 * ````javascript
 * viewer.localeService.loadMessages({
 *     "jp": { // Japanese
 *         "NavCube": {
 *             "front": "",
 *             "back": "",
 *             "top": "",
 *             "bottom": "",
 *             "left": "",
 *             "right": ""
 *         }
 *     }
 * });
 * ````
 *
 * And we can clear the translations if needed:
 *
 * ````javascript
 * viewer.localeService.clearMessages();
 * ````
 *
 * We can get an "updated" event from the LocaleService whenever we switch locales or load messages, which is useful
 * for triggering UI elements to refresh themselves with updated translations. Internally, our {@link NavCubePlugin}
 * subscribes to this event, fetching new strings for itself via {@link LocaleService#translate} each time the
 * event is fired.
 *
 * ````javascript
 * viewer.localeService.on("updated", () => {
 *     console.log( viewer.localeService.translate("NavCube.left") );
 * });
 * ````
 * @since 2.0
 */var LocaleService=/*#__PURE__*/function(){/**
     * Constructs a LocaleService.
     *
     * @param {*} [params={}]
     * @param {JSON} [params.messages]
     * @param {String} [params.locale]
     */function LocaleService(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,LocaleService);this._eventSubIDMap=null;this._eventSubEvents=null;this._eventSubs=null;this._events=null;this._locale="en";this._messages={};this._locales=[];this._locale="en";this.messages=params.messages;this.locale=params.locale;}/**
     * Replaces the current set of locale translations.
     *
     * * Fires an "updated" event when done.
     * * Automatically refreshes any plugins that depend on the translations.
     * * Does not change the current locale.
     *
     * ## Usage
     *
     * ````javascript
     * viewer.localeService.setMessages({
     *     messages: {
     *         "en": { // English
     *             "NavCube": {
     *                 "front": "Front",
     *                 "back": "Back",
     *                 "top": "Top",
     *                 "bottom": "Bottom",
     *                 "left": "Left",
     *                 "right": "Right"
     *             }
     *         },
     *         "mi": { // Mori
     *             "NavCube": {
     *                 "front": "Mua",
     *                 "back": "Tuar",
     *                 "top": "Runga",
     *                 "bottom": "Raro",
     *                 "left": "Mau",
     *                 "right": "Tika"
     *             }
     *         }
     *    }
     * });
     * ````
     *
     * @param {*} messages The new translations.
     */_createClass(LocaleService,[{key:"messages",set:function set(messages){this._messages=messages||{};this._locales=Object.keys(this._messages);this.fire("updated",this);}/**
     * Loads a new set of locale translations, adding them to the existing translations.
     *
     * * Fires an "updated" event when done.
     * * Automatically refreshes any plugins that depend on the translations.
     * * Does not change the current locale.
     *
     * ## Usage
     *
     * ````javascript
     * viewer.localeService.loadMessages({
     *     "jp": { // Japanese
     *         "NavCube": {
     *             "front": "",
     *             "back": "",
     *             "top": "",
     *             "bottom": "",
     *             "left": "",
     *             "right": ""
     *         }
     *     }
     * });
     * ````
     *
     * @param {*} messages The new translations.
     */},{key:"loadMessages",value:function loadMessages(){var messages=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};for(var locale in messages){this._messages[locale]=messages[locale];}this.messages=this._messages;}/**
     * Clears all locale translations.
     *
     * * Fires an "updated" event when done.
     * * Does not change the current locale.
     * * Automatically refreshes any plugins that depend on the translations, which will cause those
     * plugins to fall back on their internal hard-coded text values, since this method removes all
     * our translations.
     */},{key:"clearMessages",value:function clearMessages(){this.messages={};}/**
     * Gets the list of available locales.
     *
     * These are derived from the currently configured set of translations.
     *
     * @returns {String[]} The list of available locales.
     */},{key:"locales",get:function get(){return this._locales;}/**
     * Sets the current locale.
     *
     * * Fires an "updated" event when done.
     * * The given locale does not need to be in the list of available locales returned by {@link LocaleService#locales}, since
     * this method assumes that you may want to load the locales at a later point.
     * * Automatically refreshes any plugins that depend on the translations.
     * * We can then get translations for the locale, if translations have been loaded for it, via {@link LocaleService#translate} and {@link LocaleService#translatePlurals}.
     *
     * @param {String} locale The new current locale.
     */},{key:"locale",get:/**
     * Gets the current locale.
     *
     * @returns {String} The current locale.
     */function get(){return this._locale;}/**
     * Translates the given string according to the current locale.
     *
     * Returns null if no translation can be found.
     *
     * @param {String} msg String to translate.
     * @param {*} [args] Extra parameters.
     * @returns {String|null} Translated string if found, else null.
     */,set:function set(locale){locale=locale||"de";if(this._locale===locale){return;}this._locale=locale;this.fire("updated",locale);}},{key:"translate",value:function translate(msg,args){var localeMessages=this._messages[this._locale];if(!localeMessages){return null;}var localeMessage=resolvePath$1(msg,localeMessages);if(localeMessage){if(args){return vsprintf(localeMessage,args);}return localeMessage;}return null;}/**
     * Translates the given phrase according to the current locale.
     *
     * Returns null if no translation can be found.
     *
     * @param {String} msg Phrase to translate.
     * @param {Number} count The plural number.
     * @param {*} [args] Extra parameters.
     * @returns {String|null} Translated string if found, else null.
     */},{key:"translatePlurals",value:function translatePlurals(msg,count,args){var localeMessages=this._messages[this._locale];if(!localeMessages){return null;}var localeMessage=resolvePath$1(msg,localeMessages);count=parseInt(""+count,10);if(count===0){localeMessage=localeMessage.zero;}else{localeMessage=count>1?localeMessage.other:localeMessage.one;}if(!localeMessage){return null;}localeMessage=vsprintf(localeMessage,[count]);if(args){localeMessage=vsprintf(localeMessage,args);}return localeMessage;}/**
     * Fires an event on this LocaleService.
     *
     * Notifies existing subscribers to the event, optionally retains the event to give to
     * any subsequent notifications on the event as they are made.
     *
     * @param {String} event The event type name.
     * @param {Object} value The event parameters.
     * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers.
     */},{key:"fire",value:function fire(event,value,forget){if(!this._events){this._events={};}if(!this._eventSubs){this._eventSubs={};}if(forget!==true){this._events[event]=value||true;// Save notification
}var subs=this._eventSubs[event];if(subs){for(var subId in subs){if(subs.hasOwnProperty(subId)){var sub=subs[subId];sub.callback(value);}}}}/**
     * Subscribes to an event on this LocaleService.
     *
     * @param {String} event The event
     * @param {Function} callback Callback fired on the event
     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
     */},{key:"on",value:function on(event,callback){if(!this._events){this._events={};}if(!this._eventSubIDMap){this._eventSubIDMap=new Map$1();// Subscription subId pool
}if(!this._eventSubEvents){this._eventSubEvents={};}if(!this._eventSubs){this._eventSubs={};}var subs=this._eventSubs[event];if(!subs){subs={};this._eventSubs[event]=subs;}var subId=this._eventSubIDMap.addItem();// Create unique subId
subs[subId]={callback:callback};this._eventSubEvents[subId]=event;var value=this._events[event];if(value!==undefined){callback(value);}return subId;}/**
     * Cancels an event subscription that was previously made with {@link LocaleService#on}.
     *
     * @param {String} subId Subscription ID
     */},{key:"off",value:function off(subId){if(subId===undefined||subId===null){return;}if(!this._eventSubEvents){return;}var event=this._eventSubEvents[subId];if(event){delete this._eventSubEvents[subId];var subs=this._eventSubs[event];if(subs){delete subs[subId];}this._eventSubIDMap.removeItem(subId);// Release subId
}}}]);return LocaleService;}();function resolvePath$1(key,json){if(json[key]){return json[key];}var parts=key.split(".");var obj=json;for(var _i454=0,len=parts.length;obj&&_i454<len;_i454++){var part=parts[_i454];obj=obj[part];}return obj;}function vsprintf(msg){var args=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];return msg.replace(/\{\{|\}\}|\{(\d+)\}/g,function(m,n){if(m==="{{"){return"{";}if(m==="}}"){return"}";}return args[n];});}/**
 * @desc Abstract base class for curve classes.
 */var Curve=/*#__PURE__*/function(_Component31){_inherits(Curve,_Component31);var _super120=_createSuper(Curve);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this Curve as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Curve}, generated automatically when omitted.
     * @param {Object} [cfg] Configs for this Curve.
     * @param {Number} [cfg.t=0] Current position on this Curve, in range between ````0..1````.
     */function Curve(owner){var _this86;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Curve);_this86=_super120.call(this,owner,cfg);_this86.t=cfg.t;return _this86;}/**
     * Sets the progress along this Curve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The progress value.
     */_createClass(Curve,[{key:"t",get:/**
     * Gets the progress along this Curve.
     *
     * @returns {Number} The progress value.
     */function get(){return this._t;}/**
     * Gets the tangent on this Curve at position {@link Curve#t}.
     *
     * @returns {Number[]} The tangent.
     */,set:function set(value){value=value||0;this._t=value<0.0?0.0:value>1.0?1.0:value;}},{key:"tangent",get:function get(){return this.getTangent(this._t);}/**
     * Gets the length of this Curve.
     *
     * @returns {Number} The Curve length.
     */},{key:"length",get:function get(){var lengths=this._getLengths();return lengths[lengths.length-1];}/**
     * Returns a normalized tangent vector on this Curve at the given position.
     *
     * @param {Number} t Position to get tangent at.
     * @returns {Number[]} Normalized tangent vector
     */},{key:"getTangent",value:function getTangent(t){var delta=0.0001;if(t===undefined){t=this._t;}var t1=t-delta;var t2=t+delta;if(t1<0){t1=0;}if(t2>1){t2=1;}var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=math.subVec3(pt2,pt1,[]);return math.normalizeVec3(vec,[]);}},{key:"getPointAt",value:function getPointAt(u){var t=this.getUToTMapping(u);return this.getPoint(t);}/**
     * Samples points on this Curve, at the given number of equally-spaced divisions.
     *
     * @param {Number} divisions The number of divisions.
     * @returns {{Array of Array}} Array of sampled 3D points.
     */},{key:"getPoints",value:function getPoints(divisions){if(!divisions){divisions=5;}var d,pts=[];for(d=0;d<=divisions;d++){pts.push(this.getPoint(d/divisions));}return pts;}},{key:"_getLengths",value:function _getLengths(divisions){if(!divisions){divisions=this.__arcLengthDivisions?this.__arcLengthDivisions:200;}if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current;var last=this.getPoint(0);var p;var sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=math.lenVec3(math.subVec3(current,last,[]));cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum:sum }, Sum is in the last element.
}},{key:"_updateArcLengths",value:function _updateArcLengths(){this.needsUpdate=true;this._getLengths();}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
},{key:"getUToTMapping",value:function getUToTMapping(u,distance){var arcLengths=this._getLengths();var i=0;var il=arcLengths.length;var t;var targetArcLength;// The targeted u distance value to get
if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}//var time = Date.now();
var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
}}i=high;if(arcLengths[i]===targetArcLength){t=i/(il-1);return t;}var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;t=(i+segmentFraction)/(il-1);return t;}}]);return Curve;}(Component);/**
 * @desc A {@link Curve} along which a 3D position can be animated.
 *
 * * As shown in the diagram below, a SplineCurve is defined by three or more control points.
 * * You can sample a {@link SplineCurve#point} and a {@link Curve#tangent} vector on a SplineCurve for any given value of {@link SplineCurve#t} in the range ````[0..1]````.
 * * When you set {@link SplineCurve#t} on a SplineCurve, its {@link SplineCurve#point} and {@link Curve#tangent} will update accordingly.
 * * To build a complex path, you can combine an unlimited combination of SplineCurves, {@link CubicBezierCurve} and {@link QuadraticBezierCurve} into a {@link Path}.
 * <br>
 * <img style="border:1px solid; background: white;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Quadratic_spline_six_segments.svg/200px-Quadratic_spline_six_segments.svg.png"/><br>
 *
 * * <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">Spline Curve from Wikipedia</a>*
 */var SplineCurve=/*#__PURE__*/function(_Curve){_inherits(SplineCurve,_Curve);var _super121=_createSuper(SplineCurve);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this SplineCurve as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Array} [cfg.points=[]] Control points on this SplineCurve.
     * @param {Number} [cfg.t=0] Current position on this SplineCurve, in range between 0..1.
     * @param {Number} [cfg.t=0] Current position on this CubicBezierCurve, in range between 0..1.
     */function SplineCurve(owner){var _this87;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SplineCurve);_this87=_super121.call(this,owner,cfg);_this87.points=cfg.points;_this87.t=cfg.t;return _this87;}/**
     * Sets the control points on this SplineCurve.
     *
     * Default value is ````[]````.
     *
     * @param {Number[]} value New control points.
     */_createClass(SplineCurve,[{key:"points",get:/**
     * Gets the control points on this SplineCurve.
     *
     * Default value is ````[]````.
     *
     * @returns {Number[]} The control points.
     */function get(){return this._points;}/**
     * Sets the progress along this SplineCurve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The new progress.
     */,set:function set(value){this._points=value||[];}},{key:"t",get:/**
     * Gets the progress along this SplineCurve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The new progress.
     */function get(){return this._t;}/**
     * Gets the point on this SplineCurve at position {@link SplineCurve#t}.
     *
     * @returns {Number[]} The point at {@link SplineCurve#t}.
     */,set:function set(value){value=value||0;this._t=value<0.0?0.0:value>1.0?1.0:value;}},{key:"point",get:function get(){return this.getPoint(this._t);}/**
     * Returns point on this SplineCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     * @returns {Number[]} Point at the given position.
     */},{key:"getPoint",value:function getPoint(t){var points=this.points;if(points.length<3){this.error("Can't sample point from SplineCurve - not enough points on curve - returning [0,0,0].");return;}var point=(points.length-1)*t;var intPoint=Math.floor(point);var weight=point-intPoint;var point0=points[intPoint===0?intPoint:intPoint-1];var point1=points[intPoint];var point2=points[intPoint>points.length-2?points.length-1:intPoint+1];var point3=points[intPoint>points.length-3?points.length-1:intPoint+2];var vector=math.vec3();vector[0]=math.catmullRomInterpolate(point0[0],point1[0],point2[0],point3[0],weight);vector[1]=math.catmullRomInterpolate(point0[1],point1[1],point2[1],point3[1],weight);vector[2]=math.catmullRomInterpolate(point0[2],point1[2],point2[2],point3[2],weight);return vector;}},{key:"getJSON",value:function getJSON(){return{points:points,t:this._t};}}]);return SplineCurve;}(Curve);var tempVec3a$8=math.vec3();/**
 * @desc Defines a sequence of frames along which a {@link CameraPathAnimation} can animate a {@link Camera}.
 *
 * See {@link CameraPathAnimation} for usage.
 */var CameraPath=/*#__PURE__*/function(_Component32){_inherits(CameraPath,_Component32);var _super122=_createSuper(CameraPath);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this CameraPath as well.
     * @param [cfg] {*} Configuration
     * @param {String} [cfg.id]  Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {{t:Number, eye:Object, look:Object, up: Object}[]} [cfg.frames] Initial sequence of frames.
     */function CameraPath(owner){var _this88;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CameraPath);_this88=_super122.call(this,owner,cfg);_this88._frames=[];_this88._eyeCurve=new SplineCurve(_assertThisInitialized(_this88));_this88._lookCurve=new SplineCurve(_assertThisInitialized(_this88));_this88._upCurve=new SplineCurve(_assertThisInitialized(_this88));if(cfg.frames){_this88.addFrames(cfg.frames);_this88.smoothFrameTimes(1);}return _this88;}/**
     * Gets the camera frames in this CameraPath.
     *
     * @returns {{t:Number, eye:Object, look:Object, up: Object}[]} The frames on this CameraPath.
     */_createClass(CameraPath,[{key:"type",get:/**
     * Returns "CameraPath".
     *
     * @private
     *
     * @returns {string} "CameraPath"
     */function get(){return"CameraPath";}},{key:"frames",get:function get(){return this._frames;}/**
     * Gets the {@link SplineCurve} along which {@link Camera#eye} travels.
     * @returns {SplineCurve} The SplineCurve for {@link Camera#eye}.
     */},{key:"eyeCurve",get:function get(){return this._eyeCurve;}/**
     * Gets the {@link SplineCurve} along which {@link Camera#look} travels.
     * @returns {SplineCurve} The SplineCurve for {@link Camera#look}.
     */},{key:"lookCurve",get:function get(){return this._lookCurve;}/**
     * Gets the {@link SplineCurve} along which {@link Camera#up} travels.
     * @returns {SplineCurve} The SplineCurve for {@link Camera#up}.
     */},{key:"upCurve",get:function get(){return this._upCurve;}/**
     * Adds a frame to this CameraPath, given as the current position of the {@link Camera}.
     *
     * @param {Number} t Time instant for the new frame.
     */},{key:"saveFrame",value:function saveFrame(t){var camera=this.scene.camera;this.addFrame(t,camera.eye,camera.look,camera.up);}/**
     * Adds a frame to this CameraPath, specified as values for eye, look and up vectors at a given time instant.
     *
     * @param {Number} t Time instant for the new frame.
     * @param {Number[]} eye A three-element vector specifying the eye position for the new frame.
     * @param {Number[]} look A three-element vector specifying the look position for the new frame.
     * @param {Number[]} up A three-element vector specifying the up vector for the new frame.
     */},{key:"addFrame",value:function addFrame(t,eye,look,up){var frame={t:t,eye:eye.slice(0),look:look.slice(0),up:up.slice(0)};this._frames.push(frame);this._eyeCurve.points.push(frame.eye);this._lookCurve.points.push(frame.look);this._upCurve.points.push(frame.up);}/**
     * Adds multiple frames to this CameraPath, each frame specified as a set of values for eye, look and up vectors at a given time instant.
     *
     * @param {{t:Number, eye:Object, look:Object, up: Object}[]} frames Frames to add to this CameraPath.
     */},{key:"addFrames",value:function addFrames(frames){var frame;for(var _i455=0,len=frames.length;_i455<len;_i455++){frame=frames[_i455];this.addFrame(frame.t||0,frame.eye,frame.look,frame.up);}}/**
     * Sets the position of the {@link Camera} to a position interpolated within this CameraPath at the given time instant.
     *
     * @param {Number} t Time instant.
     */},{key:"loadFrame",value:function loadFrame(t){var camera=this.scene.camera;t=t/(this._frames[this._frames.length-1].t-this._frames[0].t);t=t<0.0?0.0:t>1.0?1.0:t;camera.eye=this._eyeCurve.getPoint(t,tempVec3a$8);camera.look=this._lookCurve.getPoint(t,tempVec3a$8);camera.up=this._upCurve.getPoint(t,tempVec3a$8);}/**
     * Gets eye, look and up vectors on this CameraPath at a given instant.
     *
     * @param {Number} t Time instant.
     * @param {Number[]} eye The eye position to update.
     * @param {Number[]} look The look position to update.
     * @param {Number[]} up The up vector to update.
     */},{key:"sampleFrame",value:function sampleFrame(t,eye,look,up){t=t<0.0?0.0:t>1.0?1.0:t;this._eyeCurve.getPoint(t,eye);this._lookCurve.getPoint(t,look);this._upCurve.getPoint(t,up);}/**
     * Given a total duration (in seconds) for this CameraPath, recomputes the time instant at each frame so that,
     * when animated by {@link CameraPathAnimation}, the {@link Camera} will move along the path at a constant rate.
     *
     * @param {Number} duration The total duration for this CameraPath.
     */},{key:"smoothFrameTimes",value:function smoothFrameTimes(duration){var numFrames=this._frames.length;if(numFrames===0){return;}var vec=math.vec3();var totalLen=0;this._frames[0].t=0;var lens=[];for(var _i456=1,len=this._frames.length;_i456<len;_i456++){var lenVec=math.lenVec3(math.subVec3(this._frames[_i456].eye,this._frames[_i456-1].eye,vec));lens[_i456]=lenVec;totalLen+=lenVec;}for(var _i457=1,_len92=this._frames.length;_i457<_len92;_i457++){var interFrameRate=lens[_i457]/totalLen*duration;this._frames[_i457].t=this._frames[_i457-1].t+interFrameRate;}}/**
     * Removes all frames from this CameraPath.
     */},{key:"clearFrames",value:function clearFrames(){this._frames=[];this._eyeCurve.points=[];this._lookCurve.points=[];this._upCurve.points=[];}}]);return CameraPath;}(Component);var tempVec3$4=math.vec3();var newLook=math.vec3();var newEye=math.vec3();var newUp=math.vec3();var newLookEyeVec=math.vec3();/**
 * @desc Jumps or flies the {@link Scene}'s {@link Camera} to a given target.
 *
 * * Located at {@link Viewer#cameraFlight}
 * * Can fly or jump to its target.
 * * While flying, can be stopped, or redirected to a different target.
 * * Can also smoothly transition between ortho and perspective projections.
 *
 *
 * A CameraFlightAnimation's target can be:
 *
 * * specific ````eye````, ````look```` and ````up```` positions,
 * * an axis-aligned World-space bounding box (AABB), or
 * * an instance or ID of any {@link Component} subtype that provides a World-space AABB.
 *
 * A target can also contain a ````projection```` type to transition into. For example, if your {@link Camera#projection} is
 * currently ````"perspective"```` and you supply {@link CameraFlightAnimation#flyTo} with a ````projection```` property
 * equal to "ortho", then CameraFlightAnimation will smoothly transition the Camera into an orthographic projection.
 *
 * Configure {@link CameraFlightAnimation#fit} and {@link CameraFlightAnimation#fitFOV} to make it stop at the point
 * where the target occupies a certain amount of the field-of-view.
 *
 * ## Flying to an Entity
 *
 * Flying to an {@link Entity}:
 *
 * ````Javascript
 * var entity = new Mesh(viewer.scene);
 *
 * // Fly to the Entity's World-space AABB
 * viewer.cameraFlight.flyTo(entity);
 * ````
 * ## Flying to a Position
 *
 * Flying the CameraFlightAnimation from the previous example to specified eye, look and up positions:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({
 *    eye: [-5,-5,-5],
 *    look: [0,0,0]
 *    up: [0,1,0],
 *    duration: 1 // Default, seconds
 * },() => {
 *      // Done
 * });
 * ````
 *
 * ## Flying to an AABB
 *
 * Flying the CameraFlightAnimation from the previous two examples explicitly to the {@link Boundary3D"}}Boundary3D's{{/crossLink}}
 * axis-aligned bounding box:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo(entity.aabb);
 * ````
 *
 * ## Transitioning Between Projections
 *
 * CameraFlightAnimation also allows us to smoothly transition between Camera projections. We can do that by itself, or
 * in addition to flying the Camera to a target.
 *
 * Let's transition the Camera to orthographic projection:
 *
 * [[Run example](/examples/#camera_CameraFlightAnimation_projection)]
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({ projection: "ortho", () => {
 *      // Done
 * });
 * ````
 *
 * Now let's transition the Camera back to perspective projection:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({ projection: "perspective"}, () => {
 *      // Done
 * });
 * ````
 *
 * Fly Camera to a position, while transitioning to orthographic projection:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({
 *     eye: [-100,20,2],
 *     look: [0,0,-40],
 *     up: [0,1,0],
 *     projection: "ortho", () => {
 *        // Done
 * });
 * ````
 */var CameraFlightAnimation=/*#__PURE__*/function(_Component33){_inherits(CameraFlightAnimation,_Component33);var _super123=_createSuper(CameraFlightAnimation);/**
     @constructor
     @private
     */function CameraFlightAnimation(owner){var _this89;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CameraFlightAnimation);_this89=_super123.call(this,owner,cfg);_this89._look1=math.vec3();_this89._eye1=math.vec3();_this89._up1=math.vec3();_this89._look2=math.vec3();_this89._eye2=math.vec3();_this89._up2=math.vec3();_this89._orthoScale1=1;_this89._orthoScale2=1;_this89._flying=false;_this89._flyEyeLookUp=false;_this89._flyingEye=false;_this89._flyingLook=false;_this89._callback=null;_this89._callbackScope=null;_this89._time1=null;_this89._time2=null;_this89.easing=cfg.easing!==false;_this89.duration=cfg.duration;_this89.fit=cfg.fit;_this89.fitFOV=cfg.fitFOV;_this89.trail=cfg.trail;return _this89;}/**
     * Flies the {@link Camera} to a target.
     *
     *  * When the target is a boundary, the {@link Camera} will fly towards the target and stop when the target fills most of the canvas.
     *  * When the target is an explicit {@link Camera} position, given as ````eye````, ````look```` and ````up````, then CameraFlightAnimation will interpolate the {@link Camera} to that target and stop there.
     *
     * @param {Object|Component} [params=Scene] Either a parameters object or a {@link Component} subtype that has
     * an AABB. Defaults to the {@link Scene}, which causes the {@link Camera} to fit the Scene in view.
     * @param {Number} [params.arc=0] Factor in range ````[0..1]```` indicating how much the {@link Camera#eye} position
     * will swing away from its {@link Camera#look} position as it flies to the target.
     * @param {Number|String|Component} [params.component] ID or instance of a component to fly to. Defaults to the entire {@link Scene}.
     * @param {Number[]} [params.aabb] World-space axis-aligned bounding box (AABB) target to fly to.
     * @param {Number[]} [params.eye] Position to fly the eye position to.
     * @param {Number[]} [params.look] Position to fly the look position to.
     * @param {Number[]} [params.up] Position to fly the up vector to.
     * @param {String} [params.projection] Projection type to transition into as we fly. Can be any of the values of {@link Camera.projection}.
     * @param {Boolean} [params.fit=true] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation#fit}.
     * @param {Number} [params.fitFOV] How much of field-of-view, in degrees, that a target {@link Entity} or its AABB should
     * fill the canvas on arrival. Overrides {@link CameraFlightAnimation#fitFOV}.
     * @param {Number} [params.duration] Flight duration in seconds.  Overrides {@link CameraFlightAnimation#duration}.
     * @param {Number} [params.orthoScale] Animate the Camera's orthographic scale to this target value. See {@link Ortho#scale}.
     * @param {Function} [callback] Callback fired on arrival.
     * @param {Object} [scope] Optional scope for callback.
     */_createClass(CameraFlightAnimation,[{key:"type",get:/**
     * @private
     */function get(){return"CameraFlightAnimation";}},{key:"flyTo",value:function flyTo(params,callback,scope){params=params||this.scene;if(this._flying){this.stop();}this._flying=false;this._flyingEye=false;this._flyingLook=false;this._flyingEyeLookUp=false;this._callback=callback;this._callbackScope=scope;var camera=this.scene.camera;var flyToProjection=!!params.projection&&params.projection!==camera.projection;this._eye1[0]=camera.eye[0];this._eye1[1]=camera.eye[1];this._eye1[2]=camera.eye[2];this._look1[0]=camera.look[0];this._look1[1]=camera.look[1];this._look1[2]=camera.look[2];this._up1[0]=camera.up[0];this._up1[1]=camera.up[1];this._up1[2]=camera.up[2];this._orthoScale1=camera.ortho.scale;this._orthoScale2=params.orthoScale||this._orthoScale1;var aabb;var eye;var look;var up;var componentId;if(params.aabb){aabb=params.aabb;}else if(params.length===6){aabb=params;}else if(params.eye&&params.look||params.up){eye=params.eye;look=params.look;up=params.up;}else if(params.eye){eye=params.eye;}else if(params.look){look=params.look;}else{// Argument must be an instance or ID of a Component (subtype)
var component=params;if(utils.isNumeric(component)||utils.isString(component)){componentId=component;component=this.scene.components[componentId];if(!component){this.error("Component not found: "+utils.inQuotes(componentId));if(callback){if(scope){callback.call(scope);}else{callback();}}return;}}if(!flyToProjection){aabb=component.aabb||this.scene.aabb;}}var poi=params.poi;if(aabb){if(aabb[3]<aabb[0]||aabb[4]<aabb[1]||aabb[5]<aabb[2]){// Don't fly to an inverted boundary
return;}if(aabb[3]===aabb[0]&&aabb[4]===aabb[1]&&aabb[5]===aabb[2]){// Don't fly to an empty boundary
return;}aabb=aabb.slice();var aabbCenter=math.getAABB3Center(aabb);this._look2=poi||aabbCenter;var _eyeLookVec=math.subVec3(this._eye1,this._look1,tempVec3$4);var _eyeLookVecNorm=math.normalizeVec3(_eyeLookVec);var diag=poi?math.getAABB3DiagPoint(aabb,poi):math.getAABB3Diag(aabb);var fitFOV=params.fitFOV||this._fitFOV;var sca=Math.abs(diag/Math.tan(fitFOV*math.DEGTORAD));this._orthoScale2=diag*1.1;this._eye2[0]=this._look2[0]+_eyeLookVecNorm[0]*sca;this._eye2[1]=this._look2[1]+_eyeLookVecNorm[1]*sca;this._eye2[2]=this._look2[2]+_eyeLookVecNorm[2]*sca;this._up2[0]=this._up1[0];this._up2[1]=this._up1[1];this._up2[2]=this._up1[2];this._flyingEyeLookUp=true;}else if(eye||look||up){this._flyingEyeLookUp=!!eye&&!!look&&!!up;this._flyingEye=!!eye&&!look;this._flyingLook=!!look&&!eye;if(eye){this._eye2[0]=eye[0];this._eye2[1]=eye[1];this._eye2[2]=eye[2];}if(look){this._look2[0]=look[0];this._look2[1]=look[1];this._look2[2]=look[2];}if(up){this._up2[0]=up[0];this._up2[1]=up[1];this._up2[2]=up[2];}}if(flyToProjection){if(params.projection==="ortho"&&camera.projection!=="ortho"){this._projection2="ortho";this._projMatrix1=camera.projMatrix.slice();this._projMatrix2=camera.ortho.matrix.slice();camera.projection="customProjection";}if(params.projection==="perspective"&&camera.projection!=="perspective"){this._projection2="perspective";this._projMatrix1=camera.projMatrix.slice();this._projMatrix2=camera.perspective.matrix.slice();camera.projection="customProjection";}}else{this._projection2=null;}this.fire("started",params,true);this._time1=Date.now();this._time2=this._time1+(params.duration?params.duration*1000:this._duration);this._flying=true;// False as soon as we stop
core.scheduleTask(this._update,this);}/**
     * Jumps the {@link Scene}'s {@link Camera} to the given target.
     *
     * * When the target is a boundary, this CameraFlightAnimation will position the {@link Camera} at where the target fills most of the canvas.
     * * When the target is an explicit {@link Camera} position, given as ````eye````, ````look```` and ````up```` vectors, then this CameraFlightAnimation will jump the {@link Camera} to that target.
     *
     * @param {*|Component} params  Either a parameters object or a {@link Component} subtype that has a World-space AABB.
     * @param {Number} [params.arc=0]  Factor in range [0..1] indicating how much the {@link Camera#eye} will swing away from its {@link Camera#look} as it flies to the target.
     * @param {Number|String|Component} [params.component] ID or instance of a component to fly to.
     * @param {Number[]} [params.aabb]  World-space axis-aligned bounding box (AABB) target to fly to.
     * @param {Number[]} [params.eye] Position to fly the eye position to.
     * @param {Number[]} [params.look]  Position to fly the look position to.
     * @param {Number[]} [params.up] Position to fly the up vector to.
     * @param {String} [params.projection] Projection type to transition into. Can be any of the values of {@link Camera.projection}.
     * @param {Number} [params.fitFOV] How much of field-of-view, in degrees, that a target {@link Entity} or its AABB should fill the canvas on arrival. Overrides {@link CameraFlightAnimation#fitFOV}.
     * @param {Boolean} [params.fit] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation#fit}.
     */},{key:"jumpTo",value:function jumpTo(params){this._jumpTo(params);}},{key:"_jumpTo",value:function _jumpTo(params){if(this._flying){this.stop();}var camera=this.scene.camera;var aabb;var componentId;var newEye;var newLook;var newUp;if(params.aabb){// Boundary3D
aabb=params.aabb;}else if(params.length===6){// AABB
aabb=params;}else if(params.eye||params.look||params.up){// Camera pose
newEye=params.eye;newLook=params.look;newUp=params.up;}else{// Argument must be an instance or ID of a Component (subtype)
var component=params;if(utils.isNumeric(component)||utils.isString(component)){componentId=component;component=this.scene.components[componentId];if(!component){this.error("Component not found: "+utils.inQuotes(componentId));return;}}aabb=component.aabb||this.scene.aabb;}var poi=params.poi;if(aabb){if(aabb[3]<=aabb[0]||aabb[4]<=aabb[1]||aabb[5]<=aabb[2]){// Don't fly to an empty boundary
return;}var diag=poi?math.getAABB3DiagPoint(aabb,poi):math.getAABB3Diag(aabb);newLook=poi||math.getAABB3Center(aabb,newLook);if(this._trail){math.subVec3(camera.look,newLook,newLookEyeVec);}else{math.subVec3(camera.eye,camera.look,newLookEyeVec);}math.normalizeVec3(newLookEyeVec);var dist;var fit=params.fit!==undefined?params.fit:this._fit;if(fit){dist=Math.abs(diag/Math.tan((params.fitFOV||this._fitFOV)*math.DEGTORAD));}else{dist=math.lenVec3(math.subVec3(camera.eye,camera.look,tempVec3$4));}math.mulVec3Scalar(newLookEyeVec,dist);camera.eye=math.addVec3(newLook,newLookEyeVec,tempVec3$4);camera.look=newLook;this.scene.camera.ortho.scale=diag*1.1;}else if(newEye||newLook||newUp){if(newEye){camera.eye=newEye;}if(newLook){camera.look=newLook;}if(newUp){camera.up=newUp;}}if(params.projection){camera.projection=params.projection;}}},{key:"_update",value:function _update(){if(!this._flying){return;}var time=Date.now();var t=(time-this._time1)/(this._time2-this._time1);var stopping=t>=1;if(t>1){t=1;}var tFlight=this.easing?CameraFlightAnimation._ease(t,0,1,1):t;var camera=this.scene.camera;if(this._flyingEye||this._flyingLook){if(this._flyingEye){math.subVec3(camera.eye,camera.look,newLookEyeVec);camera.eye=math.lerpVec3(tFlight,0,1,this._eye1,this._eye2,newEye);camera.look=math.subVec3(newEye,newLookEyeVec,newLook);}else if(this._flyingLook){camera.look=math.lerpVec3(tFlight,0,1,this._look1,this._look2,newLook);camera.up=math.lerpVec3(tFlight,0,1,this._up1,this._up2,newUp);}}else if(this._flyingEyeLookUp){camera.eye=math.lerpVec3(tFlight,0,1,this._eye1,this._eye2,newEye);camera.look=math.lerpVec3(tFlight,0,1,this._look1,this._look2,newLook);camera.up=math.lerpVec3(tFlight,0,1,this._up1,this._up2,newUp);}if(this._projection2){var tProj=this._projection2==="ortho"?CameraFlightAnimation._easeOutExpo(t,0,1,1):CameraFlightAnimation._easeInCubic(t,0,1,1);camera.customProjection.matrix=math.lerpMat4(tProj,0,1,this._projMatrix1,this._projMatrix2);}else{camera.ortho.scale=this._orthoScale1+t*(this._orthoScale2-this._orthoScale1);}if(stopping){camera.ortho.scale=this._orthoScale2;this.stop();return;}core.scheduleTask(this._update,this);// Keep flying
}},{key:"stop",value:/**
     * Stops an earlier flyTo, fires arrival callback.
     */function stop(){if(!this._flying){return;}this._flying=false;this._time1=null;this._time2=null;if(this._projection2){this.scene.camera.projection=this._projection2;}var callback=this._callback;if(callback){this._callback=null;if(this._callbackScope){callback.call(this._callbackScope);}else{callback();}}this.fire("stopped",true,true);}/**
     * Cancels an earlier flyTo without calling the arrival callback.
     */},{key:"cancel",value:function cancel(){if(!this._flying){return;}this._flying=false;this._time1=null;this._time2=null;if(this._callback){this._callback=null;}this.fire("canceled",true,true);}/**
     * Sets the flight duration, in seconds, when calling {@link CameraFlightAnimation#flyTo}.
     *
     * Stops any flight currently in progress.
     *
     * default value is ````0.5````.
     *
     * @param {Number} value New duration value.
     */},{key:"duration",get:/**
     * Gets the flight duration, in seconds, when calling {@link CameraFlightAnimation#flyTo}.
     *
     * default value is ````0.5````.
     *
     * @returns {Number} New duration value.
     */function get(){return this._duration/1000.0;}/**
     * Sets if, when CameraFlightAnimation is flying to a boundary, it will always adjust the distance between the
     * {@link Camera#eye} and {@link Camera#look} so as to ensure that the target boundary is always filling the view volume.
     *
     * When false, the eye will remain at its current distance from the look position.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate this behaviour.
     */,set:function set(value){this._duration=value?value*1000.0:500;this.stop();}},{key:"fit",get:/**
     * Gets if, when CameraFlightAnimation is flying to a boundary, it will always adjust the distance between the
     * {@link Camera#eye} and {@link Camera#look} so as to ensure that the target boundary is always filling the view volume.
     *
     * When false, the eye will remain at its current distance from the look position.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} value Set ````true```` to activate this behaviour.
     */function get(){return this._fit;}/**
     * Sets how much of the perspective field-of-view, in degrees, that a target {@link Entity#aabb} should
     * fill the canvas when calling {@link CameraFlightAnimation#flyTo} or {@link CameraFlightAnimation#jumpTo}.
     *
     * Default value is ````45````.
     *
     * @param {Number} value New FOV value.
     */,set:function set(value){this._fit=value!==false;}},{key:"fitFOV",get:/**
     * Gets how much of the perspective field-of-view, in degrees, that a target {@link Entity#aabb} should
     * fill the canvas when calling {@link CameraFlightAnimation#flyTo} or {@link CameraFlightAnimation#jumpTo}.
     *
     * Default value is ````45````.
     *
     * @returns {Number} Current FOV value.
     */function get(){return this._fitFOV;}/**
     * Sets if this CameraFlightAnimation to point the {@link Camera}
     * in the direction that it is travelling when flying to a target after calling {@link CameraFlightAnimation#flyTo}.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate trailing behaviour.
     */,set:function set(value){this._fitFOV=value||45;}},{key:"trail",get:/**
     * Gets if this CameraFlightAnimation points the {@link Camera}
     * in the direction that it is travelling when flying to a target after calling {@link CameraFlightAnimation#flyTo}.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} True if trailing behaviour is active.
     */function get(){return this._trail;}/**
     * @private
     */,set:function set(value){this._trail=!!value;}},{key:"destroy",value:function destroy(){this.stop();_get(_getPrototypeOf(CameraFlightAnimation.prototype),"destroy",this).call(this);}}],[{key:"_ease",value:function _ease(t,b,c,d){// Quadratic easing out - decelerating to zero velocity http://gizma.com/easing
t/=d;return-c*t*(t-2)+b;}},{key:"_easeInCubic",value:function _easeInCubic(t,b,c,d){t/=d;return c*t*t*t+b;}},{key:"_easeOutExpo",value:function _easeOutExpo(t,b,c,d){return c*(-Math.pow(2,-10*t/d)+1)+b;}}]);return CameraFlightAnimation;}(Component);/**
 * @desc Animates the {@link Scene}'s's {@link Camera} along a {@link CameraPath}.
 *
 * ## Usage
 *
 * In the example below, we'll load a model using a {@link GLTFLoaderPlugin}, then animate a {@link Camera}
 * through the frames in a {@link CameraPath}.
 *
 *  * [[Run this example](/examples/#camera_CameraPathAnimation)]
 *
 * ````Javascript
 * import {Viewer, GLTFLoaderPlugin, CameraPath, CameraPathAnimation} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.camera.eye = [124.86756896972656, -93.50288391113281, 173.2632598876953];
 * viewer.camera.look = [102.14186096191406, -90.24193572998047, 173.4224395751953];
 * viewer.camera.up = [0.23516440391540527, 0.9719591736793518, -0.0016466031083837152];
 *
 * // Load model
 *
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * const model = gltfLoader.load({
 *     id: "myModel",
 *     src: "./models/gltf/modern_office/scene.gltf",
 *     edges: true,
 *     edgeThreshold: 20,
 *     xrayed: false
 * });
 *
 * // Create a CameraPath
 *
 * var cameraPath = new CameraPath(viewer.scene, {
 *     frames: [
 *         {
 *             t:    0,
 *             eye:  [124.86, -93.50, 173.26],
 *             look: [102.14, -90.24, 173.42],
 *             up:   [0.23, 0.97, -0.00]
 *         },
 *         {
 *             t:    1,
 *             eye:  [79.75, -85.98, 226.57],
 *             look: [99.24, -84.11, 238.56],
 *             up:   [-0.14, 0.98, -0.09]
 *         },
 *         // Rest of the frames omitted for brevity
 *     ]
 * });
 *
 * // Create a CameraPathAnimation to play our CameraPath
 *
 * var cameraPathAnimation = new CameraPathAnimation(viewer.scene, {
 *     cameraPath: cameraPath,
 *     playingRate: 0.2 // Playing 0.2 time units per second
 * });
 *
 * // Once model loaded, start playing after a couple of seconds delay
 *
 * model.on("loaded", function () {
 *     setTimeout(function () {
 *         cameraPathAnimation.play(0); // Play from the beginning of the CameraPath
 *     }, 2000);
 * });
 * ````
 */var CameraPathAnimation=/*#__PURE__*/function(_Component34){_inherits(CameraPathAnimation,_Component34);var _super124=_createSuper(CameraPathAnimation);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this CameraPathAnimation as well.
     * @param {*} [cfg] Configuration
     * @param {String} [cfg.id]  Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {CameraPath} [cfg.eyeCurve] A {@link CameraPath} that defines the path of a {@link Camera}.
     */function CameraPathAnimation(owner){var _this90;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CameraPathAnimation);_this90=_super124.call(this,owner,cfg);_this90._cameraFlightAnimation=new CameraFlightAnimation(_assertThisInitialized(_this90));_this90._t=0;_this90.state=CameraPathAnimation.SCRUBBING;_this90._playingFromT=0;_this90._playingToT=0;_this90._playingRate=cfg.playingRate||1.0;_this90._playingDir=1.0;_this90._lastTime=null;_this90.cameraPath=cfg.cameraPath;_this90._tick=_this90.scene.on("tick",_this90._updateT,_assertThisInitialized(_this90));return _this90;}_createClass(CameraPathAnimation,[{key:"type",get:/**
     * Returns "CameraPathAnimation".
     *
     * @private
     * @returns {string} "CameraPathAnimation"
     */function get(){return"CameraPathAnimation";}},{key:"_updateT",value:function _updateT(){var cameraPath=this._cameraPath;if(!cameraPath){return;}var numFrames;var t;var time=performance.now();var elapsedSecs=this._lastTime?(time-this._lastTime)*0.001:0;this._lastTime=time;if(elapsedSecs===0){return;}switch(this.state){case CameraPathAnimation.SCRUBBING:return;case CameraPathAnimation.PLAYING:this._t+=this._playingRate*elapsedSecs;numFrames=this._cameraPath.frames.length;if(numFrames===0||this._playingDir<0&&this._t<=0||this._playingDir>0&&this._t>=this._cameraPath.frames[numFrames-1].t){this.state=CameraPathAnimation.SCRUBBING;this._t=this._cameraPath.frames[numFrames-1].t;this.fire("stopped");return;}cameraPath.loadFrame(this._t);break;case CameraPathAnimation.PLAYING_TO:t=this._t+this._playingRate*elapsedSecs*this._playingDir;if(this._playingDir<0&&t<=this._playingToT||this._playingDir>0&&t>=this._playingToT){t=this._playingToT;this.state=CameraPathAnimation.SCRUBBING;this.fire("stopped");}this._t=t;cameraPath.loadFrame(this._t);break;}}/*
    * @private
     */},{key:"_ease",value:function _ease(t,b,c,d){t/=d;return-c*t*(t-2)+b;}/**
     * Sets the {@link CameraPath} animated by this CameraPathAnimation.
     *
     @param {CameraPath} value The new CameraPath.
     */},{key:"cameraPath",get:/**
     * Gets the {@link CameraPath} animated by this CameraPathAnimation.
     *
     @returns {CameraPath} The CameraPath.
     */function get(){return this._cameraPath;}/**
     * Sets the rate at which the CameraPathAnimation animates the {@link Camera} along the {@link CameraPath}.
     *
     *  @param {Number} value The amount of progress per second.
     */,set:function set(value){this._cameraPath=value;}},{key:"rate",get:/**
     * Gets the rate at which the CameraPathAnimation animates the {@link Camera} along the {@link CameraPath}.
     *
     * @returns {*|number} The current playing rate.
     */function get(){return this._playingRate;}/**
     * Begins animating the {@link Camera} along CameraPathAnimation's {@link CameraPath} from the beginning.
     */,set:function set(value){this._playingRate=value;}},{key:"play",value:function play(){if(!this._cameraPath){return;}this._lastTime=null;this.state=CameraPathAnimation.PLAYING;}/**
     * Begins animating the {@link Camera} along CameraPathAnimation's {@link CameraPath} from the given time.
     *
     * @param {Number} t Time instant.
     */},{key:"playToT",value:function playToT(t){var cameraPath=this._cameraPath;if(!cameraPath){return;}this._playingFromT=this._t;this._playingToT=t;this._playingDir=this._playingToT-this._playingFromT<0?-1:1;this._lastTime=null;this.state=CameraPathAnimation.PLAYING_TO;}/**
     * Animates the {@link Camera} along CameraPathAnimation's {@link CameraPath} to the given frame.
     *
     * @param {Number} frameIdx Index of the frame to play to.
     */},{key:"playToFrame",value:function playToFrame(frameIdx){var cameraPath=this._cameraPath;if(!cameraPath){return;}var frame=cameraPath.frames[frameIdx];if(!frame){this.error("playToFrame - frame index out of range: "+frameIdx);return;}this.playToT(frame.t);}/**
     * Flies the {@link Camera} directly to the given frame on the CameraPathAnimation's {@link CameraPath}.
     *
     * @param {Number} frameIdx Index of the frame to play to.
     * @param {Function} [ok] Callback to fire when playing is complete.
     */},{key:"flyToFrame",value:function flyToFrame(frameIdx,ok){var cameraPath=this._cameraPath;if(!cameraPath){return;}var frame=cameraPath.frames[frameIdx];if(!frame){this.error("flyToFrame - frame index out of range: "+frameIdx);return;}this.state=CameraPathAnimation.SCRUBBING;this._cameraFlightAnimation.flyTo(frame,ok);}/**
     * Scrubs the {@link Camera} to the given time on the CameraPathAnimation's {@link CameraPath}.
     *
     * @param {Number} t Time instant.
     */},{key:"scrubToT",value:function scrubToT(t){var cameraPath=this._cameraPath;if(!cameraPath){return;}var camera=this.scene.camera;if(!camera){return;}this._t=t;cameraPath.loadFrame(this._t);this.state=CameraPathAnimation.SCRUBBING;}/**
     * Scrubs the {@link Camera} to the given frame on the CameraPathAnimation's {@link CameraPath}.
     *
     * @param {Number} frameIdx Index of the frame to scrub to.
     */},{key:"scrubToFrame",value:function scrubToFrame(frameIdx){var cameraPath=this._cameraPath;if(!cameraPath){return;}var camera=this.scene.camera;if(!camera){return;}var frame=cameraPath.frames[frameIdx];if(!frame){this.error("playToFrame - frame index out of range: "+frameIdx);return;}cameraPath.loadFrame(this._t);this.state=CameraPathAnimation.SCRUBBING;}/**
     * Stops playing this CameraPathAnimation.
     */},{key:"stop",value:function stop(){this.state=CameraPathAnimation.SCRUBBING;this.fire("stopped");}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(CameraPathAnimation.prototype),"destroy",this).call(this);this.scene.off(this._tick);}}]);return CameraPathAnimation;}(Component);CameraPathAnimation.STOPPED=0;CameraPathAnimation.SCRUBBING=1;CameraPathAnimation.PLAYING=2;CameraPathAnimation.PLAYING_TO=3;var tempVec3$3=math.vec3();var tempVec3b$5=math.vec3();math.vec3();var zeroVec$2=math.vec3([0,-1,0]);var tempQuat=math.vec4([0,0,0,1]);/**
 *  @desc A plane-shaped 3D object containing a bitmap image.
 *
 * Use ````ImagePlane```` to embed bitmap images in your scenes.
 *
 * As shown in the examples below, ````ImagePlane```` is useful for creating ground planes from satellite maps and embedding 2D plan
 * view images in cross-section slicing planes.
 *
 * # Example 1: Create a ground plane from a satellite image
 *
 * In our first example, we'll load the Schependomlaan model, then use
 * an ````ImagePlane```` to create a ground plane, which will contain
 * a satellite image sourced from Google Maps.
 *
 * <img src="http://xeokit.io/img/docs/ImagePlane/schependomlaanGoogleSatMapMed.png">
 *
 * [<img src="http://xeokit.io/img/docs/ImagePlane/ImagePlane.png">](/examples/#ImagePlane_groundPlane)
 *
 * [[Run this example](/examples/#ImagePlane_groundPlane)]
 *
 * ````javascript
 * import {Viewer, ImagePlane, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 *  });
 *
 * viewer.camera.eye = [-8.31, 42.21, 54.30];
 * viewer.camera.look = [-0.86, 15.40, 14.90];
 * viewer.camera.up = [0.10, 0.83, -0.54];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * xktLoader.load({             // Load IFC model
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true,
 *
 *      rotation: [0, 22, 0],   // Rotate, position and scale the model to align it correctly with the ImagePlane
 *      position: [-8, 0, 15],
 *      scale: [1.1, 1.1, 1.1]
 *  });
 *
 * new ImagePlane(viewer.scene, {
 *      src: "./images/schependomlaanSatMap.png",       // Google satellite image; accepted file types are PNG and JPEG
 *      visible: true,                                  // Show the ImagePlane
 *      gridVisible: true,                              // Show the grid - grid is only visible when ImagePlane is also visible
 *      size: 190,                                      // Size of ImagePlane's longest edge
 *      position: [0, -1, 0],                           // World-space position of ImagePlane's center
 *      rotation: [0, 0, 0],                            // Euler angles for X, Y and Z
 *      opacity: 1.0,                                   // Fully opaque
 *      collidable: false,                              // ImagePlane does not contribute to Scene boundary
 *      clippable: true,                                // ImagePlane can be clipped by SectionPlanes
 *      pickable: true                                  // Allow the ground plane to be picked
 * });
 * ````
 *<br>
 *
 * # Example 2: Embed an image in a cross-section plane
 *
 * In our second example, we'll load the Schependomlaan model again, then slice it in half with
 * a {@link SectionPlanesPlugin}, then use an ````ImagePlane```` to embed a 2D plan view image in the slicing plane.
 *
 * <img src="http://xeokit.io/img/docs/ImagePlane/schependomlaanPlanViewMed.png">
 *
 * [<img src="http://xeokit.io/img/docs/ImagePlane/ImagePlane_planView.png">](/examples/#ImagePlane_imageInSectionPlane)
 *
 * [[Run this example](/examples/#ImagePlane_imageInSectionPlane)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, SectionPlanesPlugin, ImagePlane} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.camera.eye = [-9.11, 20.01, 5.13];
 * viewer.camera.look = [9.07, 0.77, -9.78];
 * viewer.camera.up = [0.47, 0.76, -0.38];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const sectionPlanes = new SectionPlanesPlugin(viewer, {
 *     overviewVisible: false
 * });
 *
 * model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt",
 *     metaModelSrc: "./metaModels/schependomlaan/metaModel.json",
 *     edges: true,
 * });
 *
 * const sectionPlane = sectionPlanes.createSectionPlane({
 *     id: "mySectionPlane",
 *     pos: [10.95, 1.95, -10.35],
 *     dir: [0.0, -1.0, 0.0]
 * });
 *
 * const imagePlane = new ImagePlane(viewer.scene, {
 *     src: "./images/schependomlaanPlanView.png",  // Plan view image; accepted file types are PNG and JPEG
 *     visible: true,
 *     gridVisible: true,
 *     size: 23.95,
 *     position: sectionPlane.pos,
 *     dir: sectionPlane.dir,
 *     collidable: false,
 *     opacity: 0.75,
 *     clippable: false,                            // Don't allow ImagePlane to be clipped by the SectionPlane
 *     pickable: false                              // Don't allow ImagePlane to be picked
 *  });
 * ````
 */var ImagePlane=/*#__PURE__*/function(_Component35){_inherits(ImagePlane,_Component35);var _super125=_createSuper(ImagePlane);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this ````ImagePlane```` as well.
     * @param {*} [cfg]  ````ImagePlane```` configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Boolean} [cfg.visible=true] Indicates whether or not this ````ImagePlane```` is visible.
     * @param {Boolean} [cfg.gridVisible=true] Indicates whether or not the grid is visible.  Grid is only visible when ````ImagePlane```` is also visible.
     * @param {Number[]} [cfg.position=[0,0,0]] World-space position of the ````ImagePlane````.
     * @param {Number[]} [cfg.size=1] World-space size of the longest edge of the ````ImagePlane````. Note that
     * ````ImagePlane```` sets its aspect ratio to match its image. If we set a value of ````1000````, and the image
     * has size ````400x300````, then the ````ImagePlane```` will then have size ````1000 x 750````.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Local rotation of the ````ImagePlane````, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Modelling transform matrix for the ````ImagePlane````. Overrides the ````position````, ````size```, ````rotation```` and ````dir```` parameters.
     * @param {Boolean} [cfg.collidable=true] Indicates if the ````ImagePlane```` is initially included in boundary calculations.
     * @param {Boolean} [cfg.clippable=true] Indicates if the ````ImagePlane```` is initially clippable.
     * @param {Boolean} [cfg.pickable=true] Indicates if the ````ImagePlane```` is initially pickable.
     * @param {Number} [cfg.opacity=1.0] ````ImagePlane````'s initial opacity factor, multiplies by the rendered fragment alpha.
     * @param {String} [cfg.src] URL of image. Accepted file types are PNG and JPEG.
     * @param {HTMLImageElement} [cfg.image] An ````HTMLImageElement```` to source the image from. Overrides ````src````.
     */function ImagePlane(owner){var _this91;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ImagePlane);_this91=_super125.call(this,owner,cfg);_this91._src=null;_this91._image=null;_this91._pos=math.vec3();_this91._origin=math.vec3();_this91._rtcPos=math.vec3();_this91._dir=math.vec3();_this91._size=1.0;_this91._imageSize=math.vec2();_this91._texture=new Texture(_assertThisInitialized(_this91));_this91._plane=new Mesh(_assertThisInitialized(_this91),{geometry:new ReadableGeometry(_assertThisInitialized(_this91),buildPlaneGeometry({center:[0,0,0],xSize:1,zSize:1,xSegments:10,zSegments:10})),material:new PhongMaterial(_assertThisInitialized(_this91),{diffuse:[0,0,0],ambient:[0,0,0],specular:[0,0,0],diffuseMap:_this91._texture,emissiveMap:_this91._texture,backfaces:true}),clippable:cfg.clippable});_this91._grid=new Mesh(_assertThisInitialized(_this91),{geometry:new ReadableGeometry(_assertThisInitialized(_this91),buildGridGeometry({size:1,divisions:10})),material:new PhongMaterial(_assertThisInitialized(_this91),{diffuse:[0.0,0.0,0.0],ambient:[0.0,0.0,0.0],emissive:[0.2,0.8,0.2]}),position:[0,0.001,0.0],clippable:cfg.clippable});_this91._node=new Node$2(_assertThisInitialized(_this91),{rotation:[0,0,0],position:[0,0,0],scale:[1,1,1],clippable:false,children:[_this91._plane,_this91._grid]});_this91._gridVisible=false;_this91.visible=true;_this91.gridVisible=cfg.gridVisible;_this91.position=cfg.position;_this91.rotation=cfg.rotation;_this91.dir=cfg.dir;_this91.size=cfg.size;_this91.collidable=cfg.collidable;_this91.clippable=cfg.clippable;_this91.pickable=cfg.pickable;_this91.opacity=cfg.opacity;if(cfg.image){_this91.image=cfg.image;}else{_this91.src=cfg.src;}return _this91;}/**
     * Sets if this ````ImagePlane```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} visible Set ````true```` to make this ````ImagePlane```` visible.
     */_createClass(ImagePlane,[{key:"visible",get:/**
     * Gets if this ````ImagePlane```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */function get(){return this._plane.visible;}/**
     * Sets if this ````ImagePlane````'s grid  is visible or not.
     *
     * Default value is ````false````.
     *
     * Grid is only visible when ````ImagePlane```` is also visible.
     *
     * @param {Boolean} visible Set ````true```` to make this ````ImagePlane````'s grid visible.
     */,set:function set(visible){this._plane.visible=visible;this._grid.visible=this._gridVisible&&visible;}},{key:"gridVisible",get:/**
     * Gets if this ````ImagePlane````'s grid is visible or not.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */function get(){return this._gridVisible;}/**
     * Sets an ````HTMLImageElement```` to source the image from.
     *
     * Sets {@link Texture#src} null.
     *
     * @type {HTMLImageElement}
     */,set:function set(visible){visible=visible!==false;this._gridVisible=visible;this._grid.visible=this._gridVisible&&this.visible;}},{key:"image",get:/**
     * Gets the ````HTMLImageElement```` the ````ImagePlane````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {HTMLImageElement}
     */function get(){return this._image;}/**
     * Sets an image file path that the ````ImagePlane````'s image is sourced from.
     *
     * Accepted file types are PNG and JPEG.
     *
     * Sets {@link Texture#image} null.
     *
     * @type {String}
     */,set:function set(image){this._image=image;if(this._image){this._imageSize[0]=image.width;this._imageSize[1]=image.height;this._updatePlaneSizeFromImage();this._src=null;this._texture.image=this._image;}}},{key:"src",get:/**
     * Gets the image file path that the ````ImagePlane````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {String}
     */function get(){return this._src;}/**
     * Sets the World-space position of this ````ImagePlane````.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param {Number[]} value New position.
     */,set:function set(src){var _this92=this;this._src=src;if(this._src){this._image=null;var _image4=new Image();_image4.onload=function(){_this92._texture.image=_image4;_this92._imageSize[0]=_image4.width;_this92._imageSize[1]=_image4.height;_this92._updatePlaneSizeFromImage();};_image4.src=this._src;}}},{key:"position",get:/**
     * Gets the World-space position of this ````ImagePlane````.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @returns {Number[]} Current position.
     */function get(){return this._pos;}/**
     * Sets the direction of this ````ImagePlane```` using Euler angles.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param {Number[]} value Euler angles for ````X````, ````Y```` and ````Z```` axis rotations.
     */,set:function set(value){this._pos.set(value||[0,0,0]);worldToRTCPos(this._pos,this._origin,this._rtcPos);this._node.origin=this._origin;this._node.position=this._rtcPos;}},{key:"rotation",get:/**
     * Gets the direction of this ````ImagePlane```` as Euler angles.
     *
     * @returns {Number[]} Euler angles for ````X````, ````Y```` and ````Z```` axis rotations.
     */function get(){return this._node.rotation;}/**
     * Sets the World-space size of the longest edge of the ````ImagePlane````.
     *
     * Note that ````ImagePlane```` sets its aspect ratio to match its image. If we set a value of ````1000````, and
     * the image has size ````400x300````, then the ````ImagePlane```` will then have size ````1000 x 750````.
     *
     * Default value is ````1.0````.
     *
     * @param {Number} size New World-space size of the ````ImagePlane````.
     */,set:function set(value){this._node.rotation=value;}},{key:"size",get:/**
     * Gets the World-space size of the longest edge of the ````ImagePlane````.
     *
     * Returns {Number} World-space size of the ````ImagePlane````.
     */function get(){return this._size;}/**
     * Sets the direction of this ````ImagePlane```` as a direction vector.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @param {Number[]} dir New direction vector.
     */,set:function set(size){this._size=size===undefined||size===null?1.0:size;if(this._image){this._updatePlaneSizeFromImage();}}},{key:"dir",get:/**
     * Gets the direction of this ````ImagePlane```` as a direction vector.
     *
     * @returns {Number[]} value Current direction.
     */function get(){return this._dir;}/**
     * Sets if this ````ImagePlane```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(dir){this._dir.set(dir||[0,0,-1]);if(dir){var origin=this.scene.center;var negDir=[-this._dir[0],-this._dir[1],-this._dir[2]];math.subVec3(origin,this.position,tempVec3$3);var dist=-math.dotVec3(negDir,tempVec3$3);math.normalizeVec3(negDir);math.mulVec3Scalar(negDir,dist,tempVec3b$5);math.vec3PairToQuaternion(zeroVec$2,dir,tempQuat);this._node.quaternion=tempQuat;}}},{key:"collidable",get:/**
     * Gets if this ````ImagePlane```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._node.collidable;}/**
     * Sets if this ````ImagePlane```` is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){this._node.collidable=value!==false;}},{key:"clippable",get:/**
     * Gets if this ````ImagePlane````  is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._node.clippable;}/**
     * Sets if this ````ImagePlane```` is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){this._node.clippable=value!==false;}},{key:"pickable",get:/**
     * Gets if this ````ImagePlane````  is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._node.pickable;}/**
     * Sets the opacity factor for this ````ImagePlane````.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(value){this._node.pickable=value!==false;}},{key:"opacity",get:/**
     * Gets this ````ImagePlane````'s opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */function get(){return this._node.opacity;}/**
     * @destroy
     */,set:function set(opacity){this._node.opacity=opacity;}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(ImagePlane.prototype),"destroy",this).call(this);}},{key:"_updatePlaneSizeFromImage",value:function _updatePlaneSizeFromImage(){var size=this._size;var width=this._imageSize[0];var height=this._imageSize[1];if(width>height){var aspect=height/width;this._node.scale=[size,1.0,size*aspect];}else{var _aspect=width/height;this._node.scale=[size*_aspect,1.0,size];}}}]);return ImagePlane;}(Component);/**
 * A positional light source that originates from a single point and spreads outward in all directions, with optional attenuation over distance.
 *
 * * Has a position in {@link PointLight#pos}, but no direction.
 * * Defined in either *World* or *View* coordinate space. When in World-space, {@link PointLight#pos} is relative to
 * the World coordinate system, and will appear to move as the {@link Camera} moves. When in View-space,
 * {@link PointLight#pos} is relative to the View coordinate system, and will behave as if fixed to the viewer's head.
 * * Has {@link PointLight#constantAttenuation}, {@link PointLight#linearAttenuation} and {@link PointLight#quadraticAttenuation}
 * factors, which indicate how intensity attenuates over distance.
 * * {@link AmbientLight}s, {@link PointLight}s and {@link PointLight}s are registered by their {@link Component#id} on {@link Scene#lights}.
 *
 * ## Usage
 *
 * In the example below we'll replace the {@link Scene}'s default light sources with three World-space PointLights.
 *
 * [[Run this example](/examples/#lights_PointLight_world)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry, buildPlaneGeometry,
 *      ReadableGeometry, PhongMaterial, Texture, PointLight} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * // Replace the Scene's default lights with three custom world-space PointLights
 *
 * viewer.scene.clearLights();
 *
 * new PointLight(viewer.scene,{
 *      id: "keyLight",
 *      pos: [-80, 60, 80],
 *      color: [1.0, 0.3, 0.3],
 *      intensity: 1.0,
 *      space: "world"
 * });
 *
 * new PointLight(viewer.scene,{
 *      id: "fillLight",
 *      pos: [80, 40, 40],
 *      color: [0.3, 1.0, 0.3],
 *      intensity: 1.0,
 *      space: "world"
 * });
 *
 * new PointLight(viewer.scene,{
 *      id: "rimLight",
 *      pos: [-20, 80, -80],
 *      color: [0.6, 0.6, 0.6],
 *      intensity: 1.0,
 *      space: "world"
 * });
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 1.3
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuse: [0.7, 0.7, 0.7],
 *          specular: [1.0, 1.0, 1.0],
 *          emissive: [0, 0, 0],
 *          alpha: 1.0,
 *          ambient: [1, 1, 0],
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 * });
 *
 * new Mesh(viewer.scene, {
 *      geometry: buildPlaneGeometry(ReadableGeometry, viewer.scene, {
 *          xSize: 30,
 *          zSize: 30
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuseMap: new Texture(viewer.scene, {
 *               src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          backfaces: true
 *      }),
 *      position: [0, -2.1, 0]
 * });
 * ````
 */var PointLight=/*#__PURE__*/function(_Light3){_inherits(PointLight,_Light3);var _super126=_createSuper(PointLight);/**
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this PointLight as well.
     * @param {*} [cfg] The PointLight configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.pos=[ 1.0, 1.0, 1.0 ]] Position, in either World or View space, depending on the value of the **space** parameter.
     * @param {Number[]} [cfg.color=[0.7, 0.7, 0.8 ]] Color of this PointLight.
     * @param {Number} [cfg.intensity=1.0] Intensity of this PointLight, as a factor in range ````[0..1]````.
     * @param {Number} [cfg.constantAttenuation=0] Constant attenuation factor.
     * @param {Number} [cfg.linearAttenuation=0] Linear attenuation factor.
     * @param {Number} [cfg.quadraticAttenuation=0]Quadratic attenuation factor.
     * @param {String} [cfg.space="view"]The coordinate system this PointLight is defined in - "view" or "world".
     * @param {Boolean} [cfg.castsShadow=false] Flag which indicates if this PointLight casts a castsShadow.
     */function PointLight(owner){var _this93;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PointLight);_this93=_super126.call(this,owner,cfg);var self=_assertThisInitialized(_this93);_this93._shadowRenderBuf=null;_this93._shadowViewMatrix=null;_this93._shadowProjMatrix=null;_this93._shadowViewMatrixDirty=true;_this93._shadowProjMatrixDirty=true;var camera=_this93.scene.camera;var canvas=_this93.scene.canvas;_this93._onCameraViewMatrix=camera.on("viewMatrix",function(){_this93._shadowViewMatrixDirty=true;});_this93._onCameraProjMatrix=camera.on("projMatrix",function(){_this93._shadowProjMatrixDirty=true;});_this93._onCanvasBoundary=canvas.on("boundary",function(){_this93._shadowProjMatrixDirty=true;});_this93._state=new RenderState({type:"point",pos:math.vec3([1.0,1.0,1.0]),color:math.vec3([0.7,0.7,0.8]),intensity:1.0,attenuation:[0.0,0.0,0.0],space:cfg.space||"view",castsShadow:false,getShadowViewMatrix:function getShadowViewMatrix(){if(self._shadowViewMatrixDirty){if(!self._shadowViewMatrix){self._shadowViewMatrix=math.identityMat4();}var eye=self._state.pos;var look=camera.look;var up=camera.up;math.lookAtMat4v(eye,look,up,self._shadowViewMatrix);self._shadowViewMatrixDirty=false;}return self._shadowViewMatrix;},getShadowProjMatrix:function getShadowProjMatrix(){if(self._shadowProjMatrixDirty){// TODO: Set when canvas resizes
if(!self._shadowProjMatrix){self._shadowProjMatrix=math.identityMat4();}var _canvas4=self.scene.canvas.canvas;math.perspectiveMat4(70*(Math.PI/180.0),_canvas4.clientWidth/_canvas4.clientHeight,0.1,500.0,self._shadowProjMatrix);self._shadowProjMatrixDirty=false;}return self._shadowProjMatrix;},getShadowRenderBuf:function getShadowRenderBuf(){if(!self._shadowRenderBuf){self._shadowRenderBuf=new RenderBuffer(self.scene.canvas.canvas,self.scene.canvas.gl,{size:[1024,1024]});// Super old mobile devices have a limit of 1024x1024 textures
}return self._shadowRenderBuf;}});_this93.pos=cfg.pos;_this93.color=cfg.color;_this93.intensity=cfg.intensity;_this93.constantAttenuation=cfg.constantAttenuation;_this93.linearAttenuation=cfg.linearAttenuation;_this93.quadraticAttenuation=cfg.quadraticAttenuation;_this93.castsShadow=cfg.castsShadow;_this93.scene._lightCreated(_assertThisInitialized(_this93));return _this93;}/**
     * Sets the position of this PointLight.
     *
     * This will be either World- or View-space, depending on the value of {@link PointLight#space}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @param {Number[]} pos The position.
     */_createClass(PointLight,[{key:"type",get:/**
     @private
     */function get(){return"PointLight";}},{key:"pos",get:/**
     * Gets the position of this PointLight.
     *
     * This will be either World- or View-space, depending on the value of {@link PointLight#space}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @returns {Number[]} The position.
     */function get(){return this._state.pos;}/**
     * Sets the RGB color of this PointLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param {Number[]} color The PointLight's RGB color.
     */,set:function set(pos){this._state.pos.set(pos||[1.0,1.0,1.0]);this._shadowViewMatrixDirty=true;this.glRedraw();}},{key:"color",get:/**
     * Gets the RGB color of this PointLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The PointLight's RGB color.
     */function get(){return this._state.color;}/**
     * Sets the intensity of this PointLight.
     *
     * Default intensity is ````1.0```` for maximum intensity.
     *
     * @param {Number} intensity The PointLight's intensity
     */,set:function set(color){this._state.color.set(color||[0.7,0.7,0.8]);this.glRedraw();}},{key:"intensity",get:/**
     * Gets the intensity of this PointLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The PointLight's intensity.
     */function get(){return this._state.intensity;}/**
     * Sets the constant attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The constant attenuation factor.
     */,set:function set(intensity){intensity=intensity!==undefined?intensity:1.0;this._state.intensity=intensity;this.glRedraw();}},{key:"constantAttenuation",get:/**
     * Gets the constant attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The constant attenuation factor.
     */function get(){return this._state.attenuation[0];}/**
     * Sets the linear attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The linear attenuation factor.
     */,set:function set(value){this._state.attenuation[0]=value||0.0;this.glRedraw();}},{key:"linearAttenuation",get:/**
     * Gets the linear attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The linear attenuation factor.
     */function get(){return this._state.attenuation[1];}/**
     * Sets the quadratic attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The quadratic attenuation factor.
     */,set:function set(value){this._state.attenuation[1]=value||0.0;this.glRedraw();}},{key:"quadraticAttenuation",get:/**
     * Gets the quadratic attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The quadratic attenuation factor.
     */function get(){return this._state.attenuation[2];}/**
     * Sets if this PointLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} castsShadow Set ````true```` to cast shadows.
     */,set:function set(value){this._state.attenuation[2]=value||0.0;this.glRedraw();}},{key:"castsShadow",get:/**
     * Gets if this PointLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if this PointLight casts shadows.
     */function get(){return this._state.castsShadow;}/**
     * Destroys this PointLight.
     */,set:function set(castsShadow){castsShadow=!!castsShadow;if(this._state.castsShadow===castsShadow){return;}this._state.castsShadow=castsShadow;this._shadowViewMatrixDirty=true;this.glRedraw();}},{key:"destroy",value:function destroy(){var camera=this.scene.camera;var canvas=this.scene.canvas;camera.off(this._onCameraViewMatrix);camera.off(this._onCameraProjMatrix);canvas.off(this._onCanvasBoundary);_get(_getPrototypeOf(PointLight.prototype),"destroy",this).call(this);this._state.destroy();if(this._shadowRenderBuf){this._shadowRenderBuf.destroy();}this.scene._lightDestroyed(this);this.glRedraw();}}]);return PointLight;}(Light);function ensureImageSizePowerOfTwo(image){if(!isPowerOfTwo(image.width)||!isPowerOfTwo(image.height)){var _canvas5=document.createElement("canvas");_canvas5.width=nextHighestPowerOfTwo(image.width);_canvas5.height=nextHighestPowerOfTwo(image.height);var ctx=_canvas5.getContext("2d");ctx.drawImage(image,0,0,image.width,image.height,0,0,_canvas5.width,_canvas5.height);image=_canvas5;}return image;}function isPowerOfTwo(x){return(x&x-1)===0;}function nextHighestPowerOfTwo(x){--x;for(var _i458=1;_i458<32;_i458<<=1){x=x|x>>_i458;}return x+1;}/**
 * @desc A cube texture map.
 */var CubeTexture=/*#__PURE__*/function(_Component36){_inherits(CubeTexture,_Component36);var _super127=_createSuper(CubeTexture);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID for this CubeTexture, unique among all components in the parent scene, generated automatically when omitted.
     * @param {String[]} [cfg.src=null]  Paths to six image files to load into this CubeTexture.
     * @param {Boolean} [cfg.flipY=false] Flips this CubeTexture's source data along its vertical axis when true.
     * @param {Number} [cfg.encoding=LinearEncoding] Encoding format. Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.
     */function CubeTexture(owner){var _this94;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CubeTexture);_this94=_super127.call(this,owner,cfg);var gl=_this94.scene.canvas.gl;_this94._state=new RenderState({texture:new Texture2D({gl:gl,target:gl.TEXTURE_CUBE_MAP}),flipY:_this94._checkFlipY(cfg.minFilter),encoding:_this94._checkEncoding(cfg.encoding),minFilter:LinearMipmapLinearFilter,magFilter:LinearFilter,wrapS:ClampToEdgeWrapping,wrapT:ClampToEdgeWrapping,mipmaps:true});_this94._src=cfg.src;_this94._images=[];_this94._loadSrc(cfg.src);stats.memory.textures++;return _this94;}_createClass(CubeTexture,[{key:"type",get:/**
     @private
     */function get(){return"CubeTexture";}},{key:"_checkFlipY",value:function _checkFlipY(value){return!!value;}},{key:"_checkEncoding",value:function _checkEncoding(value){value=value||LinearEncoding;if(value!==LinearEncoding&&value!==sRGBEncoding){this.error("Unsupported value for 'encoding' - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding.");value=LinearEncoding;}return value;}},{key:"_webglContextRestored",value:function _webglContextRestored(){this.scene.canvas.gl;this._state.texture=null;// if (this._images.length > 0) {
//     this._state.texture = new xeokit.renderer.Texture2D(gl, gl.TEXTURE_CUBE_MAP);
//     this._state.texture.setImage(this._images, this._state);
//     this._state.texture.setProps(this._state);
// } else
if(this._src){this._loadSrc(this._src);}}},{key:"_loadSrc",value:function _loadSrc(src){var self=this;var gl=this.scene.canvas.gl;this._images=[];var loadFailed=false;var numLoaded=0;var _loop3=function _loop3(_i459){var image=new Image();image.onload=function(){var _image=image;var index=_i459;return function(){if(loadFailed){return;}_image=ensureImageSizePowerOfTwo(_image);self._images[index]=_image;numLoaded++;if(numLoaded===6){var texture=self._state.texture;if(!texture){texture=new Texture2D({gl:gl,target:gl.TEXTURE_CUBE_MAP});self._state.texture=texture;}texture.setImage(self._images,self._state);self.fire("loaded",self._src,false);self.glRedraw();}};}();image.onerror=function(){loadFailed=true;};image.src=src[_i459];};for(var _i459=0;_i459<src.length;_i459++){_loop3(_i459);}}/**
     * Destroys this CubeTexture
     *
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(CubeTexture.prototype),"destroy",this).call(this);if(this._state.texture){this._state.texture.destroy();}stats.memory.textures--;this._state.destroy();}}]);return CubeTexture;}(Component);/**
 * @desc A reflection cube map.
 *
 * ## Usage
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      ReadableGeometry, MetallicMaterial, ReflectionMap} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new ReflectionMap(viewer.scene, {
 *     src: [
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PX.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NX.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PY.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NY.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PZ.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NZ.png"
 *     ]
 * });
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 2.0
 *      }),
 *      new MetallicMaterial(viewer.scene, {
 *          baseColor: [1, 1, 1],
 *          metallic: 1.0,
 *          roughness: 1.0
 *      })
 * });
 * ````
 */var ReflectionMap=/*#__PURE__*/function(_CubeTexture){_inherits(ReflectionMap,_CubeTexture);var _super128=_createSuper(ReflectionMap);/**
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID for this ReflectionMap, unique among all components in the parent scene, generated automatically when omitted.
     * @param {String[]} [cfg.src=null]  Paths to six image files to load into this ReflectionMap.
     * @param {Boolean} [cfg.flipY=false] Flips this ReflectionMap's source data along its vertical axis when true.
     * @param {Number} [cfg.encoding=LinearEncoding] Encoding format. Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.
     */function ReflectionMap(owner){var _this95;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ReflectionMap);_this95=_super128.call(this,owner,cfg);_this95.scene._lightsState.addReflectionMap(_this95._state);_this95.scene._reflectionMapCreated(_assertThisInitialized(_this95));return _this95;}/**
     * Destroys this ReflectionMap.
     */_createClass(ReflectionMap,[{key:"type",get:/**
     @private
     */function get(){return"ReflectionMap";}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(ReflectionMap.prototype),"destroy",this).call(this);this.scene._reflectionMapDestroyed(this);}}]);return ReflectionMap;}(CubeTexture);/**
 * @desc A **LightMap** specifies a cube texture light map.
 *
 * ## Usage
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      ReadableGeometry, MetallicMaterial, LightMap} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new LightMap(viewer.scene, {
 *     src: [
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PX.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NX.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PY.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NY.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PZ.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NZ.png"
 *     ]
 * });
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 2.0
 *      }),
 *      new MetallicMaterial(viewer.scene, {
 *          baseColor: [1, 1, 1],
 *          metallic: 1.0,
 *          roughness: 1.0
 *      })
 * });
 * ````
 */var LightMap=/*#__PURE__*/function(_CubeTexture2){_inherits(LightMap,_CubeTexture2);var _super129=_createSuper(LightMap);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID for this LightMap, unique among all components in the parent scene, generated automatically when omitted.
     * @param {String:Object} [cfg.meta] Optional map of user-defined metadata to attach to this LightMap.
     * @param {String[]} [cfg.src=null] Paths to six image files to load into this LightMap.
     * @param {Boolean} [cfg.flipY=false] Flips this LightMap's source data along its vertical axis when true.
     * @param {Number} [cfg.encoding=LinearEncoding] Encoding format. Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.
     */function LightMap(owner){var _this96;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,LightMap);_this96=_super129.call(this,owner,cfg);_this96.scene._lightMapCreated(_assertThisInitialized(_this96));return _this96;}_createClass(LightMap,[{key:"type",get:/**
     @private
     */function get(){return"LightMap";}},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(LightMap.prototype),"destroy",this).call(this);this.scene._lightMapDestroyed(this);}}]);return LightMap;}(CubeTexture);/**
 * A {@link Marker} with a billboarded and textured quad attached to it.
 *
 * * Extends {@link Marker}
 * * Keeps the quad oriented towards the viewpoint
 * * Auto-fits the quad to the texture
 * * Has a world-space position
 * * Can be configured to hide the quad whenever the position is occluded by some other object
 *
 * ## Usage
 *
 * [[Run this example](/examples/#markers_SpriteMarker)]
 *
 * ```` javascript
 * import {Viewer, SpriteMarker } from "./https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/xeokit-sdk.es.min.js";
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas",
 *      transparent: true
 *  });
 *
 * viewer.scene.camera.eye = [0, 0, 25];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new SpriteMarker(viewer.scene, {
 *      worldPos: [-10, 0, 0],
 *      src: "../assets/textures/diffuse/uvGrid2_512x1024.jpg",
 *      size: 5,
 *      occludable: false
 *  });
 *
 * new SpriteMarker(viewer.scene, {
 *      worldPos: [+10, 0, 0],
 *      src: "../assets/textures/diffuse/uvGrid2_1024x512.jpg",
 *      size: 4,
 *      occludable: false
 *  });
 *````
 */var SpriteMarker=/*#__PURE__*/function(_Marker2){_inherits(SpriteMarker,_Marker2);var _super130=_createSuper(SpriteMarker);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this SpriteMarker as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID for this SpriteMarker, unique among all components in the parent scene, generated automatically when omitted.
     * @param {Entity} [cfg.entity] Entity to associate this Marker with. When the SpriteMarker has an Entity, then {@link Marker#visible} will always be ````false```` if {@link Entity#visible} is false.
     * @param {Boolean} [cfg.occludable=false] Indicates whether or not this Marker is hidden (ie. {@link Marker#visible} is ````false```` whenever occluded by {@link Entity}s in the {@link Scene}.
     * @param {Number[]} [cfg.worldPos=[0,0,0]] World-space 3D Marker position.
     * @param {String} [cfg.src=null] Path to image file to load into this SpriteMarker. See the {@link SpriteMarker#src} property for more info.
     * @param {HTMLImageElement} [cfg.image=null] HTML Image object to load into this SpriteMarker. See the {@link SpriteMarker#image} property for more info.
     * @param {Boolean} [cfg.flipY=false] Flips this SpriteMarker's texture image along its vertical axis when true.
     * @param  {String} [cfg.encoding="linear"] Texture encoding format.  See the {@link Texture#encoding} property for more info.
     */function SpriteMarker(owner){var _this97;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SpriteMarker);_this97=_super130.call(this,owner,{entity:cfg.entity,occludable:cfg.occludable,worldPos:cfg.worldPos});_this97._occluded=false;_this97._visible=true;_this97._src=null;_this97._image=null;_this97._pos=math.vec3();_this97._origin=math.vec3();_this97._rtcPos=math.vec3();_this97._dir=math.vec3();_this97._size=1.0;_this97._imageSize=math.vec2();_this97._texture=new Texture(_assertThisInitialized(_this97),{src:cfg.src});_this97._geometry=new ReadableGeometry(_assertThisInitialized(_this97),{primitive:"triangles",positions:[3,3,0,-3,3,0,-3,-3,0,3,-3,0],normals:[-1,0,0,-1,0,0,-1,0,0,-1,0,0],uv:[1,-1,0,-1,0,0,1,0],indices:[0,1,2,0,2,3]// Ensure these will be front-faces
});_this97._mesh=new Mesh(_assertThisInitialized(_this97),{geometry:_this97._geometry,material:new PhongMaterial(_assertThisInitialized(_this97),{ambient:[0.9,0.3,0.9],shininess:30,diffuseMap:_this97._texture,backfaces:true}),scale:[1,1,1],// Note: by design, scale does not work with billboard
position:cfg.worldPos,rotation:[90,0,0],billboard:"spherical",occluder:false// Don't occlude SpriteMarkers or Annotations
});_this97.visible=true;_this97.collidable=cfg.collidable;_this97.clippable=cfg.clippable;_this97.pickable=cfg.pickable;_this97.opacity=cfg.opacity;_this97.size=cfg.size;if(cfg.image){_this97.image=cfg.image;}else{_this97.src=cfg.src;}return _this97;}_createClass(SpriteMarker,[{key:"_setVisible",value:function _setVisible(visible){// Called by VisibilityTester and this._entity.on("destroyed"..)
this._occluded=!visible;this._mesh.visible=this._visible&&!this._occluded;_get(_getPrototypeOf(SpriteMarker.prototype),"_setVisible",this).call(this,visible);}/**
     * Sets if this ````SpriteMarker```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} visible Set ````true```` to make this ````SpriteMarker```` visible.
     */},{key:"visible",get:/**
     * Gets if this ````SpriteMarker```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */function get(){return this._visible;}/**
     * Sets an ````HTMLImageElement```` to source the image from.
     *
     * Sets {@link Texture#src} null.
     *
     * @type {HTMLImageElement}
     */,set:function set(visible){this._visible=visible===null||visible===undefined?true:visible;this._mesh.visible=this._visible&&!this._occluded;}},{key:"image",get:/**
     * Gets the ````HTMLImageElement```` the ````SpriteMarker````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {HTMLImageElement}
     */function get(){return this._image;}/**
     * Sets an image file path that the ````SpriteMarker````'s image is sourced from.
     *
     * Accepted file types are PNG and JPEG.
     *
     * Sets {@link Texture#image} null.
     *
     * @type {String}
     */,set:function set(image){this._image=image;if(this._image){this._imageSize[0]=this._image.width;this._imageSize[1]=this._image.height;this._updatePlaneSizeFromImage();this._src=null;this._texture.image=this._image;}}},{key:"src",get:/**
     * Gets the image file path that the ````SpriteMarker````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {String}
     */function get(){return this._src;}/**
     * Sets the World-space size of the longest edge of the ````SpriteMarker````.
     *
     * Note that ````SpriteMarker```` sets its aspect ratio to match its image. If we set a value of ````1000````, and
     * the image has size ````400x300````, then the ````SpriteMarker```` will then have size ````1000 x 750````.
     *
     * Default value is ````1.0````.
     *
     * @param {Number} size New World-space size of the ````SpriteMarker````.
     */,set:function set(src){var _this98=this;this._src=src;if(this._src){this._image=null;var _image5=new Image();_image5.onload=function(){_this98._texture.image=_image5;_this98._imageSize[0]=_image5.width;_this98._imageSize[1]=_image5.height;_this98._updatePlaneSizeFromImage();};_image5.src=this._src;}}},{key:"size",get:/**
     * Gets the World-space size of the longest edge of the ````SpriteMarker````.
     *
     * Returns {Number} World-space size of the ````SpriteMarker````.
     */function get(){return this._size;}/**
     * Sets if this ````SpriteMarker```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(size){this._size=size===undefined||size===null?1.0:size;if(this._image){this._updatePlaneSizeFromImage();}}},{key:"collidable",get:/**
     * Gets if this ````SpriteMarker```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._mesh.collidable;}/**
     * Sets if this ````SpriteMarker```` is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){this._mesh.collidable=value!==false;}},{key:"clippable",get:/**
     * Gets if this ````SpriteMarker````  is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._mesh.clippable;}/**
     * Sets if this ````SpriteMarker```` is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */,set:function set(value){this._mesh.clippable=value!==false;}},{key:"pickable",get:/**
     * Gets if this ````SpriteMarker````  is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */function get(){return this._mesh.pickable;}/**
     * Sets the opacity factor for this ````SpriteMarker````.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */,set:function set(value){this._mesh.pickable=value!==false;}},{key:"opacity",get:/**
     * Gets this ````SpriteMarker````'s opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */function get(){return this._mesh.opacity;},set:function set(opacity){this._mesh.opacity=opacity;}},{key:"_updatePlaneSizeFromImage",value:function _updatePlaneSizeFromImage(){var halfSize=this._size*0.5;var width=this._imageSize[0];var height=this._imageSize[1];var aspect=height/width;if(width>height){this._geometry.positions=[halfSize,halfSize*aspect,0,-halfSize,halfSize*aspect,0,-halfSize,-halfSize*aspect,0,halfSize,-halfSize*aspect,0];}else{this._geometry.positions=[halfSize/aspect,halfSize,0,-halfSize/aspect,halfSize,0,-halfSize/aspect,-halfSize,0,halfSize/aspect,-halfSize,0];}}}]);return SpriteMarker;}(Marker);/**
 * @desc Saves and restores the state of a {@link Scene}'s {@link Camera}.
 *
 * ## See Also
 *
 * * {@link ModelMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s of a model within a {@link Scene}.
 * * {@link ObjectsMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} and use an {@link XKTLoaderPlugin} to load an ````.xkt```` model. When the model has loaded, we'll save a snapshot of the {@link Camera} state in an CameraMemento. Then we'll move the Camera, and then we'll restore its original state again from the CameraMemento.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, CameraMemento} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Load a model
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt"
 * });
 *
 * // Set camera
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * model.on("loaded", () => {
 *
 *      // Model has loaded
 *
 *      // Save memento of camera state
 *      const cameraMemento = new CameraMemento();
 *
 *      cameraMemento.saveCamera(viewer.scene);
 *
 *      // Move the camera
 *      viewer.camera.eye = [45.3, 2.00, 5.13];
 *      viewer.camera.look = [0.0, 5.5, 10.0];
 *      viewer.camera.up = [0.10, 0.98, -0.14];
 *
 *      // Restore the camera state again
 *      objectsMemento.restoreCamera(viewer.scene);
 * });
 * ````
 */var CameraMemento=/*#__PURE__*/function(){/**
     * Creates a CameraState.
     *
     * @param {Scene} [scene] When given, immediately saves the state of the given {@link Scene}'s {@link Camera}.
     */function CameraMemento(scene){_classCallCheck(this,CameraMemento);/** @private */this._eye=math.vec3();/** @private */this._look=math.vec3();/** @private */this._up=math.vec3();/** @private */this._projection={};if(scene){this.saveCamera(scene);}}/**
     * Saves the state of the given {@link Scene}'s {@link Camera}.
     *
     * @param {Scene} scene The scene that contains the {@link Camera}.
     */_createClass(CameraMemento,[{key:"saveCamera",value:function saveCamera(scene){var camera=scene.camera;var project=camera.project;this._eye.set(camera.eye);this._look.set(camera.look);this._up.set(camera.up);switch(camera.projection){case"perspective":this._projection={projection:"perspective",fov:project.fov,fovAxis:project.fovAxis,near:project.near,far:project.far};break;case"ortho":this._projection={projection:"ortho",scale:project.scale,near:project.near,far:project.far};break;case"frustum":this._projection={projection:"frustum",left:project.left,right:project.right,top:project.top,bottom:project.bottom,near:project.near,far:project.far};break;case"custom":this._projection={projection:"custom",matrix:project.matrix.slice()};break;}}/**
     * Restores a {@link Scene}'s {@link Camera} to the state previously captured with {@link CameraMemento#saveCamera}.
     *
     * @param {Scene} scene The scene.
     * @param {Function} [done] When this callback is given, will fly the {@link Camera} to the saved state then fire the callback. Otherwise will just jump the Camera to the saved state.
     */},{key:"restoreCamera",value:function restoreCamera(scene,done){var camera=scene.camera;var savedProjection=this._projection;function restoreProjection(){switch(savedProjection.type){case"perspective":camera.perspective.fov=savedProjection.fov;camera.perspective.fovAxis=savedProjection.fovAxis;camera.perspective.near=savedProjection.near;camera.perspective.far=savedProjection.far;break;case"ortho":camera.ortho.scale=savedProjection.scale;camera.ortho.near=savedProjection.near;camera.ortho.far=savedProjection.far;break;case"frustum":camera.frustum.left=savedProjection.left;camera.frustum.right=savedProjection.right;camera.frustum.top=savedProjection.top;camera.frustum.bottom=savedProjection.bottom;camera.frustum.near=savedProjection.near;camera.frustum.far=savedProjection.far;break;case"custom":camera.customProjection.matrix=savedProjection.matrix;break;}}if(done){scene.viewer.cameraFlight.flyTo({eye:this._eye,look:this._look,up:this._up,orthoScale:savedProjection.scale,projection:savedProjection.projection},function(){restoreProjection();done();});}else{camera.eye=this._eye;camera.look=this._look;camera.up=this._up;restoreProjection();camera.projection=savedProjection.projection;}}}]);return CameraMemento;}();var color$3=math.vec3();/**
 * @desc Saves and restores a snapshot of the visual state of the {@link Entity}'s of a model within a {@link Scene}.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} and use an {@link XKTLoaderPlugin} to load an ````.xkt```` model. When the model has loaded, we'll hide a couple of {@link Entity}s and save a snapshot of the visual states of all its Entitys in an ModelMemento. Then we'll show all the Entitys
 * again, and then we'll restore the visual states of all the Entitys again from the ModelMemento, which will hide those two Entitys again.
 *
 * ## See Also
 *
 * * {@link CameraMemento} - Saves and restores the state of a {@link Scene}'s {@link Camera}.
 * * {@link ObjectsMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin,  ModelMemento} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Load a model
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      // Model has loaded
 *
 *      // Hide a couple of objects
 *      viewer.scene.objects["0u4wgLe6n0ABVaiXyikbkA"].visible = false;
 *      viewer.scene.objects["3u4wgLe3n0AXVaiXyikbYO"].visible = false;
 *
 *      // Save memento of all object states, which includes those two hidden objects
 *      const ModelMemento = new ModelMemento();
 *
 * const metaModel = viewer.metaScene.metaModels
 *      ModelMemento.saveObjects(viewer.scene);
 *
 *      // Show all objects
 *      viewer.scene.setObjectsVisible(viewer.scene.objectIds, true);
 *
 *      // Restore the objects states again, which involves hiding those two objects again
 *      ModelMemento.restoreObjects(viewer.scene);
 * });
 * `````
 *
 * ## Masking Saved State
 *
 * We can optionally supply a mask to focus what state we save and restore.
 *
 * For example, to save and restore only the {@link Entity#visible} and {@link Entity#clippable} states:
 *
 * ````javascript
 * ModelMemento.saveObjects(viewer.scene, {
 *     visible: true,
 *     clippable: true
 * });
 *
 * //...
 *
 * // Restore the objects states again
 * ModelMemento.restoreObjects(viewer.scene);
 * ````
 */var ModelMemento=/*#__PURE__*/function(){/**
     * Creates a ModelMemento.
     *
     * @param {MetaModel} [metaModel] When given, immediately saves the model's {@link Entity} states to this ModelMemento.
     */function ModelMemento(metaModel){_classCallCheck(this,ModelMemento);/** @private */this.objectsVisible=[];/** @private */this.objectsEdges=[];/** @private */this.objectsXrayed=[];/** @private */this.objectsHighlighted=[];/** @private */this.objectsSelected=[];/** @private */this.objectsClippable=[];/** @private */this.objectsPickable=[];/** @private */this.objectsColorize=[];/** @private */this.objectsOpacity=[];/** @private */this.numObjects=0;if(metaModel){var metaScene=metaModel.metaScene;var scene=metaScene.scene;this.saveObjects(scene,metaModel);}}/**
     * Saves a snapshot of the visual state of the {@link Entity}'s that represent objects within a model.
     *
     * @param {Scene} scene The scene.
     * @param {MetaModel} metaModel Represents the model. Corresponds with an {@link Entity} that represents the model in the scene.
     * @param {Object} [mask] Masks what state gets saved. Saves all state when not supplied.
     * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
     * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
     * @param {boolean} [mask.edges] Saves {@link Entity#edges} values when ````true````.
     * @param {boolean} [mask.xrayed] Saves {@link Entity#xrayed} values when ````true````.
     * @param {boolean} [mask.highlighted] Saves {@link Entity#highlighted} values when ````true````.
     * @param {boolean} [mask.selected] Saves {@link Entity#selected} values when ````true````.
     * @param {boolean} [mask.clippable] Saves {@link Entity#clippable} values when ````true````.
     * @param {boolean} [mask.pickable] Saves {@link Entity#pickable} values when ````true````.
     * @param {boolean} [mask.colorize] Saves {@link Entity#colorize} values when ````true````.
     * @param {boolean} [mask.opacity] Saves {@link Entity#opacity} values when ````true````.
     */_createClass(ModelMemento,[{key:"saveObjects",value:function saveObjects(scene,metaModel,mask){this.numObjects=0;this._mask=mask?utils.apply(mask,{}):null;var visible=!mask||mask.visible;var edges=!mask||mask.edges;var xrayed=!mask||mask.xrayed;var highlighted=!mask||mask.highlighted;var selected=!mask||mask.selected;var clippable=!mask||mask.clippable;var pickable=!mask||mask.pickable;var colorize=!mask||mask.colorize;var opacity=!mask||mask.opacity;var metaObjects=metaModel.metaObjects;var objects=scene.objects;for(var _i460=0,len=metaObjects.length;_i460<len;_i460++){var metaObject=metaObjects[_i460];var objectId=metaObject.id;var object=objects[objectId];if(!object){continue;}if(visible){this.objectsVisible[_i460]=object.visible;}if(edges){this.objectsEdges[_i460]=object.edges;}if(xrayed){this.objectsXrayed[_i460]=object.xrayed;}if(highlighted){this.objectsHighlighted[_i460]=object.highlighted;}if(selected){this.objectsSelected[_i460]=object.selected;}if(clippable){this.objectsClippable[_i460]=object.clippable;}if(pickable){this.objectsPickable[_i460]=object.pickable;}if(colorize){var objectColor=object.colorize;this.objectsColorize[_i460*3+0]=objectColor[0];this.objectsColorize[_i460*3+1]=objectColor[1];this.objectsColorize[_i460*3+2]=objectColor[2];}if(opacity){this.objectsOpacity[_i460]=object.opacity;}this.numObjects++;}}/**
     * Restores a {@link Scene}'s {@link Entity}'s to their state previously captured with {@link ModelMemento#saveObjects}.
     *
     * Assumes that the model has not been destroyed or modified since saving.
     *
     * @param {Scene} scene The scene that was given to {@link ModelMemento#saveObjects}.
     * @param {MetaModel} metaModel The metamodel that was given to {@link ModelMemento#saveObjects}.
     */},{key:"restoreObjects",value:function restoreObjects(scene,metaModel){var mask=this._mask;var visible=!mask||mask.visible;var edges=!mask||mask.edges;var xrayed=!mask||mask.xrayed;var highlighted=!mask||mask.highlighted;var selected=!mask||mask.selected;var clippable=!mask||mask.clippable;var pickable=!mask||mask.pickable;var colorize=!mask||mask.colorize;var opacity=!mask||mask.opacity;var metaObjects=metaModel.metaObjects;var objects=scene.objects;for(var _i461=0,len=metaObjects.length;_i461<len;_i461++){var metaObject=metaObjects[_i461];var objectId=metaObject.id;var object=objects[objectId];if(!object){continue;}if(visible){object.visible=this.objectsVisible[_i461];}if(edges){object.edges=this.objectsEdges[_i461];}if(xrayed){object.xrayed=this.objectsXrayed[_i461];}if(highlighted){object.highlighted=this.objectsHighlighted[_i461];}if(selected){object.selected=this.objectsSelected[_i461];}if(clippable){object.clippable=this.objectsClippable[_i461];}if(pickable){object.pickable=this.objectsPickable[_i461];}if(colorize){color$3[0]=this.objectsColorize[_i461*3+0];color$3[1]=this.objectsColorize[_i461*3+1];color$3[2]=this.objectsColorize[_i461*3+2];object.colorize=color$3;}if(opacity){object.opacity=this.objectsOpacity[_i461];}}}}]);return ModelMemento;}();var color$2=math.vec3();/**
 * @desc Saves and restores a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * * An Entity represents an object when {@link Entity#isObject} is ````true````.
 * * Each object-Entity is registered by {@link Entity#id} in {@link Scene#objects}.
 *
 * ## See Also
 *
 * * {@link CameraMemento} - Saves and restores the state of a {@link Scene}'s {@link Camera}.
 * * {@link ModelMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s of a model within a {@link Scene}.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} and use an {@link XKTLoaderPlugin} to load an ````.xkt```` model. When the model has loaded, we'll hide a couple of {@link Entity}s and save a snapshot of the visual states of all the Entitys in an ObjectsMemento. Then we'll show all the Entitys
 * again, and then we'll restore the visual states of all the Entitys again from the ObjectsMemento, which will hide those two Entitys again.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, ObjectsMemento} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Load a model
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      // Model has loaded
 *
 *      // Hide a couple of objects
 *      viewer.scene.objects["0u4wgLe6n0ABVaiXyikbkA"].visible = false;
 *      viewer.scene.objects["3u4wgLe3n0AXVaiXyikbYO"].visible = false;
 *
 *      // Save memento of all object states, which includes those two hidden objects
 *      const objectsMemento = new ObjectsMemento();
 *
 *      objectsMemento.saveObjects(viewer.scene);
 *
 *      // Show all objects
 *      viewer.scene.setObjectsVisible(viewer.scene.objectIds, true);
 *
 *      // Restore the objects states again, which involves hiding those two objects again
 *      objectsMemento.restoreObjects(viewer.scene);
 * });
 * `````
 *
 * ## Masking Saved State
 *
 * We can optionally supply a mask to focus what state we save and restore.
 *
 * For example, to save and restore only the {@link Entity#visible} and {@link Entity#clippable} states:
 *
 * ````javascript
 * objectsMemento.saveObjects(viewer.scene, {
 *     visible: true,
 *     clippable: true
 * });
 *
 * //...
 *
 * // Restore the objects states again
 * objectsMemento.restoreObjects(viewer.scene);
 * ````
 */var ObjectsMemento=/*#__PURE__*/function(){/**
     * Creates an ObjectsMemento.
     */function ObjectsMemento(){_classCallCheck(this,ObjectsMemento);/** @private */this.objectsVisible=[];/** @private */this.objectsEdges=[];/** @private */this.objectsXrayed=[];/** @private */this.objectsHighlighted=[];/** @private */this.objectsSelected=[];/** @private */this.objectsClippable=[];/** @private */this.objectsPickable=[];/** @private */this.objectsColorize=[];/** @private */this.objectsHasColorize=[];/** @private */this.objectsOpacity=[];/** @private */this.numObjects=0;}/**
     * Saves a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
     *
     * @param {Scene} scene The scene.
     * @param {Object} [mask] Masks what state gets saved. Saves all state when not supplied.
     * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
     * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
     * @param {boolean} [mask.edges] Saves {@link Entity#edges} values when ````true````.
     * @param {boolean} [mask.xrayed] Saves {@link Entity#xrayed} values when ````true````.
     * @param {boolean} [mask.highlighted] Saves {@link Entity#highlighted} values when ````true````.
     * @param {boolean} [mask.selected] Saves {@link Entity#selected} values when ````true````.
     * @param {boolean} [mask.clippable] Saves {@link Entity#clippable} values when ````true````.
     * @param {boolean} [mask.pickable] Saves {@link Entity#pickable} values when ````true````.
     * @param {boolean} [mask.colorize] Saves {@link Entity#colorize} values when ````true````.
     * @param {boolean} [mask.opacity] Saves {@link Entity#opacity} values when ````true````.
     */_createClass(ObjectsMemento,[{key:"saveObjects",value:function saveObjects(scene,mask){this.numObjects=0;this._mask=mask?utils.apply(mask,{}):null;var objects=scene.objects;var visible=!mask||mask.visible;var edges=!mask||mask.edges;var xrayed=!mask||mask.xrayed;var highlighted=!mask||mask.highlighted;var selected=!mask||mask.selected;var clippable=!mask||mask.clippable;var pickable=!mask||mask.pickable;var colorize=!mask||mask.colorize;var opacity=!mask||mask.opacity;for(var objectId in objects){if(objects.hasOwnProperty(objectId)){var object=objects[objectId];var _i462=this.numObjects;if(visible){this.objectsVisible[_i462]=object.visible;}if(edges){this.objectsEdges[_i462]=object.edges;}if(xrayed){this.objectsXrayed[_i462]=object.xrayed;}if(highlighted){this.objectsHighlighted[_i462]=object.highlighted;}if(selected){this.objectsSelected[_i462]=object.selected;}if(clippable){this.objectsClippable[_i462]=object.clippable;}if(pickable){this.objectsPickable[_i462]=object.pickable;}if(colorize){var objectColor=object.colorize;if(objectColor){this.objectsColorize[_i462*3+0]=objectColor[0];this.objectsColorize[_i462*3+1]=objectColor[1];this.objectsColorize[_i462*3+2]=objectColor[2];this.objectsHasColorize[_i462]=true;}else{this.objectsHasColorize[_i462]=false;}}if(opacity){this.objectsOpacity[_i462]=object.opacity;}this.numObjects++;}}}/**
     * Restores a {@link Scene}'s {@link Entity}'s to their state previously captured with {@link ObjectsMemento#saveObjects}.
     * @param {Scene} scene The scene.
     */},{key:"restoreObjects",value:function restoreObjects(scene){var mask=this._mask;var visible=!mask||mask.visible;var edges=!mask||mask.edges;var xrayed=!mask||mask.xrayed;var highlighted=!mask||mask.highlighted;var selected=!mask||mask.selected;var clippable=!mask||mask.clippable;var pickable=!mask||mask.pickable;var colorize=!mask||mask.colorize;var opacity=!mask||mask.opacity;var i=0;var objects=scene.objects;for(var objectId in objects){if(objects.hasOwnProperty(objectId)){var object=objects[objectId];if(visible){object.visible=this.objectsVisible[i];}if(edges){object.edges=this.objectsEdges[i];}if(xrayed){object.xrayed=this.objectsXrayed[i];}if(highlighted){object.highlighted=this.objectsHighlighted[i];}if(selected){object.selected=this.objectsSelected[i];}if(clippable){object.clippable=this.objectsClippable[i];}if(pickable){object.pickable=this.objectsPickable[i];}if(colorize){if(this.objectsHasColorize[i]){color$2[0]=this.objectsColorize[i*3+0];color$2[1]=this.objectsColorize[i*3+1];color$2[2]=this.objectsColorize[i*3+2];object.colorize=color$2;}else{object.colorize=null;}}if(opacity){object.opacity=this.objectsOpacity[i];}i++;}}}}]);return ObjectsMemento;}();/**
 * @desc A {@link Curve} along which a 3D position can be animated.
 *
 * * As shown in the diagram below, a CubicBezierCurve is defined by four control points.
 * * You can sample a {@link CubicBezierCurve#point} and a {@link CubicBezierCurve#tangent} vector on a CubicBezierCurve for any given value of {@link CubicBezierCurve#t} in the range [0..1].
 * * When you set {@link CubicBezierCurve#t} on a CubicBezierCurve, its {@link CubicBezierCurve#point} and {@link CubicBezierCurve#tangent} properties will update accordingly.
 * * To build a complex path, you can combine an unlimited combination of CubicBezierCurves, {@link QuadraticBezierCurve}s and {@link SplineCurve}s into a {@link Path}.
 *
 * <br>
 * <img style="border:1px solid;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/B%C3%A9zier_3_big.gif/240px-B%C3%A9zier_3_big.gif"/>
 * <br>
 * [Cubic Bezier Curve from WikiPedia](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
 */var CubicBezierCurve=/*#__PURE__*/function(_Curve2){_inherits(CubicBezierCurve,_Curve2);var _super131=_createSuper(CubicBezierCurve);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this CubicBezierCurve as well.
     * @param {*} [cfg] Configs
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {Number[]} [cfg.v0=[0,0,0]] The starting point.
     * @param {Number[]} [cfg.v1=[0,0,0]] The first control point.
     * @param {Number[]} [cfg.v2=[0,0,0]] The middle control point.
     * @param {Number[]} [cfg.v3=[0,0,0]] The ending point.
     * @param {Number} [cfg.t=0] Current position on this CubicBezierCurve, in range between 0..1.
     */function CubicBezierCurve(owner){var _this99;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CubicBezierCurve);_this99=_super131.call(this,owner,cfg);_this99.v0=cfg.v0;_this99.v1=cfg.v1;_this99.v2=cfg.v2;_this99.v3=cfg.v3;_this99.t=cfg.t;return _this99;}/**
     * Sets the starting point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The starting point.
     */_createClass(CubicBezierCurve,[{key:"v0",get:/**
     * Gets the starting point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The starting point.
     */function get(){return this._v0;}/**
     * Sets the first control point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The first control point.
     */,set:function set(value){this._v0=value||math.vec3([0,0,0]);}},{key:"v1",get:/**
     * Gets the first control point on this CubicBezierCurve.
     *
     * Fires a {@link CubicBezierCurve#v1:event} event on change.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The first control point.
     */function get(){return this._v1;}/**
     * Sets the second control point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The second control point.
     */,set:function set(value){this._v1=value||math.vec3([0,0,0]);}},{key:"v2",get:/**
     * Gets the second control point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The second control point.
     */function get(){return this._v2;}/**
     * Sets the end point on this CubicBezierCurve.
     *
     * Fires a {@link CubicBezierCurve#v3:event} event on change.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The end point.
     */,set:function set(value){this._v2=value||math.vec3([0,0,0]);}},{key:"v3",get:/**
     * Gets the end point on this CubicBezierCurve.
     *
     * Fires a {@link CubicBezierCurve#v3:event} event on change.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The end point.
     */function get(){return this._v3;}/**
     * Sets the current position of progress along this CubicBezierCurve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * @param {Number} value New progress time value.
     */,set:function set(value){this.fire("v3",this._v3=value||math.vec3([0,0,0]));}},{key:"t",get:/**
     * Gets the current position of progress along this CubicBezierCurve.
     *
     * @returns {Number} Current progress time value.
     */function get(){return this._t;}/**
     * Returns point on this CubicBezierCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     *
     * @returns {Number[]} The point at the given position.
     */,set:function set(value){value=value||0;this._t=value<0.0?0.0:value>1.0?1.0:value;}},{key:"point",get:function get(){return this.getPoint(this._t);}/**
     * Returns point on this CubicBezierCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     *
     * @returns {Number[]} The point at the given position.
     */},{key:"getPoint",value:function getPoint(t){var vector=math.vec3();vector[0]=math.b3(t,this._v0[0],this._v1[0],this._v2[0],this._v3[0]);vector[1]=math.b3(t,this._v0[1],this._v1[1],this._v2[1],this._v3[1]);vector[2]=math.b3(t,this._v0[2],this._v1[2],this._v2[2],this._v3[2]);return vector;}},{key:"getJSON",value:function getJSON(){return{v0:this._v0,v1:this._v1,v2:this._v2,v3:this._v3,t:this._t};}}]);return CubicBezierCurve;}(Curve);/**
 * @desc A complex curved path constructed from various {@link Curve} subtypes.
 *
 * * A Path can be constructed from these {@link Curve} subtypes: {@link SplineCurve}, {@link CubicBezierCurve} and {@link QuadraticBezierCurve}.
 * * You can sample a {@link Path#point} and a {@link Curve#tangent} vector on a Path for any given value of {@link Path#t} in the range ````[0..1]````.
 * * When you set {@link Path#t} on a Path, its {@link Path#point} and {@link Curve#tangent} properties will update accordingly.
 */var Path=/*#__PURE__*/function(_Curve3){_inherits(Path,_Curve3);var _super132=_createSuper(Path);/**
     * @constructor
     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this SectionPlane as well.
     * @param {*} [cfg]  Path configuration
     * @param {String} [cfg.id]  Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
     * @param {String []} [cfg.paths=[]] IDs or instances of {{#crossLink "path"}}{{/crossLink}} subtypes to add to this Path.
     * @param {Number} [cfg.t=0] Current position on this Path, in range between 0..1.
     */function Path(owner){var _this100;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Path);_this100=_super132.call(this,owner,cfg);_this100._cachedLengths=[];_this100._dirty=true;_this100._curves=[];// Array of child Curve components
_this100._t=0;_this100._dirtySubs=[];// Subscriptions to "dirty" events from child Curve components
_this100._destroyedSubs=[];// Subscriptions to "destroyed" events from child Curve components
_this100.curves=cfg.curves||[];// Add initial curves
_this100.t=cfg.t;// Set initial progress
return _this100;}/**
     * Adds a {@link Curve} to this Path.
     *
     * @param {Curve} curve The {@link Curve} to add.
     */_createClass(Path,[{key:"addCurve",value:function addCurve(curve){this._curves.push(curve);this._dirty=true;}/**
     * Sets the {@link Curve}s in this Path.
     *
     * Default value is ````[]````.
     *
     * @param {{Array of Spline, Path, QuadraticBezierCurve or CubicBezierCurve}} value.
     */},{key:"curves",get:/**
     * Gets the {@link Curve}s in this Path.
     *
     * @returns {{Array of Spline, Path, QuadraticBezierCurve or CubicBezierCurve}} the {@link Curve}s in this path.
     */function get(){return this._curves;}/**
     * Sets the current point of progress along this Path.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The current point of progress.
     */,set:function set(value){value=value||[];var curve;// Unsubscribe from events on old curves
var i;var len;for(i=0,len=this._curves.length;i<len;i++){curve=this._curves[i];curve.off(this._dirtySubs[i]);curve.off(this._destroyedSubs[i]);}this._curves=[];this._dirtySubs=[];this._destroyedSubs=[];var self=this;function curveDirty(){self._dirty=true;}function curveDestroyed(){var id=this.id;for(i=0,len=self._curves.length;i<len;i++){if(self._curves[i].id===id){self._curves=self._curves.slice(i,i+1);self._dirtySubs=self._dirtySubs.slice(i,i+1);self._destroyedSubs=self._destroyedSubs.slice(i,i+1);self._dirty=true;return;}}}for(i=0,len=value.length;i<len;i++){curve=value[i];if(utils.isNumeric(curve)||utils.isString(curve)){// ID given for curve - find the curve component
var id=curve;curve=this.scene.components[id];if(!curve){this.error("Component not found: "+_inQuotes(id));continue;}}var type=curve.type;if(type!=="xeokit.SplineCurve"&&type!=="xeokit.Path"&&type!=="xeokit.CubicBezierCurve"&&type!=="xeokit.QuadraticBezierCurve"){this.error("Component "+_inQuotes(curve.id)+" is not a xeokit.SplineCurve, xeokit.Path or xeokit.QuadraticBezierCurve");continue;}this._curves.push(curve);this._dirtySubs.push(curve.on("dirty",curveDirty));this._destroyedSubs.push(curve.once("destroyed",curveDestroyed));}this._dirty=true;}},{key:"t",get:/**
     * Gets the current point of progress along this Path.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The current point of progress.
     */function get(){return this._t;}/**
     * Gets point on this Path corresponding to the current value of {@link Path#t}.
     *
     * @returns {Number[]} The point.
     */,set:function set(value){value=value||0;this._t=value<0.0?0.0:value>1.0?1.0:value;}},{key:"point",get:function get(){return this.getPoint(this._t);}/**
     * Length of this Path, which is the cumulative length of all {@link Curve}s currently in {@link Path#curves}.
     *
     * @return {Number} Length of this path.
     */},{key:"length",get:function get(){var lens=this._getCurveLengths();return lens[lens.length-1];}/**
     * Gets a point on this Path corresponding to the given progress position.
     *
     * @param {Number} t Indicates point of progress along this curve, in the range [0..1].
     * @returns {Number[]}
     */},{key:"getPoint",value:function getPoint(t){var d=t*this.length;var curveLengths=this._getCurveLengths();var i=0,diff,curve;while(i<curveLengths.length){if(curveLengths[i]>=d){diff=curveLengths[i]-d;curve=this._curves[i];var u=1-diff/curve.length;return curve.getPointAt(u);}i++;}return null;}},{key:"_getCurveLengths",value:function _getCurveLengths(){if(!this._dirty){return this._cachedLengths;}var lengths=[];var sums=0;var i,il=this._curves.length;for(i=0;i<il;i++){sums+=this._curves[i].length;lengths.push(sums);}this._cachedLengths=lengths;this._dirty=false;return lengths;}},{key:"_getJSON",value:function _getJSON(){var curveIds=[];for(var i=0,len=this._curves.length;i<len;i++){curveIds.push(this._curves[i].id);}return{curves:curveIds,t:this._t};}/**
     * Destroys this Path.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(Path.prototype),"destroy",this).call(this);var i;var len;var curve;for(i=0,len=this._curves.length;i<len;i++){curve=this._curves[i];curve.off(this._dirtySubs[i]);curve.off(this._destroyedSubs[i]);}}}]);return Path;}(Curve);/**
 * A **QuadraticBezierCurve** is a {@link Curve} along which a 3D position can be animated.
 *
 * * As shown in the diagram below, a QuadraticBezierCurve is defined by three control points
 * * You can sample a {@link QuadraticBezierCurve#point} and a {@link Curve#tangent} vector on a QuadraticBezierCurve for any given value of {@link QuadraticBezierCurve#t} in the range ````[0..1]````
 * * When you set {@link QuadraticBezierCurve#t} on a QuadraticBezierCurve, its {@link QuadraticBezierCurve#point} and {@link Curve#tangent} will update accordingly.
 * * To build a complex path, you can combine an unlimited combination of QuadraticBezierCurves, {@link CubicBezierCurve}s and {@link SplineCurve}s into a {@link Path}.</li>
 * <br>
 * <img style="border:1px solid;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/B%C3%A9zier_2_big.gif/240px-B%C3%A9zier_2_big.gif"/>
 * <br>
 * *[Quadratic Bezier Curve from WikiPedia](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)*
 */var QuadraticBezierCurve=/*#__PURE__*/function(_Curve4){_inherits(QuadraticBezierCurve,_Curve4);var _super133=_createSuper(QuadraticBezierCurve);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this MetallicMaterial as well.
     * @param {*} [cfg] Configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
     * @param {Number[]} [cfg.v0=[0,0,0]] The starting point.
     * @param {Number[]} [cfg.v1=[0,0,0]] The middle control point.
     * @param {Number[]} [cfg.v2=[0,0,0]] The end point.
     * @param {Number[]} [cfg.t=0] Current position on this QuadraticBezierCurve, in range between ````0..1````.
     */function QuadraticBezierCurve(owner){var _this101;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,QuadraticBezierCurve);_this101=_super133.call(this,owner,cfg);_this101.v0=cfg.v0;_this101.v1=cfg.v1;_this101.v2=cfg.v2;_this101.t=cfg.t;return _this101;}/**
     * Sets the starting point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @param {Number[]} value New starting point.
     */_createClass(QuadraticBezierCurve,[{key:"v0",get:/**
     * Gets the starting point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @returns {Number[]} The starting point.
     */function get(){return this._v0;}/**
     * Sets the middle control point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @param {Number[]} value New middle control point.
     */,set:function set(value){this._v0=value||math.vec3([0,0,0]);}},{key:"v1",get:/**
     * Gets the middle control point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @returns {Number[]} The middle control point.
     */function get(){return this._v1;}/**
     * Sets the end point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @param {Number[]} value The new end point.
     */,set:function set(value){this._v1=value||math.vec3([0,0,0]);}},{key:"v2",get:/**
     * Gets the end point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @returns {Number[]} The end point.
     */function get(){return this._v2;}/**
     * Sets the progress along this QuadraticBezierCurve.
     *
     * Automatically clamps to range [0..1].
     *
     * Default value is ````0````.
     *
     * @param {Number} value The new progress location.
     */,set:function set(value){this._v2=value||math.vec3([0,0,0]);}},{key:"t",get:/**
     * Gets the progress along this QuadraticBezierCurve.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The current progress location.
     */function get(){return this._t;}/**
     Point on this QuadraticBezierCurve at position {@link QuadraticBezierCurve/t}.

     @property point
     @type {Number[]}
     */,set:function set(value){value=value||0;this._t=value<0.0?0.0:value>1.0?1.0:value;}},{key:"point",get:function get(){return this.getPoint(this._t);}/**
     * Returns the point on this QuadraticBezierCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     * @returns {Number[]} The point.
     */},{key:"getPoint",value:function getPoint(t){var vector=math.vec3();vector[0]=math.b2(t,this._v0[0],this._v1[0],this._v2[0]);vector[1]=math.b2(t,this._v0[1],this._v1[1],this._v2[1]);vector[2]=math.b2(t,this._v0[2],this._v1[2],this._v2[2]);return vector;}},{key:"getJSON",value:function getJSON(){return{v0:this._v0,v1:this._v1,v2:this._v2,t:this._t};}}]);return QuadraticBezierCurve;}(Curve);/**
 * @desc A high-performance model representation for efficient rendering and low memory usage.
 *
 * * PerformanceModel was replaced with {@link SceneModel} in ````xeokit-sdk v2.4````.
 * * PerformanceModel currently extends {@link SceneModel}, in order to maintain backward-compatibility until we remove PerformanceModel.
 * * See {@link SceneModel} for API details.
 *
 * @deprecated
 * @implements {Drawable}
 * @implements {Entity}
 * @extends {SceneModel}
 */var PerformanceModel=/*#__PURE__*/function(_SceneModel){_inherits(PerformanceModel,_SceneModel);var _super134=_createSuper(PerformanceModel);/**
     * See {@link VBOSceneModel} for details.
     *
     * @param owner
     * @param cfg
     */function PerformanceModel(owner){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PerformanceModel);return _super134.call(this,owner,cfg);}return _createClass(PerformanceModel);}(SceneModel);/**
 * @desc A Skybox.
 */var Skybox=/*#__PURE__*/function(_Component37){_inherits(Skybox,_Component37);var _super135=_createSuper(Skybox);/**
     * @constructor
     * @param {Component} owner Owner component. When destroyed, the owner will destroy this PointLight as well.
     * @param {*} [cfg]  Skybox configuration
     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {Scene}, generated automatically when omitted.
     * @param {String} [cfg.src=null] Path to skybox texture
     * @param {String} [cfg.encoding="linear"] Texture encoding format.  See the {@link Texture#encoding} property for more info.
     * @param {Number} [cfg.size=1000] Size of this Skybox, given as the distance from the center at ````[0,0,0]```` to each face.
     * @param {Boolean} [cfg.active=true] True when this Skybox is visible.
     */function Skybox(owner){var _this102;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Skybox);_this102=_super135.call(this,owner,cfg);_this102._skyboxMesh=new Mesh(_assertThisInitialized(_this102),{geometry:new ReadableGeometry(_assertThisInitialized(_this102),{// Box-shaped geometry
primitive:"triangles",positions:[1,1,1,-1,1,1,-1,-1,1,1,-1,1,// v0-v1-v2-v3 front
1,1,1,1,-1,1,1,-1,-1,1,1,-1,// v0-v3-v4-v5 right
1,1,1,1,1,-1,-1,1,-1,-1,1,1,// v0-v5-v6-v1 top
-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,// v1-v6-v7-v2 left
-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,// v7-v4-v3-v2 bottom
1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1// v4-v7-v6-v5 back
],uv:[0.5,0.6666,0.25,0.6666,0.25,0.3333,0.5,0.3333,0.5,0.6666,0.5,0.3333,0.75,0.3333,0.75,0.6666,0.5,0.6666,0.5,1,0.25,1,0.25,0.6666,0.25,0.6666,0.0,0.6666,0.0,0.3333,0.25,0.3333,0.25,0,0.50,0,0.50,0.3333,0.25,0.3333,0.75,0.3333,1.0,0.3333,1.0,0.6666,0.75,0.6666],indices:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]}),background:true,scale:[2000,2000,2000],// Overridden when we initialize the 'size' property, below
rotation:[0,-90,0],material:new PhongMaterial(_assertThisInitialized(_this102),{ambient:[0,0,0],diffuse:[0,0,0],specular:[0,0,0],emissive:[1,1,1],emissiveMap:new Texture(_assertThisInitialized(_this102),{src:cfg.src,flipY:true,wrapS:"clampToEdge",wrapT:"clampToEdge",encoding:cfg.encoding||"sRGB"}),backfaces:true// Show interior faces of our skybox geometry
}),// stationary: true,
visible:false,pickable:false,clippable:false,collidable:false});_this102.size=cfg.size;// Sets 'xyz' property on the Mesh's Scale transform
_this102.active=cfg.active;return _this102;}/**
     * Sets the size of this Skybox, given as the distance from the center at [0,0,0] to each face.
     *
     * Default value is ````1000````.
     *
     * @param {Number} value The size.
     */_createClass(Skybox,[{key:"size",get:/**
     * Gets the size of this Skybox, given as the distance from the center at [0,0,0] to each face.
     *
     * Default value is ````1000````.
     *
     * @returns {Number} The size.
     */function get(){return this._size;}/**
     * Sets whether this Skybox is visible or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} active Whether to make active or not.
     */,set:function set(value){this._size=value||1000;this._skyboxMesh.scale=[this._size,this._size,this._size];}},{key:"active",get:/**
     * Gets if this Skybox is visible or not.
     *
     * Default active is ````true````.
     *
     * @returns {Boolean} ````true```` if the Skybox is active.
     */function get(){return this._skyboxMesh.visible;},set:function set(active){this._skyboxMesh.visible=active;}}]);return Skybox;}(Component);/**
 * Transcodes texture data.
 *
 * A {@link SceneModel} configured with an appropriate TextureTranscoder will allow us to add textures from
 * transcoded buffers or files. For a concrete example, see {@link VBOSceneModel}, which can be configured with
 * a {@link KTX2TextureTranscoder}, which allows us to add textures from KTX2 buffers and files.
 *
 * @interface
 */var TextureTranscoder=/*#__PURE__*/function(){function TextureTranscoder(){_classCallCheck(this,TextureTranscoder);}_createClass(TextureTranscoder,[{key:"transcode",value:/**
     * Transcodes texture data from transcoded buffers into a {@link Texture2D}.
     *
     * @param {ArrayBuffer[]} buffers Transcoded texture data. Given as an array of buffers so that we can support
     * multi-image textures, such as cube maps.
     * @param {*} config Transcoding options.
     * @param {Texture2D} texture The texture to load.
     * @returns {Promise} Resolves when the texture has loaded.
     */function transcode(buffers,texture){var config=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};}/**
     * Destroys this transcoder.
     */},{key:"destroy",value:function destroy(){}}]);return TextureTranscoder;}();var screenPos=math.vec4();var viewPos=math.vec4();var tempVec3a$7=math.vec3();var tempVec3b$4=math.vec3();var tempVec3c$3=math.vec3();var tempVec4a$4=math.vec4();var tempVec4b$4=math.vec4();var tempVec4c$1=math.vec4();/**
 * @private
 */var PanController=/*#__PURE__*/function(){function PanController(scene){_classCallCheck(this,PanController);this._scene=scene;}/**
     * Dollys the Camera towards the given target 2D canvas position.
     *
     * When the target's corresponding World-space position is also provided, then this function will also test if we've
     * dollied past the target, and will return ````true```` if that's the case.
     *
     * @param [optionalTargetWorldPos] Optional world position of the target
     * @param targetCanvasPos Canvas position of the target
     * @param dollyDelta Amount to dolly
     * @return True if optionalTargetWorldPos was given, and we've dollied past that position.
     */_createClass(PanController,[{key:"dollyToCanvasPos",value:function dollyToCanvasPos(optionalTargetWorldPos,targetCanvasPos,dollyDelta){var dolliedThroughSurface=false;var camera=this._scene.camera;if(optionalTargetWorldPos){var eyeToWorldPosVec=math.subVec3(optionalTargetWorldPos,camera.eye,tempVec3a$7);var eyeWorldPosDist=math.lenVec3(eyeToWorldPosVec);dolliedThroughSurface=eyeWorldPosDist<dollyDelta;}if(camera.projection==="perspective"){camera.ortho.scale=camera.ortho.scale-dollyDelta;var unprojectedWorldPos=this._unproject(targetCanvasPos,tempVec4a$4);var offset=math.subVec3(unprojectedWorldPos,camera.eye,tempVec4c$1);var moveVec=math.mulVec3Scalar(math.normalizeVec3(offset),-dollyDelta,[]);camera.eye=[camera.eye[0]-moveVec[0],camera.eye[1]-moveVec[1],camera.eye[2]-moveVec[2]];camera.look=[camera.look[0]-moveVec[0],camera.look[1]-moveVec[1],camera.look[2]-moveVec[2]];if(optionalTargetWorldPos){// Subtle UX tweak - if we have a target World position, then set camera eye->look distance to
// the same distance as from eye->target. This just gives us a better position for look,
// if we subsequently orbit eye about look, so that we don't orbit a position that's
// suddenly a lot closer than the point we pivoted about on the surface of the last object
// that we click-drag-pivoted on.
var eyeTargetVec=math.subVec3(optionalTargetWorldPos,camera.eye,tempVec3a$7);var lenEyeTargetVec=math.lenVec3(eyeTargetVec);var _eyeLookVec2=math.mulVec3Scalar(math.normalizeVec3(math.subVec3(camera.look,camera.eye,tempVec3b$4)),lenEyeTargetVec);camera.look=[camera.eye[0]+_eyeLookVec2[0],camera.eye[1]+_eyeLookVec2[1],camera.eye[2]+_eyeLookVec2[2]];}}else if(camera.projection==="ortho"){// - set ortho scale, getting the unprojected targetCanvasPos before and after, get that difference in a vector;
// - get the vector in which we're dollying;
// - add both vectors to camera eye and look.
var worldPos1=this._unproject(targetCanvasPos,tempVec4a$4);camera.ortho.scale=camera.ortho.scale-dollyDelta;camera.ortho._update();// HACK
var worldPos2=this._unproject(targetCanvasPos,tempVec4b$4);var _offset=math.subVec3(worldPos2,worldPos1,tempVec4c$1);var eyeLookMoveVec=math.mulVec3Scalar(math.normalizeVec3(math.subVec3(camera.look,camera.eye,tempVec3a$7)),-dollyDelta,tempVec3b$4);var _moveVec=math.addVec3(_offset,eyeLookMoveVec,tempVec3c$3);camera.eye=[camera.eye[0]-_moveVec[0],camera.eye[1]-_moveVec[1],camera.eye[2]-_moveVec[2]];camera.look=[camera.look[0]-_moveVec[0],camera.look[1]-_moveVec[1],camera.look[2]-_moveVec[2]];}return dolliedThroughSurface;}},{key:"_unproject",value:function _unproject(canvasPos,worldPos){var camera=this._scene.camera;var transposedProjectMat=camera.project.transposedMatrix;var Pt3=transposedProjectMat.subarray(8,12);var Pt4=transposedProjectMat.subarray(12);var D=[0,0,-1.0,1];var screenZ=math.dotVec4(D,Pt3)/math.dotVec4(D,Pt4);camera.project.unproject(canvasPos,screenZ,screenPos,viewPos,worldPos);return worldPos;}},{key:"destroy",value:function destroy(){}}]);return PanController;}();var tempVec3a$6=math.vec3();var tempVec3b$3=math.vec3();var tempVec3c$2=math.vec3();var tempVec4a$3=math.vec4();var tempVec4b$3=math.vec4();var tempVec4c=math.vec4();/** @private */var PivotController=/*#__PURE__*/function(){/**
     * @private
     */function PivotController(scene,configs){var _this103=this;_classCallCheck(this,PivotController);// Pivot math by: http://www.derschmale.com/
this._scene=scene;this._configs=configs;this._pivotWorldPos=math.vec3();this._cameraOffset=math.vec3();this._azimuth=0;this._polar=0;this._radius=0;this._pivotPosSet=false;// Initially false, true as soon as _pivotWorldPos has been set to some value
this._pivoting=false;// True while pivoting
this._shown=false;this._pivotSphereEnabled=false;this._pivotSphere=null;this._pivotSphereSize=1;this._pivotSphereGeometry=null;this._pivotSphereMaterial=null;this._rtcCenter=math.vec3();this._rtcPos=math.vec3();this._pivotViewPos=math.vec4();this._pivotProjPos=math.vec4();this._pivotCanvasPos=math.vec2();this._cameraDirty=true;this._onViewMatrix=this._scene.camera.on("viewMatrix",function(){_this103._cameraDirty=true;});this._onProjMatrix=this._scene.camera.on("projMatrix",function(){_this103._cameraDirty=true;});this._onTick=this._scene.on("tick",function(){_this103.updatePivotElement();_this103.updatePivotSphere();});}_createClass(PivotController,[{key:"createPivotSphere",value:function createPivotSphere(){var currentPos=this.getPivotPos();var cameraPos=math.vec3();math.decomposeMat4(math.inverseMat4(this._scene.viewer.camera.viewMatrix,math.mat4()),cameraPos,math.vec4(),math.vec3());var length=math.distVec3(cameraPos,currentPos);var radius=Math.tan(Math.PI/500)*length*this._pivotSphereSize;if(this._scene.camera.projection=="ortho"){radius/=this._scene.camera.ortho.scale/2;}worldToRTCPos(currentPos,this._rtcCenter,this._rtcPos);this._pivotSphereGeometry=new VBOGeometry(this._scene,buildSphereGeometry({radius:radius}));this._pivotSphere=new Mesh(this._scene,{geometry:this._pivotSphereGeometry,material:this._pivotSphereMaterial,pickable:false,position:this._rtcPos,rtcCenter:this._rtcCenter});}},{key:"destroyPivotSphere",value:function destroyPivotSphere(){if(this._pivotSphere){this._pivotSphere.destroy();this._pivotSphere=null;}if(this._pivotSphereGeometry){this._pivotSphereGeometry.destroy();this._pivotSphereGeometry=null;}}},{key:"updatePivotElement",value:function updatePivotElement(){var camera=this._scene.camera;var canvas=this._scene.canvas;if(this._pivoting&&this._cameraDirty){math.transformPoint3(camera.viewMatrix,this.getPivotPos(),this._pivotViewPos);this._pivotViewPos[3]=1;math.transformPoint4(camera.projMatrix,this._pivotViewPos,this._pivotProjPos);var canvasAABB=canvas.boundary;var canvasWidth=canvasAABB[2];var canvasHeight=canvasAABB[3];this._pivotCanvasPos[0]=Math.floor((1+this._pivotProjPos[0]/this._pivotProjPos[3])*canvasWidth/2);this._pivotCanvasPos[1]=Math.floor((1-this._pivotProjPos[1]/this._pivotProjPos[3])*canvasHeight/2);// data-textures: avoid to do continuous DOM layout calculations            
var canvasBoundingRect=canvas._lastBoundingClientRect;if(!canvasBoundingRect||canvas._canvasSizeChanged){var canvasElem=canvas.canvas;canvasBoundingRect=canvas._lastBoundingClientRect=canvasElem.getBoundingClientRect();}if(this._pivotElement){this._pivotElement.style.left=Math.floor(canvasBoundingRect.left+this._pivotCanvasPos[0])-this._pivotElement.clientWidth/2+window.scrollX+"px";this._pivotElement.style.top=Math.floor(canvasBoundingRect.top+this._pivotCanvasPos[1])-this._pivotElement.clientHeight/2+window.scrollY+"px";}this._cameraDirty=false;}}},{key:"updatePivotSphere",value:function updatePivotSphere(){if(this._pivoting&&this._pivotSphere){worldToRTCPos(this.getPivotPos(),this._rtcCenter,this._rtcPos);if(!math.compareVec3(this._rtcPos,this._pivotSphere.position)){this.destroyPivotSphere();this.createPivotSphere();}}}/**
     * Sets the HTML DOM element that will represent the pivot position.
     *
     * @param pivotElement
     */},{key:"setPivotElement",value:function setPivotElement(pivotElement){this._pivotElement=pivotElement;}/**
     * Sets a sphere as the representation of the pivot position.
     *
     * @param {Object} [cfg] Sphere configuration.
     * @param {String} [cfg.size=1] Optional size factor of the sphere. Defaults to 1.
     * @param {String} [cfg.color=Array] Optional maretial color. Defaults to a red.
     */},{key:"enablePivotSphere",value:function enablePivotSphere(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.destroyPivotSphere();this._pivotSphereEnabled=true;if(cfg.size){this._pivotSphereSize=cfg.size;}var color=cfg.color||[1,0,0];this._pivotSphereMaterial=new PhongMaterial(this._scene,{emissive:color,ambient:color,specular:[0,0,0],diffuse:[0,0,0]});}/**
     * Remove the sphere as the representation of the pivot position.
     *
     */},{key:"disablePivotSphere",value:function disablePivotSphere(){this.destroyPivotSphere();this._pivotSphereEnabled=false;}/**
     * Begins pivoting.
     */},{key:"startPivot",value:function startPivot(){if(this._cameraLookingDownwards()){this._pivoting=false;return false;}var camera=this._scene.camera;var lookat=math.lookAtMat4v(camera.eye,camera.look,camera.worldUp);math.transformPoint3(lookat,this.getPivotPos(),this._cameraOffset);var pivotPos=this.getPivotPos();this._cameraOffset[2]+=math.distVec3(camera.eye,pivotPos);lookat=math.inverseMat4(lookat);var offset=math.transformVec3(lookat,this._cameraOffset);var diff=math.vec3();math.subVec3(camera.eye,pivotPos,diff);math.addVec3(diff,offset);if(camera.zUp){var t=diff[1];diff[1]=diff[2];diff[2]=t;}this._radius=math.lenVec3(diff);this._polar=Math.acos(diff[1]/this._radius);this._azimuth=Math.atan2(diff[0],diff[2]);this._pivoting=true;}},{key:"_cameraLookingDownwards",value:function _cameraLookingDownwards(){// Returns true if angle between camera viewing direction and World-space "up" axis is too small
var camera=this._scene.camera;var forwardAxis=math.normalizeVec3(math.subVec3(camera.look,camera.eye,tempVec3a$6));var rightAxis=math.cross3Vec3(forwardAxis,camera.worldUp,tempVec3b$3);var rightAxisLen=math.sqLenVec3(rightAxis);return rightAxisLen<=0.0001;}/**
     * Returns true if we are currently pivoting.
     *
     * @returns {Boolean}
     */},{key:"getPivoting",value:function getPivoting(){return this._pivoting;}/**
     * Sets a 3D World-space position to pivot about.
     *
     * @param {Number[]} worldPos The new World-space pivot position.
     */},{key:"setPivotPos",value:function setPivotPos(worldPos){this._pivotWorldPos.set(worldPos);this._pivotPosSet=true;}/**
     * Sets the pivot position to the 3D projection of the given 2D canvas coordinates on a sphere centered
     * at the viewpoint. The radius of the sphere is configured via {@link CameraControl#smartPivot}.
     *
     *
     * @param canvasPos
     */},{key:"setCanvasPivotPos",value:function setCanvasPivotPos(canvasPos){var camera=this._scene.camera;var pivotShereRadius=Math.abs(math.distVec3(this._scene.center,camera.eye));var transposedProjectMat=camera.project.transposedMatrix;var Pt3=transposedProjectMat.subarray(8,12);var Pt4=transposedProjectMat.subarray(12);var D=[0,0,-1.0,1];var screenZ=math.dotVec4(D,Pt3)/math.dotVec4(D,Pt4);var worldPos=tempVec4a$3;camera.project.unproject(canvasPos,screenZ,tempVec4b$3,tempVec4c,worldPos);var eyeWorldPosVec=math.normalizeVec3(math.subVec3(worldPos,camera.eye,tempVec3a$6));var posOnSphere=math.addVec3(camera.eye,math.mulVec3Scalar(eyeWorldPosVec,pivotShereRadius,tempVec3b$3),tempVec3c$2);this.setPivotPos(posOnSphere);}/**
     * Gets the current position we're pivoting about.
     * @returns {Number[]} The current World-space pivot position.
     */},{key:"getPivotPos",value:function getPivotPos(){return this._pivotPosSet?this._pivotWorldPos:this._scene.camera.look;// Avoid pivoting about [0,0,0] by default
}/**
     * Continues to pivot.
     *
     * @param {Number} yawInc Yaw rotation increment.
     * @param {Number} pitchInc Pitch rotation increment.
     */},{key:"continuePivot",value:function continuePivot(yawInc,pitchInc){if(!this._pivoting){return;}if(yawInc===0&&pitchInc===0){return;}var camera=this._scene.camera;var dx=-yawInc;var dy=-pitchInc;if(camera.worldUp[2]===1){dx=-dx;}this._azimuth+=-dx*.01;this._polar+=dy*.01;this._polar=math.clamp(this._polar,.001,Math.PI-.001);var pos=[this._radius*Math.sin(this._polar)*Math.sin(this._azimuth),this._radius*Math.cos(this._polar),this._radius*Math.sin(this._polar)*Math.cos(this._azimuth)];if(camera.worldUp[2]===1){var t=pos[1];pos[1]=pos[2];pos[2]=t;}// Preserve the eye->look distance, since in xeokit "look" is the point-of-interest, not the direction vector.
var eyeLookLen=math.lenVec3(math.subVec3(camera.look,camera.eye,math.vec3()));var pivotPos=this.getPivotPos();math.addVec3(pos,pivotPos);var lookat=math.lookAtMat4v(pos,pivotPos,camera.worldUp);lookat=math.inverseMat4(lookat);var offset=math.transformVec3(lookat,this._cameraOffset);lookat[12]-=offset[0];lookat[13]-=offset[1];lookat[14]-=offset[2];var zAxis=[lookat[8],lookat[9],lookat[10]];camera.eye=[lookat[12],lookat[13],lookat[14]];math.subVec3(camera.eye,math.mulVec3Scalar(zAxis,eyeLookLen),camera.look);camera.up=[lookat[4],lookat[5],lookat[6]];this.showPivot();}/**
     * Shows the pivot position.
     *
     * Only works if we set an  HTML DOM element to represent the pivot position.
     */},{key:"showPivot",value:function showPivot(){if(this._shown){return;}if(this._pivotElement){this.updatePivotElement();this._pivotElement.style.visibility="visible";}if(this._pivotSphereEnabled){this.destroyPivotSphere();this.createPivotSphere();}this._shown=true;}/**
     * Hides the pivot position.
     *
     * Only works if we set an  HTML DOM element to represent the pivot position.
     */},{key:"hidePivot",value:function hidePivot(){if(!this._shown){return;}if(this._pivotElement){this._pivotElement.style.visibility="hidden";}if(this._pivotSphereEnabled){this.destroyPivotSphere();}this._shown=false;}/**
     * Finishes pivoting.
     */},{key:"endPivot",value:function endPivot(){this._pivoting=false;}},{key:"destroy",value:function destroy(){this.destroyPivotSphere();this._scene.camera.off(this._onViewMatrix);this._scene.camera.off(this._onProjMatrix);this._scene.off(this._onTick);}}]);return PivotController;}();/**
 *
 * @private
 */var PickController=/*#__PURE__*/function(){function PickController(cameraControl,configs){_classCallCheck(this,PickController);/**
         * @type {Scene}
         */this._scene=cameraControl.scene;this._cameraControl=cameraControl;this._scene.canvas.canvas.oncontextmenu=function(e){e.preventDefault();};this._configs=configs;/**
         * Set true to schedule picking of an Entity.
         * @type {boolean}
         */this.schedulePickEntity=false;/**
         * Set true to schedule picking of a position on teh surface of an Entity.
         * @type {boolean}
         */this.schedulePickSurface=false;/**
         * Set true to schedule snap-picking with surface picking as a fallback - used for measurement.
         * @type {boolean}
         */this.scheduleSnapOrPick=false;/**
         * The canvas position at which to do the next scheduled pick.
         * @type {Number[]}
         */this.pickCursorPos=math.vec2();/**
         * Will be true after picking to indicate that something was picked.
         * @type {boolean}
         */this.picked=false;/**
         * Will be true after picking to indicate that a position on the surface of an Entity was picked.
         * @type {boolean}
         */this.pickedSurface=false;/**
         * Will hold the PickResult after after picking.
         * @type {PickResult}
         */this.pickResult=null;this._lastPickedEntityId=null;this._lastHash=null;this._needFireEvents=0;}/**
     * Immediately attempts a pick, if scheduled.
     */_createClass(PickController,[{key:"update",value:function update(){if(!this._configs.pointerEnabled){return;}if(!this.schedulePickEntity&&!this.schedulePickSurface){return;}var hash="".concat(~~this.pickCursorPos[0],"-").concat(~~this.pickCursorPos[1],"-").concat(this.scheduleSnapOrPick,"-").concat(this.schedulePickSurface,"-").concat(this.schedulePickEntity);if(this._lastHash===hash){return;}this.picked=false;this.pickedSurface=false;this.snappedOrPicked=false;this.hoveredSnappedOrSurfaceOff=false;var hasHoverSurfaceSubs=this._cameraControl.hasSubs("hoverSurface");if(this.scheduleSnapOrPick){var snapPickResult=this._scene.pick({canvasPos:this.pickCursorPos,snapRadius:this._configs.snapRadius,snapToVertex:this._configs.snapToVertex,snapToEdge:this._configs.snapToEdge});if(snapPickResult&&(snapPickResult.snappedToEdge||snapPickResult.snappedToVertex)){this.snapPickResult=snapPickResult;this.snappedOrPicked=true;this._needFireEvents++;}else{this.schedulePickSurface=true;// Fallback
this.snapPickResult=null;}}if(this.schedulePickSurface){if(this.pickResult&&this.pickResult.worldPos){var pickResultCanvasPos=this.pickResult.canvasPos;if(pickResultCanvasPos[0]===this.pickCursorPos[0]&&pickResultCanvasPos[1]===this.pickCursorPos[1]){this.picked=true;this.pickedSurface=true;this._needFireEvents+=hasHoverSurfaceSubs?1:0;this.schedulePickEntity=false;this.schedulePickSurface=false;if(this.scheduleSnapOrPick){this.snappedOrPicked=true;}else{this.hoveredSnappedOrSurfaceOff=true;}this.scheduleSnapOrPick=false;return;}}}if(this.schedulePickEntity){if(this.pickResult&&(this.pickResult.canvasPos||this.pickResult.snappedCanvasPos)){var _pickResultCanvasPos=this.pickResult.canvasPos||this.pickResult.snappedCanvasPos;if(_pickResultCanvasPos[0]===this.pickCursorPos[0]&&_pickResultCanvasPos[1]===this.pickCursorPos[1]){this.picked=true;this.pickedSurface=false;this.schedulePickEntity=false;this.schedulePickSurface=false;return;}}}if(this.schedulePickSurface||this.scheduleSnapOrPick&&!this.snapPickResult){this.pickResult=this._scene.pick({pickSurface:true,pickSurfaceNormal:false,canvasPos:this.pickCursorPos});if(this.pickResult){this.picked=true;if(this.scheduleSnapOrPick){this.snappedOrPicked=true;}else{this.pickedSurface=true;}this._needFireEvents++;}else if(this.scheduleSnapOrPick){this.hoveredSnappedOrSurfaceOff=true;this._needFireEvents++;}}else{// schedulePickEntity == true
this.pickResult=this._scene.pick({canvasPos:this.pickCursorPos});if(this.pickResult){this.picked=true;this.pickedSurface=false;this._needFireEvents++;}}this.scheduleSnapOrPick=false;this.schedulePickEntity=false;this.schedulePickSurface=false;}},{key:"fireEvents",value:function fireEvents(){if(this._needFireEvents===0){return;}if(this.hoveredSnappedOrSurfaceOff){this._cameraControl.fire("hoverSnapOrSurfaceOff",{canvasPos:this.pickCursorPos,pointerPos:this.pickCursorPos},true);}if(this.snappedOrPicked){if(this.snapPickResult){var pickResult=new PickResult();pickResult.snappedToVertex=this.snapPickResult.snappedToVertex;pickResult.snappedToEdge=this.snapPickResult.snappedToEdge;pickResult.worldPos=this.snapPickResult.worldPos;pickResult.canvasPos=this.pickCursorPos;pickResult.snappedCanvasPos=this.snapPickResult.snappedCanvasPos;this._cameraControl.fire("hoverSnapOrSurface",pickResult,true);this.snapPickResult=null;}else{this._cameraControl.fire("hoverSnapOrSurface",this.pickResult,true);}}if(this.picked&&this.pickResult&&(this.pickResult.entity||this.pickResult.worldPos)){if(this.pickResult.entity){var pickedEntityId=this.pickResult.entity.id;if(this._lastPickedEntityId!==pickedEntityId){if(this._lastPickedEntityId!==undefined){this._cameraControl.fire("hoverOut",{entity:this._scene.objects[this._lastPickedEntityId]},true);}this._cameraControl.fire("hoverEnter",this.pickResult,true);this._lastPickedEntityId=pickedEntityId;}}this._cameraControl.fire("hover",this.pickResult,true);if(this.pickResult.worldPos){this.pickedSurface=true;this._cameraControl.fire("hoverSurface",this.pickResult,true);}}else{if(this._lastPickedEntityId!==undefined){this._cameraControl.fire("hoverOut",{entity:this._scene.objects[this._lastPickedEntityId]},true);this._lastPickedEntityId=undefined;}this._cameraControl.fire("hoverOff",{canvasPos:this.pickCursorPos},true);}this.pickResult=null;this._needFireEvents=0;}}]);return PickController;}();/**
 * @private
 */var canvasPos=math.vec2();var getCanvasPosFromEvent$3=function getCanvasPosFromEvent$3(event,canvasPos){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;var totalScrollX=0;var totalScrollY=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;totalScrollX+=element.scrollLeft;totalScrollY+=element.scrollTop;element=element.offsetParent;}canvasPos[0]=event.pageX+totalScrollX-totalOffsetLeft;canvasPos[1]=event.pageY+totalScrollY-totalOffsetTop;}return canvasPos;};/**
 * @private
 */var MousePanRotateDollyHandler=/*#__PURE__*/function(){function MousePanRotateDollyHandler(scene,controllers,configs,states,updates){_classCallCheck(this,MousePanRotateDollyHandler);this._scene=scene;var pickController=controllers.pickController;var lastX=0;var lastY=0;var lastXDown=0;var lastYDown=0;var mouseDownLeft;var mouseDownMiddle;var mouseDownRight;var mouseDownPicked=false;var pickedWorldPos=math.vec3();var mouseMovedOnCanvasSinceLastWheel=true;var canvas=this._scene.canvas.canvas;var keyDown=[];document.addEventListener("keydown",this._documentKeyDownHandler=function(e){if(!(configs.active&&configs.pointerEnabled)||!scene.input.keyboardEnabled){return;}var keyCode=e.keyCode;keyDown[keyCode]=true;});document.addEventListener("keyup",this._documentKeyUpHandler=function(e){if(!(configs.active&&configs.pointerEnabled)||!scene.input.keyboardEnabled){return;}var keyCode=e.keyCode;keyDown[keyCode]=false;});function setMousedownState(){var pick=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;canvas.style.cursor="move";setMousedownPositions();if(pick){setMousedownPick();}}function setMousedownPositions(){lastX=states.pointerCanvasPos[0];lastY=states.pointerCanvasPos[1];lastXDown=states.pointerCanvasPos[0];lastYDown=states.pointerCanvasPos[1];}function setMousedownPick(){pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickSurface=true;pickController.update();if(pickController.picked&&pickController.pickedSurface&&pickController.pickResult&&pickController.pickResult.worldPos){mouseDownPicked=true;pickedWorldPos.set(pickController.pickResult.worldPos);}else{mouseDownPicked=false;}}canvas.addEventListener("mousedown",this._mouseDownHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}switch(e.which){case 1:// Left button
if(keyDown[scene.input.KEY_SHIFT]||configs.planView){mouseDownLeft=true;setMousedownState();}else{mouseDownLeft=true;setMousedownState(false);}break;case 2:// Middle/both buttons
mouseDownMiddle=true;setMousedownState();break;case 3:// Right button
mouseDownRight=true;if(configs.panRightClick){setMousedownState();}break;}});document.addEventListener("mousemove",this._documentMouseMoveHandler=function(){if(!(configs.active&&configs.pointerEnabled)){return;}if(!mouseDownLeft&&!mouseDownMiddle&&!mouseDownRight){return;}// Scaling drag-rotate to canvas boundary
var canvasBoundary=scene.canvas.boundary;var canvasWidth=canvasBoundary[2];var canvasHeight=canvasBoundary[3];var x=states.pointerCanvasPos[0];var y=states.pointerCanvasPos[1];var panning=keyDown[scene.input.KEY_SHIFT]||configs.planView||!configs.panRightClick&&mouseDownMiddle||configs.panRightClick&&mouseDownRight;if(panning){var xPanDelta=x-lastX;var yPanDelta=y-lastY;var camera=scene.camera;// We use only canvasHeight here so that aspect ratio does not distort speed
if(camera.projection==="perspective"){var depth=Math.abs(mouseDownPicked?math.lenVec3(math.subVec3(pickedWorldPos,scene.camera.eye,[])):scene.camera.eyeLookDist);var targetDistance=depth*Math.tan(camera.perspective.fov/2*Math.PI/180.0);updates.panDeltaX+=1.5*xPanDelta*targetDistance/canvasHeight;updates.panDeltaY+=1.5*yPanDelta*targetDistance/canvasHeight;}else{updates.panDeltaX+=0.5*camera.ortho.scale*(xPanDelta/canvasHeight);updates.panDeltaY+=0.5*camera.ortho.scale*(yPanDelta/canvasHeight);}}else if(mouseDownLeft&&!mouseDownMiddle&&!mouseDownRight){if(!configs.planView){// No rotating in plan-view mode
if(configs.firstPerson){updates.rotateDeltaY-=(x-lastX)/canvasWidth*configs.dragRotationRate/2;updates.rotateDeltaX+=(y-lastY)/canvasHeight*(configs.dragRotationRate/4);}else{updates.rotateDeltaY-=(x-lastX)/canvasWidth*(configs.dragRotationRate*1.5);updates.rotateDeltaX+=(y-lastY)/canvasHeight*(configs.dragRotationRate*1.5);}}}lastX=x;lastY=y;});canvas.addEventListener("mousemove",this._canvasMouseMoveHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}if(!states.mouseover){return;}mouseMovedOnCanvasSinceLastWheel=true;});document.addEventListener("mouseup",this._documentMouseUpHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}switch(e.which){case 1:// Left button
mouseDownLeft=false;mouseDownMiddle=false;mouseDownRight=false;break;case 2:// Middle/both buttons
mouseDownLeft=false;mouseDownMiddle=false;mouseDownRight=false;break;case 3:// Right button
mouseDownLeft=false;mouseDownMiddle=false;mouseDownRight=false;break;}});canvas.addEventListener("mouseup",this._mouseUpHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}switch(e.which){case 3:// Right button
getCanvasPosFromEvent$3(e,canvasPos);var x=canvasPos[0];var y=canvasPos[1];if(Math.abs(x-lastXDown)<3&&Math.abs(y-lastYDown)<3){controllers.cameraControl.fire("rightClick",{// For context menus
pagePos:[Math.round(e.pageX),Math.round(e.pageY)],canvasPos:canvasPos,event:e},true);}break;}canvas.style.removeProperty("cursor");});canvas.addEventListener("mouseenter",this._mouseEnterHandler=function(){if(!(configs.active&&configs.pointerEnabled)){return;}});var maxElapsed=1/20;var minElapsed=1/60;var secsNowLast=null;canvas.addEventListener("wheel",this._mouseWheelHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}var secsNow=performance.now()/1000.0;var secsElapsed=secsNowLast!==null?secsNow-secsNowLast:0;secsNowLast=secsNow;if(secsElapsed>maxElapsed){secsElapsed=maxElapsed;}if(secsElapsed<minElapsed){secsElapsed=minElapsed;}var delta=Math.max(-1,Math.min(1,-e.deltaY*40));if(delta===0){return;}var normalizedDelta=delta/Math.abs(delta);updates.dollyDelta+=-normalizedDelta*secsElapsed*configs.mouseWheelDollyRate;if(mouseMovedOnCanvasSinceLastWheel){states.followPointerDirty=true;mouseMovedOnCanvasSinceLastWheel=false;}},{passive:true});}_createClass(MousePanRotateDollyHandler,[{key:"reset",value:function reset(){}},{key:"destroy",value:function destroy(){var canvas=this._scene.canvas.canvas;document.removeEventListener("keydown",this._documentKeyDownHandler);document.removeEventListener("keyup",this._documentKeyUpHandler);canvas.removeEventListener("mousedown",this._mouseDownHandler);document.removeEventListener("mousemove",this._documentMouseMoveHandler);canvas.removeEventListener("mousemove",this._canvasMouseMoveHandler);document.removeEventListener("mouseup",this._documentMouseUpHandler);canvas.removeEventListener("mouseup",this._mouseUpHandler);canvas.removeEventListener("mouseenter",this._mouseEnterHandler);canvas.removeEventListener("wheel",this._mouseWheelHandler);}}]);return MousePanRotateDollyHandler;}();var center=math.vec3();var tempVec3a$5=math.vec3();var tempVec3b$2=math.vec3();var tempVec3c$1=math.vec3();var tempVec3d=math.vec3();var tempCameraTarget={eye:math.vec3(),look:math.vec3(),up:math.vec3()};/**
 * @private
 */var KeyboardAxisViewHandler=/*#__PURE__*/function(){function KeyboardAxisViewHandler(scene,controllers,configs,states){_classCallCheck(this,KeyboardAxisViewHandler);this._scene=scene;var cameraControl=controllers.cameraControl;var camera=scene.camera;this._onSceneKeyDown=scene.input.on("keydown",function(){if(!(configs.active&&configs.pointerEnabled)||!scene.input.keyboardEnabled){return;}if(!states.mouseover){return;}var axisViewRight=cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_RIGHT);var axisViewBack=cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_BACK);var axisViewLeft=cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_LEFT);var axisViewFront=cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_FRONT);var axisViewTop=cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_TOP);var axisViewBottom=cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_BOTTOM);if(!axisViewRight&&!axisViewBack&&!axisViewLeft&&!axisViewFront&&!axisViewTop&&!axisViewBottom){return;}var aabb=scene.aabb;var diag=math.getAABB3Diag(aabb);math.getAABB3Center(aabb,center);var perspectiveDist=Math.abs(diag/Math.tan(controllers.cameraFlight.fitFOV*math.DEGTORAD));var orthoScale=diag*1.1;tempCameraTarget.orthoScale=orthoScale;if(axisViewRight){tempCameraTarget.eye.set(math.addVec3(center,math.mulVec3Scalar(camera.worldRight,perspectiveDist,tempVec3a$5),tempVec3d));tempCameraTarget.look.set(center);tempCameraTarget.up.set(camera.worldUp);}else if(axisViewBack){tempCameraTarget.eye.set(math.addVec3(center,math.mulVec3Scalar(camera.worldForward,perspectiveDist,tempVec3a$5),tempVec3d));tempCameraTarget.look.set(center);tempCameraTarget.up.set(camera.worldUp);}else if(axisViewLeft){tempCameraTarget.eye.set(math.addVec3(center,math.mulVec3Scalar(camera.worldRight,-perspectiveDist,tempVec3a$5),tempVec3d));tempCameraTarget.look.set(center);tempCameraTarget.up.set(camera.worldUp);}else if(axisViewFront){tempCameraTarget.eye.set(math.addVec3(center,math.mulVec3Scalar(camera.worldForward,-perspectiveDist,tempVec3a$5),tempVec3d));tempCameraTarget.look.set(center);tempCameraTarget.up.set(camera.worldUp);}else if(axisViewTop){tempCameraTarget.eye.set(math.addVec3(center,math.mulVec3Scalar(camera.worldUp,perspectiveDist,tempVec3a$5),tempVec3d));tempCameraTarget.look.set(center);tempCameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward,1,tempVec3b$2),tempVec3c$1));}else if(axisViewBottom){tempCameraTarget.eye.set(math.addVec3(center,math.mulVec3Scalar(camera.worldUp,-perspectiveDist,tempVec3a$5),tempVec3d));tempCameraTarget.look.set(center);tempCameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward,-1,tempVec3b$2)));}if(!configs.firstPerson&&configs.followPointer){controllers.pivotController.setPivotPos(center);}if(controllers.cameraFlight.duration>0){controllers.cameraFlight.flyTo(tempCameraTarget,function(){if(controllers.pivotController.getPivoting()&&configs.followPointer){controllers.pivotController.showPivot();}});}else{controllers.cameraFlight.jumpTo(tempCameraTarget);if(controllers.pivotController.getPivoting()&&configs.followPointer){controllers.pivotController.showPivot();}}});}_createClass(KeyboardAxisViewHandler,[{key:"reset",value:function reset(){}},{key:"destroy",value:function destroy(){this._scene.input.off(this._onSceneKeyDown);}}]);return KeyboardAxisViewHandler;}();/**
 * @private
 */var MousePickHandler=/*#__PURE__*/function(){function MousePickHandler(scene,controllers,configs,states,updates){var _this104=this;_classCallCheck(this,MousePickHandler);this._scene=scene;var pickController=controllers.pickController;var pivotController=controllers.pivotController;var cameraControl=controllers.cameraControl;this._clicks=0;this._timeout=null;this._lastPickedEntityId=null;var leftDown=false;var rightDown=false;var canvas=this._scene.canvas.canvas;var flyCameraTo=function flyCameraTo(pickResult){var pos;if(pickResult&&pickResult.worldPos){pos=pickResult.worldPos;}var aabb=pickResult&&pickResult.entity?pickResult.entity.aabb:scene.aabb;if(pos){// Fly to look at point, don't change eye->look dist
var camera=scene.camera;math.subVec3(camera.eye,camera.look,[]);controllers.cameraFlight.flyTo({// look: pos,
// eye: xeokit.math.addVec3(pos, diff, []),
// up: camera.up,
aabb:aabb});// TODO: Option to back off to fit AABB in view
}else{// Fly to fit target boundary in view
controllers.cameraFlight.flyTo({aabb:aabb});}};var tickifiedMouseMoveFn=scene.tickify(this._canvasMouseMoveHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}if(leftDown||rightDown){return;}var hoverSubs=cameraControl.hasSubs("hover");var hoverEnterSubs=cameraControl.hasSubs("hoverEnter");var hoverOutSubs=cameraControl.hasSubs("hoverOut");var hoverOffSubs=cameraControl.hasSubs("hoverOff");var hoverSurfaceSubs=cameraControl.hasSubs("hoverSurface");var hoverSnapOrSurfaceSubs=cameraControl.hasSubs("hoverSnapOrSurface");if(hoverSubs||hoverEnterSubs||hoverOutSubs||hoverOffSubs||hoverSurfaceSubs||hoverSnapOrSurfaceSubs){pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickEntity=true;pickController.schedulePickSurface=hoverSurfaceSubs;pickController.scheduleSnapOrPick=hoverSnapOrSurfaceSubs;pickController.update();if(pickController.pickResult){if(pickController.pickResult.entity){var pickedEntityId=pickController.pickResult.entity.id;if(_this104._lastPickedEntityId!==pickedEntityId){if(_this104._lastPickedEntityId!==undefined){cameraControl.fire("hoverOut",{// Hovered off an entity
entity:scene.objects[_this104._lastPickedEntityId]},true);}cameraControl.fire("hoverEnter",pickController.pickResult,true);// Hovering over a new entity
_this104._lastPickedEntityId=pickedEntityId;}}cameraControl.fire("hover",pickController.pickResult,true);if(pickController.pickResult.worldPos||pickController.pickResult.snappedWorldPos){// Hovering the surface of an entity
cameraControl.fire("hoverSurface",pickController.pickResult,true);}}else{if(_this104._lastPickedEntityId!==undefined){cameraControl.fire("hoverOut",{// Hovered off an entity
entity:scene.objects[_this104._lastPickedEntityId]},true);_this104._lastPickedEntityId=undefined;}cameraControl.fire("hoverOff",{// Not hovering on any entity
canvasPos:pickController.pickCursorPos},true);}}});canvas.addEventListener("mousemove",tickifiedMouseMoveFn);canvas.addEventListener('mousedown',this._canvasMouseDownHandler=function(e){if(e.which===1){leftDown=true;}if(e.which===3){rightDown=true;}var leftButtonDown=e.which===1;if(!leftButtonDown){return;}if(!(configs.active&&configs.pointerEnabled)){return;}// Left mouse button down to start pivoting
states.mouseDownClientX=e.clientX;states.mouseDownClientY=e.clientY;states.mouseDownCursorX=states.pointerCanvasPos[0];states.mouseDownCursorY=states.pointerCanvasPos[1];if(!configs.firstPerson&&configs.followPointer){pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickSurface=true;pickController.update();if(e.which===1){// Left button
var pickResult=pickController.pickResult;if(pickResult&&pickResult.worldPos){pivotController.setPivotPos(pickResult.worldPos);pivotController.startPivot();}else{if(configs.smartPivot){pivotController.setCanvasPivotPos(states.pointerCanvasPos);}else{pivotController.setPivotPos(scene.camera.look);}pivotController.startPivot();}}}});document.addEventListener('mouseup',this._documentMouseUpHandler=function(e){if(e.which===1){leftDown=false;}if(e.which===3){rightDown=false;}if(pivotController.getPivoting()){pivotController.endPivot();}});canvas.addEventListener('mouseup',this._canvasMouseUpHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}var leftButtonUp=e.which===1;if(!leftButtonUp){return;}// Left mouse button up to possibly pick or double-pick
pivotController.hidePivot();if(Math.abs(e.clientX-states.mouseDownClientX)>3||Math.abs(e.clientY-states.mouseDownClientY)>3){return;}var pickedSubs=cameraControl.hasSubs("picked");var pickedNothingSubs=cameraControl.hasSubs("pickedNothing");var pickedSurfaceSubs=cameraControl.hasSubs("pickedSurface");var doublePickedSubs=cameraControl.hasSubs("doublePicked");var doublePickedSurfaceSubs=cameraControl.hasSubs("doublePickedSurface");var doublePickedNothingSubs=cameraControl.hasSubs("doublePickedNothing");if(!configs.doublePickFlyTo&&!doublePickedSubs&&!doublePickedSurfaceSubs&&!doublePickedNothingSubs){//  Avoid the single/double click differentiation timeout
if(pickedSubs||pickedNothingSubs||pickedSurfaceSubs){pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickEntity=true;pickController.schedulePickSurface=pickedSurfaceSubs;pickController.update();if(pickController.pickResult){cameraControl.fire("picked",pickController.pickResult,true);if(pickController.pickedSurface){cameraControl.fire("pickedSurface",pickController.pickResult,true);}}else{cameraControl.fire("pickedNothing",{canvasPos:states.pointerCanvasPos},true);}}_this104._clicks=0;return;}_this104._clicks++;if(_this104._clicks===1){// First click
pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickEntity=configs.doublePickFlyTo;pickController.schedulePickSurface=pickedSurfaceSubs;pickController.update();var firstClickPickResult=pickController.pickResult;var firstClickPickSurface=pickController.pickedSurface;_this104._timeout=setTimeout(function(){if(firstClickPickResult){cameraControl.fire("picked",firstClickPickResult,true);if(firstClickPickSurface){cameraControl.fire("pickedSurface",firstClickPickResult,true);if(!configs.firstPerson&&configs.followPointer){controllers.pivotController.setPivotPos(firstClickPickResult.worldPos);if(controllers.pivotController.startPivot()){controllers.pivotController.showPivot();}}}}else{cameraControl.fire("pickedNothing",{canvasPos:states.pointerCanvasPos},true);}_this104._clicks=0;},configs.doubleClickTimeFrame);}else{// Second click
if(_this104._timeout!==null){window.clearTimeout(_this104._timeout);_this104._timeout=null;}pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickEntity=configs.doublePickFlyTo||doublePickedSubs||doublePickedSurfaceSubs;pickController.schedulePickSurface=pickController.schedulePickEntity&&doublePickedSurfaceSubs;pickController.update();if(pickController.pickResult){cameraControl.fire("doublePicked",pickController.pickResult,true);if(pickController.pickedSurface){cameraControl.fire("doublePickedSurface",pickController.pickResult,true);}if(configs.doublePickFlyTo){flyCameraTo(pickController.pickResult);if(!configs.firstPerson&&configs.followPointer){var pickedEntityAABB=pickController.pickResult.entity.aabb;var pickedEntityCenterPos=math.getAABB3Center(pickedEntityAABB);controllers.pivotController.setPivotPos(pickedEntityCenterPos);if(controllers.pivotController.startPivot()){controllers.pivotController.showPivot();}}}}else{cameraControl.fire("doublePickedNothing",{canvasPos:states.pointerCanvasPos},true);if(configs.doublePickFlyTo){flyCameraTo();if(!configs.firstPerson&&configs.followPointer){var sceneAABB=scene.aabb;var sceneCenterPos=math.getAABB3Center(sceneAABB);controllers.pivotController.setPivotPos(sceneCenterPos);if(controllers.pivotController.startPivot()){controllers.pivotController.showPivot();}}}}_this104._clicks=0;}},false);}_createClass(MousePickHandler,[{key:"reset",value:function reset(){this._clicks=0;this._lastPickedEntityId=null;if(this._timeout){window.clearTimeout(this._timeout);this._timeout=null;}}},{key:"destroy",value:function destroy(){var canvas=this._scene.canvas.canvas;canvas.removeEventListener("mousemove",this._canvasMouseMoveHandler);canvas.removeEventListener("mousedown",this._canvasMouseDownHandler);document.removeEventListener("mouseup",this._documentMouseUpHandler);canvas.removeEventListener("mouseup",this._canvasMouseUpHandler);if(this._timeout){window.clearTimeout(this._timeout);this._timeout=null;}}}]);return MousePickHandler;}();/**
 * @private
 */var KeyboardPanRotateDollyHandler=/*#__PURE__*/function(){function KeyboardPanRotateDollyHandler(scene,controllers,configs,states,updates){_classCallCheck(this,KeyboardPanRotateDollyHandler);this._scene=scene;var input=scene.input;var keyDownMap=[];var canvas=scene.canvas.canvas;var mouseMovedSinceLastKeyboardDolly=true;this._onSceneMouseMove=input.on("mousemove",function(){mouseMovedSinceLastKeyboardDolly=true;});this._onSceneKeyDown=input.on("keydown",function(keyCode){if(!(configs.active&&configs.pointerEnabled)||!scene.input.keyboardEnabled){return;}if(!states.mouseover){return;}keyDownMap[keyCode]=true;if(keyCode===input.KEY_SHIFT){canvas.style.cursor="move";}});this._onSceneKeyUp=input.on("keyup",function(keyCode){if(!(configs.active&&configs.pointerEnabled)||!scene.input.keyboardEnabled){return;}keyDownMap[keyCode]=false;if(keyCode===input.KEY_SHIFT){canvas.style.cursor=null;}if(controllers.pivotController.getPivoting()){controllers.pivotController.endPivot();}});this._onTick=scene.on("tick",function(e){if(!(configs.active&&configs.pointerEnabled)||!scene.input.keyboardEnabled){return;}if(!states.mouseover){return;}var cameraControl=controllers.cameraControl;var elapsedSecs=e.deltaTime/1000.0;//-------------------------------------------------------------------------------------------------
// Keyboard rotation
//-------------------------------------------------------------------------------------------------
if(!configs.planView){var rotateYPos=cameraControl._isKeyDownForAction(cameraControl.ROTATE_Y_POS,keyDownMap);var rotateYNeg=cameraControl._isKeyDownForAction(cameraControl.ROTATE_Y_NEG,keyDownMap);var rotateXPos=cameraControl._isKeyDownForAction(cameraControl.ROTATE_X_POS,keyDownMap);var rotateXNeg=cameraControl._isKeyDownForAction(cameraControl.ROTATE_X_NEG,keyDownMap);var orbitDelta=elapsedSecs*configs.keyboardRotationRate;if(rotateYPos||rotateYNeg||rotateXPos||rotateXNeg){if(!configs.firstPerson&&configs.followPointer){controllers.pivotController.startPivot();}if(rotateYPos){updates.rotateDeltaY+=orbitDelta;}else if(rotateYNeg){updates.rotateDeltaY-=orbitDelta;}if(rotateXPos){updates.rotateDeltaX+=orbitDelta;}else if(rotateXNeg){updates.rotateDeltaX-=orbitDelta;}if(!configs.firstPerson&&configs.followPointer){controllers.pivotController.startPivot();}}}//-------------------------------------------------------------------------------------------------
// Keyboard panning
//-------------------------------------------------------------------------------------------------
if(!keyDownMap[input.KEY_CTRL]&&!keyDownMap[input.KEY_ALT]){var dollyBackwards=cameraControl._isKeyDownForAction(cameraControl.DOLLY_BACKWARDS,keyDownMap);var dollyForwards=cameraControl._isKeyDownForAction(cameraControl.DOLLY_FORWARDS,keyDownMap);if(dollyBackwards||dollyForwards){var dollyDelta=elapsedSecs*configs.keyboardDollyRate;if(!configs.firstPerson&&configs.followPointer){controllers.pivotController.startPivot();}if(dollyForwards){updates.dollyDelta-=dollyDelta;}else if(dollyBackwards){updates.dollyDelta+=dollyDelta;}if(mouseMovedSinceLastKeyboardDolly){states.followPointerDirty=true;mouseMovedSinceLastKeyboardDolly=false;}}}var panForwards=cameraControl._isKeyDownForAction(cameraControl.PAN_FORWARDS,keyDownMap);var panBackwards=cameraControl._isKeyDownForAction(cameraControl.PAN_BACKWARDS,keyDownMap);var panLeft=cameraControl._isKeyDownForAction(cameraControl.PAN_LEFT,keyDownMap);var panRight=cameraControl._isKeyDownForAction(cameraControl.PAN_RIGHT,keyDownMap);var panUp=cameraControl._isKeyDownForAction(cameraControl.PAN_UP,keyDownMap);var panDown=cameraControl._isKeyDownForAction(cameraControl.PAN_DOWN,keyDownMap);var panDelta=(keyDownMap[input.KEY_ALT]?0.3:1.0)*elapsedSecs*configs.keyboardPanRate;// ALT for slower pan rate
if(panForwards||panBackwards||panLeft||panRight||panUp||panDown){if(!configs.firstPerson&&configs.followPointer){controllers.pivotController.startPivot();}if(panDown){updates.panDeltaY+=panDelta;}else if(panUp){updates.panDeltaY+=-panDelta;}if(panRight){updates.panDeltaX+=-panDelta;}else if(panLeft){updates.panDeltaX+=panDelta;}if(panBackwards){updates.panDeltaZ+=panDelta;}else if(panForwards){updates.panDeltaZ+=-panDelta;}}});}_createClass(KeyboardPanRotateDollyHandler,[{key:"reset",value:function reset(){}},{key:"destroy",value:function destroy(){this._scene.off(this._onTick);this._scene.input.off(this._onSceneMouseMove);this._scene.input.off(this._onSceneKeyDown);this._scene.input.off(this._onSceneKeyUp);}}]);return KeyboardPanRotateDollyHandler;}();var SCALE_DOLLY_EACH_FRAME=1;// Recalculate dolly speed for eye->target distance on each Nth frame
var EPSILON=0.001;var tempVec3$2=math.vec3();/**
 * Handles camera updates on each "tick" that were scheduled by the various controllers.
 *
 * @private
 */var CameraUpdater=/*#__PURE__*/function(){function CameraUpdater(scene,controllers,configs,states,updates){_classCallCheck(this,CameraUpdater);this._scene=scene;var camera=scene.camera;var pickController=controllers.pickController;var pivotController=controllers.pivotController;var panController=controllers.panController;var countDown=SCALE_DOLLY_EACH_FRAME;// Decrements on each tick
var dollyDistFactor=1.0;// Calculated when countDown is zero
var followPointerWorldPos=null;// Holds the pointer's World position when configs.followPointer is true
this._onTick=scene.on("tick",function(){if(!(configs.active&&configs.pointerEnabled)){return;}var cursorType="default";//----------------------------------------------------------------------------------------------------------
// Dolly decay
//------------------------------------------------------------------------------------  ----------------------
if(Math.abs(updates.dollyDelta)<EPSILON){updates.dollyDelta=0;}//----------------------------------------------------------------------------------------------------------
// Rotation decay
//----------------------------------------------------------------------------------------------------------
if(Math.abs(updates.rotateDeltaX)<EPSILON){updates.rotateDeltaX=0;}if(Math.abs(updates.rotateDeltaY)<EPSILON){updates.rotateDeltaY=0;}if(updates.rotateDeltaX!==0||updates.rotateDeltaY!==0){updates.dollyDelta=0;}//----------------------------------------------------------------------------------------------------------
// Dolly speed eye->look scaling
//
// If pointer is over an object, then dolly speed is proportional to the distance to that object.
//
// If pointer is not over an object, then dolly speed is proportional to the distance to the last
// object the pointer was over. This is so that we can dolly to structures that may have gaps through
// which empty background shows, that the pointer may inadvertently be over. In these cases, we don't
// want dolly speed wildly varying depending on how accurately the user avoids the gaps with the pointer.
//----------------------------------------------------------------------------------------------------------
if(configs.followPointer){if(--countDown<=0){countDown=SCALE_DOLLY_EACH_FRAME;if(updates.dollyDelta!==0){if(updates.rotateDeltaY===0&&updates.rotateDeltaX===0){if(configs.followPointer&&states.followPointerDirty){pickController.pickCursorPos=states.pointerCanvasPos;pickController.schedulePickSurface=true;pickController.update();if(pickController.pickResult&&pickController.pickResult.worldPos){followPointerWorldPos=pickController.pickResult.worldPos;}else{dollyDistFactor=1.0;followPointerWorldPos=null;}states.followPointerDirty=false;}}if(followPointerWorldPos){var dist=Math.abs(math.lenVec3(math.subVec3(followPointerWorldPos,scene.camera.eye,tempVec3$2)));dollyDistFactor=dist/configs.dollyProximityThreshold;}if(dollyDistFactor<configs.dollyMinSpeed){dollyDistFactor=configs.dollyMinSpeed;}}}}else{dollyDistFactor=1;followPointerWorldPos=null;}var dollyDeltaForDist=updates.dollyDelta*dollyDistFactor;//----------------------------------------------------------------------------------------------------------
// Rotation
//----------------------------------------------------------------------------------------------------------
if(updates.rotateDeltaY!==0||updates.rotateDeltaX!==0){if(!configs.firstPerson&&configs.followPointer&&pivotController.getPivoting()){pivotController.continuePivot(updates.rotateDeltaY,updates.rotateDeltaX);pivotController.showPivot();}else{if(updates.rotateDeltaX!==0){if(configs.firstPerson){camera.pitch(-updates.rotateDeltaX);}else{camera.orbitPitch(updates.rotateDeltaX);}}if(updates.rotateDeltaY!==0){if(configs.firstPerson){camera.yaw(updates.rotateDeltaY);}else{camera.orbitYaw(updates.rotateDeltaY);}}}updates.rotateDeltaX*=configs.rotationInertia;updates.rotateDeltaY*=configs.rotationInertia;cursorType="grabbing";}//----------------------------------------------------------------------------------------------------------
// Panning
//----------------------------------------------------------------------------------------------------------
if(Math.abs(updates.panDeltaX)<EPSILON){updates.panDeltaX=0;}if(Math.abs(updates.panDeltaY)<EPSILON){updates.panDeltaY=0;}if(Math.abs(updates.panDeltaZ)<EPSILON){updates.panDeltaZ=0;}if(updates.panDeltaX!==0||updates.panDeltaY!==0||updates.panDeltaZ!==0){var vec=math.vec3();vec[0]=updates.panDeltaX;vec[1]=updates.panDeltaY;vec[2]=updates.panDeltaZ;var verticalEye;var verticalLook;if(configs.constrainVertical){if(camera.xUp){verticalEye=camera.eye[0];verticalLook=camera.look[0];}else if(camera.yUp){verticalEye=camera.eye[1];verticalLook=camera.look[1];}else if(camera.zUp){verticalEye=camera.eye[2];verticalLook=camera.look[2];}camera.pan(vec);var eye=camera.eye;var look=camera.look;if(camera.xUp){eye[0]=verticalEye;look[0]=verticalLook;}else if(camera.yUp){eye[1]=verticalEye;look[1]=verticalLook;}else if(camera.zUp){eye[2]=verticalEye;look[2]=verticalLook;}camera.eye=eye;camera.look=look;}else{camera.pan(vec);}cursorType="grabbing";}updates.panDeltaX*=configs.panInertia;updates.panDeltaY*=configs.panInertia;updates.panDeltaZ*=configs.panInertia;//----------------------------------------------------------------------------------------------------------
// Dollying
//----------------------------------------------------------------------------------------------------------
if(dollyDeltaForDist!==0){if(dollyDeltaForDist<0){cursorType="zoom-in";}else{cursorType="zoom-out";}if(configs.firstPerson){var _verticalEye;var _verticalLook;if(configs.constrainVertical){if(camera.xUp){_verticalEye=camera.eye[0];_verticalLook=camera.look[0];}else if(camera.yUp){_verticalEye=camera.eye[1];_verticalLook=camera.look[1];}else if(camera.zUp){_verticalEye=camera.eye[2];_verticalLook=camera.look[2];}}if(configs.followPointer){var dolliedThroughSurface=panController.dollyToCanvasPos(followPointerWorldPos,states.pointerCanvasPos,-dollyDeltaForDist);if(dolliedThroughSurface){states.followPointerDirty=true;}}else{camera.pan([0,0,dollyDeltaForDist]);camera.ortho.scale=camera.ortho.scale-dollyDeltaForDist;}if(configs.constrainVertical){var _eye=camera.eye;var _look=camera.look;if(camera.xUp){_eye[0]=_verticalEye;_look[0]=_verticalLook;}else if(camera.yUp){_eye[1]=_verticalEye;_look[1]=_verticalLook;}else if(camera.zUp){_eye[2]=_verticalEye;_look[2]=_verticalLook;}camera.eye=_eye;camera.look=_look;}}else if(configs.planView){if(configs.followPointer){var _dolliedThroughSurface=panController.dollyToCanvasPos(followPointerWorldPos,states.pointerCanvasPos,-dollyDeltaForDist);if(_dolliedThroughSurface){states.followPointerDirty=true;}}else{camera.ortho.scale=camera.ortho.scale+dollyDeltaForDist;camera.zoom(dollyDeltaForDist);}}else{// Orbiting
if(configs.followPointer){var _dolliedThroughSurface2=panController.dollyToCanvasPos(followPointerWorldPos,states.pointerCanvasPos,-dollyDeltaForDist);if(_dolliedThroughSurface2){states.followPointerDirty=true;}}else{camera.ortho.scale=camera.ortho.scale+dollyDeltaForDist;camera.zoom(dollyDeltaForDist);}}updates.dollyDelta*=configs.dollyInertia;}pickController.fireEvents();document.body.style.cursor=cursorType;});}_createClass(CameraUpdater,[{key:"destroy",value:function destroy(){this._scene.off(this._onTick);}}]);return CameraUpdater;}();/**
 * @private
 */var MouseMiscHandler=/*#__PURE__*/function(){function MouseMiscHandler(scene,controllers,configs,states,updates){_classCallCheck(this,MouseMiscHandler);this._scene=scene;var canvas=this._scene.canvas.canvas;canvas.addEventListener("mouseenter",this._mouseEnterHandler=function(){states.mouseover=true;});canvas.addEventListener("mouseleave",this._mouseLeaveHandler=function(){states.mouseover=false;canvas.style.cursor=null;});document.addEventListener("mousemove",this._mouseMoveHandler=function(e){getCanvasPosFromEvent$2(e,canvas,states.pointerCanvasPos);});canvas.addEventListener("mousedown",this._mouseDownHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}getCanvasPosFromEvent$2(e,canvas,states.pointerCanvasPos);states.mouseover=true;});canvas.addEventListener("mouseup",this._mouseUpHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}});}_createClass(MouseMiscHandler,[{key:"reset",value:function reset(){}},{key:"destroy",value:function destroy(){var canvas=this._scene.canvas.canvas;document.removeEventListener("mousemove",this._mouseMoveHandler);canvas.removeEventListener("mouseenter",this._mouseEnterHandler);canvas.removeEventListener("mouseleave",this._mouseLeaveHandler);canvas.removeEventListener("mousedown",this._mouseDownHandler);canvas.removeEventListener("mouseup",this._mouseUpHandler);}}]);return MouseMiscHandler;}();function getCanvasPosFromEvent$2(event,canvas,canvasPos){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y;}else{var _canvas$getBoundingCl=canvas.getBoundingClientRect(),left=_canvas$getBoundingCl.left,top=_canvas$getBoundingCl.top;canvasPos[0]=event.clientX-left-window.scrollX;canvasPos[1]=event.clientY-top-window.scrollY;}return canvasPos;}var getCanvasPosFromEvent$1=function getCanvasPosFromEvent$1(event,canvasPos){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent;}canvasPos[0]=event.pageX-totalOffsetLeft;canvasPos[1]=event.pageY-totalOffsetTop;}return canvasPos;};/**
 * @private
 */var TouchPanRotateAndDollyHandler=/*#__PURE__*/function(){function TouchPanRotateAndDollyHandler(scene,controllers,configs,states,updates){_classCallCheck(this,TouchPanRotateAndDollyHandler);this._scene=scene;var pickController=controllers.pickController;var pivotController=controllers.pivotController;var tapStartCanvasPos=math.vec2();var tapCanvasPos0=math.vec2();var tapCanvasPos1=math.vec2();var touch0Vec=math.vec2();var lastCanvasTouchPosList=[];var canvas=this._scene.canvas.canvas;var numTouches=0;var waitForTick=false;this._onTick=scene.on("tick",function(){waitForTick=false;});canvas.addEventListener("touchstart",this._canvasTouchStartHandler=function(event){if(!(configs.active&&configs.pointerEnabled)){return;}event.preventDefault();var touches=event.touches;var changedTouches=event.changedTouches;states.touchStartTime=Date.now();if(touches.length===1&&changedTouches.length===1){getCanvasPosFromEvent$1(touches[0],tapStartCanvasPos);if(configs.followPointer){pickController.pickCursorPos=tapStartCanvasPos;pickController.schedulePickSurface=true;pickController.update();if(!configs.planView){if(pickController.picked&&pickController.pickedSurface&&pickController.pickResult&&pickController.pickResult.worldPos){pivotController.setPivotPos(pickController.pickResult.worldPos);if(!configs.firstPerson&&pivotController.startPivot()){pivotController.showPivot();}}else{if(configs.smartPivot){pivotController.setCanvasPivotPos(states.pointerCanvasPos);}else{pivotController.setPivotPos(scene.camera.look);}if(!configs.firstPerson&&pivotController.startPivot()){pivotController.showPivot();}}}}}while(lastCanvasTouchPosList.length<touches.length){lastCanvasTouchPosList.push(math.vec2());}for(var _i463=0,len=touches.length;_i463<len;++_i463){getCanvasPosFromEvent$1(touches[_i463],lastCanvasTouchPosList[_i463]);}numTouches=touches.length;});canvas.addEventListener("touchend",this._canvasTouchEndHandler=function(){if(pivotController.getPivoting()){pivotController.endPivot();}});canvas.addEventListener("touchmove",this._canvasTouchMoveHandler=function(event){if(!(configs.active&&configs.pointerEnabled)){return;}event.stopPropagation();event.preventDefault();if(waitForTick){// Limit changes detection to one per frame
return;}waitForTick=true;// Scaling drag-rotate to canvas boundary
var canvasBoundary=scene.canvas.boundary;var canvasWidth=canvasBoundary[2];var canvasHeight=canvasBoundary[3];var touches=event.touches;if(event.touches.length!==numTouches){// Two fingers were pressed, then one of them is removed
// We don't want to rotate in this case (weird behavior)
return;}if(numTouches===1){getCanvasPosFromEvent$1(touches[0],tapCanvasPos0);//-----------------------------------------------------------------------------------------------
// Drag rotation
//-----------------------------------------------------------------------------------------------
math.subVec2(tapCanvasPos0,lastCanvasTouchPosList[0],touch0Vec);var xPanDelta=touch0Vec[0];var yPanDelta=touch0Vec[1];if(states.longTouchTimeout!==null&&(Math.abs(xPanDelta)>configs.longTapRadius||Math.abs(yPanDelta)>configs.longTapRadius)){clearTimeout(states.longTouchTimeout);states.longTouchTimeout=null;}if(configs.planView){// No rotating in plan-view mode
var camera=scene.camera;// We use only canvasHeight here so that aspect ratio does not distort speed
if(camera.projection==="perspective"){var depth=Math.abs(scene.camera.eyeLookDist);var targetDistance=depth*Math.tan(camera.perspective.fov/2*Math.PI/180.0);updates.panDeltaX+=xPanDelta*targetDistance/canvasHeight*configs.touchPanRate;updates.panDeltaY+=yPanDelta*targetDistance/canvasHeight*configs.touchPanRate;}else{updates.panDeltaX+=0.5*camera.ortho.scale*(xPanDelta/canvasHeight)*configs.touchPanRate;updates.panDeltaY+=0.5*camera.ortho.scale*(yPanDelta/canvasHeight)*configs.touchPanRate;}}else{//  if (!absorbTinyFirstDrag) {
updates.rotateDeltaY-=xPanDelta/canvasWidth*(configs.dragRotationRate*1.0);// Full horizontal rotation
updates.rotateDeltaX+=yPanDelta/canvasHeight*(configs.dragRotationRate*1.5);// Half vertical rotation
// } else {
//     firstDragDeltaY -= (xPanDelta / canvasWidth) * (configs.dragRotationRate * 1.0); // Full horizontal rotation
//     firstDragDeltaX += (yPanDelta / canvasHeight) * (configs.dragRotationRate * 1.5); // Half vertical rotation
//     if (Math.abs(firstDragDeltaX) > 5 || Math.abs(firstDragDeltaY) > 5) {
//         updates.rotateDeltaX += firstDragDeltaX;
//         updates.rotateDeltaY += firstDragDeltaY;
//         firstDragDeltaX = 0;
//         firstDragDeltaY = 0;
//         absorbTinyFirstDrag = false;
//     }
// }
}}else if(numTouches===2){var touch0=touches[0];var touch1=touches[1];getCanvasPosFromEvent$1(touch0,tapCanvasPos0);getCanvasPosFromEvent$1(touch1,tapCanvasPos1);var lastMiddleTouch=math.geometricMeanVec2(lastCanvasTouchPosList[0],lastCanvasTouchPosList[1]);var currentMiddleTouch=math.geometricMeanVec2(tapCanvasPos0,tapCanvasPos1);var touchDelta=math.vec2();math.subVec2(lastMiddleTouch,currentMiddleTouch,touchDelta);var _xPanDelta=touchDelta[0];var _yPanDelta=touchDelta[1];var _camera2=scene.camera;// Dollying
var d1=math.distVec2([touch0.pageX,touch0.pageY],[touch1.pageX,touch1.pageY]);var d2=math.distVec2(lastCanvasTouchPosList[0],lastCanvasTouchPosList[1]);var dollyDelta=(d2-d1)*configs.touchDollyRate;updates.dollyDelta=dollyDelta;if(Math.abs(dollyDelta)<1.0){// We use only canvasHeight here so that aspect ratio does not distort speed
if(_camera2.projection==="perspective"){var pickedWorldPos=pickController.pickResult?pickController.pickResult.worldPos:scene.center;var _depth=Math.abs(math.lenVec3(math.subVec3(pickedWorldPos,scene.camera.eye,[])));var _targetDistance=_depth*Math.tan(_camera2.perspective.fov/2*Math.PI/180.0);updates.panDeltaX-=_xPanDelta*_targetDistance/canvasHeight*configs.touchPanRate;updates.panDeltaY-=_yPanDelta*_targetDistance/canvasHeight*configs.touchPanRate;}else{updates.panDeltaX-=0.5*_camera2.ortho.scale*(_xPanDelta/canvasHeight)*configs.touchPanRate;updates.panDeltaY-=0.5*_camera2.ortho.scale*(_yPanDelta/canvasHeight)*configs.touchPanRate;}}states.pointerCanvasPos=currentMiddleTouch;}for(var _i464=0;_i464<numTouches;++_i464){getCanvasPosFromEvent$1(touches[_i464],lastCanvasTouchPosList[_i464]);}});}_createClass(TouchPanRotateAndDollyHandler,[{key:"reset",value:function reset(){}},{key:"destroy",value:function destroy(){var canvas=this._scene.canvas.canvas;canvas.removeEventListener("touchstart",this._canvasTouchStartHandler);canvas.removeEventListener("touchend",this._canvasTouchEndHandler);canvas.removeEventListener("touchmove",this._canvasTouchMoveHandler);this._scene.off(this._onTick);}}]);return TouchPanRotateAndDollyHandler;}();var TAP_INTERVAL=150;var DBL_TAP_INTERVAL=325;var TAP_DISTANCE_THRESHOLD=4;var getCanvasPosFromEvent=function getCanvasPosFromEvent(event,canvasPos){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent;}canvasPos[0]=event.pageX-totalOffsetLeft;canvasPos[1]=event.pageY-totalOffsetTop;}return canvasPos;};/**
 * @private
 */var TouchPickHandler=/*#__PURE__*/function(){function TouchPickHandler(scene,controllers,configs,states,updates){_classCallCheck(this,TouchPickHandler);this._scene=scene;var pickController=controllers.pickController;var cameraControl=controllers.cameraControl;var touchStartTime;var activeTouches=[];var tapStartPos=new Float32Array(2);var tapStartTime=-1;var lastTapTime=-1;var canvas=this._scene.canvas.canvas;var flyCameraTo=function flyCameraTo(pickResult){var pos;if(pickResult&&pickResult.worldPos){pos=pickResult.worldPos;}var aabb=pickResult?pickResult.entity.aabb:scene.aabb;if(pos){// Fly to look at point, don't change eye->look dist
var camera=scene.camera;math.subVec3(camera.eye,camera.look,[]);controllers.cameraFlight.flyTo({aabb:aabb});// TODO: Option to back off to fit AABB in view
}else{// Fly to fit target boundary in view
controllers.cameraFlight.flyTo({aabb:aabb});}};canvas.addEventListener("touchstart",this._canvasTouchStartHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}if(states.longTouchTimeout!==null){clearTimeout(states.longTouchTimeout);states.longTouchTimeout=null;}var touches=e.touches;var changedTouches=e.changedTouches;touchStartTime=Date.now();if(touches.length===1&&changedTouches.length===1){tapStartTime=touchStartTime;getCanvasPosFromEvent(touches[0],tapStartPos);var rightClickClientX=tapStartPos[0];var rightClickClientY=tapStartPos[1];var rightClickPageX=touches[0].pageX;var rightClickPageY=touches[0].pageY;states.longTouchTimeout=setTimeout(function(){controllers.cameraControl.fire("rightClick",{// For context menus
pagePos:[Math.round(rightClickPageX),Math.round(rightClickPageY)],canvasPos:[Math.round(rightClickClientX),Math.round(rightClickClientY)],event:e},true);states.longTouchTimeout=null;},configs.longTapTimeout);}else{tapStartTime=-1;}while(activeTouches.length<touches.length){activeTouches.push(new Float32Array(2));}for(var _i465=0,len=touches.length;_i465<len;++_i465){getCanvasPosFromEvent(touches[_i465],activeTouches[_i465]);}activeTouches.length=touches.length;},{passive:true});canvas.addEventListener("touchend",this._canvasTouchEndHandler=function(e){if(!(configs.active&&configs.pointerEnabled)){return;}var currentTime=Date.now();var touches=e.touches;var changedTouches=e.changedTouches;var pickedSurfaceSubs=cameraControl.hasSubs("pickedSurface");if(states.longTouchTimeout!==null){clearTimeout(states.longTouchTimeout);states.longTouchTimeout=null;}// process tap
if(touches.length===0&&changedTouches.length===1){if(tapStartTime>-1&&currentTime-tapStartTime<TAP_INTERVAL){if(lastTapTime>-1&&tapStartTime-lastTapTime<DBL_TAP_INTERVAL){// Double-tap
getCanvasPosFromEvent(changedTouches[0],pickController.pickCursorPos);pickController.schedulePickEntity=true;pickController.schedulePickSurface=pickedSurfaceSubs;pickController.update();if(pickController.pickResult){pickController.pickResult.touchInput=true;cameraControl.fire("doublePicked",pickController.pickResult);if(pickController.pickedSurface){cameraControl.fire("doublePickedSurface",pickController.pickResult);}if(configs.doublePickFlyTo){flyCameraTo(pickController.pickResult);}}else{cameraControl.fire("doublePickedNothing");if(configs.doublePickFlyTo){flyCameraTo();}}lastTapTime=-1;}else if(math.distVec2(activeTouches[0],tapStartPos)<TAP_DISTANCE_THRESHOLD){// Single-tap
getCanvasPosFromEvent(changedTouches[0],pickController.pickCursorPos);pickController.schedulePickEntity=true;pickController.schedulePickSurface=pickedSurfaceSubs;pickController.update();if(pickController.pickResult){pickController.pickResult.touchInput=true;cameraControl.fire("picked",pickController.pickResult);if(pickController.pickedSurface){cameraControl.fire("pickedSurface",pickController.pickResult);}}else{cameraControl.fire("pickedNothing");}lastTapTime=currentTime;}tapStartTime=-1;}}activeTouches.length=touches.length;for(var _i466=0,len=touches.length;_i466<len;++_i466){activeTouches[_i466][0]=touches[_i466].pageX;activeTouches[_i466][1]=touches[_i466].pageY;}//  e.stopPropagation();
},{passive:true});}_createClass(TouchPickHandler,[{key:"reset",value:function reset(){// TODO
// tapStartTime = -1;
// lastTapTime = -1;
}},{key:"destroy",value:function destroy(){var canvas=this._scene.canvas.canvas;canvas.removeEventListener("touchstart",this._canvasTouchStartHandler);canvas.removeEventListener("touchend",this._canvasTouchEndHandler);}}]);return TouchPickHandler;}();var DEFAULT_SNAP_PICK_RADIUS=30;var DEFAULT_SNAP_VERTEX=true;var DEFAULT_SNAP_EDGE=true;/**
 * @desc Controls the {@link Camera} with user input, and fires events when the user interacts with pickable {@link Entity}s.
 *
 * # Contents
 *
 * * [Overview](#overview)
 * * [Examples](#examples)
 * * [Orbit Mode](#orbit-mode)
 *      + [Following the Pointer in Orbit Mode](#--following-the-pointer-in-orbit-mode--)
 *      + [Showing the Pivot Position](#--showing-the-pivot-position--)
 *      + [Axis-Aligned Views in Orbit Mode](#--axis-aligned-views-in-orbit-mode--)
 *      + [View-Fitting Entitys in Orbit Mode](#--view-fitting-entitys-in-orbit-mode--)
 * * [First-Person Mode](#first-person-mode)
 *      + [Following the Pointer in First-Person Mode](#--following-the-pointer-in-first-person-mode--)
 *      + [Constraining Vertical Position in First-Person Mode](#--constraining-vertical-position-in-first-person-mode--)
 *      + [Axis-Aligned Views in First-Person Mode](#--axis-aligned-views-in-first-person-mode--)
 *      + [View-Fitting Entitys in First-Person Mode](#--view-fitting-entitys-in-first-person-mode--)
 * * [Plan-View Mode](#plan-view-mode)
 *      + [Following the Pointer in Plan-View Mode](#--following-the-pointer-in-plan-view-mode--)
 *      + [Axis-Aligned Views in Plan-View Mode](#--axis-aligned-views-in-plan-view-mode--)
 * * [CameraControl Events](#cameracontrol-events)
 *      + ["hover"](#---hover---)
 *      + ["hoverOff"](#---hoveroff---)
 *      + ["hoverEnter"](#---hoverenter---)
 *      + ["hoverOut"](#---hoverout---)
 *      + ["picked"](#---picked---)
 *      + ["pickedSurface"](#---pickedsurface---)
 *      + ["pickedNothing"](#---pickednothing---)
 *      + ["doublePicked"](#---doublepicked---)
 *      + ["doublePickedSurface"](#---doublepickedsurface---)
 *      + ["doublePickedNothing"](#---doublepickednothing---)
 *      + ["rightClick"](#---rightclick---)
 * * [Custom Keyboard Mappings](#custom-keyboard-mappings)
 *
 * <br><br>
 *
 * # Overview
 *
 * * Each {@link Viewer} has a ````CameraControl````, located at {@link Viewer#cameraControl}.
 * * {@link CameraControl#navMode} selects the navigation mode:
 *      * ````"orbit"```` rotates the {@link Camera} position about the target.
 *      * ````"firstPerson"```` rotates the World about the Camera position.
 *      * ````"planView"```` never rotates, but still allows to pan and dolly, typically for an axis-aligned view.
 * * {@link CameraControl#followPointer} makes the Camera follow the mouse or touch pointer.
 * * {@link CameraControl#constrainVertical} locks the Camera to its current height when in first-person mode.
 * * ````CameraControl```` fires pick events when we hover, click or tap on an {@link Entity}.
 * <br><br>
 *
 * # Examples
 *
 * * [Orbit Navigation - Duplex Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_orbit_Duplex)
 * * [Orbit Navigation - Holter Tower Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_orbit_HolterTower)
 * * [First-Person Navigation - Duplex Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_firstPerson_Duplex)
 * * [First-Person Navigation - Holter Tower Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_firstPerson_HolterTower)
 * * [Plan-view Navigation - Schependomlaan Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_planView_Schependomlaan)
 * * [Custom Keyboard Mapping](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_keyMap)
 * <br><br>
 *
 * # Orbit Mode
 *
 * In orbit mode, ````CameraControl```` orbits the {@link Camera} about the target.
 *
 * To enable orbit mode:
 *
 * ````javascript
 * const cameraControl = myViewer.cameraControl;
 * cameraControl.navMode = "orbit";
 * ````
 *
 * Then orbit by:
 *
 * * left-dragging the mouse,
 * * tap-dragging the touch pad, and
 * * pressing arrow keys, or ````Q```` and ````E```` on a QWERTY keyboard, or ````A```` and ````E```` on an AZERTY keyboard.
 * <br><br>
 *
 * Dolly forwards and backwards by:
 *
 * * spinning the mouse wheel,
 * * pinching on the touch pad, and
 * * pressing the ````+```` and ````-```` keys, or ````W```` and ````S```` on a QWERTY keyboard, or ````Z```` and ````S```` for AZERTY.
 * <br><br>
 *
 * Pan horizontally and vertically by:
 *
 * * right-dragging the mouse,
 * * left-dragging the mouse with the SHIFT key down,
 * * tap-dragging the touch pad with SHIFT down,
 * * pressing the ````A````, ````D````, ````Z```` and ````X```` keys on a QWERTY keyboard, and
 * * pressing the ````Q````, ````D````, ````W```` and ````X```` keys on an AZERTY keyboard,
 * <br><br>
 *
 * ## Following the Pointer in Orbit Mode
 *
 * When {@link CameraControl#followPointer} is ````true````in orbiting mode, the mouse or touch pointer will dynamically
 * indicate the target that the {@link Camera} will orbit, as well as dolly to and from.
 *
 * Lets ensure that we're in orbit mode, then enable the {@link Camera} to follow the pointer:
 *
 * ````javascript
 * cameraControl.navMode = "orbit";
 * cameraControl.followPointer = true;
 * ````
 *
 * ## Smart Pivoting
 *
 * TODO
 *
 * ## Showing the Pivot Position
 *
 * We can configure {@link CameraControl#pivotElement} with an HTML element to indicate the current
 * pivot position. The indicator will appear momentarily each time we move the {@link Camera} while in orbit mode with
 * {@link CameraControl#followPointer} set ````true````.
 *
 * First we'll define some CSS to style our pivot indicator as a black dot with a white border:
 *
 * ````css
 * .camera-pivot-marker {
 *      color: #ffffff;
 *      position: absolute;
 *      width: 25px;
 *      height: 25px;
 *      border-radius: 15px;
 *      border: 2px solid #ebebeb;
 *      background: black;
 *      visibility: hidden;
 *      box-shadow: 5px 5px 15px 1px #000000;
 *      z-index: 10000;
 *      pointer-events: none;
 * }
 * ````
 *
 * Then we'll attach our pivot indicator's HTML element to the ````CameraControl````:
 *
 * ````javascript
 * const pivotElement = document.createRange().createContextualFragment("<div class='camera-pivot-marker'></div>").firstChild;
 *
 * document.body.appendChild(pivotElement);
 *
 * cameraControl.pivotElement = pivotElement;
 * ````
 *
 * ## Axis-Aligned Views in Orbit Mode
 *
 * In orbit mode, we can use keys 1-6 to position the {@link Camera} to look at the center of the {@link Scene} from along each of the
 * six World-space axis. Pressing one of these keys will fly the {@link Camera} to the corresponding axis-aligned view.
 *
 * ## View-Fitting Entitys in Orbit Mode
 *
 * When {@link CameraControl#doublePickFlyTo} is ````true````, we can left-double-click or
 * double-tap (ie. "double-pick") an {@link Entity} to fit it to view. This will cause the {@link Camera}
 * to fly to that Entity. Our target then becomes the center of that Entity. If we are currently pivoting,
 * then our pivot position is then also set to the Entity center.
 *
 * Disable that behaviour by setting {@link CameraControl#doublePickFlyTo} ````false````.
 *
 * # First-Person Mode
 *
 * In first-person mode, ````CameraControl```` rotates the World about the {@link Camera} position.
 *
 * To enable first-person mode:
 *
 * ````javascript
 * cameraControl.navMode = "firstPerson";
 * ````
 *
 * Then rotate by:
 *
 * * left-dragging the mouse,
 * * tap-dragging the touch pad,
 * * pressing arrow keys, or ````Q```` and ````E```` on a QWERTY keyboard, or ````A```` and ````E```` on an AZERTY keyboard.
 * <br><br>
 *
 * Dolly forwards and backwards by:
 *
 * * spinning the mouse wheel,
 * * pinching on the touch pad, and
 * * pressing the ````+```` and ````-```` keys, or ````W```` and ````S```` on a QWERTY keyboard, or ````Z```` and ````S```` for AZERTY.
 * <br><br>
 *
 * Pan left, right, up and down by:
 *
 * * left-dragging or right-dragging the mouse, and
 * * tap-dragging the touch pad with SHIFT down.
 *
 * Pan forwards, backwards, left, right, up and down by pressing the ````WSADZX```` keys on a QWERTY keyboard,
 * or ````WSQDWX```` keys on an AZERTY keyboard.
 * <br><br>
 *
 * ## Following the Pointer in First-Person Mode
 *
 * When {@link CameraControl#followPointer} is ````true```` in first-person mode, the mouse or touch pointer will dynamically
 * indicate the target to which the {@link Camera} will dolly to and from. In first-person mode, however, the World will always rotate
 * about the {@link Camera} position.
 *
 * Lets ensure that we're in first-person mode, then enable the {@link Camera} to follow the pointer:
 *
 * ````javascript
 * cameraControl.navMode = "firstPerson";
 * cameraControl.followPointer = true;
 * ````
 *
 * When the pointer is over empty space, the target will remain the last object that the pointer was over.
 *
 * ## Constraining Vertical Position in First-Person Mode
 *
 * In first-person mode, we can lock the {@link Camera} to its current position on the vertical World axis, which is useful for walk-through navigation:
 *
 * ````javascript
 * cameraControl.constrainVertical = true;
 * ````
 *
 * ## Axis-Aligned Views in First-Person Mode
 *
 * In first-person mode we can use keys 1-6 to position the {@link Camera} to look at the center of
 * the {@link Scene} from along each of the six World-space axis. Pressing one of these keys will fly the {@link Camera} to the
 * corresponding axis-aligned view.
 *
 * ## View-Fitting Entitys in First-Person Mode
 *
 * As in orbit mode, when in first-person mode and {@link CameraControl#doublePickFlyTo} is ````true````, we can double-click
 * or double-tap an {@link Entity} (ie. "double-picking") to fit it in view. This will cause the {@link Camera} to fly to
 * that Entity. Our target then becomes the center of that Entity.
 *
 * Disable that behaviour by setting {@link CameraControl#doublePickFlyTo} ````false````.
 *
 * # Plan-View Mode
 *
 * In plan-view mode, ````CameraControl```` pans and rotates the {@link Camera}, without rotating it.
 *
 * To enable plan-view mode:
 *
 * ````javascript
 * cameraControl.navMode = "planView";
 * ````
 *
 * Dolly forwards and backwards by:
 *
 * * spinning the mouse wheel,
 * * pinching on the touch pad, and
 * * pressing the ````+```` and ````-```` keys.
 *
 * <br>
 * Pan left, right, up and down by:
 *
 * * left-dragging or right-dragging the mouse, and
 * * tap-dragging the touch pad with SHIFT down.
 *
 * Pan forwards, backwards, left, right, up and down by pressing the ````WSADZX```` keys on a QWERTY keyboard,
 * or ````WSQDWX```` keys on an AZERTY keyboard.
 * <br><br>
 *
 * ## Following the Pointer in Plan-View Mode
 *
 * When {@link CameraControl#followPointer} is ````true```` in plan-view mode, the mouse or touch pointer will dynamically
 * indicate the target to which the {@link Camera} will dolly to and from.  In plan-view mode, however, the {@link Camera} cannot rotate.
 *
 * Lets ensure that we're in plan-view mode, then enable the {@link Camera} to follow the pointer:
 *
 * ````javascript
 * cameraControl.navMode = "planView";
 * cameraControl.followPointer = true; // Default
 * ````
 *
 * When the pointer is over empty space, the target will remain the last object that the pointer was over.
 *
 * ## Axis-Aligned Views in Plan-View Mode
 *
 * As in orbit and first-person modes, in plan-view mode we can use keys 1-6 to position the {@link Camera} to look at the center of
 * the {@link Scene} from along each of the six World-space axis. Pressing one of these keys will fly the {@link Camera} to the
 * corresponding axis-aligned view.
 *
 * # CameraControl Events
 *
 * ````CameraControl```` fires events as we interact with {@link Entity}s using mouse or touch input.
 *
 * The following examples demonstrate how to subscribe to those events.
 *
 * The first example shows how to save a handle to a subscription, which we can later use to unsubscribe.
 *
 * ## "hover"
 *
 * Event fired when the pointer moves while hovering over an Entity.
 *
 * ````javascript
 * const onHover = cameraControl.on("hover", (e) => {
 *      const entity = e.entity; // Entity
 *      const canvasPos = e.canvasPos; // 2D canvas position
 * });
 * ````
 *
 * To unsubscribe from the event:
 *
 * ````javascript
 * cameraControl.off(onHover);
 * ````
 *
 * ## "hoverOff"
 *
 * Event fired when the pointer moves while hovering over empty space.
 *
 * ````javascript
 * cameraControl.on("hoverOff", (e) => {
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "hoverEnter"
 *
 * Event fired when the pointer moves onto an Entity.
 *
 * ````javascript
 * cameraControl.on("hoverEnter", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "hoverOut"
 *
 * Event fired when the pointer moves off an Entity.
 *
 * ````javascript
 * cameraControl.on("hoverOut", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "picked"
 *
 * Event fired when we left-click or tap on an Entity.
 *
 * ````javascript
 * cameraControl.on("picked", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "pickedSurface"
 *
 * Event fired when we left-click or tap on the surface of an Entity.
 *
 * ````javascript
 * cameraControl.on("picked", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 *      const worldPos = e.worldPos; // 3D World-space position
 *      const viewPos = e.viewPos; // 3D View-space position
 *      const worldNormal = e.worldNormal; // 3D World-space normal vector
 * });
 * ````
 *
 * ## "pickedNothing"
 *
 * Event fired when we left-click or tap on empty space.
 *
 * ````javascript
 * cameraControl.on("pickedNothing", (e) => {
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "doublePicked"
 *
 * Event fired wwhen we left-double-click or double-tap on an Entity.
 *
 * ````javascript
 * cameraControl.on("doublePicked", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "doublePickedSurface"
 *
 * Event fired when we left-double-click or double-tap on the surface of an Entity.
 *
 * ````javascript
 * cameraControl.on("doublePickedSurface", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 *      const worldPos = e.worldPos;
 *      const viewPos = e.viewPos;
 *      const worldNormal = e.worldNormal;
 * });
 * ````
 *
 * ## "doublePickedNothing"
 *
 * Event fired when we left-double-click or double-tap on empty space.
 *
 * ````javascript
 * cameraControl.on("doublePickedNothing", (e) => {
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "rightClick"
 *
 * Event fired when we right-click on the canvas.
 *
 * ````javascript
 * cameraControl.on("rightClick", (e) => {
 *      const event = e.event; // Mouse event
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## Custom Keyboard Mappings
 *
 * We can customize````CameraControl```` key bindings as shown below.
 *
 * In this example, we'll just set the default bindings for a QWERTY keyboard.
 *
 * ````javascript
 * const input = myViewer.scene.input;
 *
 * cameraControl.navMode = "orbit";
 * cameraControl.followPointer = true;
 *
 * const keyMap = {};
 *
 * keyMap[cameraControl.PAN_LEFT] = [input.KEY_A];
 * keyMap[cameraControl.PAN_RIGHT] = [input.KEY_D];
 * keyMap[cameraControl.PAN_UP] = [input.KEY_Z];
 * keyMap[cameraControl.PAN_DOWN] = [input.KEY_X];
 * keyMap[cameraControl.DOLLY_FORWARDS] = [input.KEY_W, input.KEY_ADD];
 * keyMap[cameraControl.DOLLY_BACKWARDS] = [input.KEY_S, input.KEY_SUBTRACT];
 * keyMap[cameraControl.ROTATE_X_POS] = [input.KEY_DOWN_ARROW];
 * keyMap[cameraControl.ROTATE_X_NEG] = [input.KEY_UP_ARROW];
 * keyMap[cameraControl.ROTATE_Y_POS] = [input.KEY_LEFT_ARROW];
 * keyMap[cameraControl.ROTATE_Y_NEG] = [input.KEY_RIGHT_ARROW];
 * keyMap[cameraControl.AXIS_VIEW_RIGHT] = [input.KEY_NUM_1];
 * keyMap[cameraControl.AXIS_VIEW_BACK] = [input.KEY_NUM_2];
 * keyMap[cameraControl.AXIS_VIEW_LEFT] = [input.KEY_NUM_3];
 * keyMap[cameraControl.AXIS_VIEW_FRONT] = [input.KEY_NUM_4];
 * keyMap[cameraControl.AXIS_VIEW_TOP] = [input.KEY_NUM_5];
 * keyMap[cameraControl.AXIS_VIEW_BOTTOM] = [input.KEY_NUM_6];
 *
 * cameraControl.keyMap = keyMap;
 * ````
 *
 * We can also just configure default bindings for a specified keyboard layout, like this:
 *
 * ````javascript
 * cameraControl.keyMap = "qwerty";
 * ````
 *
 * Then, ````CameraControl```` will internally set {@link CameraControl#keyMap} to the default key map for the QWERTY
 * layout (which is the same set of mappings we set in the previous example). In other words, if we subsequently
 * read {@link CameraControl#keyMap}, it will now be a key map, instead of the "qwerty" string value we set it to.
 *
 * Supported layouts are, so far:
 *
 * * ````"qwerty"````
 * * ````"azerty"````
 */var CameraControl=/*#__PURE__*/function(_Component38){_inherits(CameraControl,_Component38);var _super136=_createSuper(CameraControl);/**
     * @private
     * @constructor
     */function CameraControl(owner){var _this105;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CameraControl);_this105=_super136.call(this,owner,cfg);/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.PAN_LEFT=0;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.PAN_RIGHT=1;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.PAN_UP=2;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.PAN_DOWN=3;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.PAN_FORWARDS=4;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.PAN_BACKWARDS=5;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.ROTATE_X_POS=6;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.ROTATE_X_NEG=7;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.ROTATE_Y_POS=8;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.ROTATE_Y_NEG=9;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.DOLLY_FORWARDS=10;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.DOLLY_BACKWARDS=11;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.AXIS_VIEW_RIGHT=12;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.AXIS_VIEW_BACK=13;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.AXIS_VIEW_LEFT=14;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.AXIS_VIEW_FRONT=15;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.AXIS_VIEW_TOP=16;/**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */_this105.AXIS_VIEW_BOTTOM=17;_this105._keyMap={};// Maps key codes to the above actions
_this105.scene.canvas.canvas.oncontextmenu=function(e){e.preventDefault();};// User-settable CameraControl configurations
_this105._configs={// Private
longTapTimeout:600,// Millisecs
longTapRadius:5,// Pixels
// General
active:true,keyboardLayout:"qwerty",navMode:"orbit",planView:false,firstPerson:false,followPointer:true,doublePickFlyTo:true,panRightClick:true,showPivot:false,pointerEnabled:true,constrainVertical:false,smartPivot:false,doubleClickTimeFrame:250,snapToVertex:DEFAULT_SNAP_VERTEX,snapToEdge:DEFAULT_SNAP_EDGE,snapRadius:DEFAULT_SNAP_PICK_RADIUS,// Rotation
dragRotationRate:360.0,keyboardRotationRate:90.0,rotationInertia:0.0,// Panning
keyboardPanRate:1.0,touchPanRate:1.0,panInertia:0.5,// Dollying
keyboardDollyRate:10,mouseWheelDollyRate:100,touchDollyRate:0.2,dollyInertia:0,dollyProximityThreshold:30.0,dollyMinSpeed:0.04};// Current runtime state of the CameraControl
_this105._states={pointerCanvasPos:math.vec2(),mouseover:false,followPointerDirty:true,mouseDownClientX:0,mouseDownClientY:0,mouseDownCursorX:0,mouseDownCursorY:0,touchStartTime:null,activeTouches:[],tapStartPos:math.vec2(),tapStartTime:-1,lastTapTime:-1,longTouchTimeout:null};// Updates for CameraUpdater to process on next Scene "tick" event
_this105._updates={rotateDeltaX:0,rotateDeltaY:0,panDeltaX:0,panDeltaY:0,panDeltaZ:0,dollyDelta:0};// Controllers to assist input event handlers with controlling the Camera
var scene=_this105.scene;_this105._controllers={cameraControl:_assertThisInitialized(_this105),pickController:new PickController(_assertThisInitialized(_this105),_this105._configs),pivotController:new PivotController(scene,_this105._configs),panController:new PanController(scene),cameraFlight:new CameraFlightAnimation(_assertThisInitialized(_this105),{duration:0.5})};// Input event handlers
_this105._handlers=[new MouseMiscHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates),new TouchPanRotateAndDollyHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates),new MousePanRotateDollyHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates),new KeyboardAxisViewHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates),new MousePickHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates),new TouchPickHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates),new KeyboardPanRotateDollyHandler(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates)];// Applies scheduled updates to the Camera on each Scene "tick" event
_this105._cameraUpdater=new CameraUpdater(_this105.scene,_this105._controllers,_this105._configs,_this105._states,_this105._updates);// Set initial user configurations
_this105.navMode=cfg.navMode;if(cfg.planView){_this105.planView=cfg.planView;}_this105.constrainVertical=cfg.constrainVertical;if(cfg.keyboardLayout){_this105.keyboardLayout=cfg.keyboardLayout;// Deprecated
}else{_this105.keyMap=cfg.keyMap;}_this105.doublePickFlyTo=cfg.doublePickFlyTo;_this105.panRightClick=cfg.panRightClick;_this105.active=cfg.active;_this105.followPointer=cfg.followPointer;_this105.rotationInertia=cfg.rotationInertia;_this105.keyboardPanRate=cfg.keyboardPanRate;_this105.touchPanRate=cfg.touchPanRate;_this105.keyboardRotationRate=cfg.keyboardRotationRate;_this105.dragRotationRate=cfg.dragRotationRate;_this105.touchDollyRate=cfg.touchDollyRate;_this105.dollyInertia=cfg.dollyInertia;_this105.dollyProximityThreshold=cfg.dollyProximityThreshold;_this105.dollyMinSpeed=cfg.dollyMinSpeed;_this105.panInertia=cfg.panInertia;_this105.pointerEnabled=true;_this105.keyboardDollyRate=cfg.keyboardDollyRate;_this105.mouseWheelDollyRate=cfg.mouseWheelDollyRate;return _this105;}/**
     * Sets custom mappings of keys to ````CameraControl```` actions.
     *
     * See class docs for usage.
     *
     * @param {{Number:Number}|String} value Either a set of new key mappings, or a string to select a keyboard layout,
     * which causes ````CameraControl```` to use the default key mappings for that layout.
     */_createClass(CameraControl,[{key:"keyMap",get:/**
     * Gets custom mappings of keys to {@link CameraControl} actions.
     *
     * @returns {{Number:Number}} Current key mappings.
     */function get(){return this._keyMap;}/**
     * Returns true if any keys configured for the given action are down.
     * @param action
     * @param keyDownMap
     * @private
     */,set:function set(value){value=value||"qwerty";if(utils.isString(value)){var input=this.scene.input;var keyMap={};switch(value){default:this.error("Unsupported value for 'keyMap': "+value+" defaulting to 'qwerty'");// Intentional fall-through to "qwerty"
case"qwerty":keyMap[this.PAN_LEFT]=[input.KEY_A];keyMap[this.PAN_RIGHT]=[input.KEY_D];keyMap[this.PAN_UP]=[input.KEY_Z];keyMap[this.PAN_DOWN]=[input.KEY_X];keyMap[this.PAN_BACKWARDS]=[];keyMap[this.PAN_FORWARDS]=[];keyMap[this.DOLLY_FORWARDS]=[input.KEY_W,input.KEY_ADD];keyMap[this.DOLLY_BACKWARDS]=[input.KEY_S,input.KEY_SUBTRACT];keyMap[this.ROTATE_X_POS]=[input.KEY_DOWN_ARROW];keyMap[this.ROTATE_X_NEG]=[input.KEY_UP_ARROW];keyMap[this.ROTATE_Y_POS]=[input.KEY_Q,input.KEY_LEFT_ARROW];keyMap[this.ROTATE_Y_NEG]=[input.KEY_E,input.KEY_RIGHT_ARROW];keyMap[this.AXIS_VIEW_RIGHT]=[input.KEY_NUM_1];keyMap[this.AXIS_VIEW_BACK]=[input.KEY_NUM_2];keyMap[this.AXIS_VIEW_LEFT]=[input.KEY_NUM_3];keyMap[this.AXIS_VIEW_FRONT]=[input.KEY_NUM_4];keyMap[this.AXIS_VIEW_TOP]=[input.KEY_NUM_5];keyMap[this.AXIS_VIEW_BOTTOM]=[input.KEY_NUM_6];break;case"azerty":keyMap[this.PAN_LEFT]=[input.KEY_Q];keyMap[this.PAN_RIGHT]=[input.KEY_D];keyMap[this.PAN_UP]=[input.KEY_W];keyMap[this.PAN_DOWN]=[input.KEY_X];keyMap[this.PAN_BACKWARDS]=[];keyMap[this.PAN_FORWARDS]=[];keyMap[this.DOLLY_FORWARDS]=[input.KEY_Z,input.KEY_ADD];keyMap[this.DOLLY_BACKWARDS]=[input.KEY_S,input.KEY_SUBTRACT];keyMap[this.ROTATE_X_POS]=[input.KEY_DOWN_ARROW];keyMap[this.ROTATE_X_NEG]=[input.KEY_UP_ARROW];keyMap[this.ROTATE_Y_POS]=[input.KEY_A,input.KEY_LEFT_ARROW];keyMap[this.ROTATE_Y_NEG]=[input.KEY_E,input.KEY_RIGHT_ARROW];keyMap[this.AXIS_VIEW_RIGHT]=[input.KEY_NUM_1];keyMap[this.AXIS_VIEW_BACK]=[input.KEY_NUM_2];keyMap[this.AXIS_VIEW_LEFT]=[input.KEY_NUM_3];keyMap[this.AXIS_VIEW_FRONT]=[input.KEY_NUM_4];keyMap[this.AXIS_VIEW_TOP]=[input.KEY_NUM_5];keyMap[this.AXIS_VIEW_BOTTOM]=[input.KEY_NUM_6];break;}this._keyMap=keyMap;}else{var _keyMap=value;this._keyMap=_keyMap;}}},{key:"_isKeyDownForAction",value:function _isKeyDownForAction(action,keyDownMap){var keys=this._keyMap[action];if(!keys){return false;}if(!keyDownMap){keyDownMap=this.scene.input.keyDown;}for(var _i467=0,len=keys.length;_i467<len;_i467++){var key=keys[_i467];if(keyDownMap[key]){return true;}}return false;}/**
     * Sets the HTMl element to represent the pivot point when {@link CameraControl#followPointer} is true.
     *
     * See class comments for an example.
     *
     * @param {HTMLElement} element HTML element representing the pivot point.
     */},{key:"pivotElement",set:function set(element){this._controllers.pivotController.setPivotElement(element);}/**
     *  Sets if this ````CameraControl```` is active or not.
     *
     * When inactive, the ````CameraControl```` will not react to input.
     *
     * Default is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate this ````CameraControl````.
     */},{key:"active",get:/**
     * Gets if this ````CameraControl```` is active or not.
     *
     * When inactive, the ````CameraControl```` will not react to input.
     *
     * Default is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if this ````CameraControl```` is active.
     */function get(){return this._configs.active;}/**
     * Sets whether the pointer snap to vertex.
     *
     * @param {boolean} snapToVertex
     */,set:function set(value){value=value!==false;this._configs.active=value;this._handlers[1]._active=value;this._handlers[5]._active=value;}},{key:"snapToVertex",get:/**
     * Gets whether the pointer snap to vertex.
     *
     * @returns {boolean}
     */function get(){return this._configs.snapToVertex;}/**
     * Sets whether the pointer snap to edge.
     *
     * @param {boolean} snapToEdge
     */,set:function set(snapToVertex){this._configs.snapToVertex=!!snapToVertex;}},{key:"snapToEdge",get:/**
     * Gets whether the pointer snap to edge.
     *
     * @returns {boolean}
     */function get(){return this._configs.snapToEdge;}/**
     * Sets the current snap radius for "hoverSnapOrSurface" events, to specify whether the radius
     * within which the pointer snaps to the nearest vertex or the nearest edge.
     *
     * Default value is 30 pixels.
     *
     * @param {Number} snapRadius The snap radius.
     */,set:function set(snapToEdge){this._configs.snapToEdge=!!snapToEdge;}},{key:"snapRadius",get:/**
     * Gets the current snap radius.
     *
     * @returns {Number} The snap radius.
     */function get(){return this._configs.snapRadius;}/**
     * Sets the current navigation mode.
     *
     * Accepted values are:
     *
     * * "orbit" - rotation orbits about the current target or pivot point,
     * * "firstPerson" - rotation is about the current eye position,
     * * "planView" - rotation is disabled.
     *
     * See class comments for more info.
     *
     * @param {String} navMode The navigation mode: "orbit", "firstPerson" or "planView".
     */,set:function set(snapRadius){snapRadius=snapRadius||DEFAULT_SNAP_PICK_RADIUS;this._configs.snapRadius=snapRadius;}},{key:"navMode",get:/**
     * Gets the current navigation mode.
     *
     * @returns {String} The navigation mode: "orbit", "firstPerson" or "planView".
     */function get(){return this._configs.navMode;}/**
     * Sets whether mouse and touch input is enabled.
     *
     * Default is ````true````.
     *
     * Disabling mouse and touch input on ````CameraControl```` is useful when we want to temporarily use mouse or
     * touch input to interact with some other 3D control, without disturbing the {@link Camera}.
     *
     * @param {Boolean} value Set ````true```` to enable mouse and touch input.
     */,set:function set(navMode){navMode=navMode||"orbit";if(navMode!=="firstPerson"&&navMode!=="orbit"&&navMode!=="planView"){this.error("Unsupported value for navMode: "+navMode+" - supported values are 'orbit', 'firstPerson' and 'planView' - defaulting to 'orbit'");navMode="orbit";}this._configs.firstPerson=navMode==="firstPerson";this._configs.planView=navMode==="planView";if(this._configs.firstPerson||this._configs.planView){this._controllers.pivotController.hidePivot();this._controllers.pivotController.endPivot();}this._configs.navMode=navMode;}},{key:"pointerEnabled",get:/**
     * Gets whether mouse and touch input is enabled.
     *
     * Default is ````true````.
     *
     * Disabling mouse and touch input on ````CameraControl```` is desirable when we want to temporarily use mouse or
     * touch input to interact with some other 3D control, without interfering with the {@link Camera}.
     *
     * @returns {Boolean} Returns ````true```` if mouse and touch input is enabled.
     */function get(){return this._configs.pointerEnabled;}/**
     * Sets whether the {@link Camera} follows the mouse/touch pointer.
     *
     * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
     *
     * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
     *
     * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
     *
     * Default is ````true````.
     *
     * See class comments for more info.
     *
     * @param {Boolean} value Set ````true```` to enable the Camera to follow the pointer.
     */,set:function set(value){this._reset();this._configs.pointerEnabled=!!value;}},{key:"_reset",value:function _reset(){for(var _i468=0,len=this._handlers.length;_i468<len;_i468++){var handler=this._handlers[_i468];if(handler.reset){handler.reset();}}this._updates.panDeltaX=0;this._updates.panDeltaY=0;this._updates.rotateDeltaX=0;this._updates.rotateDeltaY=0;this._updates.dolyDelta=0;}},{key:"followPointer",get:/**
     * Sets whether the {@link Camera} follows the mouse/touch pointer.
     *
     * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
     *
     * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
     *
     * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
     *
     * Default is ````true````.
     *
     * See class comments for more info.
     *
     * @returns {Boolean} Returns ````true```` if the Camera follows the pointer.
     */function get(){return this._configs.followPointer;}/**
     * Sets the current World-space 3D target position.
     *
     * Only applies when {@link CameraControl#followPointer} is ````true````.
     *
     * @param {Number[]} worldPos The new World-space 3D target position.
     */,set:function set(value){this._configs.followPointer=value!==false;}},{key:"pivotPos",get:/**
     * Gets the current World-space 3D pivot position.
     *
     * Only applies when {@link CameraControl#followPointer} is ````true````.
     *
     * @return {Number[]} worldPos The current World-space 3D pivot position.
     */function get(){return this._controllers.pivotController.getPivotPos();}/**
     * @deprecated
     * @param {Boolean} value Set ````true```` to enable dolly-to-pointer behaviour.
     */,set:function set(worldPos){this._controllers.pivotController.setPivotPos(worldPos);}},{key:"dollyToPointer",get:/**
     * @deprecated
     * @returns {Boolean} Returns ````true```` if dolly-to-pointer behaviour is enabled.
     */function get(){this.warn("dollyToPointer property is deprecated - replaced with followPointer");return this.followPointer;}/**
     * @deprecated
     * @param {Boolean} value Set ````true```` to enable dolly-to-pointer behaviour.
     */,set:function set(value){this.warn("dollyToPointer property is deprecated - replaced with followPointer");this.followPointer=value;}},{key:"panToPointer",get:/**
     * @deprecated
     * @returns {Boolean} Returns ````true```` if dolly-to-pointer behaviour is enabled.
     */function get(){this.warn("panToPointer property is deprecated - replaced with followPointer");return false;}/**
     * Sets whether this ````CameraControl```` is in plan-view mode.
     *
     * When in plan-view mode, rotation is disabled.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @param {Boolean} value Set ````true```` to enable plan-view mode.
     * @deprecated
     */,set:function set(value){this.warn("panToPointer property is deprecated - replaced with followPointer");}},{key:"planView",get:/**
     * Gets whether this ````CameraControl```` is in plan-view mode.
     *
     * When in plan-view mode, rotation is disabled.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @returns {Boolean} Returns ````true```` if plan-view mode is enabled.
     * @deprecated
     */function get(){this.warn("planView property is deprecated - replaced with navMode");return this._configs.planView;}/**
     * Sets whether this ````CameraControl```` is in first-person mode.
     *
     * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,  {@link Camera#eye} rotates about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @param {Boolean} value Set ````true```` to enable first-person mode.
     * @deprecated
     */,set:function set(value){this._configs.planView=!!value;this._configs.firstPerson=false;if(this._configs.planView){this._controllers.pivotController.hidePivot();this._controllers.pivotController.endPivot();}this.warn("planView property is deprecated - replaced with navMode");}},{key:"firstPerson",get:/**
     * Gets whether this ````CameraControl```` is in first-person mode.
     *
     * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,  {@link Camera#eye} rotates about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @returns {Boolean} Returns ````true```` if first-person mode is enabled.
     * @deprecated
     */function get(){this.warn("firstPerson property is deprecated - replaced with navMode");return this._configs.firstPerson;}/**
     * Sets whether to vertically constrain the {@link Camera} position for first-person navigation.
     *
     * When set ````true````, this constrains {@link Camera#eye} to its current vertical position.
     *
     * Only applies when {@link CameraControl#navMode} is ````"firstPerson"````.
     *
     * Default is ````false````.
     *
     * @param {Boolean} value Set ````true```` to vertically constrain the Camera.
     */,set:function set(value){this.warn("firstPerson property is deprecated - replaced with navMode");this._configs.firstPerson=!!value;this._configs.planView=false;if(this._configs.firstPerson){this._controllers.pivotController.hidePivot();this._controllers.pivotController.endPivot();}}},{key:"constrainVertical",get:/**
     * Gets whether to vertically constrain the {@link Camera} position for first-person navigation.
     *
     * When set ````true````, this constrains {@link Camera#eye} to its current vertical position.
     *
     * Only applies when {@link CameraControl#navMode} is ````"firstPerson"````.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} ````true```` when Camera is vertically constrained.
     */function get(){return this._configs.constrainVertical;}/**
     * Sets whether double-picking an {@link Entity} causes the {@link Camera} to fly to its boundary.
     *
     * Default is ````false````.
     *
     * @param {Boolean} value Set ````true```` to enable double-pick-fly-to mode.
     */,set:function set(value){this._configs.constrainVertical=!!value;}},{key:"doublePickFlyTo",get:/**
     * Gets whether double-picking an {@link Entity} causes the {@link Camera} to fly to its boundary.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when double-pick-fly-to mode is enabled.
     */function get(){return this._configs.doublePickFlyTo;}/**
     * Sets whether either right-clicking (true) or middle-clicking (false) pans the {@link Camera}.
     *
     * Default is ````true````.
     *
     * @param {Boolean} value Set ````false```` to disable pan on right-click.
     */,set:function set(value){this._configs.doublePickFlyTo=value!==false;}},{key:"panRightClick",get:/**
     * Gets whether right-clicking pans the {@link Camera}.
     *
     * Default is ````true````.
     *
     * @returns {Boolean} Returns ````false```` when pan on right-click is disabled.
     */function get(){return this._configs.panRightClick;}/**
     * Sets a factor in range ````[0..1]```` indicating how much the {@link Camera} keeps moving after you finish rotating it.
     *
     * A value of ````0.0```` causes it to immediately stop, ````0.5```` causes its movement to decay 50% on each tick,
     * while ````1.0```` causes no decay, allowing it continue moving, by the current rate of rotation.
     *
     * You may choose an inertia of zero when you want be able to precisely rotate the Camera,
     * without interference from inertia. Zero inertia can also mean that less frames are rendered while
     * you are rotating the Camera.
     *
     * Default is ````0.0````.
     *
     * Does not apply when {@link CameraControl#navMode} is ````"planView"````, which disallows rotation.
     *
     * @param {Number} rotationInertia New inertial factor.
     */,set:function set(value){this._configs.panRightClick=value!==false;}},{key:"rotationInertia",get:/**
     * Gets the rotation inertia factor.
     *
     * Default is ````0.0````.
     *
     * Does not apply when {@link CameraControl#navMode} is ````"planView"````, which disallows rotation.
     *
     * @returns {Number} The inertia factor.
     */function get(){return this._configs.rotationInertia;}/**
     * Sets how much the {@link Camera} pans each second with keyboard input.
     *
     * Default is ````5.0````, to pan the Camera ````5.0```` World-space units every second that
     * a panning key is depressed. See the ````CameraControl```` class documentation for which keys control
     * panning.
     *
     * Panning direction is aligned to our Camera's orientation. When we pan horizontally, we pan
     * to our left and right, when we pan vertically, we pan upwards and downwards, and when we pan forwards
     * and backwards, we pan along the direction the Camera is pointing.
     *
     * Unlike dollying when {@link followPointer} is ````true````, panning does not follow the pointer.
     *
     * @param {Number} keyboardPanRate The new keyboard pan rate.
     */,set:function set(rotationInertia){this._configs.rotationInertia=rotationInertia!==undefined&&rotationInertia!==null?rotationInertia:0.0;}},{key:"keyboardPanRate",get:/**
     * Gets how much the {@link Camera} pans each second with keyboard input.
     *
     * Default is ````5.0````.
     *
     * @returns {Number} The current keyboard pan rate.
     */function get(){return this._configs.keyboardPanRate;}/**
     * Sets how many degrees per second the {@link Camera} rotates/orbits with keyboard input.
     *
     * Default is ````90.0````, to rotate/orbit the Camera ````90.0```` degrees every second that
     * a rotation key is depressed. See the ````CameraControl```` class documentation for which keys control
     * rotation/orbit.
     *
     * @param {Number} keyboardRotationRate The new keyboard rotation rate.
     */,set:function set(keyboardPanRate){this._configs.keyboardPanRate=keyboardPanRate!==null&&keyboardPanRate!==undefined?keyboardPanRate:5.0;}/**
     * Sets how fast the camera pans on touch panning
     *
     * @param {Number} touchPanRate The new touch pan rate.
     */},{key:"touchPanRate",get:/**
     * Gets how fast the {@link Camera} pans on touch panning
     *
     * Default is ````1.0````.
     *
     * @returns {Number} The current touch pan rate.
     */function get(){return this._configs.touchPanRate;},set:function set(touchPanRate){this._configs.touchPanRate=touchPanRate!==null&&touchPanRate!==undefined?touchPanRate:1.0;}},{key:"keyboardRotationRate",get:/**
     * Sets how many degrees per second the {@link Camera} rotates/orbits with keyboard input.
     *
     * Default is ````90.0````.
     *
     * @returns {Number} The current keyboard rotation rate.
     */function get(){return this._configs.keyboardRotationRate;}/**
     * Sets the current drag rotation rate.
     *
     * This configures how many degrees the {@link Camera} rotates/orbits for a full sweep of the canvas by mouse or touch dragging.
     *
     * For example, a value of ````360.0```` indicates that the ````Camera```` rotates/orbits ````360.0```` degrees horizontally
     * when we sweep the entire width of the canvas.
     *
     * ````CameraControl```` makes vertical rotation half as sensitive as horizontal rotation, so that we don't tend to
     * flip upside-down. Therefore, a value of ````360.0```` rotates/orbits the ````Camera```` through ````180.0```` degrees
     * vertically when we sweep the entire height of the canvas.
     *
     * Default is ````360.0````.
     *
     * @param {Number} dragRotationRate The new drag rotation rate.
     */,set:function set(keyboardRotationRate){this._configs.keyboardRotationRate=keyboardRotationRate!==null&&keyboardRotationRate!==undefined?keyboardRotationRate:90.0;}},{key:"dragRotationRate",get:/**
     * Gets the current drag rotation rate.
     *
     * Default is ````360.0````.
     *
     * @returns {Number} The current drag rotation rate.
     */function get(){return this._configs.dragRotationRate;}/**
     * Sets how much the {@link Camera} dollys each second with keyboard input.
     *
     * Default is ````15.0````, to dolly the {@link Camera} ````15.0```` World-space units per second while we hold down
     * the ````+```` and ````-```` keys.
     *
     * @param {Number} keyboardDollyRate The new keyboard dolly rate.
     */,set:function set(dragRotationRate){this._configs.dragRotationRate=dragRotationRate!==null&&dragRotationRate!==undefined?dragRotationRate:360.0;}},{key:"keyboardDollyRate",get:/**
     * Gets how much the {@link Camera} dollys each second with keyboard input.
     *
     * Default is ````15.0````.
     *
     * @returns {Number} The current keyboard dolly rate.
     */function get(){return this._configs.keyboardDollyRate;}/**
     * Sets how much the {@link Camera} dollys with touch input.
     *
     * Default is ````0.2````
     *
     * @param {Number} touchDollyRate The new touch dolly rate.
     */,set:function set(keyboardDollyRate){this._configs.keyboardDollyRate=keyboardDollyRate!==null&&keyboardDollyRate!==undefined?keyboardDollyRate:15.0;}},{key:"touchDollyRate",get:/**
     * Gets how much the {@link Camera} dollys each second with touch input.
     *
     * Default is ````0.2````.
     *
     * @returns {Number} The current touch dolly rate.
     */function get(){return this._configs.touchDollyRate;}/**
     * Sets how much the {@link Camera} dollys each second while the mouse wheel is spinning.
     *
     * Default is ````100.0````, to dolly the {@link Camera} ````10.0```` World-space units per second as we spin
     * the mouse wheel.
     *
     * @param {Number} mouseWheelDollyRate The new mouse wheel dolly rate.
     */,set:function set(touchDollyRate){this._configs.touchDollyRate=touchDollyRate!==null&&touchDollyRate!==undefined?touchDollyRate:0.2;}},{key:"mouseWheelDollyRate",get:/**
     * Gets how much the {@link Camera} dollys each second while the mouse wheel is spinning.
     *
     * Default is ````100.0````.
     *
     * @returns {Number} The current mouseWheel dolly rate.
     */function get(){return this._configs.mouseWheelDollyRate;}/**
     * Sets the dolly inertia factor.
     *
     * This factor configures how much the {@link Camera} keeps moving after you finish dollying it.
     *
     * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes dollying to immediately stop,
     * ````0.5```` causes dollying to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows dollying
     * to continue until further input stops it.
     *
     * You might set ````dollyInertia```` to zero when you want be able to precisely position or rotate the Camera,
     * without interference from inertia. This also means that xeokit renders less frames while dollying the Camera,
     * which can improve rendering performance.
     *
     * Default is ````0````.
     *
     * @param {Number} dollyInertia New dolly inertia factor.
     */,set:function set(mouseWheelDollyRate){this._configs.mouseWheelDollyRate=mouseWheelDollyRate!==null&&mouseWheelDollyRate!==undefined?mouseWheelDollyRate:100.0;}},{key:"dollyInertia",get:/**
     * Gets the dolly inertia factor.
     *
     * Default is ````0````.
     *
     * @returns {Number} The current dolly inertia factor.
     */function get(){return this._configs.dollyInertia;}/**
     * Sets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
     *
     * Default is ````35.0````.
     *
     * @param {Number} dollyProximityThreshold New dolly proximity threshold.
     */,set:function set(dollyInertia){this._configs.dollyInertia=dollyInertia!==undefined&&dollyInertia!==null?dollyInertia:0;}},{key:"dollyProximityThreshold",get:/**
     * Gets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
     *
     * Default is ````35.0````.
     *
     * @returns {Number} The current dolly proximity threshold.
     */function get(){return this._configs.dollyProximityThreshold;}/**
     * Sets the minimum dolly speed.
     *
     * Default is ````0.04````.
     *
     * @param {Number} dollyMinSpeed New dolly minimum speed.
     */,set:function set(dollyProximityThreshold){this._configs.dollyProximityThreshold=dollyProximityThreshold!==undefined&&dollyProximityThreshold!==null?dollyProximityThreshold:35.0;}},{key:"dollyMinSpeed",get:/**
     * Gets the minimum dolly speed.
     *
     * Default is ````0.04````.
     *
     * @returns {Number} The current minimum dolly speed.
     */function get(){return this._configs.dollyMinSpeed;}/**
     * Sets the pan inertia factor.
     *
     * This factor configures how much the {@link Camera} keeps moving after you finish panning it.
     *
     * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes panning to immediately stop,
     * ````0.5```` causes panning to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows panning
     * to continue until further input stops it.
     *
     * You might set ````panInertia```` to zero when you want be able to precisely position or rotate the Camera,
     * without interference from inertia. This also means that xeokit renders less frames while panning the Camera,
     * wich can improve rendering performance.
     *
     * Default is ````0.5````.
     *
     * @param {Number} panInertia New pan inertia factor.
     */,set:function set(dollyMinSpeed){this._configs.dollyMinSpeed=dollyMinSpeed!==undefined&&dollyMinSpeed!==null?dollyMinSpeed:0.04;}},{key:"panInertia",get:/**
     * Gets the pan inertia factor.
     *
     * Default is ````0.5````.
     *
     * @returns {Number} The current pan inertia factor.
     */function get(){return this._configs.panInertia;}/**
     * Sets the keyboard layout.
     *
     * Supported layouts are:
     *
     * * ````"qwerty"```` (default)
     * * ````"azerty"````
     *
     * @deprecated
     * @param {String} value Selects the keyboard layout.
     */,set:function set(panInertia){this._configs.panInertia=panInertia!==undefined&&panInertia!==null?panInertia:0.5;}},{key:"keyboardLayout",get:/**
     * Gets the keyboard layout.
     *
     * Supported layouts are:
     *
     * * ````"qwerty"```` (default)
     * * ````"azerty"````
     *
     * @deprecated
     * @returns {String} The current keyboard layout.
     */function get(){return this._configs.keyboardLayout;}/**
     * Sets a sphere as the representation of the pivot position.
     *
     * @param {Object} [cfg] Sphere configuration.
     * @param {String} [cfg.size=1] Optional size factor of the sphere. Defaults to 1.
     * @param {String} [cfg.material=PhongMaterial] Optional size factor of the sphere. Defaults to a red opaque material.
     */,set:function set(value){// this.warn("keyboardLayout property is deprecated - use keyMap property instead");
value=value||"qwerty";if(value!=="qwerty"&&value!=="azerty"){this.error("Unsupported value for keyboardLayout - defaulting to 'qwerty'");value="qwerty";}this._configs.keyboardLayout=value;this.keyMap=this._configs.keyboardLayout;}},{key:"enablePivotSphere",value:function enablePivotSphere(){var cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this._controllers.pivotController.enablePivotSphere(cfg);}/**
     * Remove the sphere as the representation of the pivot position.
     *
     */},{key:"disablePivotSphere",value:function disablePivotSphere(){this._controllers.pivotController.disablePivotSphere();}/**
     * Sets whether smart default pivoting is enabled.
     *
     * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
     * imaginary sphere that's centered at {@link Camera#eye} and sized to the {@link Scene} boundary.
     *
     * When ````false````, we'll pivot by default about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * @param {Boolean} enabled Set ````true```` to pivot by default about the selected point on the virtual sphere, or ````false```` to pivot by default about {@link Camera#look}.
     */},{key:"smartPivot",get:/**
     * Gets whether smart default pivoting is enabled.
     *
     * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
     * imaginary sphere that's centered at {@link Camera#eye} and sized to the {@link Scene} boundary.
     *
     * When ````false````, we'll pivot by default about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when pivoting by default about the selected point on the virtual sphere, or ````false```` when pivoting by default about {@link Camera#look}.
     */function get(){return this._configs.smartPivot;}/**
     * Sets the double click time frame length in milliseconds.
     * 
     * If two mouse click events occur within this time frame, it is considered a double click. 
     * 
     * Default is ````250````
     * 
     * @param {Number} value New double click time frame.
     */,set:function set(enabled){this._configs.smartPivot=enabled!==false;}},{key:"doubleClickTimeFrame",get:/**
     * Gets the double click time frame length in milliseconds.
     *  
     * Default is ````250````
     * 
     * @param {Number} value Current double click time frame.
     */function get(){return this._configs.doubleClickTimeFrame;}/**
     * Destroys this ````CameraControl````.
     * @private
     */,set:function set(value){this._configs.doubleClickTimeFrame=value!==undefined&&value!==null?value:250;}},{key:"destroy",value:function destroy(){this._destroyHandlers();this._destroyControllers();this._cameraUpdater.destroy();_get(_getPrototypeOf(CameraControl.prototype),"destroy",this).call(this);}},{key:"_destroyHandlers",value:function _destroyHandlers(){for(var _i469=0,len=this._handlers.length;_i469<len;_i469++){var handler=this._handlers[_i469];if(handler.destroy){handler.destroy();}}}},{key:"_destroyControllers",value:function _destroyControllers(){for(var _i470=0,len=this._controllers.length;_i470<len;_i470++){var controller=this._controllers[_i470];if(controller.destroy){controller.destroy();}}}}]);return CameraControl;}(Component);/**
 * @desc A property within a {@link PropertySet}.
 *
 * @class Property
 */var Property=/*#__PURE__*/_createClass(/**
     * @private
     */function Property(name,value,type,valueType,description){_classCallCheck(this,Property);/**
         * The name of this property.
         *
         * @property name
         * @type {String}
         */this.name=name;/**
         * The type of this property.
         *
         * @property type
         * @type {Number|String}
         */this.type=type;/**
         * The value of this property.
         *
         * @property value
         * @type {*}
         */this.value=value;/**
         * The type of this property's value.
         *
         * @property valueType
         * @type {Number|String}
         */this.valueType=valueType;/**
         * Informative text to explain the property.
         *
         * @property name
         * @type {String}
         */this.description=description;});/**
 * @desc A set of properties associated with one or more {@link MetaObject}s.
 *
 * A PropertySet is created within {@link MetaScene#createMetaModel} and belongs to a {@link MetaModel}.
 *
 * Each PropertySet is registered by {@link PropertySet#id} in {@link MetaScene#propertySets} and {@link MetaModel#propertySets}.
 *
 * @class PropertySet
 */var PropertySet=/*#__PURE__*/_createClass(/**
     * @private
     */function PropertySet(params){_classCallCheck(this,PropertySet);/**
         * Globally-unique ID for this PropertySet.
         *
         * PropertySet instances are registered by this ID in {@link MetaScene#propertySets} and {@link MetaModel#propertySets}.
         *
         * @property id
         * @type {String}
         */this.id=params.id;/**
         * ID of the corresponding object within the originating system, if any.
         *
         * @type {String}
         * @abstract
         */this.originalSystemId=params.originalSystemId;/**
         * The MetaModels that share this PropertySet.
         * @type {MetaModel[]}
         */this.metaModels=[];/**
         * Human-readable name of this PropertySet.
         *
         * @property name
         * @type {String}
         */this.name=params.name;/**
         * Type of this PropertySet.
         *
         * @property type
         * @type {String}
         */this.type=params.type;/**
         * Properties within this PropertySet.
         *
         * @property properties
         * @type {Property[]}
         */this.properties=[];if(params.properties){var properties=params.properties;for(var _i471=0,len=properties.length;_i471<len;_i471++){var property=properties[_i471];this.properties.push(new Property(property.name,property.value,property.type,property.valueType,property.description));}}});/**
 * @desc Metadata corresponding to an {@link Entity} that represents an object.
 *
 * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````
 *
 * A MetaObject corresponds to an {@link Entity} by having the same {@link MetaObject#id} as the {@link Entity#id}.
 *
 * A MetaObject is created within {@link MetaScene#createMetaModel} and belongs to a {@link MetaModel}.
 *
 * Each MetaObject is registered by {@link MetaObject#id} in {@link MetaScene#metaObjects}.
 *
 * A {@link MetaModel} represents its object structure with a tree of MetaObjects, with {@link MetaModel#rootMetaObject} referencing
 * the root MetaObject.
 *
 * @class MetaObject
 */var MetaObject=/*#__PURE__*/function(){/**
     * @private
     */function MetaObject(params){_classCallCheck(this,MetaObject);/**
         * The MetaModels that share this MetaObject.
         * @type {MetaModel[]}
         */this.metaModels=[];/**
         * Globally-unique ID.
         *
         * MetaObject instances are registered by this ID in {@link MetaScene#metaObjects}.
         *
         * @property id
         * @type {String|Number}
         */this.id=params.id;/**
         * ID of the parent MetaObject.
         * @type {String|Number}
         */this.parentId=params.parentId;/**
         * The parent MetaObject.
         * @type {MetaObject | null}
         */this.parent=null;/**
         * ID of the corresponding object within the originating system, if any.
         *
         * @type {String}
         * @abstract
         */this.originalSystemId=params.originalSystemId;/**
         * Human-readable name.
         *
         * @property name
         * @type {String}
         */this.name=params.name;/**
         * Type - often an IFC product type.
         *
         * @property type
         * @type {String}
         */this.type=params.type;/**
         * IDs of PropertySets associated with this MetaObject.
         * @type {[]|*}
         */this.propertySetIds=params.propertySetIds;/**
         * The {@link PropertySet}s associated with this MetaObject.
         *
         * @property propertySets
         * @type {PropertySet[]}
         */this.propertySets=[];/**
         * The attributes of this MetaObject.
         * @type {{}}
         */this.attributes=params.attributes||{};if(params.external!==undefined&&params.external!==null){/**
             * External application-specific metadata
             *
             * Undefined when there are is no external application-specific metadata.
             *
             * @property external
             * @type {*}
             */this.external=params.external;}}/**
     * Backwards compatibility with the object belonging to a single MetaModel.
     * 
     * @property metaModel
     * @type {MetaModel|null}
     **/_createClass(MetaObject,[{key:"metaModel",get:function get(){if(this.metaModels.length==1){return this.metaModels[0];}return null;}/**
     * Gets the {@link MetaObject#id}s of the {@link MetaObject}s within the subtree.
     *
     * @returns {String[]} Array of {@link MetaObject#id}s.
     */},{key:"getObjectIDsInSubtree",value:function getObjectIDsInSubtree(){var objectIds=[];function visit(metaObject){if(!metaObject){return;}objectIds.push(metaObject.id);var children=metaObject.children;if(children){for(var i=0,len=children.length;i<len;i++){visit(children[i]);}}}visit(this);return objectIds;}/**
     * Iterates over the {@link MetaObject}s within the subtree.
     *
     * @param {Function} callback Callback fired at each {@link MetaObject}.
     */},{key:"withMetaObjectsInSubtree",value:function withMetaObjectsInSubtree(callback){function visit(metaObject){if(!metaObject){return;}callback(metaObject);var children=metaObject.children;if(children){for(var i=0,len=children.length;i<len;i++){visit(children[i]);}}}visit(this);}/**
     * Gets the {@link MetaObject#id}s of the {@link MetaObject}s within the subtree that have the given {@link MetaObject#type}s.
     *
     * @param {String[]} types {@link MetaObject#type} values.
     * @returns {String[]} Array of {@link MetaObject#id}s.
     */},{key:"getObjectIDsInSubtreeByType",value:function getObjectIDsInSubtreeByType(types){var mask={};for(var i=0,len=types.length;i<len;i++){mask[types[i]]=types[i];}var objectIds=[];function visit(metaObject){if(!metaObject){return;}if(mask[metaObject.type]){objectIds.push(metaObject.id);}var children=metaObject.children;if(children){for(var i=0,len=children.length;i<len;i++){visit(children[i]);}}}visit(this);return objectIds;}/**
     * Returns properties of this MeteObject as JSON.
     *
     * @returns {{id: (String|Number), type: String, name: String, parent: (String|Number|Undefined)}}
     */},{key:"getJSON",value:function getJSON(){var json={id:this.id,type:this.type,name:this.name};if(this.parent){json.parent=this.parent.id;}return json;}}]);return MetaObject;}();/**
 * @desc Metadata corresponding to an {@link Entity} that represents a model.
 *
 * An {@link Entity} represents a model when {@link Entity#isModel} is ````true````
 *
 * A MetaModel corresponds to an {@link Entity} by having the same {@link MetaModel#id} as the {@link Entity#id}.
 *
 * A MetaModel is created by {@link MetaScene#createMetaModel} and belongs to a {@link MetaScene}.
 *
 * Each MetaModel is registered by {@link MetaModel#id} in {@link MetaScene#metaModels}.
 *
 * A {@link MetaModel} represents its object structure with a tree of {@link MetaObject}s, with {@link MetaModel#rootMetaObject} referencing the root {@link MetaObject}.
 *
 * @class MetaModel
 */var MetaModel=/*#__PURE__*/function(){/**
     * Creates a new, unfinalized MetaModel.
     *
     * * The MetaModel is immediately registered by {@link MetaModel#id} in {@link MetaScene#metaModels}, even though it's not yet populated.
     * * The MetaModel then needs to be populated with one or more calls to {@link metaModel#loadData}.
     * * As we populate it, the MetaModel will create {@link MetaObject}s and {@link PropertySet}s in itself, and in the MetaScene.
     * * When populated, call {@link MetaModel#finalize} to finish it off, which causes MetaScene to fire a "metaModelCreated" event.
     */function MetaModel(params){_classCallCheck(this,MetaModel);/**
         * Globally-unique ID.
         *
         * MetaModels are registered by ID in {@link MetaScene#metaModels}.
         *
         * When this MetaModel corresponds to an {@link Entity} then this ID will match the {@link Entity#id}.
         *
         * @property id
         * @type {String|Number}
         */this.id=params.id;/**
         * The project ID
         * @property projectId
         * @type {String|Number}
         */this.projectId=params.projectId;/**
         * The revision ID, if available.
         *
         * Will be undefined if not available.
         *
         * @property revisionId
         * @type {String|Number}
         */this.revisionId=params.revisionId;/**
         * The model author, if available.
         *
         * Will be undefined if not available.
         *
         * @property author
         * @type {String}
         */this.author=params.author;/**
         * The date the model was created, if available.
         *
         * Will be undefined if not available.
         *
         * @property createdAt
         * @type {String}
         */this.createdAt=params.createdAt;/**
         * The application that created the model, if available.
         *
         * Will be undefined if not available.
         *
         * @property creatingApplication
         * @type {String}
         */this.creatingApplication=params.creatingApplication;/**
         * The model schema version, if available.
         *
         * Will be undefined if not available.
         *
         * @property schema
         * @type {String}
         */this.schema=params.schema;/**
         * Metadata on the {@link Scene}.
         *
         * @property metaScene
         * @type {MetaScene}
         */this.metaScene=params.metaScene;/**
         * The {@link PropertySet}s in this MetaModel.
         *
         * @property propertySets
         * @type  {PropertySet[]}
         */this.propertySets=[];/**
         * The root {@link MetaObject}s in this MetaModel's composition structure hierarchy.
         *
         * @property rootMetaObject
         * @type {MetaObject[]}
         */this.rootMetaObjects=[];/**
         * The {@link MetaObject}s in this MetaModel, each mapped to its ID.
         *
         * @property metaObjects
         * @type  {MetaObject[]}
         */this.metaObjects=[];/**
         * Connectivity graph.
         * @type {{}}
         */this.graph=params.graph||{};this.metaScene.metaModels[this.id]=this;/**
         * True when this MetaModel has been finalized.
         * @type {boolean}
         */this.finalized=false;}/**
     * Backwards compatibility with the model having a single root MetaObject.
     *
     * @property rootMetaObject
     * @type {MetaObject|null}
     */_createClass(MetaModel,[{key:"rootMetaObject",get:function get(){if(this.rootMetaObjects.length==1){return this.rootMetaObjects[0];}return null;}/**
     * Load metamodel data into this MetaModel.
     * @param metaModelData
     */},{key:"loadData",value:function loadData(metaModelData){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this.finalized){throw"MetaScene already finalized - can't add more data";}this._globalizeIDs(metaModelData,options);var metaScene=this.metaScene;var propertyLookup=metaModelData.properties;// Create global Property Sets
if(metaModelData.propertySets){for(var _i472=0,len=metaModelData.propertySets.length;_i472<len;_i472++){var propertySetData=metaModelData.propertySets[_i472];if(!propertySetData.properties){// HACK: https://github.com/Creoox/creoox-ifc2gltfcxconverter/issues/8
propertySetData.properties=[];}var propertySet=metaScene.propertySets[propertySetData.id];if(!propertySet){if(propertyLookup){this._decompressProperties(propertyLookup,propertySetData.properties);}propertySet=new PropertySet({id:propertySetData.id,originalSystemId:propertySetData.originalSystemId||propertySetData.id,type:propertySetData.type,name:propertySetData.name,properties:propertySetData.properties});metaScene.propertySets[propertySet.id]=propertySet;}propertySet.metaModels.push(this);this.propertySets.push(propertySet);}}if(metaModelData.metaObjects){for(var _i473=0,_len93=metaModelData.metaObjects.length;_i473<_len93;_i473++){var metaObjectData=metaModelData.metaObjects[_i473];var id=metaObjectData.id;var metaObject=metaScene.metaObjects[id];if(!metaObject){var type=metaObjectData.type;var originalSystemId=metaObjectData.originalSystemId;var propertySetIds=metaObjectData.propertySets||metaObjectData.propertySetIds;metaObject=new MetaObject({id:id,originalSystemId:originalSystemId,parentId:metaObjectData.parent,type:type,name:metaObjectData.name,attributes:metaObjectData.attributes,propertySetIds:propertySetIds,external:metaObjectData.external});this.metaScene.metaObjects[id]=metaObject;metaObject.metaModels=[];}this.metaObjects.push(metaObject);if(!metaObjectData.parent){this.rootMetaObjects.push(metaObject);metaScene.rootMetaObjects[id]=metaObject;}}}}},{key:"_decompressProperties",value:function _decompressProperties(propertyLookup,properties){for(var _i474=0,len=properties.length;_i474<len;_i474++){var property=properties[_i474];if(Number.isInteger(property)){var lookupProperty=propertyLookup[property];if(lookupProperty){properties[_i474]=lookupProperty;}}}}},{key:"finalize",value:function finalize(){if(this.finalized){throw"MetaScene already finalized - can't re-finalize";}// Re-link MetaScene's entire MetaObject parent/child hierarchy
var metaScene=this.metaScene;for(var objectId in metaScene.metaObjects){var metaObject=metaScene.metaObjects[objectId];if(metaObject.children){metaObject.children=[];}// Re-link each MetaObject's property sets
if(metaObject.propertySets){metaObject.propertySets=[];}if(metaObject.propertySetIds){for(var _i475=0,len=metaObject.propertySetIds.length;_i475<len;_i475++){var propertySetId=metaObject.propertySetIds[_i475];var propertySet=metaScene.propertySets[propertySetId];metaObject.propertySets.push(propertySet);}}}for(var _objectId in metaScene.metaObjects){var _metaObject3=metaScene.metaObjects[_objectId];if(_metaObject3.parentId){var parentMetaObject=metaScene.metaObjects[_metaObject3.parentId];if(parentMetaObject){_metaObject3.parent=parentMetaObject;(parentMetaObject.children||(parentMetaObject.children=[])).push(_metaObject3);}}}// Relink MetaObjects to their MetaModels
for(var _objectId2 in metaScene.metaObjects){var _metaObject4=metaScene.metaObjects[_objectId2];_metaObject4.metaModels=[];}for(var modelId in metaScene.metaModels){var metaModel=metaScene.metaModels[modelId];for(var _i476=0,_len94=metaModel.metaObjects.length;_i476<_len94;_i476++){var _metaObject5=metaModel.metaObjects[_i476];_metaObject5.metaModels.push(metaModel);}}// Rebuild MetaScene's MetaObjects-by-type lookup
metaScene.metaObjectsByType={};for(var _objectId3 in metaScene.metaObjects){var _metaObject6=metaScene.metaObjects[_objectId3];var type=_metaObject6.type;(metaScene.metaObjectsByType[type]||(metaScene.metaObjectsByType[type]={}))[_objectId3]=_metaObject6;}this.finalized=true;this.metaScene.fire("metaModelCreated",this.id);}/**
     * Gets this MetaModel as JSON.
     * @returns {{schema: (String|string|*), createdAt: (String|string|*), metaObjects: *[], author: (String|string|*), id: (String|Number|string|number|*), creatingApplication: (String|string|*), projectId: (String|Number|string|number|*), propertySets: *[]}}
     */},{key:"getJSON",value:function getJSON(){var json={id:this.id,projectId:this.projectId,author:this.author,createdAt:this.createdAt,schema:this.schema,creatingApplication:this.creatingApplication,metaObjects:[],propertySets:[]};for(var _i477=0,len=this.metaObjects.length;_i477<len;_i477++){var metaObject=this.metaObjects[_i477];var metaObjectCfg={id:metaObject.id,originalSystemId:metaObject.originalSystemId,extId:metaObject.extId,type:metaObject.type,name:metaObject.name};if(metaObject.parent){metaObjectCfg.parent=metaObject.parent.id;}if(metaObject.attributes){metaObjectCfg.attributes=metaObject.attributes;}if(metaObject.propertySetIds){metaObjectCfg.propertySetIds=metaObject.propertySetIds;}json.metaObjects.push(metaObjectCfg);}for(var _i478=0,_len95=this.propertySets.length;_i478<_len95;_i478++){var propertySet=this.propertySets[_i478];var propertySetCfg={id:propertySet.id,originalSystemId:propertySet.originalSystemId,extId:propertySet.extId,type:propertySet.type,name:propertySet.name,propertyies:[]};for(var j=0,lenj=propertySet.properties.length;j<lenj;j++){var property=propertySet.properties[j];var propertyCfg={id:property.id,description:property.description,type:property.type,name:property.name,value:property.value,valueType:property.valueType};propertySetCfg.properties.push(propertyCfg);}json.propertySets.push(propertySetCfg);}return json;}},{key:"_globalizeIDs",value:function _globalizeIDs(metaModelData,options){var globalize=!!options.globalizeObjectIds;if(metaModelData.metaObjects){for(var _i479=0,len=metaModelData.metaObjects.length;_i479<len;_i479++){var metaObjectData=metaModelData.metaObjects[_i479];// Globalize MetaObject IDs and parent IDs
metaObjectData.originalSystemId=metaObjectData.id;if(metaObjectData.parent){metaObjectData.originalParentSystemId=metaObjectData.parent;}if(globalize){metaObjectData.id=math.globalizeObjectId(this.id,metaObjectData.id);if(metaObjectData.parent){metaObjectData.parent=math.globalizeObjectId(this.id,metaObjectData.parent);}}// Globalize MetaObject property set IDs
if(globalize){var propertySetIds=metaObjectData.propertySetIds;if(propertySetIds){var propertySetGlobalIds=[];for(var j=0,lenj=propertySetIds.length;j<lenj;j++){propertySetGlobalIds.push(math.globalizeObjectId(this.id,propertySetIds[j]));}metaObjectData.propertySetIds=propertySetGlobalIds;metaObjectData.originalSystemPropertySetIds=propertySetIds;}}else{metaObjectData.originalSystemPropertySetIds=metaObjectData.propertySetIds;}}}// Globalize global PropertySet IDs
if(metaModelData.propertySets){for(var _i480=0,_len96=metaModelData.propertySets.length;_i480<_len96;_i480++){var propertySet=metaModelData.propertySets[_i480];propertySet.originalSystemId=propertySet.id;if(globalize){propertySet.id=math.globalizeObjectId(this.id,propertySet.id);}}}}}]);return MetaModel;}();/**
 * @desc Metadata corresponding to a {@link Scene}.
 *
 * * Located in {@link Viewer#metaScene}.
 * * Contains {@link MetaModel}s and {@link MetaObject}s.
 * * [Scene graph example with metadata](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneGraph_metadata)
 */var MetaScene=/*#__PURE__*/function(){/**
     * @private
     */function MetaScene(viewer,scene){_classCallCheck(this,MetaScene);/**
         * The {@link Viewer}.
         * @property viewer
         * @type {Viewer}
         */this.viewer=viewer;/**
         * The {@link Scene}.
         * @property scene
         * @type {Scene}
         */this.scene=scene;/**
         * The {@link MetaModel}s belonging to this MetaScene, each mapped to its {@link MetaModel#modelId}.
         *
         * @type {{String:MetaModel}}
         */this.metaModels={};/**
         * The {@link PropertySet}s belonging to this MetaScene, each mapped to its {@link PropertySet#id}.
         *
         * @type {{String:PropertySet}}
         */this.propertySets={};/**
         * The {@link MetaObject}s belonging to this MetaScene, each mapped to its {@link MetaObject#id}.
         *
         * @type {{String:MetaObject}}
         */this.metaObjects={};/**
         * The {@link MetaObject}s belonging to this MetaScene, each mapped to its {@link MetaObject#type}.
         *
         * @type {{String:MetaObject}}
         */this.metaObjectsByType={};/**
         * The root {@link MetaObject}s belonging to this MetaScene, each mapped to its {@link MetaObject#id}.
         *
         * @type {{String:MetaObject}}
         */this.rootMetaObjects={};/**
         * Subscriptions to events sent with {@link fire}.
         * @private
         */this._eventSubs={};}/**
     * Subscribes to an event fired at this Viewer.
     *
     * @param {String} event The event
     * @param {Function} callback Callback fired on the event
     */_createClass(MetaScene,[{key:"on",value:function on(event,callback){var subs=this._eventSubs[event];if(!subs){subs=[];this._eventSubs[event]=subs;}subs.push(callback);}/**
     * Fires an event at this Viewer.
     *
     * @param {String} event Event name
     * @param {Object} value Event parameters
     */},{key:"fire",value:function fire(event,value){var subs=this._eventSubs[event];if(subs){for(var _i481=0,len=subs.length;_i481<len;_i481++){subs[_i481](value);}}}/**
     * Unsubscribes from an event fired at this Viewer.
     * @param event
     */},{key:"off",value:function off(event){// TODO
}/**
     * Creates a {@link MetaModel} in this MetaScene.
     *
     * The MetaModel will contain a hierarchy of {@link MetaObject}s, created from the
     * meta objects in ````metaModelData````.
     *
     * The meta object hierarchy in ````metaModelData```` is expected to be non-cyclic, with a single root. If the meta
     * objects are cyclic, then this method will log an error and attempt to recover by creating a dummy root MetaObject
     * of type "Model" and connecting all other MetaObjects as its direct children. If the meta objects contain multiple
     * roots, then this method similarly attempts to recover by creating a dummy root MetaObject of type "Model" and
     * connecting all the root MetaObjects as its children.
     *
     * @param {String} modelId ID for the new {@link MetaModel}, which will have {@link MetaModel#id} set to this value.
     * @param {Object} metaModelData Data for the {@link MetaModel}.
     * @param {Object} [options] Options for creating the {@link MetaModel}.
     * @param {Object} [options.includeTypes] When provided, only create {@link MetaObject}s with types in this list.
     * @param {Object} [options.excludeTypes] When provided, never create {@link MetaObject}s with types in this list.
     * @param {Boolean} [options.globalizeObjectIds=false] Whether to globalize each {@link MetaObject#id}. Set this ````true```` when you need to load multiple instances of the same meta model, to avoid ID clashes between the meta objects in the different instances.
     * @returns {MetaModel} The new MetaModel.
     */},{key:"createMetaModel",value:function createMetaModel(modelId,metaModelData){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var metaModel=new MetaModel({// Registers MetaModel in #metaModels
metaScene:this,id:modelId,projectId:metaModelData.projectId||"none",revisionId:metaModelData.revisionId||"none",author:metaModelData.author||"none",createdAt:metaModelData.createdAt||"none",creatingApplication:metaModelData.creatingApplication||"none",schema:metaModelData.schema||"none",propertySets:[]});metaModel.loadData(metaModelData);metaModel.finalize();return metaModel;}/**
     * Removes a {@link MetaModel} from this MetaScene.
     *
     * Fires a "metaModelDestroyed" event with the value of the {@link MetaModel#id}.
     *
     * @param {String} metaModelId ID of the target {@link MetaModel}.
     */},{key:"destroyMetaModel",value:function destroyMetaModel(metaModelId){var metaModel=this.metaModels[metaModelId];if(!metaModel){return;}// Remove global PropertySets
if(metaModel.propertySets){for(var _i482=0,len=metaModel.propertySets.length;_i482<len;_i482++){var propertySet=metaModel.propertySets[_i482];if(propertySet.metaModels.length===1&&propertySet.metaModels[0].id===metaModelId){// Property set owned only by this model, delete
delete this.propertySets[propertySet.id];}else{var newMetaModels=[];for(var j=0,lenj=propertySet.metaModels.length;j<lenj;j++){if(propertySet.metaModels[j].id!==metaModelId){newMetaModels.push(propertySet.metaModels[j]);}}propertySet.metaModels=newMetaModels;}}}// Remove MetaObjects
if(metaModel.metaObjects){for(var _i483=0,_len97=metaModel.metaObjects.length;_i483<_len97;_i483++){var metaObject=metaModel.metaObjects[_i483];metaObject.type;var id=metaObject.id;if(metaObject.metaModels.length===1&&metaObject.metaModels[0].id===metaModelId){// MetaObject owned only by this model, delete
delete this.metaObjects[id];if(!metaObject.parent){delete this.rootMetaObjects[id];}}}}// Re-link entire MetaObject parent/child hierarchy
for(var objectId in this.metaObjects){var _metaObject7=this.metaObjects[objectId];if(_metaObject7.children){_metaObject7.children=[];}// Re-link each MetaObject's property sets
if(_metaObject7.propertySets){_metaObject7.propertySets=[];}if(_metaObject7.propertySetIds){for(var _i484=0,_len98=_metaObject7.propertySetIds.length;_i484<_len98;_i484++){var propertySetId=_metaObject7.propertySetIds[_i484];var _propertySet=this.propertySets[propertySetId];_metaObject7.propertySets.push(_propertySet);}}}this.metaObjectsByType={};for(var _objectId4 in this.metaObjects){var _metaObject8=this.metaObjects[_objectId4];var type=_metaObject8.type;if(_metaObject8.children){_metaObject8.children=null;}(this.metaObjectsByType[type]||(this.metaObjectsByType[type]={}))[_objectId4]=_metaObject8;}for(var _objectId5 in this.metaObjects){var _metaObject9=this.metaObjects[_objectId5];if(_metaObject9.parentId){var parentMetaObject=this.metaObjects[_metaObject9.parentId];if(parentMetaObject){_metaObject9.parent=parentMetaObject;(parentMetaObject.children||(parentMetaObject.children=[])).push(_metaObject9);}}}delete this.metaModels[metaModelId];// Relink MetaObjects to their MetaModels
for(var _objectId6 in this.metaObjects){var _metaObject10=this.metaObjects[_objectId6];_metaObject10.metaModels=[];}for(var modelId in this.metaModels){var _metaModel=this.metaModels[modelId];for(var _i485=0,_len99=_metaModel.metaObjects.length;_i485<_len99;_i485++){var _metaObject11=_metaModel.metaObjects[_i485];_metaObject11.metaModels.push(_metaModel);}}this.fire("metaModelDestroyed",metaModelId);}/**
     * Gets the {@link MetaObject#id}s of the {@link MetaObject}s that have the given {@link MetaObject#type}.
     *
     * @param {String} type The type.
     * @returns {String[]} Array of {@link MetaObject#id}s.
     */},{key:"getObjectIDsByType",value:function getObjectIDsByType(type){var metaObjects=this.metaObjectsByType[type];return metaObjects?Object.keys(metaObjects):[];}/**
     * Gets the {@link MetaObject#id}s of the {@link MetaObject}s within the given subtree.
     *
     * @param {String} id  ID of the root {@link MetaObject} of the given subtree.
     * @param {String[]} [includeTypes] Optional list of types to include.
     * @param {String[]} [excludeTypes] Optional list of types to exclude.
     * @returns {String[]} Array of {@link MetaObject#id}s.
     */},{key:"getObjectIDsInSubtree",value:function getObjectIDsInSubtree(id,includeTypes,excludeTypes){var list=[];var metaObject=this.metaObjects[id];var includeMask=includeTypes&&includeTypes.length>0?arrayToMap(includeTypes):null;var excludeMask=excludeTypes&&excludeTypes.length>0?arrayToMap(excludeTypes):null;var visit=function visit(metaObject){if(!metaObject){return;}var include=true;if(excludeMask&&excludeMask[metaObject.type]){include=false;}else if(includeMask&&!includeMask[metaObject.type]){include=false;}if(include){list.push(metaObject.id);}var children=metaObject.children;if(children){for(var i=0,len=children.length;i<len;i++){visit(children[i]);}}};visit(metaObject);return list;}/**
     * Iterates over the {@link MetaObject}s within the subtree.
     *
     * @param {String} id ID of root {@link MetaObject}.
     * @param {Function} callback Callback fired at each {@link MetaObject}.
     */},{key:"withMetaObjectsInSubtree",value:function withMetaObjectsInSubtree(id,callback){var metaObject=this.metaObjects[id];if(!metaObject){return;}metaObject.withMetaObjectsInSubtree(callback);}}]);return MetaScene;}();function arrayToMap(array){var map={};for(var i=0,len=array.length;i<len;i++){map[array[i]]=true;}return map;}/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */ /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(Object.prototype.hasOwnProperty.call(b,p))d[p]=b[p];}};return _extendStatics(d,b);};function __extends(d,b){if(typeof b!=="function"&&b!==null)throw new TypeError("Class extends value "+String(b)+" is not a constructor or null");_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}var _assign=function __assign(){_assign=Object.assign||function __assign(t){for(var s,i=1,n=arguments.length;i<n;i++){s=arguments[i];for(var p in s){if(Object.prototype.hasOwnProperty.call(s,p))t[p]=s[p];}}return t;};return _assign.apply(this,arguments);};function __awaiter(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});}function __generator(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}}function __spreadArray(to,from,pack){if(pack||arguments.length===2)for(var i=0,l=from.length,ar;i<l;i++){if(ar||!(i in from)){if(!ar)ar=Array.prototype.slice.call(from,0,i);ar[i]=from[i];}}return to.concat(ar||from);}var Bounds=/** @class */function(){function Bounds(left,top,width,height){this.left=left;this.top=top;this.width=width;this.height=height;}Bounds.prototype.add=function(x,y,w,h){return new Bounds(this.left+x,this.top+y,this.width+w,this.height+h);};Bounds.fromClientRect=function(context,clientRect){return new Bounds(clientRect.left+context.windowBounds.left,clientRect.top+context.windowBounds.top,clientRect.width,clientRect.height);};Bounds.fromDOMRectList=function(context,domRectList){var domRect=Array.from(domRectList).find(function(rect){return rect.width!==0;});return domRect?new Bounds(domRect.left+context.windowBounds.left,domRect.top+context.windowBounds.top,domRect.width,domRect.height):Bounds.EMPTY;};Bounds.EMPTY=new Bounds(0,0,0,0);return Bounds;}();var parseBounds=function parseBounds(context,node){return Bounds.fromClientRect(context,node.getBoundingClientRect());};var parseDocumentSize=function parseDocumentSize(document){var body=document.body;var documentElement=document.documentElement;if(!body||!documentElement){throw new Error("Unable to get document size");}var width=Math.max(Math.max(body.scrollWidth,documentElement.scrollWidth),Math.max(body.offsetWidth,documentElement.offsetWidth),Math.max(body.clientWidth,documentElement.clientWidth));var height=Math.max(Math.max(body.scrollHeight,documentElement.scrollHeight),Math.max(body.offsetHeight,documentElement.offsetHeight),Math.max(body.clientHeight,documentElement.clientHeight));return new Bounds(0,0,width,height);};/*
 * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */var toCodePoints$1=function toCodePoints$1(str){var codePoints=[];var i=0;var length=str.length;while(i<length){var value=str.charCodeAt(i++);if(value>=0xd800&&value<=0xdbff&&i<length){var extra=str.charCodeAt(i++);if((extra&0xfc00)===0xdc00){codePoints.push(((value&0x3ff)<<10)+(extra&0x3ff)+0x10000);}else{codePoints.push(value);i--;}}else{codePoints.push(value);}}return codePoints;};var fromCodePoint$1=function fromCodePoint$1(){var codePoints=[];for(var _i=0;_i<arguments.length;_i++){codePoints[_i]=arguments[_i];}if(String.fromCodePoint){return String.fromCodePoint.apply(String,codePoints);}var length=codePoints.length;if(!length){return'';}var codeUnits=[];var index=-1;var result='';while(++index<length){var codePoint=codePoints[index];if(codePoint<=0xffff){codeUnits.push(codePoint);}else{codePoint-=0x10000;codeUnits.push((codePoint>>10)+0xd800,codePoint%0x400+0xdc00);}if(index+1===length||codeUnits.length>0x4000){result+=String.fromCharCode.apply(String,codeUnits);codeUnits.length=0;}}return result;};var chars$2='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';// Use a lookup table to find the index.
var lookup$2=typeof Uint8Array==='undefined'?[]:new Uint8Array(256);for(var i$2=0;i$2<chars$2.length;i$2++){lookup$2[chars$2.charCodeAt(i$2)]=i$2;}/*
 * utrie 1.0.2 <https://github.com/niklasvh/utrie>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */var chars$1$1='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';// Use a lookup table to find the index.
var lookup$1$1=typeof Uint8Array==='undefined'?[]:new Uint8Array(256);for(var i$1$1=0;i$1$1<chars$1$1.length;i$1$1++){lookup$1$1[chars$1$1.charCodeAt(i$1$1)]=i$1$1;}var decode$1$1=function decode$1$1(base64){var bufferLength=base64.length*0.75,len=base64.length,i,p=0,encoded1,encoded2,encoded3,encoded4;if(base64[base64.length-1]==='='){bufferLength--;if(base64[base64.length-2]==='='){bufferLength--;}}var buffer=typeof ArrayBuffer!=='undefined'&&typeof Uint8Array!=='undefined'&&typeof Uint8Array.prototype.slice!=='undefined'?new ArrayBuffer(bufferLength):new Array(bufferLength);var bytes=Array.isArray(buffer)?buffer:new Uint8Array(buffer);for(i=0;i<len;i+=4){encoded1=lookup$1$1[base64.charCodeAt(i)];encoded2=lookup$1$1[base64.charCodeAt(i+1)];encoded3=lookup$1$1[base64.charCodeAt(i+2)];encoded4=lookup$1$1[base64.charCodeAt(i+3)];bytes[p++]=encoded1<<2|encoded2>>4;bytes[p++]=(encoded2&15)<<4|encoded3>>2;bytes[p++]=(encoded3&3)<<6|encoded4&63;}return buffer;};var polyUint16Array$1=function polyUint16Array$1(buffer){var length=buffer.length;var bytes=[];for(var i=0;i<length;i+=2){bytes.push(buffer[i+1]<<8|buffer[i]);}return bytes;};var polyUint32Array$1=function polyUint32Array$1(buffer){var length=buffer.length;var bytes=[];for(var i=0;i<length;i+=4){bytes.push(buffer[i+3]<<24|buffer[i+2]<<16|buffer[i+1]<<8|buffer[i]);}return bytes;};/** Shift size for getting the index-2 table offset. */var UTRIE2_SHIFT_2$1=5;/** Shift size for getting the index-1 table offset. */var UTRIE2_SHIFT_1$1=6+5;/**
 * Shift size for shifting left the index array values.
 * Increases possible data size with 16-bit index values at the cost
 * of compactability.
 * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
 */var UTRIE2_INDEX_SHIFT$1=2;/**
 * Difference between the two shift sizes,
 * for getting an index-1 offset from an index-2 offset. 6=11-5
 */var UTRIE2_SHIFT_1_2$1=UTRIE2_SHIFT_1$1-UTRIE2_SHIFT_2$1;/**
 * The part of the index-2 table for U+D800..U+DBFF stores values for
 * lead surrogate code _units_ not code _points_.
 * Values for lead surrogate code _points_ are indexed with this portion of the table.
 * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
 */var UTRIE2_LSCP_INDEX_2_OFFSET$1=0x10000>>UTRIE2_SHIFT_2$1;/** Number of entries in a data block. 32=0x20 */var UTRIE2_DATA_BLOCK_LENGTH$1=1<<UTRIE2_SHIFT_2$1;/** Mask for getting the lower bits for the in-data-block offset. */var UTRIE2_DATA_MASK$1=UTRIE2_DATA_BLOCK_LENGTH$1-1;var UTRIE2_LSCP_INDEX_2_LENGTH$1=0x400>>UTRIE2_SHIFT_2$1;/** Count the lengths of both BMP pieces. 2080=0x820 */var UTRIE2_INDEX_2_BMP_LENGTH$1=UTRIE2_LSCP_INDEX_2_OFFSET$1+UTRIE2_LSCP_INDEX_2_LENGTH$1;/**
 * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
 * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
 */var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1=UTRIE2_INDEX_2_BMP_LENGTH$1;var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1=0x800>>6;/* U+0800 is the first code point after 2-byte UTF-8 */ /**
 * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
 * Variable length, for code points up to highStart, where the last single-value range starts.
 * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
 * (For 0x100000 supplementary code points U+10000..U+10ffff.)
 *
 * The part of the index-2 table for supplementary code points starts
 * after this index-1 table.
 *
 * Both the index-1 table and the following part of the index-2 table
 * are omitted completely if there is only BMP data.
 */var UTRIE2_INDEX_1_OFFSET$1=UTRIE2_UTF8_2B_INDEX_2_OFFSET$1+UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;/**
 * Number of index-1 entries for the BMP. 32=0x20
 * This part of the index-1 table is omitted from the serialized form.
 */var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1=0x10000>>UTRIE2_SHIFT_1$1;/** Number of entries in an index-2 block. 64=0x40 */var UTRIE2_INDEX_2_BLOCK_LENGTH$1=1<<UTRIE2_SHIFT_1_2$1;/** Mask for getting the lower bits for the in-index-2-block offset. */var UTRIE2_INDEX_2_MASK$1=UTRIE2_INDEX_2_BLOCK_LENGTH$1-1;var slice16$1=function slice16$1(view,start,end){if(view.slice){return view.slice(start,end);}return new Uint16Array(Array.prototype.slice.call(view,start,end));};var slice32$1=function slice32$1(view,start,end){if(view.slice){return view.slice(start,end);}return new Uint32Array(Array.prototype.slice.call(view,start,end));};var createTrieFromBase64$1=function createTrieFromBase64$1(base64,_byteLength){var buffer=decode$1$1(base64);var view32=Array.isArray(buffer)?polyUint32Array$1(buffer):new Uint32Array(buffer);var view16=Array.isArray(buffer)?polyUint16Array$1(buffer):new Uint16Array(buffer);var headerLength=24;var index=slice16$1(view16,headerLength/2,view32[4]/2);var data=view32[5]===2?slice16$1(view16,(headerLength+view32[4])/2):slice32$1(view32,Math.ceil((headerLength+view32[4])/4));return new Trie$1(view32[0],view32[1],view32[2],view32[3],index,data);};var Trie$1=/** @class */function(){function Trie(initialValue,errorValue,highStart,highValueIndex,index,data){this.initialValue=initialValue;this.errorValue=errorValue;this.highStart=highStart;this.highValueIndex=highValueIndex;this.index=index;this.data=data;}/**
     * Get the value for a code point as stored in the Trie.
     *
     * @param codePoint the code point
     * @return the value
     */Trie.prototype.get=function(codePoint){var ix;if(codePoint>=0){if(codePoint<0x0d800||codePoint>0x0dbff&&codePoint<=0x0ffff){// Ordinary BMP code point, excluding leading surrogates.
// BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
// 16 bit data is stored in the index array itself.
ix=this.index[codePoint>>UTRIE2_SHIFT_2$1];ix=(ix<<UTRIE2_INDEX_SHIFT$1)+(codePoint&UTRIE2_DATA_MASK$1);return this.data[ix];}if(codePoint<=0xffff){// Lead Surrogate Code Point.  A Separate index section is stored for
// lead surrogate code units and code points.
//   The main index has the code unit data.
//   For this function, we need the code point data.
// Note: this expression could be refactored for slightly improved efficiency, but
//       surrogate code points will be so rare in practice that it's not worth it.
ix=this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1+(codePoint-0xd800>>UTRIE2_SHIFT_2$1)];ix=(ix<<UTRIE2_INDEX_SHIFT$1)+(codePoint&UTRIE2_DATA_MASK$1);return this.data[ix];}if(codePoint<this.highStart){// Supplemental code point, use two-level lookup.
ix=UTRIE2_INDEX_1_OFFSET$1-UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1+(codePoint>>UTRIE2_SHIFT_1$1);ix=this.index[ix];ix+=codePoint>>UTRIE2_SHIFT_2$1&UTRIE2_INDEX_2_MASK$1;ix=this.index[ix];ix=(ix<<UTRIE2_INDEX_SHIFT$1)+(codePoint&UTRIE2_DATA_MASK$1);return this.data[ix];}if(codePoint<=0x10ffff){return this.data[this.highValueIndex];}}// Fall through.  The code point is outside of the legal range of 0..0x10ffff.
return this.errorValue;};return Trie;}();/*
 * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */var chars$3='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';// Use a lookup table to find the index.
var lookup$3=typeof Uint8Array==='undefined'?[]:new Uint8Array(256);for(var i$3=0;i$3<chars$3.length;i$3++){lookup$3[chars$3.charCodeAt(i$3)]=i$3;}var base64$1='KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';var LETTER_NUMBER_MODIFIER=50;// Non-tailorable Line Breaking Classes
var BK=1;//  Cause a line break (after)
var CR$1=2;//  Cause a line break (after), except between CR and LF
var LF$1=3;//  Cause a line break (after)
var CM=4;//  Prohibit a line break between the character and the preceding character
var NL=5;//  Cause a line break (after)
var WJ=7;//  Prohibit line breaks before and after
var ZW=8;//  Provide a break opportunity
var GL=9;//  Prohibit line breaks before and after
var SP=10;// Enable indirect line breaks
var ZWJ$1=11;// Prohibit line breaks within joiner sequences
// Break Opportunities
var B2=12;//  Provide a line break opportunity before and after the character
var BA=13;//  Generally provide a line break opportunity after the character
var BB=14;//  Generally provide a line break opportunity before the character
var HY=15;//  Provide a line break opportunity after the character, except in numeric context
var CB=16;//   Provide a line break opportunity contingent on additional information
// Characters Prohibiting Certain Breaks
var CL=17;//  Prohibit line breaks before
var CP=18;//  Prohibit line breaks before
var EX=19;//  Prohibit line breaks before
var IN=20;//  Allow only indirect line breaks between pairs
var NS=21;//  Allow only indirect line breaks before
var OP=22;//  Prohibit line breaks after
var QU=23;//  Act like they are both opening and closing
// Numeric Context
var IS=24;//  Prevent breaks after any and before numeric
var NU=25;//  Form numeric expressions for line breaking purposes
var PO=26;//  Do not break following a numeric expression
var PR=27;//  Do not break in front of a numeric expression
var SY=28;//  Prevent a break before; and allow a break after
// Other Characters
var AI=29;//  Act like AL when the resolvedEAW is N; otherwise; act as ID
var AL=30;//  Are alphabetic characters or symbols that are used with alphabetic characters
var CJ=31;//  Treat as NS or ID for strict or normal breaking.
var EB=32;//  Do not break from following Emoji Modifier
var EM=33;//  Do not break from preceding Emoji Base
var H2=34;//  Form Korean syllable blocks
var H3=35;//  Form Korean syllable blocks
var HL=36;//  Do not break around a following hyphen; otherwise act as Alphabetic
var ID=37;//  Break before or after; except in some numeric context
var JL=38;//  Form Korean syllable blocks
var JV=39;//  Form Korean syllable blocks
var JT=40;//  Form Korean syllable blocks
var RI$1=41;//  Keep pairs together. For pairs; break before and after other classes
var SA=42;//  Provide a line break opportunity contingent on additional, language-specific context analysis
var XX=43;//  Have as yet unknown line breaking behavior or unassigned code positions
var ea_OP=[0x2329,0xff08];var BREAK_MANDATORY='!';var BREAK_NOT_ALLOWED$1='';var BREAK_ALLOWED$1='';var UnicodeTrie$1=createTrieFromBase64$1(base64$1);var ALPHABETICS=[AL,HL];var HARD_LINE_BREAKS=[BK,CR$1,LF$1,NL];var SPACE$1=[SP,ZW];var PREFIX_POSTFIX=[PR,PO];var LINE_BREAKS=HARD_LINE_BREAKS.concat(SPACE$1);var KOREAN_SYLLABLE_BLOCK=[JL,JV,JT,H2,H3];var HYPHEN=[HY,BA];var codePointsToCharacterClasses=function codePointsToCharacterClasses(codePoints,lineBreak){if(lineBreak===void 0){lineBreak='strict';}var types=[];var indices=[];var categories=[];codePoints.forEach(function(codePoint,index){var classType=UnicodeTrie$1.get(codePoint);if(classType>LETTER_NUMBER_MODIFIER){categories.push(true);classType-=LETTER_NUMBER_MODIFIER;}else{categories.push(false);}if(['normal','auto','loose'].indexOf(lineBreak)!==-1){// U+2010,  U+2013,  U+301C,  U+30A0
if([0x2010,0x2013,0x301c,0x30a0].indexOf(codePoint)!==-1){indices.push(index);return types.push(CB);}}if(classType===CM||classType===ZWJ$1){// LB10 Treat any remaining combining mark or ZWJ as AL.
if(index===0){indices.push(index);return types.push(AL);}// LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
// the base character in all of the following rules. Treat ZWJ as if it were CM.
var prev=types[index-1];if(LINE_BREAKS.indexOf(prev)===-1){indices.push(indices[index-1]);return types.push(prev);}indices.push(index);return types.push(AL);}indices.push(index);if(classType===CJ){return types.push(lineBreak==='strict'?NS:ID);}if(classType===SA){return types.push(AL);}if(classType===AI){return types.push(AL);}// For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
// and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
// to take into account the actual line breaking properties for these characters.
if(classType===XX){if(codePoint>=0x20000&&codePoint<=0x2fffd||codePoint>=0x30000&&codePoint<=0x3fffd){return types.push(ID);}else{return types.push(AL);}}types.push(classType);});return[indices,types,categories];};var isAdjacentWithSpaceIgnored=function isAdjacentWithSpaceIgnored(a,b,currentIndex,classTypes){var current=classTypes[currentIndex];if(Array.isArray(a)?a.indexOf(current)!==-1:a===current){var i=currentIndex;while(i<=classTypes.length){i++;var next=classTypes[i];if(next===b){return true;}if(next!==SP){break;}}}if(current===SP){var i=currentIndex;while(i>0){i--;var prev=classTypes[i];if(Array.isArray(a)?a.indexOf(prev)!==-1:a===prev){var n=currentIndex;while(n<=classTypes.length){n++;var next=classTypes[n];if(next===b){return true;}if(next!==SP){break;}}}if(prev!==SP){break;}}}return false;};var previousNonSpaceClassType=function previousNonSpaceClassType(currentIndex,classTypes){var i=currentIndex;while(i>=0){var type=classTypes[i];if(type===SP){i--;}else{return type;}}return 0;};var _lineBreakAtIndex=function _lineBreakAtIndex(codePoints,classTypes,indicies,index,forbiddenBreaks){if(indicies[index]===0){return BREAK_NOT_ALLOWED$1;}var currentIndex=index-1;if(Array.isArray(forbiddenBreaks)&&forbiddenBreaks[currentIndex]===true){return BREAK_NOT_ALLOWED$1;}var beforeIndex=currentIndex-1;var afterIndex=currentIndex+1;var current=classTypes[currentIndex];// LB4 Always break after hard line breaks.
// LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
var before=beforeIndex>=0?classTypes[beforeIndex]:0;var next=classTypes[afterIndex];if(current===CR$1&&next===LF$1){return BREAK_NOT_ALLOWED$1;}if(HARD_LINE_BREAKS.indexOf(current)!==-1){return BREAK_MANDATORY;}// LB6 Do not break before hard line breaks.
if(HARD_LINE_BREAKS.indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// LB7 Do not break before spaces or zero width space.
if(SPACE$1.indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
if(previousNonSpaceClassType(currentIndex,classTypes)===ZW){return BREAK_ALLOWED$1;}// LB8a Do not break after a zero width joiner.
if(UnicodeTrie$1.get(codePoints[currentIndex])===ZWJ$1){return BREAK_NOT_ALLOWED$1;}// zwj emojis
if((current===EB||current===EM)&&UnicodeTrie$1.get(codePoints[afterIndex])===ZWJ$1){return BREAK_NOT_ALLOWED$1;}// LB11 Do not break before or after Word joiner and related characters.
if(current===WJ||next===WJ){return BREAK_NOT_ALLOWED$1;}// LB12 Do not break after NBSP and related characters.
if(current===GL){return BREAK_NOT_ALLOWED$1;}// LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
if([SP,BA,HY].indexOf(current)===-1&&next===GL){return BREAK_NOT_ALLOWED$1;}// LB13 Do not break before ] or ! or ; or /, even after spaces.
if([CL,CP,EX,IS,SY].indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// LB14 Do not break after [, even after spaces.
if(previousNonSpaceClassType(currentIndex,classTypes)===OP){return BREAK_NOT_ALLOWED$1;}// LB15 Do not break within [, even with intervening spaces.
if(isAdjacentWithSpaceIgnored(QU,OP,currentIndex,classTypes)){return BREAK_NOT_ALLOWED$1;}// LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
if(isAdjacentWithSpaceIgnored([CL,CP],NS,currentIndex,classTypes)){return BREAK_NOT_ALLOWED$1;}// LB17 Do not break within , even with intervening spaces.
if(isAdjacentWithSpaceIgnored(B2,B2,currentIndex,classTypes)){return BREAK_NOT_ALLOWED$1;}// LB18 Break after spaces.
if(current===SP){return BREAK_ALLOWED$1;}// LB19 Do not break before or after quotation marks, such as   .
if(current===QU||next===QU){return BREAK_NOT_ALLOWED$1;}// LB20 Break before and after unresolved CB.
if(next===CB||current===CB){return BREAK_ALLOWED$1;}// LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
if([BA,HY,NS].indexOf(next)!==-1||current===BB){return BREAK_NOT_ALLOWED$1;}// LB21a Don't break after Hebrew + Hyphen.
if(before===HL&&HYPHEN.indexOf(current)!==-1){return BREAK_NOT_ALLOWED$1;}// LB21b Dont break between Solidus and Hebrew letters.
if(current===SY&&next===HL){return BREAK_NOT_ALLOWED$1;}// LB22 Do not break before ellipsis.
if(next===IN){return BREAK_NOT_ALLOWED$1;}// LB23 Do not break between digits and letters.
if(ALPHABETICS.indexOf(next)!==-1&&current===NU||ALPHABETICS.indexOf(current)!==-1&&next===NU){return BREAK_NOT_ALLOWED$1;}// LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
if(current===PR&&[ID,EB,EM].indexOf(next)!==-1||[ID,EB,EM].indexOf(current)!==-1&&next===PO){return BREAK_NOT_ALLOWED$1;}// LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
if(ALPHABETICS.indexOf(current)!==-1&&PREFIX_POSTFIX.indexOf(next)!==-1||PREFIX_POSTFIX.indexOf(current)!==-1&&ALPHABETICS.indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// LB25 Do not break between the following pairs of classes relevant to numbers:
if(// (PR | PO)  ( OP | HY )? NU
[PR,PO].indexOf(current)!==-1&&(next===NU||[OP,HY].indexOf(next)!==-1&&classTypes[afterIndex+1]===NU)||// ( OP | HY )  NU
[OP,HY].indexOf(current)!==-1&&next===NU||// NU 	(NU | SY | IS)
current===NU&&[NU,SY,IS].indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// NU (NU | SY | IS)*  (NU | SY | IS | CL | CP)
if([NU,SY,IS,CL,CP].indexOf(next)!==-1){var prevIndex=currentIndex;while(prevIndex>=0){var type=classTypes[prevIndex];if(type===NU){return BREAK_NOT_ALLOWED$1;}else if([SY,IS].indexOf(type)!==-1){prevIndex--;}else{break;}}}// NU (NU | SY | IS)* (CL | CP)?  (PO | PR))
if([PR,PO].indexOf(next)!==-1){var prevIndex=[CL,CP].indexOf(current)!==-1?beforeIndex:currentIndex;while(prevIndex>=0){var type=classTypes[prevIndex];if(type===NU){return BREAK_NOT_ALLOWED$1;}else if([SY,IS].indexOf(type)!==-1){prevIndex--;}else{break;}}}// LB26 Do not break a Korean syllable.
if(JL===current&&[JL,JV,H2,H3].indexOf(next)!==-1||[JV,H2].indexOf(current)!==-1&&[JV,JT].indexOf(next)!==-1||[JT,H3].indexOf(current)!==-1&&next===JT){return BREAK_NOT_ALLOWED$1;}// LB27 Treat a Korean Syllable Block the same as ID.
if(KOREAN_SYLLABLE_BLOCK.indexOf(current)!==-1&&[IN,PO].indexOf(next)!==-1||KOREAN_SYLLABLE_BLOCK.indexOf(next)!==-1&&current===PR){return BREAK_NOT_ALLOWED$1;}// LB28 Do not break between alphabetics (at).
if(ALPHABETICS.indexOf(current)!==-1&&ALPHABETICS.indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// LB29 Do not break between numeric punctuation and alphabetics (e.g.).
if(current===IS&&ALPHABETICS.indexOf(next)!==-1){return BREAK_NOT_ALLOWED$1;}// LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
if(ALPHABETICS.concat(NU).indexOf(current)!==-1&&next===OP&&ea_OP.indexOf(codePoints[afterIndex])===-1||ALPHABETICS.concat(NU).indexOf(next)!==-1&&current===CP){return BREAK_NOT_ALLOWED$1;}// LB30a Break between two regional indicator symbols if and only if there are an even number of regional
// indicators preceding the position of the break.
if(current===RI$1&&next===RI$1){var i=indicies[currentIndex];var count=1;while(i>0){i--;if(classTypes[i]===RI$1){count++;}else{break;}}if(count%2!==0){return BREAK_NOT_ALLOWED$1;}}// LB30b Do not break between an emoji base and an emoji modifier.
if(current===EB&&next===EM){return BREAK_NOT_ALLOWED$1;}return BREAK_ALLOWED$1;};var cssFormattedClasses=function cssFormattedClasses(codePoints,options){if(!options){options={lineBreak:'normal',wordBreak:'normal'};}var _a=codePointsToCharacterClasses(codePoints,options.lineBreak),indicies=_a[0],classTypes=_a[1],isLetterNumber=_a[2];if(options.wordBreak==='break-all'||options.wordBreak==='break-word'){classTypes=classTypes.map(function(type){return[NU,AL,SA].indexOf(type)!==-1?ID:type;});}var forbiddenBreakpoints=options.wordBreak==='keep-all'?isLetterNumber.map(function(letterNumber,i){return letterNumber&&codePoints[i]>=0x4e00&&codePoints[i]<=0x9fff;}):undefined;return[indicies,classTypes,forbiddenBreakpoints];};var Break=/** @class */function(){function Break(codePoints,lineBreak,start,end){this.codePoints=codePoints;this.required=lineBreak===BREAK_MANDATORY;this.start=start;this.end=end;}Break.prototype.slice=function(){return fromCodePoint$1.apply(void 0,this.codePoints.slice(this.start,this.end));};return Break;}();var LineBreaker=function LineBreaker(str,options){var codePoints=toCodePoints$1(str);var _a=cssFormattedClasses(codePoints,options),indicies=_a[0],classTypes=_a[1],forbiddenBreakpoints=_a[2];var length=codePoints.length;var lastEnd=0;var nextIndex=0;return{next:function next(){if(nextIndex>=length){return{done:true,value:null};}var lineBreak=BREAK_NOT_ALLOWED$1;while(nextIndex<length&&(lineBreak=_lineBreakAtIndex(codePoints,classTypes,indicies,++nextIndex,forbiddenBreakpoints))===BREAK_NOT_ALLOWED$1){}if(lineBreak!==BREAK_NOT_ALLOWED$1||nextIndex===length){var value=new Break(codePoints,lineBreak,lastEnd,nextIndex);lastEnd=nextIndex;return{value:value,done:false};}return{done:true,value:null};}};};// https://www.w3.org/TR/css-syntax-3
var FLAG_UNRESTRICTED=1<<0;var FLAG_ID=1<<1;var FLAG_INTEGER=1<<2;var FLAG_NUMBER=1<<3;var LINE_FEED=0x000a;var SOLIDUS=0x002f;var REVERSE_SOLIDUS=0x005c;var CHARACTER_TABULATION=0x0009;var SPACE=0x0020;var QUOTATION_MARK=0x0022;var EQUALS_SIGN=0x003d;var NUMBER_SIGN=0x0023;var DOLLAR_SIGN=0x0024;var PERCENTAGE_SIGN=0x0025;var APOSTROPHE=0x0027;var LEFT_PARENTHESIS=0x0028;var RIGHT_PARENTHESIS=0x0029;var LOW_LINE=0x005f;var HYPHEN_MINUS=0x002d;var EXCLAMATION_MARK=0x0021;var LESS_THAN_SIGN=0x003c;var GREATER_THAN_SIGN=0x003e;var COMMERCIAL_AT=0x0040;var LEFT_SQUARE_BRACKET=0x005b;var RIGHT_SQUARE_BRACKET=0x005d;var CIRCUMFLEX_ACCENT=0x003d;var LEFT_CURLY_BRACKET=0x007b;var QUESTION_MARK=0x003f;var RIGHT_CURLY_BRACKET=0x007d;var VERTICAL_LINE=0x007c;var TILDE=0x007e;var CONTROL=0x0080;var REPLACEMENT_CHARACTER=0xfffd;var ASTERISK=0x002a;var PLUS_SIGN=0x002b;var COMMA=0x002c;var COLON=0x003a;var SEMICOLON=0x003b;var FULL_STOP=0x002e;var NULL=0x0000;var BACKSPACE=0x0008;var LINE_TABULATION=0x000b;var SHIFT_OUT=0x000e;var INFORMATION_SEPARATOR_ONE=0x001f;var DELETE=0x007f;var EOF=-1;var ZERO=0x0030;var a$1=0x0061;var e=0x0065;var f$1=0x0066;var u=0x0075;var z=0x007a;var A=0x0041;var E=0x0045;var F=0x0046;var U=0x0055;var Z=0x005a;var isDigit=function isDigit(codePoint){return codePoint>=ZERO&&codePoint<=0x0039;};var isSurrogateCodePoint=function isSurrogateCodePoint(codePoint){return codePoint>=0xd800&&codePoint<=0xdfff;};var isHex=function isHex(codePoint){return isDigit(codePoint)||codePoint>=A&&codePoint<=F||codePoint>=a$1&&codePoint<=f$1;};var isLowerCaseLetter=function isLowerCaseLetter(codePoint){return codePoint>=a$1&&codePoint<=z;};var isUpperCaseLetter=function isUpperCaseLetter(codePoint){return codePoint>=A&&codePoint<=Z;};var isLetter=function isLetter(codePoint){return isLowerCaseLetter(codePoint)||isUpperCaseLetter(codePoint);};var isNonASCIICodePoint=function isNonASCIICodePoint(codePoint){return codePoint>=CONTROL;};var isWhiteSpace=function isWhiteSpace(codePoint){return codePoint===LINE_FEED||codePoint===CHARACTER_TABULATION||codePoint===SPACE;};var isNameStartCodePoint=function isNameStartCodePoint(codePoint){return isLetter(codePoint)||isNonASCIICodePoint(codePoint)||codePoint===LOW_LINE;};var isNameCodePoint=function isNameCodePoint(codePoint){return isNameStartCodePoint(codePoint)||isDigit(codePoint)||codePoint===HYPHEN_MINUS;};var isNonPrintableCodePoint=function isNonPrintableCodePoint(codePoint){return codePoint>=NULL&&codePoint<=BACKSPACE||codePoint===LINE_TABULATION||codePoint>=SHIFT_OUT&&codePoint<=INFORMATION_SEPARATOR_ONE||codePoint===DELETE;};var isValidEscape=function isValidEscape(c1,c2){if(c1!==REVERSE_SOLIDUS){return false;}return c2!==LINE_FEED;};var isIdentifierStart=function isIdentifierStart(c1,c2,c3){if(c1===HYPHEN_MINUS){return isNameStartCodePoint(c2)||isValidEscape(c2,c3);}else if(isNameStartCodePoint(c1)){return true;}else if(c1===REVERSE_SOLIDUS&&isValidEscape(c1,c2)){return true;}return false;};var isNumberStart=function isNumberStart(c1,c2,c3){if(c1===PLUS_SIGN||c1===HYPHEN_MINUS){if(isDigit(c2)){return true;}return c2===FULL_STOP&&isDigit(c3);}if(c1===FULL_STOP){return isDigit(c2);}return isDigit(c1);};var stringToNumber=function stringToNumber(codePoints){var c=0;var sign=1;if(codePoints[c]===PLUS_SIGN||codePoints[c]===HYPHEN_MINUS){if(codePoints[c]===HYPHEN_MINUS){sign=-1;}c++;}var integers=[];while(isDigit(codePoints[c])){integers.push(codePoints[c++]);}var _int=integers.length?parseInt(fromCodePoint$1.apply(void 0,integers),10):0;if(codePoints[c]===FULL_STOP){c++;}var fraction=[];while(isDigit(codePoints[c])){fraction.push(codePoints[c++]);}var fracd=fraction.length;var frac=fracd?parseInt(fromCodePoint$1.apply(void 0,fraction),10):0;if(codePoints[c]===E||codePoints[c]===e){c++;}var expsign=1;if(codePoints[c]===PLUS_SIGN||codePoints[c]===HYPHEN_MINUS){if(codePoints[c]===HYPHEN_MINUS){expsign=-1;}c++;}var exponent=[];while(isDigit(codePoints[c])){exponent.push(codePoints[c++]);}var exp=exponent.length?parseInt(fromCodePoint$1.apply(void 0,exponent),10):0;return sign*(_int+frac*Math.pow(10,-fracd))*Math.pow(10,expsign*exp);};var LEFT_PARENTHESIS_TOKEN={type:2/* LEFT_PARENTHESIS_TOKEN */};var RIGHT_PARENTHESIS_TOKEN={type:3/* RIGHT_PARENTHESIS_TOKEN */};var COMMA_TOKEN={type:4/* COMMA_TOKEN */};var SUFFIX_MATCH_TOKEN={type:13/* SUFFIX_MATCH_TOKEN */};var PREFIX_MATCH_TOKEN={type:8/* PREFIX_MATCH_TOKEN */};var COLUMN_TOKEN={type:21/* COLUMN_TOKEN */};var DASH_MATCH_TOKEN={type:9/* DASH_MATCH_TOKEN */};var INCLUDE_MATCH_TOKEN={type:10/* INCLUDE_MATCH_TOKEN */};var LEFT_CURLY_BRACKET_TOKEN={type:11/* LEFT_CURLY_BRACKET_TOKEN */};var RIGHT_CURLY_BRACKET_TOKEN={type:12/* RIGHT_CURLY_BRACKET_TOKEN */};var SUBSTRING_MATCH_TOKEN={type:14/* SUBSTRING_MATCH_TOKEN */};var BAD_URL_TOKEN={type:23/* BAD_URL_TOKEN */};var BAD_STRING_TOKEN={type:1/* BAD_STRING_TOKEN */};var CDO_TOKEN={type:25/* CDO_TOKEN */};var CDC_TOKEN={type:24/* CDC_TOKEN */};var COLON_TOKEN={type:26/* COLON_TOKEN */};var SEMICOLON_TOKEN={type:27/* SEMICOLON_TOKEN */};var LEFT_SQUARE_BRACKET_TOKEN={type:28/* LEFT_SQUARE_BRACKET_TOKEN */};var RIGHT_SQUARE_BRACKET_TOKEN={type:29/* RIGHT_SQUARE_BRACKET_TOKEN */};var WHITESPACE_TOKEN={type:31/* WHITESPACE_TOKEN */};var EOF_TOKEN={type:32/* EOF_TOKEN */};var Tokenizer=/** @class */function(){function Tokenizer(){this._value=[];}Tokenizer.prototype.write=function(chunk){this._value=this._value.concat(toCodePoints$1(chunk));};Tokenizer.prototype.read=function(){var tokens=[];var token=this.consumeToken();while(token!==EOF_TOKEN){tokens.push(token);token=this.consumeToken();}return tokens;};Tokenizer.prototype.consumeToken=function(){var codePoint=this.consumeCodePoint();switch(codePoint){case QUOTATION_MARK:return this.consumeStringToken(QUOTATION_MARK);case NUMBER_SIGN:var c1=this.peekCodePoint(0);var c2=this.peekCodePoint(1);var c3=this.peekCodePoint(2);if(isNameCodePoint(c1)||isValidEscape(c2,c3)){var flags=isIdentifierStart(c1,c2,c3)?FLAG_ID:FLAG_UNRESTRICTED;var value=this.consumeName();return{type:5/* HASH_TOKEN */,value:value,flags:flags};}break;case DOLLAR_SIGN:if(this.peekCodePoint(0)===EQUALS_SIGN){this.consumeCodePoint();return SUFFIX_MATCH_TOKEN;}break;case APOSTROPHE:return this.consumeStringToken(APOSTROPHE);case LEFT_PARENTHESIS:return LEFT_PARENTHESIS_TOKEN;case RIGHT_PARENTHESIS:return RIGHT_PARENTHESIS_TOKEN;case ASTERISK:if(this.peekCodePoint(0)===EQUALS_SIGN){this.consumeCodePoint();return SUBSTRING_MATCH_TOKEN;}break;case PLUS_SIGN:if(isNumberStart(codePoint,this.peekCodePoint(0),this.peekCodePoint(1))){this.reconsumeCodePoint(codePoint);return this.consumeNumericToken();}break;case COMMA:return COMMA_TOKEN;case HYPHEN_MINUS:var e1=codePoint;var e2=this.peekCodePoint(0);var e3=this.peekCodePoint(1);if(isNumberStart(e1,e2,e3)){this.reconsumeCodePoint(codePoint);return this.consumeNumericToken();}if(isIdentifierStart(e1,e2,e3)){this.reconsumeCodePoint(codePoint);return this.consumeIdentLikeToken();}if(e2===HYPHEN_MINUS&&e3===GREATER_THAN_SIGN){this.consumeCodePoint();this.consumeCodePoint();return CDC_TOKEN;}break;case FULL_STOP:if(isNumberStart(codePoint,this.peekCodePoint(0),this.peekCodePoint(1))){this.reconsumeCodePoint(codePoint);return this.consumeNumericToken();}break;case SOLIDUS:if(this.peekCodePoint(0)===ASTERISK){this.consumeCodePoint();while(true){var c=this.consumeCodePoint();if(c===ASTERISK){c=this.consumeCodePoint();if(c===SOLIDUS){return this.consumeToken();}}if(c===EOF){return this.consumeToken();}}}break;case COLON:return COLON_TOKEN;case SEMICOLON:return SEMICOLON_TOKEN;case LESS_THAN_SIGN:if(this.peekCodePoint(0)===EXCLAMATION_MARK&&this.peekCodePoint(1)===HYPHEN_MINUS&&this.peekCodePoint(2)===HYPHEN_MINUS){this.consumeCodePoint();this.consumeCodePoint();return CDO_TOKEN;}break;case COMMERCIAL_AT:var a1=this.peekCodePoint(0);var a2=this.peekCodePoint(1);var a3=this.peekCodePoint(2);if(isIdentifierStart(a1,a2,a3)){var value=this.consumeName();return{type:7/* AT_KEYWORD_TOKEN */,value:value};}break;case LEFT_SQUARE_BRACKET:return LEFT_SQUARE_BRACKET_TOKEN;case REVERSE_SOLIDUS:if(isValidEscape(codePoint,this.peekCodePoint(0))){this.reconsumeCodePoint(codePoint);return this.consumeIdentLikeToken();}break;case RIGHT_SQUARE_BRACKET:return RIGHT_SQUARE_BRACKET_TOKEN;case CIRCUMFLEX_ACCENT:if(this.peekCodePoint(0)===EQUALS_SIGN){this.consumeCodePoint();return PREFIX_MATCH_TOKEN;}break;case LEFT_CURLY_BRACKET:return LEFT_CURLY_BRACKET_TOKEN;case RIGHT_CURLY_BRACKET:return RIGHT_CURLY_BRACKET_TOKEN;case u:case U:var u1=this.peekCodePoint(0);var u2=this.peekCodePoint(1);if(u1===PLUS_SIGN&&(isHex(u2)||u2===QUESTION_MARK)){this.consumeCodePoint();this.consumeUnicodeRangeToken();}this.reconsumeCodePoint(codePoint);return this.consumeIdentLikeToken();case VERTICAL_LINE:if(this.peekCodePoint(0)===EQUALS_SIGN){this.consumeCodePoint();return DASH_MATCH_TOKEN;}if(this.peekCodePoint(0)===VERTICAL_LINE){this.consumeCodePoint();return COLUMN_TOKEN;}break;case TILDE:if(this.peekCodePoint(0)===EQUALS_SIGN){this.consumeCodePoint();return INCLUDE_MATCH_TOKEN;}break;case EOF:return EOF_TOKEN;}if(isWhiteSpace(codePoint)){this.consumeWhiteSpace();return WHITESPACE_TOKEN;}if(isDigit(codePoint)){this.reconsumeCodePoint(codePoint);return this.consumeNumericToken();}if(isNameStartCodePoint(codePoint)){this.reconsumeCodePoint(codePoint);return this.consumeIdentLikeToken();}return{type:6/* DELIM_TOKEN */,value:fromCodePoint$1(codePoint)};};Tokenizer.prototype.consumeCodePoint=function(){var value=this._value.shift();return typeof value==='undefined'?-1:value;};Tokenizer.prototype.reconsumeCodePoint=function(codePoint){this._value.unshift(codePoint);};Tokenizer.prototype.peekCodePoint=function(delta){if(delta>=this._value.length){return-1;}return this._value[delta];};Tokenizer.prototype.consumeUnicodeRangeToken=function(){var digits=[];var codePoint=this.consumeCodePoint();while(isHex(codePoint)&&digits.length<6){digits.push(codePoint);codePoint=this.consumeCodePoint();}var questionMarks=false;while(codePoint===QUESTION_MARK&&digits.length<6){digits.push(codePoint);codePoint=this.consumeCodePoint();questionMarks=true;}if(questionMarks){var start_1=parseInt(fromCodePoint$1.apply(void 0,digits.map(function(digit){return digit===QUESTION_MARK?ZERO:digit;})),16);var end=parseInt(fromCodePoint$1.apply(void 0,digits.map(function(digit){return digit===QUESTION_MARK?F:digit;})),16);return{type:30/* UNICODE_RANGE_TOKEN */,start:start_1,end:end};}var start=parseInt(fromCodePoint$1.apply(void 0,digits),16);if(this.peekCodePoint(0)===HYPHEN_MINUS&&isHex(this.peekCodePoint(1))){this.consumeCodePoint();codePoint=this.consumeCodePoint();var endDigits=[];while(isHex(codePoint)&&endDigits.length<6){endDigits.push(codePoint);codePoint=this.consumeCodePoint();}var end=parseInt(fromCodePoint$1.apply(void 0,endDigits),16);return{type:30/* UNICODE_RANGE_TOKEN */,start:start,end:end};}else{return{type:30/* UNICODE_RANGE_TOKEN */,start:start,end:start};}};Tokenizer.prototype.consumeIdentLikeToken=function(){var value=this.consumeName();if(value.toLowerCase()==='url'&&this.peekCodePoint(0)===LEFT_PARENTHESIS){this.consumeCodePoint();return this.consumeUrlToken();}else if(this.peekCodePoint(0)===LEFT_PARENTHESIS){this.consumeCodePoint();return{type:19/* FUNCTION_TOKEN */,value:value};}return{type:20/* IDENT_TOKEN */,value:value};};Tokenizer.prototype.consumeUrlToken=function(){var value=[];this.consumeWhiteSpace();if(this.peekCodePoint(0)===EOF){return{type:22/* URL_TOKEN */,value:''};}var next=this.peekCodePoint(0);if(next===APOSTROPHE||next===QUOTATION_MARK){var stringToken=this.consumeStringToken(this.consumeCodePoint());if(stringToken.type===0/* STRING_TOKEN */){this.consumeWhiteSpace();if(this.peekCodePoint(0)===EOF||this.peekCodePoint(0)===RIGHT_PARENTHESIS){this.consumeCodePoint();return{type:22/* URL_TOKEN */,value:stringToken.value};}}this.consumeBadUrlRemnants();return BAD_URL_TOKEN;}while(true){var codePoint=this.consumeCodePoint();if(codePoint===EOF||codePoint===RIGHT_PARENTHESIS){return{type:22/* URL_TOKEN */,value:fromCodePoint$1.apply(void 0,value)};}else if(isWhiteSpace(codePoint)){this.consumeWhiteSpace();if(this.peekCodePoint(0)===EOF||this.peekCodePoint(0)===RIGHT_PARENTHESIS){this.consumeCodePoint();return{type:22/* URL_TOKEN */,value:fromCodePoint$1.apply(void 0,value)};}this.consumeBadUrlRemnants();return BAD_URL_TOKEN;}else if(codePoint===QUOTATION_MARK||codePoint===APOSTROPHE||codePoint===LEFT_PARENTHESIS||isNonPrintableCodePoint(codePoint)){this.consumeBadUrlRemnants();return BAD_URL_TOKEN;}else if(codePoint===REVERSE_SOLIDUS){if(isValidEscape(codePoint,this.peekCodePoint(0))){value.push(this.consumeEscapedCodePoint());}else{this.consumeBadUrlRemnants();return BAD_URL_TOKEN;}}else{value.push(codePoint);}}};Tokenizer.prototype.consumeWhiteSpace=function(){while(isWhiteSpace(this.peekCodePoint(0))){this.consumeCodePoint();}};Tokenizer.prototype.consumeBadUrlRemnants=function(){while(true){var codePoint=this.consumeCodePoint();if(codePoint===RIGHT_PARENTHESIS||codePoint===EOF){return;}if(isValidEscape(codePoint,this.peekCodePoint(0))){this.consumeEscapedCodePoint();}}};Tokenizer.prototype.consumeStringSlice=function(count){var SLICE_STACK_SIZE=50000;var value='';while(count>0){var amount=Math.min(SLICE_STACK_SIZE,count);value+=fromCodePoint$1.apply(void 0,this._value.splice(0,amount));count-=amount;}this._value.shift();return value;};Tokenizer.prototype.consumeStringToken=function(endingCodePoint){var value='';var i=0;do{var codePoint=this._value[i];if(codePoint===EOF||codePoint===undefined||codePoint===endingCodePoint){value+=this.consumeStringSlice(i);return{type:0/* STRING_TOKEN */,value:value};}if(codePoint===LINE_FEED){this._value.splice(0,i);return BAD_STRING_TOKEN;}if(codePoint===REVERSE_SOLIDUS){var next=this._value[i+1];if(next!==EOF&&next!==undefined){if(next===LINE_FEED){value+=this.consumeStringSlice(i);i=-1;this._value.shift();}else if(isValidEscape(codePoint,next)){value+=this.consumeStringSlice(i);value+=fromCodePoint$1(this.consumeEscapedCodePoint());i=-1;}}}i++;}while(true);};Tokenizer.prototype.consumeNumber=function(){var repr=[];var type=FLAG_INTEGER;var c1=this.peekCodePoint(0);if(c1===PLUS_SIGN||c1===HYPHEN_MINUS){repr.push(this.consumeCodePoint());}while(isDigit(this.peekCodePoint(0))){repr.push(this.consumeCodePoint());}c1=this.peekCodePoint(0);var c2=this.peekCodePoint(1);if(c1===FULL_STOP&&isDigit(c2)){repr.push(this.consumeCodePoint(),this.consumeCodePoint());type=FLAG_NUMBER;while(isDigit(this.peekCodePoint(0))){repr.push(this.consumeCodePoint());}}c1=this.peekCodePoint(0);c2=this.peekCodePoint(1);var c3=this.peekCodePoint(2);if((c1===E||c1===e)&&((c2===PLUS_SIGN||c2===HYPHEN_MINUS)&&isDigit(c3)||isDigit(c2))){repr.push(this.consumeCodePoint(),this.consumeCodePoint());type=FLAG_NUMBER;while(isDigit(this.peekCodePoint(0))){repr.push(this.consumeCodePoint());}}return[stringToNumber(repr),type];};Tokenizer.prototype.consumeNumericToken=function(){var _a=this.consumeNumber(),number=_a[0],flags=_a[1];var c1=this.peekCodePoint(0);var c2=this.peekCodePoint(1);var c3=this.peekCodePoint(2);if(isIdentifierStart(c1,c2,c3)){var unit=this.consumeName();return{type:15/* DIMENSION_TOKEN */,number:number,flags:flags,unit:unit};}if(c1===PERCENTAGE_SIGN){this.consumeCodePoint();return{type:16/* PERCENTAGE_TOKEN */,number:number,flags:flags};}return{type:17/* NUMBER_TOKEN */,number:number,flags:flags};};Tokenizer.prototype.consumeEscapedCodePoint=function(){var codePoint=this.consumeCodePoint();if(isHex(codePoint)){var hex=fromCodePoint$1(codePoint);while(isHex(this.peekCodePoint(0))&&hex.length<6){hex+=fromCodePoint$1(this.consumeCodePoint());}if(isWhiteSpace(this.peekCodePoint(0))){this.consumeCodePoint();}var hexCodePoint=parseInt(hex,16);if(hexCodePoint===0||isSurrogateCodePoint(hexCodePoint)||hexCodePoint>0x10ffff){return REPLACEMENT_CHARACTER;}return hexCodePoint;}if(codePoint===EOF){return REPLACEMENT_CHARACTER;}return codePoint;};Tokenizer.prototype.consumeName=function(){var result='';while(true){var codePoint=this.consumeCodePoint();if(isNameCodePoint(codePoint)){result+=fromCodePoint$1(codePoint);}else if(isValidEscape(codePoint,this.peekCodePoint(0))){result+=fromCodePoint$1(this.consumeEscapedCodePoint());}else{this.reconsumeCodePoint(codePoint);return result;}}};return Tokenizer;}();var Parser=/** @class */function(){function Parser(tokens){this._tokens=tokens;}Parser.create=function(value){var tokenizer=new Tokenizer();tokenizer.write(value);return new Parser(tokenizer.read());};Parser.parseValue=function(value){return Parser.create(value).parseComponentValue();};Parser.parseValues=function(value){return Parser.create(value).parseComponentValues();};Parser.prototype.parseComponentValue=function(){var token=this.consumeToken();while(token.type===31/* WHITESPACE_TOKEN */){token=this.consumeToken();}if(token.type===32/* EOF_TOKEN */){throw new SyntaxError("Error parsing CSS component value, unexpected EOF");}this.reconsumeToken(token);var value=this.consumeComponentValue();do{token=this.consumeToken();}while(token.type===31/* WHITESPACE_TOKEN */);if(token.type===32/* EOF_TOKEN */){return value;}throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");};Parser.prototype.parseComponentValues=function(){var values=[];while(true){var value=this.consumeComponentValue();if(value.type===32/* EOF_TOKEN */){return values;}values.push(value);values.push();}};Parser.prototype.consumeComponentValue=function(){var token=this.consumeToken();switch(token.type){case 11/* LEFT_CURLY_BRACKET_TOKEN */:case 28/* LEFT_SQUARE_BRACKET_TOKEN */:case 2/* LEFT_PARENTHESIS_TOKEN */:return this.consumeSimpleBlock(token.type);case 19/* FUNCTION_TOKEN */:return this.consumeFunction(token);}return token;};Parser.prototype.consumeSimpleBlock=function(type){var block={type:type,values:[]};var token=this.consumeToken();while(true){if(token.type===32/* EOF_TOKEN */||isEndingTokenFor(token,type)){return block;}this.reconsumeToken(token);block.values.push(this.consumeComponentValue());token=this.consumeToken();}};Parser.prototype.consumeFunction=function(functionToken){var cssFunction={name:functionToken.value,values:[],type:18/* FUNCTION */};while(true){var token=this.consumeToken();if(token.type===32/* EOF_TOKEN */||token.type===3/* RIGHT_PARENTHESIS_TOKEN */){return cssFunction;}this.reconsumeToken(token);cssFunction.values.push(this.consumeComponentValue());}};Parser.prototype.consumeToken=function(){var token=this._tokens.shift();return typeof token==='undefined'?EOF_TOKEN:token;};Parser.prototype.reconsumeToken=function(token){this._tokens.unshift(token);};return Parser;}();var isDimensionToken=function isDimensionToken(token){return token.type===15/* DIMENSION_TOKEN */;};var isNumberToken=function isNumberToken(token){return token.type===17/* NUMBER_TOKEN */;};var isIdentToken=function isIdentToken(token){return token.type===20/* IDENT_TOKEN */;};var isStringToken=function isStringToken(token){return token.type===0/* STRING_TOKEN */;};var isIdentWithValue=function isIdentWithValue(token,value){return isIdentToken(token)&&token.value===value;};var nonWhiteSpace=function nonWhiteSpace(token){return token.type!==31/* WHITESPACE_TOKEN */;};var nonFunctionArgSeparator=function nonFunctionArgSeparator(token){return token.type!==31/* WHITESPACE_TOKEN */&&token.type!==4/* COMMA_TOKEN */;};var parseFunctionArgs=function parseFunctionArgs(tokens){var args=[];var arg=[];tokens.forEach(function(token){if(token.type===4/* COMMA_TOKEN */){if(arg.length===0){throw new Error("Error parsing function args, zero tokens for arg");}args.push(arg);arg=[];return;}if(token.type!==31/* WHITESPACE_TOKEN */){arg.push(token);}});if(arg.length){args.push(arg);}return args;};var isEndingTokenFor=function isEndingTokenFor(token,type){if(type===11/* LEFT_CURLY_BRACKET_TOKEN */&&token.type===12/* RIGHT_CURLY_BRACKET_TOKEN */){return true;}if(type===28/* LEFT_SQUARE_BRACKET_TOKEN */&&token.type===29/* RIGHT_SQUARE_BRACKET_TOKEN */){return true;}return type===2/* LEFT_PARENTHESIS_TOKEN */&&token.type===3/* RIGHT_PARENTHESIS_TOKEN */;};var isLength=function isLength(token){return token.type===17/* NUMBER_TOKEN */||token.type===15/* DIMENSION_TOKEN */;};var isLengthPercentage=function isLengthPercentage(token){return token.type===16/* PERCENTAGE_TOKEN */||isLength(token);};var parseLengthPercentageTuple=function parseLengthPercentageTuple(tokens){return tokens.length>1?[tokens[0],tokens[1]]:[tokens[0]];};var ZERO_LENGTH={type:17/* NUMBER_TOKEN */,number:0,flags:FLAG_INTEGER};var FIFTY_PERCENT={type:16/* PERCENTAGE_TOKEN */,number:50,flags:FLAG_INTEGER};var HUNDRED_PERCENT={type:16/* PERCENTAGE_TOKEN */,number:100,flags:FLAG_INTEGER};var getAbsoluteValueForTuple=function getAbsoluteValueForTuple(tuple,width,height){var x=tuple[0],y=tuple[1];return[getAbsoluteValue(x,width),getAbsoluteValue(typeof y!=='undefined'?y:x,height)];};var getAbsoluteValue=function getAbsoluteValue(token,parent){if(token.type===16/* PERCENTAGE_TOKEN */){return token.number/100*parent;}if(isDimensionToken(token)){switch(token.unit){case'rem':case'em':return 16*token.number;// TODO use correct font-size
case'px':default:return token.number;}}return token.number;};var DEG='deg';var GRAD='grad';var RAD='rad';var TURN='turn';var angle={name:'angle',parse:function parse(_context,value){if(value.type===15/* DIMENSION_TOKEN */){switch(value.unit){case DEG:return Math.PI*value.number/180;case GRAD:return Math.PI/200*value.number;case RAD:return value.number;case TURN:return Math.PI*2*value.number;}}throw new Error("Unsupported angle type");}};var isAngle=function isAngle(value){if(value.type===15/* DIMENSION_TOKEN */){if(value.unit===DEG||value.unit===GRAD||value.unit===RAD||value.unit===TURN){return true;}}return false;};var parseNamedSide=function parseNamedSide(tokens){var sideOrCorner=tokens.filter(isIdentToken).map(function(ident){return ident.value;}).join(' ');switch(sideOrCorner){case'to bottom right':case'to right bottom':case'left top':case'top left':return[ZERO_LENGTH,ZERO_LENGTH];case'to top':case'bottom':return deg(0);case'to bottom left':case'to left bottom':case'right top':case'top right':return[ZERO_LENGTH,HUNDRED_PERCENT];case'to right':case'left':return deg(90);case'to top left':case'to left top':case'right bottom':case'bottom right':return[HUNDRED_PERCENT,HUNDRED_PERCENT];case'to bottom':case'top':return deg(180);case'to top right':case'to right top':case'left bottom':case'bottom left':return[HUNDRED_PERCENT,ZERO_LENGTH];case'to left':case'right':return deg(270);}return 0;};var deg=function deg(_deg){return Math.PI*_deg/180;};var color$1={name:'color',parse:function parse(context,value){if(value.type===18/* FUNCTION */){var colorFunction=SUPPORTED_COLOR_FUNCTIONS[value.name];if(typeof colorFunction==='undefined'){throw new Error("Attempting to parse an unsupported color function \""+value.name+"\"");}return colorFunction(context,value.values);}if(value.type===5/* HASH_TOKEN */){if(value.value.length===3){var r=value.value.substring(0,1);var g=value.value.substring(1,2);var b=value.value.substring(2,3);return pack(parseInt(r+r,16),parseInt(g+g,16),parseInt(b+b,16),1);}if(value.value.length===4){var r=value.value.substring(0,1);var g=value.value.substring(1,2);var b=value.value.substring(2,3);var a=value.value.substring(3,4);return pack(parseInt(r+r,16),parseInt(g+g,16),parseInt(b+b,16),parseInt(a+a,16)/255);}if(value.value.length===6){var r=value.value.substring(0,2);var g=value.value.substring(2,4);var b=value.value.substring(4,6);return pack(parseInt(r,16),parseInt(g,16),parseInt(b,16),1);}if(value.value.length===8){var r=value.value.substring(0,2);var g=value.value.substring(2,4);var b=value.value.substring(4,6);var a=value.value.substring(6,8);return pack(parseInt(r,16),parseInt(g,16),parseInt(b,16),parseInt(a,16)/255);}}if(value.type===20/* IDENT_TOKEN */){var namedColor=COLORS[value.value.toUpperCase()];if(typeof namedColor!=='undefined'){return namedColor;}}return COLORS.TRANSPARENT;}};var isTransparent=function isTransparent(color){return(0xff&color)===0;};var asString=function asString(color){var alpha=0xff&color;var blue=0xff&color>>8;var green=0xff&color>>16;var red=0xff&color>>24;return alpha<255?"rgba("+red+","+green+","+blue+","+alpha/255+")":"rgb("+red+","+green+","+blue+")";};var pack=function pack(r,g,b,a){return(r<<24|g<<16|b<<8|Math.round(a*255)<<0)>>>0;};var getTokenColorValue=function getTokenColorValue(token,i){if(token.type===17/* NUMBER_TOKEN */){return token.number;}if(token.type===16/* PERCENTAGE_TOKEN */){var max=i===3?1:255;return i===3?token.number/100*max:Math.round(token.number/100*max);}return 0;};var rgb=function rgb(_context,args){var tokens=args.filter(nonFunctionArgSeparator);if(tokens.length===3){var _a=tokens.map(getTokenColorValue),r=_a[0],g=_a[1],b=_a[2];return pack(r,g,b,1);}if(tokens.length===4){var _b=tokens.map(getTokenColorValue),r=_b[0],g=_b[1],b=_b[2],a=_b[3];return pack(r,g,b,a);}return 0;};function hue2rgb(t1,t2,hue){if(hue<0){hue+=1;}if(hue>=1){hue-=1;}if(hue<1/6){return(t2-t1)*hue*6+t1;}else if(hue<1/2){return t2;}else if(hue<2/3){return(t2-t1)*6*(2/3-hue)+t1;}else{return t1;}}var hsl=function hsl(context,args){var tokens=args.filter(nonFunctionArgSeparator);var hue=tokens[0],saturation=tokens[1],lightness=tokens[2],alpha=tokens[3];var h=(hue.type===17/* NUMBER_TOKEN */?deg(hue.number):angle.parse(context,hue))/(Math.PI*2);var s=isLengthPercentage(saturation)?saturation.number/100:0;var l=isLengthPercentage(lightness)?lightness.number/100:0;var a=typeof alpha!=='undefined'&&isLengthPercentage(alpha)?getAbsoluteValue(alpha,1):1;if(s===0){return pack(l*255,l*255,l*255,1);}var t2=l<=0.5?l*(s+1):l+s-l*s;var t1=l*2-t2;var r=hue2rgb(t1,t2,h+1/3);var g=hue2rgb(t1,t2,h);var b=hue2rgb(t1,t2,h-1/3);return pack(r*255,g*255,b*255,a);};var SUPPORTED_COLOR_FUNCTIONS={hsl:hsl,hsla:hsl,rgb:rgb,rgba:rgb};var parseColor=function parseColor(context,value){return color$1.parse(context,Parser.create(value).parseComponentValue());};var COLORS={ALICEBLUE:0xf0f8ffff,ANTIQUEWHITE:0xfaebd7ff,AQUA:0x00ffffff,AQUAMARINE:0x7fffd4ff,AZURE:0xf0ffffff,BEIGE:0xf5f5dcff,BISQUE:0xffe4c4ff,BLACK:0x000000ff,BLANCHEDALMOND:0xffebcdff,BLUE:0x0000ffff,BLUEVIOLET:0x8a2be2ff,BROWN:0xa52a2aff,BURLYWOOD:0xdeb887ff,CADETBLUE:0x5f9ea0ff,CHARTREUSE:0x7fff00ff,CHOCOLATE:0xd2691eff,CORAL:0xff7f50ff,CORNFLOWERBLUE:0x6495edff,CORNSILK:0xfff8dcff,CRIMSON:0xdc143cff,CYAN:0x00ffffff,DARKBLUE:0x00008bff,DARKCYAN:0x008b8bff,DARKGOLDENROD:0xb886bbff,DARKGRAY:0xa9a9a9ff,DARKGREEN:0x006400ff,DARKGREY:0xa9a9a9ff,DARKKHAKI:0xbdb76bff,DARKMAGENTA:0x8b008bff,DARKOLIVEGREEN:0x556b2fff,DARKORANGE:0xff8c00ff,DARKORCHID:0x9932ccff,DARKRED:0x8b0000ff,DARKSALMON:0xe9967aff,DARKSEAGREEN:0x8fbc8fff,DARKSLATEBLUE:0x483d8bff,DARKSLATEGRAY:0x2f4f4fff,DARKSLATEGREY:0x2f4f4fff,DARKTURQUOISE:0x00ced1ff,DARKVIOLET:0x9400d3ff,DEEPPINK:0xff1493ff,DEEPSKYBLUE:0x00bfffff,DIMGRAY:0x696969ff,DIMGREY:0x696969ff,DODGERBLUE:0x1e90ffff,FIREBRICK:0xb22222ff,FLORALWHITE:0xfffaf0ff,FORESTGREEN:0x228b22ff,FUCHSIA:0xff00ffff,GAINSBORO:0xdcdcdcff,GHOSTWHITE:0xf8f8ffff,GOLD:0xffd700ff,GOLDENROD:0xdaa520ff,GRAY:0x808080ff,GREEN:0x008000ff,GREENYELLOW:0xadff2fff,GREY:0x808080ff,HONEYDEW:0xf0fff0ff,HOTPINK:0xff69b4ff,INDIANRED:0xcd5c5cff,INDIGO:0x4b0082ff,IVORY:0xfffff0ff,KHAKI:0xf0e68cff,LAVENDER:0xe6e6faff,LAVENDERBLUSH:0xfff0f5ff,LAWNGREEN:0x7cfc00ff,LEMONCHIFFON:0xfffacdff,LIGHTBLUE:0xadd8e6ff,LIGHTCORAL:0xf08080ff,LIGHTCYAN:0xe0ffffff,LIGHTGOLDENRODYELLOW:0xfafad2ff,LIGHTGRAY:0xd3d3d3ff,LIGHTGREEN:0x90ee90ff,LIGHTGREY:0xd3d3d3ff,LIGHTPINK:0xffb6c1ff,LIGHTSALMON:0xffa07aff,LIGHTSEAGREEN:0x20b2aaff,LIGHTSKYBLUE:0x87cefaff,LIGHTSLATEGRAY:0x778899ff,LIGHTSLATEGREY:0x778899ff,LIGHTSTEELBLUE:0xb0c4deff,LIGHTYELLOW:0xffffe0ff,LIME:0x00ff00ff,LIMEGREEN:0x32cd32ff,LINEN:0xfaf0e6ff,MAGENTA:0xff00ffff,MAROON:0x800000ff,MEDIUMAQUAMARINE:0x66cdaaff,MEDIUMBLUE:0x0000cdff,MEDIUMORCHID:0xba55d3ff,MEDIUMPURPLE:0x9370dbff,MEDIUMSEAGREEN:0x3cb371ff,MEDIUMSLATEBLUE:0x7b68eeff,MEDIUMSPRINGGREEN:0x00fa9aff,MEDIUMTURQUOISE:0x48d1ccff,MEDIUMVIOLETRED:0xc71585ff,MIDNIGHTBLUE:0x191970ff,MINTCREAM:0xf5fffaff,MISTYROSE:0xffe4e1ff,MOCCASIN:0xffe4b5ff,NAVAJOWHITE:0xffdeadff,NAVY:0x000080ff,OLDLACE:0xfdf5e6ff,OLIVE:0x808000ff,OLIVEDRAB:0x6b8e23ff,ORANGE:0xffa500ff,ORANGERED:0xff4500ff,ORCHID:0xda70d6ff,PALEGOLDENROD:0xeee8aaff,PALEGREEN:0x98fb98ff,PALETURQUOISE:0xafeeeeff,PALEVIOLETRED:0xdb7093ff,PAPAYAWHIP:0xffefd5ff,PEACHPUFF:0xffdab9ff,PERU:0xcd853fff,PINK:0xffc0cbff,PLUM:0xdda0ddff,POWDERBLUE:0xb0e0e6ff,PURPLE:0x800080ff,REBECCAPURPLE:0x663399ff,RED:0xff0000ff,ROSYBROWN:0xbc8f8fff,ROYALBLUE:0x4169e1ff,SADDLEBROWN:0x8b4513ff,SALMON:0xfa8072ff,SANDYBROWN:0xf4a460ff,SEAGREEN:0x2e8b57ff,SEASHELL:0xfff5eeff,SIENNA:0xa0522dff,SILVER:0xc0c0c0ff,SKYBLUE:0x87ceebff,SLATEBLUE:0x6a5acdff,SLATEGRAY:0x708090ff,SLATEGREY:0x708090ff,SNOW:0xfffafaff,SPRINGGREEN:0x00ff7fff,STEELBLUE:0x4682b4ff,TAN:0xd2b48cff,TEAL:0x008080ff,THISTLE:0xd8bfd8ff,TOMATO:0xff6347ff,TRANSPARENT:0x00000000,TURQUOISE:0x40e0d0ff,VIOLET:0xee82eeff,WHEAT:0xf5deb3ff,WHITE:0xffffffff,WHITESMOKE:0xf5f5f5ff,YELLOW:0xffff00ff,YELLOWGREEN:0x9acd32ff};var backgroundClip={name:'background-clip',initialValue:'border-box',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return tokens.map(function(token){if(isIdentToken(token)){switch(token.value){case'padding-box':return 1/* PADDING_BOX */;case'content-box':return 2/* CONTENT_BOX */;}}return 0/* BORDER_BOX */;});}};var backgroundColor={name:"background-color",initialValue:'transparent',prefix:false,type:3/* TYPE_VALUE */,format:'color'};var parseColorStop=function parseColorStop(context,args){var color=color$1.parse(context,args[0]);var stop=args[1];return stop&&isLengthPercentage(stop)?{color:color,stop:stop}:{color:color,stop:null};};var processColorStops=function processColorStops(stops,lineLength){var first=stops[0];var last=stops[stops.length-1];if(first.stop===null){first.stop=ZERO_LENGTH;}if(last.stop===null){last.stop=HUNDRED_PERCENT;}var processStops=[];var previous=0;for(var i=0;i<stops.length;i++){var stop_1=stops[i].stop;if(stop_1!==null){var absoluteValue=getAbsoluteValue(stop_1,lineLength);if(absoluteValue>previous){processStops.push(absoluteValue);}else{processStops.push(previous);}previous=absoluteValue;}else{processStops.push(null);}}var gapBegin=null;for(var i=0;i<processStops.length;i++){var stop_2=processStops[i];if(stop_2===null){if(gapBegin===null){gapBegin=i;}}else if(gapBegin!==null){var gapLength=i-gapBegin;var beforeGap=processStops[gapBegin-1];var gapValue=(stop_2-beforeGap)/(gapLength+1);for(var g=1;g<=gapLength;g++){processStops[gapBegin+g-1]=gapValue*g;}gapBegin=null;}}return stops.map(function(_a,i){var color=_a.color;return{color:color,stop:Math.max(Math.min(1,processStops[i]/lineLength),0)};});};var getAngleFromCorner=function getAngleFromCorner(corner,width,height){var centerX=width/2;var centerY=height/2;var x=getAbsoluteValue(corner[0],width)-centerX;var y=centerY-getAbsoluteValue(corner[1],height);return(Math.atan2(y,x)+Math.PI*2)%(Math.PI*2);};var calculateGradientDirection=function calculateGradientDirection(angle,width,height){var radian=typeof angle==='number'?angle:getAngleFromCorner(angle,width,height);var lineLength=Math.abs(width*Math.sin(radian))+Math.abs(height*Math.cos(radian));var halfWidth=width/2;var halfHeight=height/2;var halfLineLength=lineLength/2;var yDiff=Math.sin(radian-Math.PI/2)*halfLineLength;var xDiff=Math.cos(radian-Math.PI/2)*halfLineLength;return[lineLength,halfWidth-xDiff,halfWidth+xDiff,halfHeight-yDiff,halfHeight+yDiff];};var distance=function distance(a,b){return Math.sqrt(a*a+b*b);};var findCorner=function findCorner(width,height,x,y,closest){var corners=[[0,0],[0,height],[width,0],[width,height]];return corners.reduce(function(stat,corner){var cx=corner[0],cy=corner[1];var d=distance(x-cx,y-cy);if(closest?d<stat.optimumDistance:d>stat.optimumDistance){return{optimumCorner:corner,optimumDistance:d};}return stat;},{optimumDistance:closest?Infinity:-Infinity,optimumCorner:null}).optimumCorner;};var calculateRadius=function calculateRadius(gradient,x,y,width,height){var rx=0;var ry=0;switch(gradient.size){case 0/* CLOSEST_SIDE */:// The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradients center.
// If the shape is an ellipse, it exactly meets the closest side in each dimension.
if(gradient.shape===0/* CIRCLE */){rx=ry=Math.min(Math.abs(x),Math.abs(x-width),Math.abs(y),Math.abs(y-height));}else if(gradient.shape===1/* ELLIPSE */){rx=Math.min(Math.abs(x),Math.abs(x-width));ry=Math.min(Math.abs(y),Math.abs(y-height));}break;case 2/* CLOSEST_CORNER */:// The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradients center.
// If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
if(gradient.shape===0/* CIRCLE */){rx=ry=Math.min(distance(x,y),distance(x,y-height),distance(x-width,y),distance(x-width,y-height));}else if(gradient.shape===1/* ELLIPSE */){// Compute the ratio ry/rx (which is to be the same as for "closest-side")
var c=Math.min(Math.abs(y),Math.abs(y-height))/Math.min(Math.abs(x),Math.abs(x-width));var _a=findCorner(width,height,x,y,true),cx=_a[0],cy=_a[1];rx=distance(cx-x,(cy-y)/c);ry=c*rx;}break;case 1/* FARTHEST_SIDE */:// Same as closest-side, except the ending shape is sized based on the farthest side(s)
if(gradient.shape===0/* CIRCLE */){rx=ry=Math.max(Math.abs(x),Math.abs(x-width),Math.abs(y),Math.abs(y-height));}else if(gradient.shape===1/* ELLIPSE */){rx=Math.max(Math.abs(x),Math.abs(x-width));ry=Math.max(Math.abs(y),Math.abs(y-height));}break;case 3/* FARTHEST_CORNER */:// Same as closest-corner, except the ending shape is sized based on the farthest corner.
// If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
if(gradient.shape===0/* CIRCLE */){rx=ry=Math.max(distance(x,y),distance(x,y-height),distance(x-width,y),distance(x-width,y-height));}else if(gradient.shape===1/* ELLIPSE */){// Compute the ratio ry/rx (which is to be the same as for "farthest-side")
var c=Math.max(Math.abs(y),Math.abs(y-height))/Math.max(Math.abs(x),Math.abs(x-width));var _b=findCorner(width,height,x,y,false),cx=_b[0],cy=_b[1];rx=distance(cx-x,(cy-y)/c);ry=c*rx;}break;}if(Array.isArray(gradient.size)){rx=getAbsoluteValue(gradient.size[0],width);ry=gradient.size.length===2?getAbsoluteValue(gradient.size[1],height):rx;}return[rx,ry];};var linearGradient=function linearGradient(context,tokens){var angle$1=deg(180);var stops=[];parseFunctionArgs(tokens).forEach(function(arg,i){if(i===0){var firstToken=arg[0];if(firstToken.type===20/* IDENT_TOKEN */&&firstToken.value==='to'){angle$1=parseNamedSide(arg);return;}else if(isAngle(firstToken)){angle$1=angle.parse(context,firstToken);return;}}var colorStop=parseColorStop(context,arg);stops.push(colorStop);});return{angle:angle$1,stops:stops,type:1/* LINEAR_GRADIENT */};};var prefixLinearGradient=function prefixLinearGradient(context,tokens){var angle$1=deg(180);var stops=[];parseFunctionArgs(tokens).forEach(function(arg,i){if(i===0){var firstToken=arg[0];if(firstToken.type===20/* IDENT_TOKEN */&&['top','left','right','bottom'].indexOf(firstToken.value)!==-1){angle$1=parseNamedSide(arg);return;}else if(isAngle(firstToken)){angle$1=(angle.parse(context,firstToken)+deg(270))%deg(360);return;}}var colorStop=parseColorStop(context,arg);stops.push(colorStop);});return{angle:angle$1,stops:stops,type:1/* LINEAR_GRADIENT */};};var webkitGradient=function webkitGradient(context,tokens){var angle=deg(180);var stops=[];var type=1/* LINEAR_GRADIENT */;var shape=0/* CIRCLE */;var size=3/* FARTHEST_CORNER */;var position=[];parseFunctionArgs(tokens).forEach(function(arg,i){var firstToken=arg[0];if(i===0){if(isIdentToken(firstToken)&&firstToken.value==='linear'){type=1/* LINEAR_GRADIENT */;return;}else if(isIdentToken(firstToken)&&firstToken.value==='radial'){type=2/* RADIAL_GRADIENT */;return;}}if(firstToken.type===18/* FUNCTION */){if(firstToken.name==='from'){var color=color$1.parse(context,firstToken.values[0]);stops.push({stop:ZERO_LENGTH,color:color});}else if(firstToken.name==='to'){var color=color$1.parse(context,firstToken.values[0]);stops.push({stop:HUNDRED_PERCENT,color:color});}else if(firstToken.name==='color-stop'){var values=firstToken.values.filter(nonFunctionArgSeparator);if(values.length===2){var color=color$1.parse(context,values[1]);var stop_1=values[0];if(isNumberToken(stop_1)){stops.push({stop:{type:16/* PERCENTAGE_TOKEN */,number:stop_1.number*100,flags:stop_1.flags},color:color});}}}}});return type===1/* LINEAR_GRADIENT */?{angle:(angle+deg(180))%deg(360),stops:stops,type:type}:{size:size,shape:shape,stops:stops,position:position,type:type};};var CLOSEST_SIDE='closest-side';var FARTHEST_SIDE='farthest-side';var CLOSEST_CORNER='closest-corner';var FARTHEST_CORNER='farthest-corner';var CIRCLE='circle';var ELLIPSE='ellipse';var COVER='cover';var CONTAIN='contain';var radialGradient=function radialGradient(context,tokens){var shape=0/* CIRCLE */;var size=3/* FARTHEST_CORNER */;var stops=[];var position=[];parseFunctionArgs(tokens).forEach(function(arg,i){var isColorStop=true;if(i===0){var isAtPosition_1=false;isColorStop=arg.reduce(function(acc,token){if(isAtPosition_1){if(isIdentToken(token)){switch(token.value){case'center':position.push(FIFTY_PERCENT);return acc;case'top':case'left':position.push(ZERO_LENGTH);return acc;case'right':case'bottom':position.push(HUNDRED_PERCENT);return acc;}}else if(isLengthPercentage(token)||isLength(token)){position.push(token);}}else if(isIdentToken(token)){switch(token.value){case CIRCLE:shape=0/* CIRCLE */;return false;case ELLIPSE:shape=1/* ELLIPSE */;return false;case'at':isAtPosition_1=true;return false;case CLOSEST_SIDE:size=0/* CLOSEST_SIDE */;return false;case COVER:case FARTHEST_SIDE:size=1/* FARTHEST_SIDE */;return false;case CONTAIN:case CLOSEST_CORNER:size=2/* CLOSEST_CORNER */;return false;case FARTHEST_CORNER:size=3/* FARTHEST_CORNER */;return false;}}else if(isLength(token)||isLengthPercentage(token)){if(!Array.isArray(size)){size=[];}size.push(token);return false;}return acc;},isColorStop);}if(isColorStop){var colorStop=parseColorStop(context,arg);stops.push(colorStop);}});return{size:size,shape:shape,stops:stops,position:position,type:2/* RADIAL_GRADIENT */};};var prefixRadialGradient=function prefixRadialGradient(context,tokens){var shape=0/* CIRCLE */;var size=3/* FARTHEST_CORNER */;var stops=[];var position=[];parseFunctionArgs(tokens).forEach(function(arg,i){var isColorStop=true;if(i===0){isColorStop=arg.reduce(function(acc,token){if(isIdentToken(token)){switch(token.value){case'center':position.push(FIFTY_PERCENT);return false;case'top':case'left':position.push(ZERO_LENGTH);return false;case'right':case'bottom':position.push(HUNDRED_PERCENT);return false;}}else if(isLengthPercentage(token)||isLength(token)){position.push(token);return false;}return acc;},isColorStop);}else if(i===1){isColorStop=arg.reduce(function(acc,token){if(isIdentToken(token)){switch(token.value){case CIRCLE:shape=0/* CIRCLE */;return false;case ELLIPSE:shape=1/* ELLIPSE */;return false;case CONTAIN:case CLOSEST_SIDE:size=0/* CLOSEST_SIDE */;return false;case FARTHEST_SIDE:size=1/* FARTHEST_SIDE */;return false;case CLOSEST_CORNER:size=2/* CLOSEST_CORNER */;return false;case COVER:case FARTHEST_CORNER:size=3/* FARTHEST_CORNER */;return false;}}else if(isLength(token)||isLengthPercentage(token)){if(!Array.isArray(size)){size=[];}size.push(token);return false;}return acc;},isColorStop);}if(isColorStop){var colorStop=parseColorStop(context,arg);stops.push(colorStop);}});return{size:size,shape:shape,stops:stops,position:position,type:2/* RADIAL_GRADIENT */};};var isLinearGradient=function isLinearGradient(background){return background.type===1/* LINEAR_GRADIENT */;};var isRadialGradient=function isRadialGradient(background){return background.type===2/* RADIAL_GRADIENT */;};var image$1={name:'image',parse:function parse(context,value){if(value.type===22/* URL_TOKEN */){var image_1={url:value.value,type:0/* URL */};context.cache.addImage(value.value);return image_1;}if(value.type===18/* FUNCTION */){var imageFunction=SUPPORTED_IMAGE_FUNCTIONS[value.name];if(typeof imageFunction==='undefined'){throw new Error("Attempting to parse an unsupported image function \""+value.name+"\"");}return imageFunction(context,value.values);}throw new Error("Unsupported image type "+value.type);}};function isSupportedImage(value){return!(value.type===20/* IDENT_TOKEN */&&value.value==='none')&&(value.type!==18/* FUNCTION */||!!SUPPORTED_IMAGE_FUNCTIONS[value.name]);}var SUPPORTED_IMAGE_FUNCTIONS={'linear-gradient':linearGradient,'-moz-linear-gradient':prefixLinearGradient,'-ms-linear-gradient':prefixLinearGradient,'-o-linear-gradient':prefixLinearGradient,'-webkit-linear-gradient':prefixLinearGradient,'radial-gradient':radialGradient,'-moz-radial-gradient':prefixRadialGradient,'-ms-radial-gradient':prefixRadialGradient,'-o-radial-gradient':prefixRadialGradient,'-webkit-radial-gradient':prefixRadialGradient,'-webkit-gradient':webkitGradient};var backgroundImage={name:'background-image',initialValue:'none',type:1/* LIST */,prefix:false,parse:function parse(context,tokens){if(tokens.length===0){return[];}var first=tokens[0];if(first.type===20/* IDENT_TOKEN */&&first.value==='none'){return[];}return tokens.filter(function(value){return nonFunctionArgSeparator(value)&&isSupportedImage(value);}).map(function(value){return image$1.parse(context,value);});}};var backgroundOrigin={name:'background-origin',initialValue:'border-box',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return tokens.map(function(token){if(isIdentToken(token)){switch(token.value){case'padding-box':return 1/* PADDING_BOX */;case'content-box':return 2/* CONTENT_BOX */;}}return 0/* BORDER_BOX */;});}};var backgroundPosition={name:'background-position',initialValue:'0% 0%',type:1/* LIST */,prefix:false,parse:function parse(_context,tokens){return parseFunctionArgs(tokens).map(function(values){return values.filter(isLengthPercentage);}).map(parseLengthPercentageTuple);}};var backgroundRepeat={name:'background-repeat',initialValue:'repeat',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return parseFunctionArgs(tokens).map(function(values){return values.filter(isIdentToken).map(function(token){return token.value;}).join(' ');}).map(parseBackgroundRepeat);}};var parseBackgroundRepeat=function parseBackgroundRepeat(value){switch(value){case'no-repeat':return 1/* NO_REPEAT */;case'repeat-x':case'repeat no-repeat':return 2/* REPEAT_X */;case'repeat-y':case'no-repeat repeat':return 3/* REPEAT_Y */;case'repeat':default:return 0/* REPEAT */;}};var BACKGROUND_SIZE;(function(BACKGROUND_SIZE){BACKGROUND_SIZE["AUTO"]="auto";BACKGROUND_SIZE["CONTAIN"]="contain";BACKGROUND_SIZE["COVER"]="cover";})(BACKGROUND_SIZE||(BACKGROUND_SIZE={}));var backgroundSize={name:'background-size',initialValue:'0',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return parseFunctionArgs(tokens).map(function(values){return values.filter(isBackgroundSizeInfoToken);});}};var isBackgroundSizeInfoToken=function isBackgroundSizeInfoToken(value){return isIdentToken(value)||isLengthPercentage(value);};var borderColorForSide=function borderColorForSide(side){return{name:"border-"+side+"-color",initialValue:'transparent',prefix:false,type:3/* TYPE_VALUE */,format:'color'};};var borderTopColor=borderColorForSide('top');var borderRightColor=borderColorForSide('right');var borderBottomColor=borderColorForSide('bottom');var borderLeftColor=borderColorForSide('left');var borderRadiusForSide=function borderRadiusForSide(side){return{name:"border-radius-"+side,initialValue:'0 0',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));}};};var borderTopLeftRadius=borderRadiusForSide('top-left');var borderTopRightRadius=borderRadiusForSide('top-right');var borderBottomRightRadius=borderRadiusForSide('bottom-right');var borderBottomLeftRadius=borderRadiusForSide('bottom-left');var borderStyleForSide=function borderStyleForSide(side){return{name:"border-"+side+"-style",initialValue:'solid',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,style){switch(style){case'none':return 0/* NONE */;case'dashed':return 2/* DASHED */;case'dotted':return 3/* DOTTED */;case'double':return 4/* DOUBLE */;}return 1/* SOLID */;}};};var borderTopStyle=borderStyleForSide('top');var borderRightStyle=borderStyleForSide('right');var borderBottomStyle=borderStyleForSide('bottom');var borderLeftStyle=borderStyleForSide('left');var borderWidthForSide=function borderWidthForSide(side){return{name:"border-"+side+"-width",initialValue:'0',type:0/* VALUE */,prefix:false,parse:function parse(_context,token){if(isDimensionToken(token)){return token.number;}return 0;}};};var borderTopWidth=borderWidthForSide('top');var borderRightWidth=borderWidthForSide('right');var borderBottomWidth=borderWidthForSide('bottom');var borderLeftWidth=borderWidthForSide('left');var color={name:"color",initialValue:'transparent',prefix:false,type:3/* TYPE_VALUE */,format:'color'};var direction={name:'direction',initialValue:'ltr',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,direction){switch(direction){case'rtl':return 1/* RTL */;case'ltr':default:return 0/* LTR */;}}};var display={name:'display',initialValue:'inline-block',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return tokens.filter(isIdentToken).reduce(function(bit,token){return bit|parseDisplayValue(token.value);},0/* NONE */);}};var parseDisplayValue=function parseDisplayValue(display){switch(display){case'block':case'-webkit-box':return 2/* BLOCK */;case'inline':return 4/* INLINE */;case'run-in':return 8/* RUN_IN */;case'flow':return 16/* FLOW */;case'flow-root':return 32/* FLOW_ROOT */;case'table':return 64/* TABLE */;case'flex':case'-webkit-flex':return 128/* FLEX */;case'grid':case'-ms-grid':return 256/* GRID */;case'ruby':return 512/* RUBY */;case'subgrid':return 1024/* SUBGRID */;case'list-item':return 2048/* LIST_ITEM */;case'table-row-group':return 4096/* TABLE_ROW_GROUP */;case'table-header-group':return 8192/* TABLE_HEADER_GROUP */;case'table-footer-group':return 16384/* TABLE_FOOTER_GROUP */;case'table-row':return 32768/* TABLE_ROW */;case'table-cell':return 65536/* TABLE_CELL */;case'table-column-group':return 131072/* TABLE_COLUMN_GROUP */;case'table-column':return 262144/* TABLE_COLUMN */;case'table-caption':return 524288/* TABLE_CAPTION */;case'ruby-base':return 1048576/* RUBY_BASE */;case'ruby-text':return 2097152/* RUBY_TEXT */;case'ruby-base-container':return 4194304/* RUBY_BASE_CONTAINER */;case'ruby-text-container':return 8388608/* RUBY_TEXT_CONTAINER */;case'contents':return 16777216/* CONTENTS */;case'inline-block':return 33554432/* INLINE_BLOCK */;case'inline-list-item':return 67108864/* INLINE_LIST_ITEM */;case'inline-table':return 134217728/* INLINE_TABLE */;case'inline-flex':return 268435456/* INLINE_FLEX */;case'inline-grid':return 536870912/* INLINE_GRID */;}return 0/* NONE */;};var _float={name:'float',initialValue:'none',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,_float2){switch(_float2){case'left':return 1/* LEFT */;case'right':return 2/* RIGHT */;case'inline-start':return 3/* INLINE_START */;case'inline-end':return 4/* INLINE_END */;}return 0/* NONE */;}};var letterSpacing={name:'letter-spacing',initialValue:'0',prefix:false,type:0/* VALUE */,parse:function parse(_context,token){if(token.type===20/* IDENT_TOKEN */&&token.value==='normal'){return 0;}if(token.type===17/* NUMBER_TOKEN */){return token.number;}if(token.type===15/* DIMENSION_TOKEN */){return token.number;}return 0;}};var LINE_BREAK;(function(LINE_BREAK){LINE_BREAK["NORMAL"]="normal";LINE_BREAK["STRICT"]="strict";})(LINE_BREAK||(LINE_BREAK={}));var lineBreak={name:'line-break',initialValue:'normal',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,lineBreak){switch(lineBreak){case'strict':return LINE_BREAK.STRICT;case'normal':default:return LINE_BREAK.NORMAL;}}};var lineHeight={name:'line-height',initialValue:'normal',prefix:false,type:4/* TOKEN_VALUE */};var computeLineHeight=function computeLineHeight(token,fontSize){if(isIdentToken(token)&&token.value==='normal'){return 1.2*fontSize;}else if(token.type===17/* NUMBER_TOKEN */){return fontSize*token.number;}else if(isLengthPercentage(token)){return getAbsoluteValue(token,fontSize);}return fontSize;};var listStyleImage={name:'list-style-image',initialValue:'none',type:0/* VALUE */,prefix:false,parse:function parse(context,token){if(token.type===20/* IDENT_TOKEN */&&token.value==='none'){return null;}return image$1.parse(context,token);}};var listStylePosition={name:'list-style-position',initialValue:'outside',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,position){switch(position){case'inside':return 0/* INSIDE */;case'outside':default:return 1/* OUTSIDE */;}}};var listStyleType={name:'list-style-type',initialValue:'none',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,type){switch(type){case'disc':return 0/* DISC */;case'circle':return 1/* CIRCLE */;case'square':return 2/* SQUARE */;case'decimal':return 3/* DECIMAL */;case'cjk-decimal':return 4/* CJK_DECIMAL */;case'decimal-leading-zero':return 5/* DECIMAL_LEADING_ZERO */;case'lower-roman':return 6/* LOWER_ROMAN */;case'upper-roman':return 7/* UPPER_ROMAN */;case'lower-greek':return 8/* LOWER_GREEK */;case'lower-alpha':return 9/* LOWER_ALPHA */;case'upper-alpha':return 10/* UPPER_ALPHA */;case'arabic-indic':return 11/* ARABIC_INDIC */;case'armenian':return 12/* ARMENIAN */;case'bengali':return 13/* BENGALI */;case'cambodian':return 14/* CAMBODIAN */;case'cjk-earthly-branch':return 15/* CJK_EARTHLY_BRANCH */;case'cjk-heavenly-stem':return 16/* CJK_HEAVENLY_STEM */;case'cjk-ideographic':return 17/* CJK_IDEOGRAPHIC */;case'devanagari':return 18/* DEVANAGARI */;case'ethiopic-numeric':return 19/* ETHIOPIC_NUMERIC */;case'georgian':return 20/* GEORGIAN */;case'gujarati':return 21/* GUJARATI */;case'gurmukhi':return 22/* GURMUKHI */;case'hebrew':return 22/* HEBREW */;case'hiragana':return 23/* HIRAGANA */;case'hiragana-iroha':return 24/* HIRAGANA_IROHA */;case'japanese-formal':return 25/* JAPANESE_FORMAL */;case'japanese-informal':return 26/* JAPANESE_INFORMAL */;case'kannada':return 27/* KANNADA */;case'katakana':return 28/* KATAKANA */;case'katakana-iroha':return 29/* KATAKANA_IROHA */;case'khmer':return 30/* KHMER */;case'korean-hangul-formal':return 31/* KOREAN_HANGUL_FORMAL */;case'korean-hanja-formal':return 32/* KOREAN_HANJA_FORMAL */;case'korean-hanja-informal':return 33/* KOREAN_HANJA_INFORMAL */;case'lao':return 34/* LAO */;case'lower-armenian':return 35/* LOWER_ARMENIAN */;case'malayalam':return 36/* MALAYALAM */;case'mongolian':return 37/* MONGOLIAN */;case'myanmar':return 38/* MYANMAR */;case'oriya':return 39/* ORIYA */;case'persian':return 40/* PERSIAN */;case'simp-chinese-formal':return 41/* SIMP_CHINESE_FORMAL */;case'simp-chinese-informal':return 42/* SIMP_CHINESE_INFORMAL */;case'tamil':return 43/* TAMIL */;case'telugu':return 44/* TELUGU */;case'thai':return 45/* THAI */;case'tibetan':return 46/* TIBETAN */;case'trad-chinese-formal':return 47/* TRAD_CHINESE_FORMAL */;case'trad-chinese-informal':return 48/* TRAD_CHINESE_INFORMAL */;case'upper-armenian':return 49/* UPPER_ARMENIAN */;case'disclosure-open':return 50/* DISCLOSURE_OPEN */;case'disclosure-closed':return 51/* DISCLOSURE_CLOSED */;case'none':default:return-1/* NONE */;}}};var marginForSide=function marginForSide(side){return{name:"margin-"+side,initialValue:'0',prefix:false,type:4/* TOKEN_VALUE */};};var marginTop=marginForSide('top');var marginRight=marginForSide('right');var marginBottom=marginForSide('bottom');var marginLeft=marginForSide('left');var overflow={name:'overflow',initialValue:'visible',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return tokens.filter(isIdentToken).map(function(overflow){switch(overflow.value){case'hidden':return 1/* HIDDEN */;case'scroll':return 2/* SCROLL */;case'clip':return 3/* CLIP */;case'auto':return 4/* AUTO */;case'visible':default:return 0/* VISIBLE */;}});}};var overflowWrap={name:'overflow-wrap',initialValue:'normal',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,overflow){switch(overflow){case'break-word':return"break-word"/* BREAK_WORD */;case'normal':default:return"normal"/* NORMAL */;}}};var paddingForSide=function paddingForSide(side){return{name:"padding-"+side,initialValue:'0',prefix:false,type:3/* TYPE_VALUE */,format:'length-percentage'};};var paddingTop=paddingForSide('top');var paddingRight=paddingForSide('right');var paddingBottom=paddingForSide('bottom');var paddingLeft=paddingForSide('left');var textAlign={name:'text-align',initialValue:'left',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,textAlign){switch(textAlign){case'right':return 2/* RIGHT */;case'center':case'justify':return 1/* CENTER */;case'left':default:return 0/* LEFT */;}}};var position={name:'position',initialValue:'static',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,position){switch(position){case'relative':return 1/* RELATIVE */;case'absolute':return 2/* ABSOLUTE */;case'fixed':return 3/* FIXED */;case'sticky':return 4/* STICKY */;}return 0/* STATIC */;}};var textShadow={name:'text-shadow',initialValue:'none',type:1/* LIST */,prefix:false,parse:function parse(context,tokens){if(tokens.length===1&&isIdentWithValue(tokens[0],'none')){return[];}return parseFunctionArgs(tokens).map(function(values){var shadow={color:COLORS.TRANSPARENT,offsetX:ZERO_LENGTH,offsetY:ZERO_LENGTH,blur:ZERO_LENGTH};var c=0;for(var i=0;i<values.length;i++){var token=values[i];if(isLength(token)){if(c===0){shadow.offsetX=token;}else if(c===1){shadow.offsetY=token;}else{shadow.blur=token;}c++;}else{shadow.color=color$1.parse(context,token);}}return shadow;});}};var textTransform={name:'text-transform',initialValue:'none',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,textTransform){switch(textTransform){case'uppercase':return 2/* UPPERCASE */;case'lowercase':return 1/* LOWERCASE */;case'capitalize':return 3/* CAPITALIZE */;}return 0/* NONE */;}};var transform$1={name:'transform',initialValue:'none',prefix:true,type:0/* VALUE */,parse:function parse(_context,token){if(token.type===20/* IDENT_TOKEN */&&token.value==='none'){return null;}if(token.type===18/* FUNCTION */){var transformFunction=SUPPORTED_TRANSFORM_FUNCTIONS[token.name];if(typeof transformFunction==='undefined'){throw new Error("Attempting to parse an unsupported transform function \""+token.name+"\"");}return transformFunction(token.values);}return null;}};var matrix=function matrix(args){var values=args.filter(function(arg){return arg.type===17/* NUMBER_TOKEN */;}).map(function(arg){return arg.number;});return values.length===6?values:null;};// doesn't support 3D transforms at the moment
var matrix3d=function matrix3d(args){var values=args.filter(function(arg){return arg.type===17/* NUMBER_TOKEN */;}).map(function(arg){return arg.number;});var a1=values[0],b1=values[1];values[2];values[3];var a2=values[4],b2=values[5];values[6];values[7];values[8];values[9];values[10];values[11];var a4=values[12],b4=values[13];values[14];values[15];return values.length===16?[a1,b1,a2,b2,a4,b4]:null;};var SUPPORTED_TRANSFORM_FUNCTIONS={matrix:matrix,matrix3d:matrix3d};var DEFAULT_VALUE={type:16/* PERCENTAGE_TOKEN */,number:50,flags:FLAG_INTEGER};var DEFAULT=[DEFAULT_VALUE,DEFAULT_VALUE];var transformOrigin={name:'transform-origin',initialValue:'50% 50%',prefix:true,type:1/* LIST */,parse:function parse(_context,tokens){var origins=tokens.filter(isLengthPercentage);if(origins.length!==2){return DEFAULT;}return[origins[0],origins[1]];}};var visibility={name:'visible',initialValue:'none',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,visibility){switch(visibility){case'hidden':return 1/* HIDDEN */;case'collapse':return 2/* COLLAPSE */;case'visible':default:return 0/* VISIBLE */;}}};var WORD_BREAK;(function(WORD_BREAK){WORD_BREAK["NORMAL"]="normal";WORD_BREAK["BREAK_ALL"]="break-all";WORD_BREAK["KEEP_ALL"]="keep-all";})(WORD_BREAK||(WORD_BREAK={}));var wordBreak={name:'word-break',initialValue:'normal',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,wordBreak){switch(wordBreak){case'break-all':return WORD_BREAK.BREAK_ALL;case'keep-all':return WORD_BREAK.KEEP_ALL;case'normal':default:return WORD_BREAK.NORMAL;}}};var zIndex={name:'z-index',initialValue:'auto',prefix:false,type:0/* VALUE */,parse:function parse(_context,token){if(token.type===20/* IDENT_TOKEN */){return{auto:true,order:0};}if(isNumberToken(token)){return{auto:false,order:token.number};}throw new Error("Invalid z-index number parsed");}};var time={name:'time',parse:function parse(_context,value){if(value.type===15/* DIMENSION_TOKEN */){switch(value.unit.toLowerCase()){case's':return 1000*value.number;case'ms':return value.number;}}throw new Error("Unsupported time type");}};var opacity={name:'opacity',initialValue:'1',type:0/* VALUE */,prefix:false,parse:function parse(_context,token){if(isNumberToken(token)){return token.number;}return 1;}};var textDecorationColor={name:"text-decoration-color",initialValue:'transparent',prefix:false,type:3/* TYPE_VALUE */,format:'color'};var textDecorationLine={name:'text-decoration-line',initialValue:'none',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){return tokens.filter(isIdentToken).map(function(token){switch(token.value){case'underline':return 1/* UNDERLINE */;case'overline':return 2/* OVERLINE */;case'line-through':return 3/* LINE_THROUGH */;case'none':return 4/* BLINK */;}return 0/* NONE */;}).filter(function(line){return line!==0/* NONE */;});}};var fontFamily={name:"font-family",initialValue:'',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){var accumulator=[];var results=[];tokens.forEach(function(token){switch(token.type){case 20/* IDENT_TOKEN */:case 0/* STRING_TOKEN */:accumulator.push(token.value);break;case 17/* NUMBER_TOKEN */:accumulator.push(token.number.toString());break;case 4/* COMMA_TOKEN */:results.push(accumulator.join(' '));accumulator.length=0;break;}});if(accumulator.length){results.push(accumulator.join(' '));}return results.map(function(result){return result.indexOf(' ')===-1?result:"'"+result+"'";});}};var fontSize={name:"font-size",initialValue:'0',prefix:false,type:3/* TYPE_VALUE */,format:'length'};var fontWeight={name:'font-weight',initialValue:'normal',type:0/* VALUE */,prefix:false,parse:function parse(_context,token){if(isNumberToken(token)){return token.number;}if(isIdentToken(token)){switch(token.value){case'bold':return 700;case'normal':default:return 400;}}return 400;}};var fontVariant={name:'font-variant',initialValue:'none',type:1/* LIST */,prefix:false,parse:function parse(_context,tokens){return tokens.filter(isIdentToken).map(function(token){return token.value;});}};var fontStyle={name:'font-style',initialValue:'normal',prefix:false,type:2/* IDENT_VALUE */,parse:function parse(_context,overflow){switch(overflow){case'oblique':return"oblique"/* OBLIQUE */;case'italic':return"italic"/* ITALIC */;case'normal':default:return"normal"/* NORMAL */;}}};var contains=function contains(bit,value){return(bit&value)!==0;};var content={name:'content',initialValue:'none',type:1/* LIST */,prefix:false,parse:function parse(_context,tokens){if(tokens.length===0){return[];}var first=tokens[0];if(first.type===20/* IDENT_TOKEN */&&first.value==='none'){return[];}return tokens;}};var counterIncrement={name:'counter-increment',initialValue:'none',prefix:true,type:1/* LIST */,parse:function parse(_context,tokens){if(tokens.length===0){return null;}var first=tokens[0];if(first.type===20/* IDENT_TOKEN */&&first.value==='none'){return null;}var increments=[];var filtered=tokens.filter(nonWhiteSpace);for(var i=0;i<filtered.length;i++){var counter=filtered[i];var next=filtered[i+1];if(counter.type===20/* IDENT_TOKEN */){var increment=next&&isNumberToken(next)?next.number:1;increments.push({counter:counter.value,increment:increment});}}return increments;}};var counterReset={name:'counter-reset',initialValue:'none',prefix:true,type:1/* LIST */,parse:function parse(_context,tokens){if(tokens.length===0){return[];}var resets=[];var filtered=tokens.filter(nonWhiteSpace);for(var i=0;i<filtered.length;i++){var counter=filtered[i];var next=filtered[i+1];if(isIdentToken(counter)&&counter.value!=='none'){var reset=next&&isNumberToken(next)?next.number:0;resets.push({counter:counter.value,reset:reset});}}return resets;}};var duration={name:'duration',initialValue:'0s',prefix:false,type:1/* LIST */,parse:function parse(context,tokens){return tokens.filter(isDimensionToken).map(function(token){return time.parse(context,token);});}};var quotes={name:'quotes',initialValue:'none',prefix:true,type:1/* LIST */,parse:function parse(_context,tokens){if(tokens.length===0){return null;}var first=tokens[0];if(first.type===20/* IDENT_TOKEN */&&first.value==='none'){return null;}var quotes=[];var filtered=tokens.filter(isStringToken);if(filtered.length%2!==0){return null;}for(var i=0;i<filtered.length;i+=2){var open_1=filtered[i].value;var close_1=filtered[i+1].value;quotes.push({open:open_1,close:close_1});}return quotes;}};var getQuote=function getQuote(quotes,depth,open){if(!quotes){return'';}var quote=quotes[Math.min(depth,quotes.length-1)];if(!quote){return'';}return open?quote.open:quote.close;};var boxShadow={name:'box-shadow',initialValue:'none',type:1/* LIST */,prefix:false,parse:function parse(context,tokens){if(tokens.length===1&&isIdentWithValue(tokens[0],'none')){return[];}return parseFunctionArgs(tokens).map(function(values){var shadow={color:0x000000ff,offsetX:ZERO_LENGTH,offsetY:ZERO_LENGTH,blur:ZERO_LENGTH,spread:ZERO_LENGTH,inset:false};var c=0;for(var i=0;i<values.length;i++){var token=values[i];if(isIdentWithValue(token,'inset')){shadow.inset=true;}else if(isLength(token)){if(c===0){shadow.offsetX=token;}else if(c===1){shadow.offsetY=token;}else if(c===2){shadow.blur=token;}else{shadow.spread=token;}c++;}else{shadow.color=color$1.parse(context,token);}}return shadow;});}};var paintOrder={name:'paint-order',initialValue:'normal',prefix:false,type:1/* LIST */,parse:function parse(_context,tokens){var DEFAULT_VALUE=[0/* FILL */,1/* STROKE */,2/* MARKERS */];var layers=[];tokens.filter(isIdentToken).forEach(function(token){switch(token.value){case'stroke':layers.push(1/* STROKE */);break;case'fill':layers.push(0/* FILL */);break;case'markers':layers.push(2/* MARKERS */);break;}});DEFAULT_VALUE.forEach(function(value){if(layers.indexOf(value)===-1){layers.push(value);}});return layers;}};var webkitTextStrokeColor={name:"-webkit-text-stroke-color",initialValue:'currentcolor',prefix:false,type:3/* TYPE_VALUE */,format:'color'};var webkitTextStrokeWidth={name:"-webkit-text-stroke-width",initialValue:'0',type:0/* VALUE */,prefix:false,parse:function parse(_context,token){if(isDimensionToken(token)){return token.number;}return 0;}};var CSSParsedDeclaration=/** @class */function(){function CSSParsedDeclaration(context,declaration){var _a,_b;this.animationDuration=parse$4(context,duration,declaration.animationDuration);this.backgroundClip=parse$4(context,backgroundClip,declaration.backgroundClip);this.backgroundColor=parse$4(context,backgroundColor,declaration.backgroundColor);this.backgroundImage=parse$4(context,backgroundImage,declaration.backgroundImage);this.backgroundOrigin=parse$4(context,backgroundOrigin,declaration.backgroundOrigin);this.backgroundPosition=parse$4(context,backgroundPosition,declaration.backgroundPosition);this.backgroundRepeat=parse$4(context,backgroundRepeat,declaration.backgroundRepeat);this.backgroundSize=parse$4(context,backgroundSize,declaration.backgroundSize);this.borderTopColor=parse$4(context,borderTopColor,declaration.borderTopColor);this.borderRightColor=parse$4(context,borderRightColor,declaration.borderRightColor);this.borderBottomColor=parse$4(context,borderBottomColor,declaration.borderBottomColor);this.borderLeftColor=parse$4(context,borderLeftColor,declaration.borderLeftColor);this.borderTopLeftRadius=parse$4(context,borderTopLeftRadius,declaration.borderTopLeftRadius);this.borderTopRightRadius=parse$4(context,borderTopRightRadius,declaration.borderTopRightRadius);this.borderBottomRightRadius=parse$4(context,borderBottomRightRadius,declaration.borderBottomRightRadius);this.borderBottomLeftRadius=parse$4(context,borderBottomLeftRadius,declaration.borderBottomLeftRadius);this.borderTopStyle=parse$4(context,borderTopStyle,declaration.borderTopStyle);this.borderRightStyle=parse$4(context,borderRightStyle,declaration.borderRightStyle);this.borderBottomStyle=parse$4(context,borderBottomStyle,declaration.borderBottomStyle);this.borderLeftStyle=parse$4(context,borderLeftStyle,declaration.borderLeftStyle);this.borderTopWidth=parse$4(context,borderTopWidth,declaration.borderTopWidth);this.borderRightWidth=parse$4(context,borderRightWidth,declaration.borderRightWidth);this.borderBottomWidth=parse$4(context,borderBottomWidth,declaration.borderBottomWidth);this.borderLeftWidth=parse$4(context,borderLeftWidth,declaration.borderLeftWidth);this.boxShadow=parse$4(context,boxShadow,declaration.boxShadow);this.color=parse$4(context,color,declaration.color);this.direction=parse$4(context,direction,declaration.direction);this.display=parse$4(context,display,declaration.display);this["float"]=parse$4(context,_float,declaration.cssFloat);this.fontFamily=parse$4(context,fontFamily,declaration.fontFamily);this.fontSize=parse$4(context,fontSize,declaration.fontSize);this.fontStyle=parse$4(context,fontStyle,declaration.fontStyle);this.fontVariant=parse$4(context,fontVariant,declaration.fontVariant);this.fontWeight=parse$4(context,fontWeight,declaration.fontWeight);this.letterSpacing=parse$4(context,letterSpacing,declaration.letterSpacing);this.lineBreak=parse$4(context,lineBreak,declaration.lineBreak);this.lineHeight=parse$4(context,lineHeight,declaration.lineHeight);this.listStyleImage=parse$4(context,listStyleImage,declaration.listStyleImage);this.listStylePosition=parse$4(context,listStylePosition,declaration.listStylePosition);this.listStyleType=parse$4(context,listStyleType,declaration.listStyleType);this.marginTop=parse$4(context,marginTop,declaration.marginTop);this.marginRight=parse$4(context,marginRight,declaration.marginRight);this.marginBottom=parse$4(context,marginBottom,declaration.marginBottom);this.marginLeft=parse$4(context,marginLeft,declaration.marginLeft);this.opacity=parse$4(context,opacity,declaration.opacity);var overflowTuple=parse$4(context,overflow,declaration.overflow);this.overflowX=overflowTuple[0];this.overflowY=overflowTuple[overflowTuple.length>1?1:0];this.overflowWrap=parse$4(context,overflowWrap,declaration.overflowWrap);this.paddingTop=parse$4(context,paddingTop,declaration.paddingTop);this.paddingRight=parse$4(context,paddingRight,declaration.paddingRight);this.paddingBottom=parse$4(context,paddingBottom,declaration.paddingBottom);this.paddingLeft=parse$4(context,paddingLeft,declaration.paddingLeft);this.paintOrder=parse$4(context,paintOrder,declaration.paintOrder);this.position=parse$4(context,position,declaration.position);this.textAlign=parse$4(context,textAlign,declaration.textAlign);this.textDecorationColor=parse$4(context,textDecorationColor,(_a=declaration.textDecorationColor)!==null&&_a!==void 0?_a:declaration.color);this.textDecorationLine=parse$4(context,textDecorationLine,(_b=declaration.textDecorationLine)!==null&&_b!==void 0?_b:declaration.textDecoration);this.textShadow=parse$4(context,textShadow,declaration.textShadow);this.textTransform=parse$4(context,textTransform,declaration.textTransform);this.transform=parse$4(context,transform$1,declaration.transform);this.transformOrigin=parse$4(context,transformOrigin,declaration.transformOrigin);this.visibility=parse$4(context,visibility,declaration.visibility);this.webkitTextStrokeColor=parse$4(context,webkitTextStrokeColor,declaration.webkitTextStrokeColor);this.webkitTextStrokeWidth=parse$4(context,webkitTextStrokeWidth,declaration.webkitTextStrokeWidth);this.wordBreak=parse$4(context,wordBreak,declaration.wordBreak);this.zIndex=parse$4(context,zIndex,declaration.zIndex);}CSSParsedDeclaration.prototype.isVisible=function(){return this.display>0&&this.opacity>0&&this.visibility===0/* VISIBLE */;};CSSParsedDeclaration.prototype.isTransparent=function(){return isTransparent(this.backgroundColor);};CSSParsedDeclaration.prototype.isTransformed=function(){return this.transform!==null;};CSSParsedDeclaration.prototype.isPositioned=function(){return this.position!==0/* STATIC */;};CSSParsedDeclaration.prototype.isPositionedWithZIndex=function(){return this.isPositioned()&&!this.zIndex.auto;};CSSParsedDeclaration.prototype.isFloating=function(){return this["float"]!==0/* NONE */;};CSSParsedDeclaration.prototype.isInlineLevel=function(){return contains(this.display,4/* INLINE */)||contains(this.display,33554432/* INLINE_BLOCK */)||contains(this.display,268435456/* INLINE_FLEX */)||contains(this.display,536870912/* INLINE_GRID */)||contains(this.display,67108864/* INLINE_LIST_ITEM */)||contains(this.display,134217728/* INLINE_TABLE */);};return CSSParsedDeclaration;}();var CSSParsedPseudoDeclaration=/** @class */function(){function CSSParsedPseudoDeclaration(context,declaration){this.content=parse$4(context,content,declaration.content);this.quotes=parse$4(context,quotes,declaration.quotes);}return CSSParsedPseudoDeclaration;}();var CSSParsedCounterDeclaration=/** @class */function(){function CSSParsedCounterDeclaration(context,declaration){this.counterIncrement=parse$4(context,counterIncrement,declaration.counterIncrement);this.counterReset=parse$4(context,counterReset,declaration.counterReset);}return CSSParsedCounterDeclaration;}();// eslint-disable-next-line @typescript-eslint/no-explicit-any
var parse$4=function parse$4(context,descriptor,style){var tokenizer=new Tokenizer();var value=style!==null&&typeof style!=='undefined'?style.toString():descriptor.initialValue;tokenizer.write(value);var parser=new Parser(tokenizer.read());switch(descriptor.type){case 2/* IDENT_VALUE */:var token=parser.parseComponentValue();return descriptor.parse(context,isIdentToken(token)?token.value:descriptor.initialValue);case 0/* VALUE */:return descriptor.parse(context,parser.parseComponentValue());case 1/* LIST */:return descriptor.parse(context,parser.parseComponentValues());case 4/* TOKEN_VALUE */:return parser.parseComponentValue();case 3/* TYPE_VALUE */:switch(descriptor.format){case'angle':return angle.parse(context,parser.parseComponentValue());case'color':return color$1.parse(context,parser.parseComponentValue());case'image':return image$1.parse(context,parser.parseComponentValue());case'length':var length_1=parser.parseComponentValue();return isLength(length_1)?length_1:ZERO_LENGTH;case'length-percentage':var value_1=parser.parseComponentValue();return isLengthPercentage(value_1)?value_1:ZERO_LENGTH;case'time':return time.parse(context,parser.parseComponentValue());}break;}};var elementDebuggerAttribute='data-html2canvas-debug';var getElementDebugType=function getElementDebugType(element){var attribute=element.getAttribute(elementDebuggerAttribute);switch(attribute){case'all':return 1/* ALL */;case'clone':return 2/* CLONE */;case'parse':return 3/* PARSE */;case'render':return 4/* RENDER */;default:return 0/* NONE */;}};var isDebugging=function isDebugging(element,type){var elementType=getElementDebugType(element);return elementType===1/* ALL */||type===elementType;};var ElementContainer=/** @class */function(){function ElementContainer(context,element){this.context=context;this.textNodes=[];this.elements=[];this.flags=0;if(isDebugging(element,3/* PARSE */)){debugger;}this.styles=new CSSParsedDeclaration(context,window.getComputedStyle(element,null));if(isHTMLElementNode(element)){if(this.styles.animationDuration.some(function(duration){return duration>0;})){element.style.animationDuration='0s';}if(this.styles.transform!==null){// getBoundingClientRect takes transforms into account
element.style.transform='none';}}this.bounds=parseBounds(this.context,element);if(isDebugging(element,4/* RENDER */)){this.flags|=16/* DEBUG_RENDER */;}}return ElementContainer;}();/*
 * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */var base64='AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';/*
 * utrie 1.0.2 <https://github.com/niklasvh/utrie>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */var chars$1='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';// Use a lookup table to find the index.
var lookup$1=typeof Uint8Array==='undefined'?[]:new Uint8Array(256);for(var i$1=0;i$1<chars$1.length;i$1++){lookup$1[chars$1.charCodeAt(i$1)]=i$1;}var decode$6=function decode$6(base64){var bufferLength=base64.length*0.75,len=base64.length,i,p=0,encoded1,encoded2,encoded3,encoded4;if(base64[base64.length-1]==='='){bufferLength--;if(base64[base64.length-2]==='='){bufferLength--;}}var buffer=typeof ArrayBuffer!=='undefined'&&typeof Uint8Array!=='undefined'&&typeof Uint8Array.prototype.slice!=='undefined'?new ArrayBuffer(bufferLength):new Array(bufferLength);var bytes=Array.isArray(buffer)?buffer:new Uint8Array(buffer);for(i=0;i<len;i+=4){encoded1=lookup$1[base64.charCodeAt(i)];encoded2=lookup$1[base64.charCodeAt(i+1)];encoded3=lookup$1[base64.charCodeAt(i+2)];encoded4=lookup$1[base64.charCodeAt(i+3)];bytes[p++]=encoded1<<2|encoded2>>4;bytes[p++]=(encoded2&15)<<4|encoded3>>2;bytes[p++]=(encoded3&3)<<6|encoded4&63;}return buffer;};var polyUint16Array=function polyUint16Array(buffer){var length=buffer.length;var bytes=[];for(var i=0;i<length;i+=2){bytes.push(buffer[i+1]<<8|buffer[i]);}return bytes;};var polyUint32Array=function polyUint32Array(buffer){var length=buffer.length;var bytes=[];for(var i=0;i<length;i+=4){bytes.push(buffer[i+3]<<24|buffer[i+2]<<16|buffer[i+1]<<8|buffer[i]);}return bytes;};/** Shift size for getting the index-2 table offset. */var UTRIE2_SHIFT_2=5;/** Shift size for getting the index-1 table offset. */var UTRIE2_SHIFT_1=6+5;/**
 * Shift size for shifting left the index array values.
 * Increases possible data size with 16-bit index values at the cost
 * of compactability.
 * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
 */var UTRIE2_INDEX_SHIFT=2;/**
 * Difference between the two shift sizes,
 * for getting an index-1 offset from an index-2 offset. 6=11-5
 */var UTRIE2_SHIFT_1_2=UTRIE2_SHIFT_1-UTRIE2_SHIFT_2;/**
 * The part of the index-2 table for U+D800..U+DBFF stores values for
 * lead surrogate code _units_ not code _points_.
 * Values for lead surrogate code _points_ are indexed with this portion of the table.
 * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
 */var UTRIE2_LSCP_INDEX_2_OFFSET=0x10000>>UTRIE2_SHIFT_2;/** Number of entries in a data block. 32=0x20 */var UTRIE2_DATA_BLOCK_LENGTH=1<<UTRIE2_SHIFT_2;/** Mask for getting the lower bits for the in-data-block offset. */var UTRIE2_DATA_MASK=UTRIE2_DATA_BLOCK_LENGTH-1;var UTRIE2_LSCP_INDEX_2_LENGTH=0x400>>UTRIE2_SHIFT_2;/** Count the lengths of both BMP pieces. 2080=0x820 */var UTRIE2_INDEX_2_BMP_LENGTH=UTRIE2_LSCP_INDEX_2_OFFSET+UTRIE2_LSCP_INDEX_2_LENGTH;/**
 * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
 * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
 */var UTRIE2_UTF8_2B_INDEX_2_OFFSET=UTRIE2_INDEX_2_BMP_LENGTH;var UTRIE2_UTF8_2B_INDEX_2_LENGTH=0x800>>6;/* U+0800 is the first code point after 2-byte UTF-8 */ /**
 * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
 * Variable length, for code points up to highStart, where the last single-value range starts.
 * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
 * (For 0x100000 supplementary code points U+10000..U+10ffff.)
 *
 * The part of the index-2 table for supplementary code points starts
 * after this index-1 table.
 *
 * Both the index-1 table and the following part of the index-2 table
 * are omitted completely if there is only BMP data.
 */var UTRIE2_INDEX_1_OFFSET=UTRIE2_UTF8_2B_INDEX_2_OFFSET+UTRIE2_UTF8_2B_INDEX_2_LENGTH;/**
 * Number of index-1 entries for the BMP. 32=0x20
 * This part of the index-1 table is omitted from the serialized form.
 */var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH=0x10000>>UTRIE2_SHIFT_1;/** Number of entries in an index-2 block. 64=0x40 */var UTRIE2_INDEX_2_BLOCK_LENGTH=1<<UTRIE2_SHIFT_1_2;/** Mask for getting the lower bits for the in-index-2-block offset. */var UTRIE2_INDEX_2_MASK=UTRIE2_INDEX_2_BLOCK_LENGTH-1;var slice16=function slice16(view,start,end){if(view.slice){return view.slice(start,end);}return new Uint16Array(Array.prototype.slice.call(view,start,end));};var slice32=function slice32(view,start,end){if(view.slice){return view.slice(start,end);}return new Uint32Array(Array.prototype.slice.call(view,start,end));};var createTrieFromBase64=function createTrieFromBase64(base64,_byteLength){var buffer=decode$6(base64);var view32=Array.isArray(buffer)?polyUint32Array(buffer):new Uint32Array(buffer);var view16=Array.isArray(buffer)?polyUint16Array(buffer):new Uint16Array(buffer);var headerLength=24;var index=slice16(view16,headerLength/2,view32[4]/2);var data=view32[5]===2?slice16(view16,(headerLength+view32[4])/2):slice32(view32,Math.ceil((headerLength+view32[4])/4));return new Trie(view32[0],view32[1],view32[2],view32[3],index,data);};var Trie=/** @class */function(){function Trie(initialValue,errorValue,highStart,highValueIndex,index,data){this.initialValue=initialValue;this.errorValue=errorValue;this.highStart=highStart;this.highValueIndex=highValueIndex;this.index=index;this.data=data;}/**
     * Get the value for a code point as stored in the Trie.
     *
     * @param codePoint the code point
     * @return the value
     */Trie.prototype.get=function(codePoint){var ix;if(codePoint>=0){if(codePoint<0x0d800||codePoint>0x0dbff&&codePoint<=0x0ffff){// Ordinary BMP code point, excluding leading surrogates.
// BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
// 16 bit data is stored in the index array itself.
ix=this.index[codePoint>>UTRIE2_SHIFT_2];ix=(ix<<UTRIE2_INDEX_SHIFT)+(codePoint&UTRIE2_DATA_MASK);return this.data[ix];}if(codePoint<=0xffff){// Lead Surrogate Code Point.  A Separate index section is stored for
// lead surrogate code units and code points.
//   The main index has the code unit data.
//   For this function, we need the code point data.
// Note: this expression could be refactored for slightly improved efficiency, but
//       surrogate code points will be so rare in practice that it's not worth it.
ix=this.index[UTRIE2_LSCP_INDEX_2_OFFSET+(codePoint-0xd800>>UTRIE2_SHIFT_2)];ix=(ix<<UTRIE2_INDEX_SHIFT)+(codePoint&UTRIE2_DATA_MASK);return this.data[ix];}if(codePoint<this.highStart){// Supplemental code point, use two-level lookup.
ix=UTRIE2_INDEX_1_OFFSET-UTRIE2_OMITTED_BMP_INDEX_1_LENGTH+(codePoint>>UTRIE2_SHIFT_1);ix=this.index[ix];ix+=codePoint>>UTRIE2_SHIFT_2&UTRIE2_INDEX_2_MASK;ix=this.index[ix];ix=(ix<<UTRIE2_INDEX_SHIFT)+(codePoint&UTRIE2_DATA_MASK);return this.data[ix];}if(codePoint<=0x10ffff){return this.data[this.highValueIndex];}}// Fall through.  The code point is outside of the legal range of 0..0x10ffff.
return this.errorValue;};return Trie;}();/*
 * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */var chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';// Use a lookup table to find the index.
var lookup=typeof Uint8Array==='undefined'?[]:new Uint8Array(256);for(var i$4=0;i$4<chars.length;i$4++){lookup[chars.charCodeAt(i$4)]=i$4;}var Prepend=1;var CR=2;var LF=3;var Control$1=4;var Extend=5;var SpacingMark=7;var L=8;var V=9;var T=10;var LV=11;var LVT=12;var ZWJ=13;var Extended_Pictographic=14;var RI=15;var toCodePoints=function toCodePoints(str){var codePoints=[];var i=0;var length=str.length;while(i<length){var value=str.charCodeAt(i++);if(value>=0xd800&&value<=0xdbff&&i<length){var extra=str.charCodeAt(i++);if((extra&0xfc00)===0xdc00){codePoints.push(((value&0x3ff)<<10)+(extra&0x3ff)+0x10000);}else{codePoints.push(value);i--;}}else{codePoints.push(value);}}return codePoints;};var fromCodePoint=function fromCodePoint(){var codePoints=[];for(var _i=0;_i<arguments.length;_i++){codePoints[_i]=arguments[_i];}if(String.fromCodePoint){return String.fromCodePoint.apply(String,codePoints);}var length=codePoints.length;if(!length){return'';}var codeUnits=[];var index=-1;var result='';while(++index<length){var codePoint=codePoints[index];if(codePoint<=0xffff){codeUnits.push(codePoint);}else{codePoint-=0x10000;codeUnits.push((codePoint>>10)+0xd800,codePoint%0x400+0xdc00);}if(index+1===length||codeUnits.length>0x4000){result+=String.fromCharCode.apply(String,codeUnits);codeUnits.length=0;}}return result;};var UnicodeTrie=createTrieFromBase64(base64);var BREAK_NOT_ALLOWED='';var BREAK_ALLOWED='';var codePointToClass=function codePointToClass(codePoint){return UnicodeTrie.get(codePoint);};var _graphemeBreakAtIndex=function _graphemeBreakAtIndex(_codePoints,classTypes,index){var prevIndex=index-2;var prev=classTypes[prevIndex];var current=classTypes[index-1];var next=classTypes[index];// GB3 Do not break between a CR and LF
if(current===CR&&next===LF){return BREAK_NOT_ALLOWED;}// GB4 Otherwise, break before and after controls.
if(current===CR||current===LF||current===Control$1){return BREAK_ALLOWED;}// GB5
if(next===CR||next===LF||next===Control$1){return BREAK_ALLOWED;}// Do not break Hangul syllable sequences.
// GB6
if(current===L&&[L,V,LV,LVT].indexOf(next)!==-1){return BREAK_NOT_ALLOWED;}// GB7
if((current===LV||current===V)&&(next===V||next===T)){return BREAK_NOT_ALLOWED;}// GB8
if((current===LVT||current===T)&&next===T){return BREAK_NOT_ALLOWED;}// GB9 Do not break before extending characters or ZWJ.
if(next===ZWJ||next===Extend){return BREAK_NOT_ALLOWED;}// Do not break before SpacingMarks, or after Prepend characters.
// GB9a
if(next===SpacingMark){return BREAK_NOT_ALLOWED;}// GB9a
if(current===Prepend){return BREAK_NOT_ALLOWED;}// GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
if(current===ZWJ&&next===Extended_Pictographic){while(prev===Extend){prev=classTypes[--prevIndex];}if(prev===Extended_Pictographic){return BREAK_NOT_ALLOWED;}}// GB12 Do not break within emoji flag sequences.
// That is, do not break between regional indicator (RI) symbols
// if there is an odd number of RI characters before the break point.
if(current===RI&&next===RI){var countRI=0;while(prev===RI){countRI++;prev=classTypes[--prevIndex];}if(countRI%2===0){return BREAK_NOT_ALLOWED;}}return BREAK_ALLOWED;};var GraphemeBreaker=function GraphemeBreaker(str){var codePoints=toCodePoints(str);var length=codePoints.length;var index=0;var lastEnd=0;var classTypes=codePoints.map(codePointToClass);return{next:function next(){if(index>=length){return{done:true,value:null};}var graphemeBreak=BREAK_NOT_ALLOWED;while(index<length&&(graphemeBreak=_graphemeBreakAtIndex(codePoints,classTypes,++index))===BREAK_NOT_ALLOWED){}if(graphemeBreak!==BREAK_NOT_ALLOWED||index===length){var value=fromCodePoint.apply(null,codePoints.slice(lastEnd,index));lastEnd=index;return{value:value,done:false};}return{done:true,value:null};}};};var splitGraphemes=function splitGraphemes(str){var breaker=GraphemeBreaker(str);var graphemes=[];var bk;while(!(bk=breaker.next()).done){if(bk.value){graphemes.push(bk.value.slice());}}return graphemes;};var testRangeBounds=function testRangeBounds(document){var TEST_HEIGHT=123;if(document.createRange){var range=document.createRange();if(range.getBoundingClientRect){var testElement=document.createElement('boundtest');testElement.style.height=TEST_HEIGHT+"px";testElement.style.display='block';document.body.appendChild(testElement);range.selectNode(testElement);var rangeBounds=range.getBoundingClientRect();var rangeHeight=Math.round(rangeBounds.height);document.body.removeChild(testElement);if(rangeHeight===TEST_HEIGHT){return true;}}}return false;};var testIOSLineBreak=function testIOSLineBreak(document){var testElement=document.createElement('boundtest');testElement.style.width='50px';testElement.style.display='block';testElement.style.fontSize='12px';testElement.style.letterSpacing='0px';testElement.style.wordSpacing='0px';document.body.appendChild(testElement);var range=document.createRange();testElement.innerHTML=typeof''.repeat==='function'?'&#128104;'.repeat(10):'';var node=testElement.firstChild;var textList=toCodePoints$1(node.data).map(function(i){return fromCodePoint$1(i);});var offset=0;var prev={};// ios 13 does not handle range getBoundingClientRect line changes correctly #2177
var supports=textList.every(function(text,i){range.setStart(node,offset);range.setEnd(node,offset+text.length);var rect=range.getBoundingClientRect();offset+=text.length;var boundAhead=rect.x>prev.x||rect.y>prev.y;prev=rect;if(i===0){return true;}return boundAhead;});document.body.removeChild(testElement);return supports;};var testCORS=function testCORS(){return typeof new Image().crossOrigin!=='undefined';};var testResponseType=function testResponseType(){return typeof new XMLHttpRequest().responseType==='string';};var testSVG=function testSVG(document){var img=new Image();var canvas=document.createElement('canvas');var ctx=canvas.getContext('2d');if(!ctx){return false;}img.src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";try{ctx.drawImage(img,0,0);canvas.toDataURL();}catch(e){return false;}return true;};var isGreenPixel=function isGreenPixel(data){return data[0]===0&&data[1]===255&&data[2]===0&&data[3]===255;};var testForeignObject=function testForeignObject(document){var canvas=document.createElement('canvas');var size=100;canvas.width=size;canvas.height=size;var ctx=canvas.getContext('2d');if(!ctx){return Promise.reject(false);}ctx.fillStyle='rgb(0, 255, 0)';ctx.fillRect(0,0,size,size);var img=new Image();var greenImageSrc=canvas.toDataURL();img.src=greenImageSrc;var svg=createForeignObjectSVG(size,size,0,0,img);ctx.fillStyle='red';ctx.fillRect(0,0,size,size);return loadSerializedSVG$1(svg).then(function(img){ctx.drawImage(img,0,0);var data=ctx.getImageData(0,0,size,size).data;ctx.fillStyle='red';ctx.fillRect(0,0,size,size);var node=document.createElement('div');node.style.backgroundImage="url("+greenImageSrc+")";node.style.height=size+"px";// Firefox 55 does not render inline <img /> tags
return isGreenPixel(data)?loadSerializedSVG$1(createForeignObjectSVG(size,size,0,0,node)):Promise.reject(false);}).then(function(img){ctx.drawImage(img,0,0);// Edge does not render background-images
return isGreenPixel(ctx.getImageData(0,0,size,size).data);})["catch"](function(){return false;});};var createForeignObjectSVG=function createForeignObjectSVG(width,height,x,y,node){var xmlns='http://www.w3.org/2000/svg';var svg=document.createElementNS(xmlns,'svg');var foreignObject=document.createElementNS(xmlns,'foreignObject');svg.setAttributeNS(null,'width',width.toString());svg.setAttributeNS(null,'height',height.toString());foreignObject.setAttributeNS(null,'width','100%');foreignObject.setAttributeNS(null,'height','100%');foreignObject.setAttributeNS(null,'x',x.toString());foreignObject.setAttributeNS(null,'y',y.toString());foreignObject.setAttributeNS(null,'externalResourcesRequired','true');svg.appendChild(foreignObject);foreignObject.appendChild(node);return svg;};var loadSerializedSVG$1=function loadSerializedSVG$1(svg){return new Promise(function(resolve,reject){var img=new Image();img.onload=function(){return resolve(img);};img.onerror=reject;img.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(new XMLSerializer().serializeToString(svg));});};var FEATURES={get SUPPORT_RANGE_BOUNDS(){var value=testRangeBounds(document);Object.defineProperty(FEATURES,'SUPPORT_RANGE_BOUNDS',{value:value});return value;},get SUPPORT_WORD_BREAKING(){var value=FEATURES.SUPPORT_RANGE_BOUNDS&&testIOSLineBreak(document);Object.defineProperty(FEATURES,'SUPPORT_WORD_BREAKING',{value:value});return value;},get SUPPORT_SVG_DRAWING(){var value=testSVG(document);Object.defineProperty(FEATURES,'SUPPORT_SVG_DRAWING',{value:value});return value;},get SUPPORT_FOREIGNOBJECT_DRAWING(){var value=typeof Array.from==='function'&&typeof window.fetch==='function'?testForeignObject(document):Promise.resolve(false);Object.defineProperty(FEATURES,'SUPPORT_FOREIGNOBJECT_DRAWING',{value:value});return value;},get SUPPORT_CORS_IMAGES(){var value=testCORS();Object.defineProperty(FEATURES,'SUPPORT_CORS_IMAGES',{value:value});return value;},get SUPPORT_RESPONSE_TYPE(){var value=testResponseType();Object.defineProperty(FEATURES,'SUPPORT_RESPONSE_TYPE',{value:value});return value;},get SUPPORT_CORS_XHR(){var value=('withCredentials'in new XMLHttpRequest());Object.defineProperty(FEATURES,'SUPPORT_CORS_XHR',{value:value});return value;},get SUPPORT_NATIVE_TEXT_SEGMENTATION(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
var value=!!(typeof Intl!=='undefined'&&Intl.Segmenter);Object.defineProperty(FEATURES,'SUPPORT_NATIVE_TEXT_SEGMENTATION',{value:value});return value;}};var TextBounds=/** @class */function(){function TextBounds(text,bounds){this.text=text;this.bounds=bounds;}return TextBounds;}();var parseTextBounds=function parseTextBounds(context,value,styles,node){var textList=breakText(value,styles);var textBounds=[];var offset=0;textList.forEach(function(text){if(styles.textDecorationLine.length||text.trim().length>0){if(FEATURES.SUPPORT_RANGE_BOUNDS){var clientRects=createRange(node,offset,text.length).getClientRects();if(clientRects.length>1){var subSegments=segmentGraphemes(text);var subOffset_1=0;subSegments.forEach(function(subSegment){textBounds.push(new TextBounds(subSegment,Bounds.fromDOMRectList(context,createRange(node,subOffset_1+offset,subSegment.length).getClientRects())));subOffset_1+=subSegment.length;});}else{textBounds.push(new TextBounds(text,Bounds.fromDOMRectList(context,clientRects)));}}else{var replacementNode=node.splitText(text.length);textBounds.push(new TextBounds(text,getWrapperBounds(context,node)));node=replacementNode;}}else if(!FEATURES.SUPPORT_RANGE_BOUNDS){node=node.splitText(text.length);}offset+=text.length;});return textBounds;};var getWrapperBounds=function getWrapperBounds(context,node){var ownerDocument=node.ownerDocument;if(ownerDocument){var wrapper=ownerDocument.createElement('html2canvaswrapper');wrapper.appendChild(node.cloneNode(true));var parentNode=node.parentNode;if(parentNode){parentNode.replaceChild(wrapper,node);var bounds=parseBounds(context,wrapper);if(wrapper.firstChild){parentNode.replaceChild(wrapper.firstChild,wrapper);}return bounds;}}return Bounds.EMPTY;};var createRange=function createRange(node,offset,length){var ownerDocument=node.ownerDocument;if(!ownerDocument){throw new Error('Node has no owner document');}var range=ownerDocument.createRange();range.setStart(node,offset);range.setEnd(node,offset+length);return range;};var segmentGraphemes=function segmentGraphemes(value){if(FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION){// eslint-disable-next-line @typescript-eslint/no-explicit-any
var segmenter=new Intl.Segmenter(void 0,{granularity:'grapheme'});// eslint-disable-next-line @typescript-eslint/no-explicit-any
return Array.from(segmenter.segment(value)).map(function(segment){return segment.segment;});}return splitGraphemes(value);};var segmentWords=function segmentWords(value,styles){if(FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION){// eslint-disable-next-line @typescript-eslint/no-explicit-any
var segmenter=new Intl.Segmenter(void 0,{granularity:'word'});// eslint-disable-next-line @typescript-eslint/no-explicit-any
return Array.from(segmenter.segment(value)).map(function(segment){return segment.segment;});}return breakWords(value,styles);};var breakText=function breakText(value,styles){return styles.letterSpacing!==0?segmentGraphemes(value):segmentWords(value,styles);};// https://drafts.csswg.org/css-text/#word-separator
var wordSeparators=[0x0020,0x00a0,0x1361,0x10100,0x10101,0x1039,0x1091];var breakWords=function breakWords(str,styles){var breaker=LineBreaker(str,{lineBreak:styles.lineBreak,wordBreak:styles.overflowWrap==="break-word"/* BREAK_WORD */?'break-word':styles.wordBreak});var words=[];var bk;var _loop_1=function _loop_1(){if(bk.value){var value=bk.value.slice();var codePoints=toCodePoints$1(value);var word_1='';codePoints.forEach(function(codePoint){if(wordSeparators.indexOf(codePoint)===-1){word_1+=fromCodePoint$1(codePoint);}else{if(word_1.length){words.push(word_1);}words.push(fromCodePoint$1(codePoint));word_1='';}});if(word_1.length){words.push(word_1);}}};while(!(bk=breaker.next()).done){_loop_1();}return words;};var TextContainer=/** @class */function(){function TextContainer(context,node,styles){this.text=transform(node.data,styles.textTransform);this.textBounds=parseTextBounds(context,this.text,styles,node);}return TextContainer;}();var transform=function transform(text,_transform){switch(_transform){case 1/* LOWERCASE */:return text.toLowerCase();case 3/* CAPITALIZE */:return text.replace(CAPITALIZE,capitalize);case 2/* UPPERCASE */:return text.toUpperCase();default:return text;}};var CAPITALIZE=/(^|\s|:|-|\(|\))([a-z])/g;var capitalize=function capitalize(m,p1,p2){if(m.length>0){return p1+p2.toUpperCase();}return m;};var ImageElementContainer=/** @class */function(_super){__extends(ImageElementContainer,_super);function ImageElementContainer(context,img){var _this=_super.call(this,context,img)||this;_this.src=img.currentSrc||img.src;_this.intrinsicWidth=img.naturalWidth;_this.intrinsicHeight=img.naturalHeight;_this.context.cache.addImage(_this.src);return _this;}return ImageElementContainer;}(ElementContainer);var CanvasElementContainer=/** @class */function(_super){__extends(CanvasElementContainer,_super);function CanvasElementContainer(context,canvas){var _this=_super.call(this,context,canvas)||this;_this.canvas=canvas;_this.intrinsicWidth=canvas.width;_this.intrinsicHeight=canvas.height;return _this;}return CanvasElementContainer;}(ElementContainer);var SVGElementContainer=/** @class */function(_super){__extends(SVGElementContainer,_super);function SVGElementContainer(context,img){var _this=_super.call(this,context,img)||this;var s=new XMLSerializer();var bounds=parseBounds(context,img);img.setAttribute('width',bounds.width+"px");img.setAttribute('height',bounds.height+"px");_this.svg="data:image/svg+xml,"+encodeURIComponent(s.serializeToString(img));_this.intrinsicWidth=img.width.baseVal.value;_this.intrinsicHeight=img.height.baseVal.value;_this.context.cache.addImage(_this.svg);return _this;}return SVGElementContainer;}(ElementContainer);var LIElementContainer=/** @class */function(_super){__extends(LIElementContainer,_super);function LIElementContainer(context,element){var _this=_super.call(this,context,element)||this;_this.value=element.value;return _this;}return LIElementContainer;}(ElementContainer);var OLElementContainer=/** @class */function(_super){__extends(OLElementContainer,_super);function OLElementContainer(context,element){var _this=_super.call(this,context,element)||this;_this.start=element.start;_this.reversed=typeof element.reversed==='boolean'&&element.reversed===true;return _this;}return OLElementContainer;}(ElementContainer);var CHECKBOX_BORDER_RADIUS=[{type:15/* DIMENSION_TOKEN */,flags:0,unit:'px',number:3}];var RADIO_BORDER_RADIUS=[{type:16/* PERCENTAGE_TOKEN */,flags:0,number:50}];var reformatInputBounds=function reformatInputBounds(bounds){if(bounds.width>bounds.height){return new Bounds(bounds.left+(bounds.width-bounds.height)/2,bounds.top,bounds.height,bounds.height);}else if(bounds.width<bounds.height){return new Bounds(bounds.left,bounds.top+(bounds.height-bounds.width)/2,bounds.width,bounds.width);}return bounds;};var getInputValue=function getInputValue(node){var value=node.type===PASSWORD?new Array(node.value.length+1).join("\u2022"):node.value;return value.length===0?node.placeholder||'':value;};var CHECKBOX='checkbox';var RADIO='radio';var PASSWORD='password';var INPUT_COLOR=0x2a2a2aff;var InputElementContainer=/** @class */function(_super){__extends(InputElementContainer,_super);function InputElementContainer(context,input){var _this=_super.call(this,context,input)||this;_this.type=input.type.toLowerCase();_this.checked=input.checked;_this.value=getInputValue(input);if(_this.type===CHECKBOX||_this.type===RADIO){_this.styles.backgroundColor=0xdededeff;_this.styles.borderTopColor=_this.styles.borderRightColor=_this.styles.borderBottomColor=_this.styles.borderLeftColor=0xa5a5a5ff;_this.styles.borderTopWidth=_this.styles.borderRightWidth=_this.styles.borderBottomWidth=_this.styles.borderLeftWidth=1;_this.styles.borderTopStyle=_this.styles.borderRightStyle=_this.styles.borderBottomStyle=_this.styles.borderLeftStyle=1/* SOLID */;_this.styles.backgroundClip=[0/* BORDER_BOX */];_this.styles.backgroundOrigin=[0/* BORDER_BOX */];_this.bounds=reformatInputBounds(_this.bounds);}switch(_this.type){case CHECKBOX:_this.styles.borderTopRightRadius=_this.styles.borderTopLeftRadius=_this.styles.borderBottomRightRadius=_this.styles.borderBottomLeftRadius=CHECKBOX_BORDER_RADIUS;break;case RADIO:_this.styles.borderTopRightRadius=_this.styles.borderTopLeftRadius=_this.styles.borderBottomRightRadius=_this.styles.borderBottomLeftRadius=RADIO_BORDER_RADIUS;break;}return _this;}return InputElementContainer;}(ElementContainer);var SelectElementContainer=/** @class */function(_super){__extends(SelectElementContainer,_super);function SelectElementContainer(context,element){var _this=_super.call(this,context,element)||this;var option=element.options[element.selectedIndex||0];_this.value=option?option.text||'':'';return _this;}return SelectElementContainer;}(ElementContainer);var TextareaElementContainer=/** @class */function(_super){__extends(TextareaElementContainer,_super);function TextareaElementContainer(context,element){var _this=_super.call(this,context,element)||this;_this.value=element.value;return _this;}return TextareaElementContainer;}(ElementContainer);var IFrameElementContainer=/** @class */function(_super){__extends(IFrameElementContainer,_super);function IFrameElementContainer(context,iframe){var _this=_super.call(this,context,iframe)||this;_this.src=iframe.src;_this.width=parseInt(iframe.width,10)||0;_this.height=parseInt(iframe.height,10)||0;_this.backgroundColor=_this.styles.backgroundColor;try{if(iframe.contentWindow&&iframe.contentWindow.document&&iframe.contentWindow.document.documentElement){_this.tree=parseTree(context,iframe.contentWindow.document.documentElement);// http://www.w3.org/TR/css3-background/#special-backgrounds
var documentBackgroundColor=iframe.contentWindow.document.documentElement?parseColor(context,getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor):COLORS.TRANSPARENT;var bodyBackgroundColor=iframe.contentWindow.document.body?parseColor(context,getComputedStyle(iframe.contentWindow.document.body).backgroundColor):COLORS.TRANSPARENT;_this.backgroundColor=isTransparent(documentBackgroundColor)?isTransparent(bodyBackgroundColor)?_this.styles.backgroundColor:bodyBackgroundColor:documentBackgroundColor;}}catch(e){}return _this;}return IFrameElementContainer;}(ElementContainer);var LIST_OWNERS=['OL','UL','MENU'];var parseNodeTree=function parseNodeTree(context,node,parent,root){for(var childNode=node.firstChild,nextNode=void 0;childNode;childNode=nextNode){nextNode=childNode.nextSibling;if(isTextNode(childNode)&&childNode.data.trim().length>0){parent.textNodes.push(new TextContainer(context,childNode,parent.styles));}else if(isElementNode(childNode)){if(isSlotElement(childNode)&&childNode.assignedNodes){childNode.assignedNodes().forEach(function(childNode){return parseNodeTree(context,childNode,parent,root);});}else{var container=createContainer(context,childNode);if(container.styles.isVisible()){if(createsRealStackingContext(childNode,container,root)){container.flags|=4/* CREATES_REAL_STACKING_CONTEXT */;}else if(createsStackingContext(container.styles)){container.flags|=2/* CREATES_STACKING_CONTEXT */;}if(LIST_OWNERS.indexOf(childNode.tagName)!==-1){container.flags|=8/* IS_LIST_OWNER */;}parent.elements.push(container);childNode.slot;if(childNode.shadowRoot){parseNodeTree(context,childNode.shadowRoot,container,root);}else if(!isTextareaElement(childNode)&&!isSVGElement(childNode)&&!isSelectElement(childNode)){parseNodeTree(context,childNode,container,root);}}}}}};var createContainer=function createContainer(context,element){if(isImageElement(element)){return new ImageElementContainer(context,element);}if(isCanvasElement(element)){return new CanvasElementContainer(context,element);}if(isSVGElement(element)){return new SVGElementContainer(context,element);}if(isLIElement(element)){return new LIElementContainer(context,element);}if(isOLElement(element)){return new OLElementContainer(context,element);}if(isInputElement(element)){return new InputElementContainer(context,element);}if(isSelectElement(element)){return new SelectElementContainer(context,element);}if(isTextareaElement(element)){return new TextareaElementContainer(context,element);}if(isIFrameElement(element)){return new IFrameElementContainer(context,element);}return new ElementContainer(context,element);};var parseTree=function parseTree(context,element){var container=createContainer(context,element);container.flags|=4/* CREATES_REAL_STACKING_CONTEXT */;parseNodeTree(context,element,container,container);return container;};var createsRealStackingContext=function createsRealStackingContext(node,container,root){return container.styles.isPositionedWithZIndex()||container.styles.opacity<1||container.styles.isTransformed()||isBodyElement(node)&&root.styles.isTransparent();};var createsStackingContext=function createsStackingContext(styles){return styles.isPositioned()||styles.isFloating();};var isTextNode=function isTextNode(node){return node.nodeType===Node.TEXT_NODE;};var isElementNode=function isElementNode(node){return node.nodeType===Node.ELEMENT_NODE;};var isHTMLElementNode=function isHTMLElementNode(node){return isElementNode(node)&&typeof node.style!=='undefined'&&!isSVGElementNode(node);};var isSVGElementNode=function isSVGElementNode(element){return _typeof(element.className)==='object';};var isLIElement=function isLIElement(node){return node.tagName==='LI';};var isOLElement=function isOLElement(node){return node.tagName==='OL';};var isInputElement=function isInputElement(node){return node.tagName==='INPUT';};var isHTMLElement=function isHTMLElement(node){return node.tagName==='HTML';};var isSVGElement=function isSVGElement(node){return node.tagName==='svg';};var isBodyElement=function isBodyElement(node){return node.tagName==='BODY';};var isCanvasElement=function isCanvasElement(node){return node.tagName==='CANVAS';};var isVideoElement=function isVideoElement(node){return node.tagName==='VIDEO';};var isImageElement=function isImageElement(node){return node.tagName==='IMG';};var isIFrameElement=function isIFrameElement(node){return node.tagName==='IFRAME';};var isStyleElement=function isStyleElement(node){return node.tagName==='STYLE';};var isScriptElement=function isScriptElement(node){return node.tagName==='SCRIPT';};var isTextareaElement=function isTextareaElement(node){return node.tagName==='TEXTAREA';};var isSelectElement=function isSelectElement(node){return node.tagName==='SELECT';};var isSlotElement=function isSlotElement(node){return node.tagName==='SLOT';};// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
var isCustomElement=function isCustomElement(node){return node.tagName.indexOf('-')>0;};var CounterState=/** @class */function(){function CounterState(){this.counters={};}CounterState.prototype.getCounterValue=function(name){var counter=this.counters[name];if(counter&&counter.length){return counter[counter.length-1];}return 1;};CounterState.prototype.getCounterValues=function(name){var counter=this.counters[name];return counter?counter:[];};CounterState.prototype.pop=function(counters){var _this=this;counters.forEach(function(counter){return _this.counters[counter].pop();});};CounterState.prototype.parse=function(style){var _this=this;var counterIncrement=style.counterIncrement;var counterReset=style.counterReset;var canReset=true;if(counterIncrement!==null){counterIncrement.forEach(function(entry){var counter=_this.counters[entry.counter];if(counter&&entry.increment!==0){canReset=false;if(!counter.length){counter.push(1);}counter[Math.max(0,counter.length-1)]+=entry.increment;}});}var counterNames=[];if(canReset){counterReset.forEach(function(entry){var counter=_this.counters[entry.counter];counterNames.push(entry.counter);if(!counter){counter=_this.counters[entry.counter]=[];}counter.push(entry.reset);});}return counterNames;};return CounterState;}();var ROMAN_UPPER={integers:[1000,900,500,400,100,90,50,40,10,9,5,4,1],values:['M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I']};var ARMENIAN={integers:[9000,8000,7000,6000,5000,4000,3000,2000,1000,900,800,700,600,500,400,300,200,100,90,80,70,60,50,40,30,20,10,9,8,7,6,5,4,3,2,1],values:['','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','']};var HEBREW={integers:[10000,9000,8000,7000,6000,5000,4000,3000,2000,1000,400,300,200,100,90,80,70,60,50,40,30,20,19,18,17,16,15,10,9,8,7,6,5,4,3,2,1],values:['','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','']};var GEORGIAN={integers:[10000,9000,8000,7000,6000,5000,4000,3000,2000,1000,900,800,700,600,500,400,300,200,100,90,80,70,60,50,40,30,20,10,9,8,7,6,5,4,3,2,1],values:['','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','']};var createAdditiveCounter=function createAdditiveCounter(value,min,max,symbols,fallback,suffix){if(value<min||value>max){return createCounterText(value,fallback,suffix.length>0);}return symbols.integers.reduce(function(string,integer,index){while(value>=integer){value-=integer;string+=symbols.values[index];}return string;},'')+suffix;};var createCounterStyleWithSymbolResolver=function createCounterStyleWithSymbolResolver(value,codePointRangeLength,isNumeric,resolver){var string='';do{if(!isNumeric){value--;}string=resolver(value)+string;value/=codePointRangeLength;}while(value*codePointRangeLength>=codePointRangeLength);return string;};var createCounterStyleFromRange=function createCounterStyleFromRange(value,codePointRangeStart,codePointRangeEnd,isNumeric,suffix){var codePointRangeLength=codePointRangeEnd-codePointRangeStart+1;return(value<0?'-':'')+(createCounterStyleWithSymbolResolver(Math.abs(value),codePointRangeLength,isNumeric,function(codePoint){return fromCodePoint$1(Math.floor(codePoint%codePointRangeLength)+codePointRangeStart);})+suffix);};var createCounterStyleFromSymbols=function createCounterStyleFromSymbols(value,symbols,suffix){if(suffix===void 0){suffix='. ';}var codePointRangeLength=symbols.length;return createCounterStyleWithSymbolResolver(Math.abs(value),codePointRangeLength,false,function(codePoint){return symbols[Math.floor(codePoint%codePointRangeLength)];})+suffix;};var CJK_ZEROS=1<<0;var CJK_TEN_COEFFICIENTS=1<<1;var CJK_TEN_HIGH_COEFFICIENTS=1<<2;var CJK_HUNDRED_COEFFICIENTS=1<<3;var createCJKCounter=function createCJKCounter(value,numbers,multipliers,negativeSign,suffix,flags){if(value<-9999||value>9999){return createCounterText(value,4/* CJK_DECIMAL */,suffix.length>0);}var tmp=Math.abs(value);var string=suffix;if(tmp===0){return numbers[0]+string;}for(var digit=0;tmp>0&&digit<=4;digit++){var coefficient=tmp%10;if(coefficient===0&&contains(flags,CJK_ZEROS)&&string!==''){string=numbers[coefficient]+string;}else if(coefficient>1||coefficient===1&&digit===0||coefficient===1&&digit===1&&contains(flags,CJK_TEN_COEFFICIENTS)||coefficient===1&&digit===1&&contains(flags,CJK_TEN_HIGH_COEFFICIENTS)&&value>100||coefficient===1&&digit>1&&contains(flags,CJK_HUNDRED_COEFFICIENTS)){string=numbers[coefficient]+(digit>0?multipliers[digit-1]:'')+string;}else if(coefficient===1&&digit>0){string=multipliers[digit-1]+string;}tmp=Math.floor(tmp/10);}return(value<0?negativeSign:'')+string;};var CHINESE_INFORMAL_MULTIPLIERS='';var CHINESE_FORMAL_MULTIPLIERS='';var JAPANESE_NEGATIVE='';var KOREAN_NEGATIVE='';var createCounterText=function createCounterText(value,type,appendSuffix){var defaultSuffix=appendSuffix?'. ':'';var cjkSuffix=appendSuffix?'':'';var koreanSuffix=appendSuffix?', ':'';var spaceSuffix=appendSuffix?' ':'';switch(type){case 0/* DISC */:return''+spaceSuffix;case 1/* CIRCLE */:return''+spaceSuffix;case 2/* SQUARE */:return''+spaceSuffix;case 5/* DECIMAL_LEADING_ZERO */:var string=createCounterStyleFromRange(value,48,57,true,defaultSuffix);return string.length<4?"0"+string:string;case 4/* CJK_DECIMAL */:return createCounterStyleFromSymbols(value,'',cjkSuffix);case 6/* LOWER_ROMAN */:return createAdditiveCounter(value,1,3999,ROMAN_UPPER,3/* DECIMAL */,defaultSuffix).toLowerCase();case 7/* UPPER_ROMAN */:return createAdditiveCounter(value,1,3999,ROMAN_UPPER,3/* DECIMAL */,defaultSuffix);case 8/* LOWER_GREEK */:return createCounterStyleFromRange(value,945,969,false,defaultSuffix);case 9/* LOWER_ALPHA */:return createCounterStyleFromRange(value,97,122,false,defaultSuffix);case 10/* UPPER_ALPHA */:return createCounterStyleFromRange(value,65,90,false,defaultSuffix);case 11/* ARABIC_INDIC */:return createCounterStyleFromRange(value,1632,1641,true,defaultSuffix);case 12/* ARMENIAN */:case 49/* UPPER_ARMENIAN */:return createAdditiveCounter(value,1,9999,ARMENIAN,3/* DECIMAL */,defaultSuffix);case 35/* LOWER_ARMENIAN */:return createAdditiveCounter(value,1,9999,ARMENIAN,3/* DECIMAL */,defaultSuffix).toLowerCase();case 13/* BENGALI */:return createCounterStyleFromRange(value,2534,2543,true,defaultSuffix);case 14/* CAMBODIAN */:case 30/* KHMER */:return createCounterStyleFromRange(value,6112,6121,true,defaultSuffix);case 15/* CJK_EARTHLY_BRANCH */:return createCounterStyleFromSymbols(value,'',cjkSuffix);case 16/* CJK_HEAVENLY_STEM */:return createCounterStyleFromSymbols(value,'',cjkSuffix);case 17/* CJK_IDEOGRAPHIC */:case 48/* TRAD_CHINESE_INFORMAL */:return createCJKCounter(value,'',CHINESE_INFORMAL_MULTIPLIERS,'',cjkSuffix,CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS|CJK_HUNDRED_COEFFICIENTS);case 47/* TRAD_CHINESE_FORMAL */:return createCJKCounter(value,'',CHINESE_FORMAL_MULTIPLIERS,'',cjkSuffix,CJK_ZEROS|CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS|CJK_HUNDRED_COEFFICIENTS);case 42/* SIMP_CHINESE_INFORMAL */:return createCJKCounter(value,'',CHINESE_INFORMAL_MULTIPLIERS,'',cjkSuffix,CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS|CJK_HUNDRED_COEFFICIENTS);case 41/* SIMP_CHINESE_FORMAL */:return createCJKCounter(value,'',CHINESE_FORMAL_MULTIPLIERS,'',cjkSuffix,CJK_ZEROS|CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS|CJK_HUNDRED_COEFFICIENTS);case 26/* JAPANESE_INFORMAL */:return createCJKCounter(value,'','',JAPANESE_NEGATIVE,cjkSuffix,0);case 25/* JAPANESE_FORMAL */:return createCJKCounter(value,'','',JAPANESE_NEGATIVE,cjkSuffix,CJK_ZEROS|CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS);case 31/* KOREAN_HANGUL_FORMAL */:return createCJKCounter(value,'','',KOREAN_NEGATIVE,koreanSuffix,CJK_ZEROS|CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS);case 33/* KOREAN_HANJA_INFORMAL */:return createCJKCounter(value,'','',KOREAN_NEGATIVE,koreanSuffix,0);case 32/* KOREAN_HANJA_FORMAL */:return createCJKCounter(value,'','',KOREAN_NEGATIVE,koreanSuffix,CJK_ZEROS|CJK_TEN_COEFFICIENTS|CJK_TEN_HIGH_COEFFICIENTS);case 18/* DEVANAGARI */:return createCounterStyleFromRange(value,0x966,0x96f,true,defaultSuffix);case 20/* GEORGIAN */:return createAdditiveCounter(value,1,19999,GEORGIAN,3/* DECIMAL */,defaultSuffix);case 21/* GUJARATI */:return createCounterStyleFromRange(value,0xae6,0xaef,true,defaultSuffix);case 22/* GURMUKHI */:return createCounterStyleFromRange(value,0xa66,0xa6f,true,defaultSuffix);case 22/* HEBREW */:return createAdditiveCounter(value,1,10999,HEBREW,3/* DECIMAL */,defaultSuffix);case 23/* HIRAGANA */:return createCounterStyleFromSymbols(value,'');case 24/* HIRAGANA_IROHA */:return createCounterStyleFromSymbols(value,'');case 27/* KANNADA */:return createCounterStyleFromRange(value,0xce6,0xcef,true,defaultSuffix);case 28/* KATAKANA */:return createCounterStyleFromSymbols(value,'',cjkSuffix);case 29/* KATAKANA_IROHA */:return createCounterStyleFromSymbols(value,'',cjkSuffix);case 34/* LAO */:return createCounterStyleFromRange(value,0xed0,0xed9,true,defaultSuffix);case 37/* MONGOLIAN */:return createCounterStyleFromRange(value,0x1810,0x1819,true,defaultSuffix);case 38/* MYANMAR */:return createCounterStyleFromRange(value,0x1040,0x1049,true,defaultSuffix);case 39/* ORIYA */:return createCounterStyleFromRange(value,0xb66,0xb6f,true,defaultSuffix);case 40/* PERSIAN */:return createCounterStyleFromRange(value,0x6f0,0x6f9,true,defaultSuffix);case 43/* TAMIL */:return createCounterStyleFromRange(value,0xbe6,0xbef,true,defaultSuffix);case 44/* TELUGU */:return createCounterStyleFromRange(value,0xc66,0xc6f,true,defaultSuffix);case 45/* THAI */:return createCounterStyleFromRange(value,0xe50,0xe59,true,defaultSuffix);case 46/* TIBETAN */:return createCounterStyleFromRange(value,0xf20,0xf29,true,defaultSuffix);case 3/* DECIMAL */:default:return createCounterStyleFromRange(value,48,57,true,defaultSuffix);}};var IGNORE_ATTRIBUTE='data-html2canvas-ignore';var DocumentCloner=/** @class */function(){function DocumentCloner(context,element,options){this.context=context;this.options=options;this.scrolledElements=[];this.referenceElement=element;this.counters=new CounterState();this.quoteDepth=0;if(!element.ownerDocument){throw new Error('Cloned element does not have an owner document');}this.documentElement=this.cloneNode(element.ownerDocument.documentElement,false);}DocumentCloner.prototype.toIFrame=function(ownerDocument,windowSize){var _this=this;var iframe=createIFrameContainer(ownerDocument,windowSize);if(!iframe.contentWindow){return Promise.reject("Unable to find iframe window");}var scrollX=ownerDocument.defaultView.pageXOffset;var scrollY=ownerDocument.defaultView.pageYOffset;var cloneWindow=iframe.contentWindow;var documentClone=cloneWindow.document;/* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
         if window url is about:blank, we can assign the url to current by writing onto the document
         */var iframeLoad=iframeLoader(iframe).then(function(){return __awaiter(_this,void 0,void 0,function(){var onclone,referenceElement;return __generator(this,function(_a){switch(_a.label){case 0:this.scrolledElements.forEach(restoreNodeScroll);if(cloneWindow){cloneWindow.scrollTo(windowSize.left,windowSize.top);if(/(iPad|iPhone|iPod)/g.test(navigator.userAgent)&&(cloneWindow.scrollY!==windowSize.top||cloneWindow.scrollX!==windowSize.left)){this.context.logger.warn('Unable to restore scroll position for cloned document');this.context.windowBounds=this.context.windowBounds.add(cloneWindow.scrollX-windowSize.left,cloneWindow.scrollY-windowSize.top,0,0);}}onclone=this.options.onclone;referenceElement=this.clonedReferenceElement;if(typeof referenceElement==='undefined'){return[2/*return*/,Promise.reject("Error finding the "+this.referenceElement.nodeName+" in the cloned document")];}if(!(documentClone.fonts&&documentClone.fonts.ready))return[3/*break*/,2];return[4/*yield*/,documentClone.fonts.ready];case 1:_a.sent();_a.label=2;case 2:if(!/(AppleWebKit)/g.test(navigator.userAgent))return[3/*break*/,4];return[4/*yield*/,imagesReady(documentClone)];case 3:_a.sent();_a.label=4;case 4:if(typeof onclone==='function'){return[2/*return*/,Promise.resolve().then(function(){return onclone(documentClone,referenceElement);}).then(function(){return iframe;})];}return[2/*return*/,iframe];}});});});documentClone.open();documentClone.write(serializeDoctype(document.doctype)+"<html></html>");// Chrome scrolls the parent document for some reason after the write to the cloned window???
restoreOwnerScroll(this.referenceElement.ownerDocument,scrollX,scrollY);documentClone.replaceChild(documentClone.adoptNode(this.documentElement),documentClone.documentElement);documentClone.close();return iframeLoad;};DocumentCloner.prototype.createElementClone=function(node){if(isDebugging(node,2/* CLONE */)){debugger;}if(isCanvasElement(node)){return this.createCanvasClone(node);}if(isVideoElement(node)){return this.createVideoClone(node);}if(isStyleElement(node)){return this.createStyleClone(node);}var clone=node.cloneNode(false);if(isImageElement(clone)){if(isImageElement(node)&&node.currentSrc&&node.currentSrc!==node.src){clone.src=node.currentSrc;clone.srcset='';}if(clone.loading==='lazy'){clone.loading='eager';}}if(isCustomElement(clone)){return this.createCustomElementClone(clone);}return clone;};DocumentCloner.prototype.createCustomElementClone=function(node){var clone=document.createElement('html2canvascustomelement');copyCSSStyles(node.style,clone);return clone;};DocumentCloner.prototype.createStyleClone=function(node){try{var sheet=node.sheet;if(sheet&&sheet.cssRules){var css=[].slice.call(sheet.cssRules,0).reduce(function(css,rule){if(rule&&typeof rule.cssText==='string'){return css+rule.cssText;}return css;},'');var style=node.cloneNode(false);style.textContent=css;return style;}}catch(e){// accessing node.sheet.cssRules throws a DOMException
this.context.logger.error('Unable to access cssRules property',e);if(e.name!=='SecurityError'){throw e;}}return node.cloneNode(false);};DocumentCloner.prototype.createCanvasClone=function(canvas){var _a;if(this.options.inlineImages&&canvas.ownerDocument){var img=canvas.ownerDocument.createElement('img');try{img.src=canvas.toDataURL();return img;}catch(e){this.context.logger.info("Unable to inline canvas contents, canvas is tainted",canvas);}}var clonedCanvas=canvas.cloneNode(false);try{clonedCanvas.width=canvas.width;clonedCanvas.height=canvas.height;var ctx=canvas.getContext('2d');var clonedCtx=clonedCanvas.getContext('2d');if(clonedCtx){if(!this.options.allowTaint&&ctx){clonedCtx.putImageData(ctx.getImageData(0,0,canvas.width,canvas.height),0,0);}else{var gl=(_a=canvas.getContext('webgl2'))!==null&&_a!==void 0?_a:canvas.getContext('webgl');if(gl){var attribs=gl.getContextAttributes();if((attribs===null||attribs===void 0?void 0:attribs.preserveDrawingBuffer)===false){this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false',canvas);}}clonedCtx.drawImage(canvas,0,0);}}return clonedCanvas;}catch(e){this.context.logger.info("Unable to clone canvas as it is tainted",canvas);}return clonedCanvas;};DocumentCloner.prototype.createVideoClone=function(video){var canvas=video.ownerDocument.createElement('canvas');canvas.width=video.offsetWidth;canvas.height=video.offsetHeight;var ctx=canvas.getContext('2d');try{if(ctx){ctx.drawImage(video,0,0,canvas.width,canvas.height);if(!this.options.allowTaint){ctx.getImageData(0,0,canvas.width,canvas.height);}}return canvas;}catch(e){this.context.logger.info("Unable to clone video as it is tainted",video);}var blankCanvas=video.ownerDocument.createElement('canvas');blankCanvas.width=video.offsetWidth;blankCanvas.height=video.offsetHeight;return blankCanvas;};DocumentCloner.prototype.appendChildNode=function(clone,child,copyStyles){if(!isElementNode(child)||!isScriptElement(child)&&!child.hasAttribute(IGNORE_ATTRIBUTE)&&(typeof this.options.ignoreElements!=='function'||!this.options.ignoreElements(child))){if(!this.options.copyStyles||!isElementNode(child)||!isStyleElement(child)){clone.appendChild(this.cloneNode(child,copyStyles));}}};DocumentCloner.prototype.cloneChildNodes=function(node,clone,copyStyles){var _this=this;for(var child=node.shadowRoot?node.shadowRoot.firstChild:node.firstChild;child;child=child.nextSibling){if(isElementNode(child)&&isSlotElement(child)&&typeof child.assignedNodes==='function'){var assignedNodes=child.assignedNodes();if(assignedNodes.length){assignedNodes.forEach(function(assignedNode){return _this.appendChildNode(clone,assignedNode,copyStyles);});}}else{this.appendChildNode(clone,child,copyStyles);}}};DocumentCloner.prototype.cloneNode=function(node,copyStyles){if(isTextNode(node)){return document.createTextNode(node.data);}if(!node.ownerDocument){return node.cloneNode(false);}var window=node.ownerDocument.defaultView;if(window&&isElementNode(node)&&(isHTMLElementNode(node)||isSVGElementNode(node))){var clone=this.createElementClone(node);clone.style.transitionProperty='none';var style=window.getComputedStyle(node);var styleBefore=window.getComputedStyle(node,':before');var styleAfter=window.getComputedStyle(node,':after');if(this.referenceElement===node&&isHTMLElementNode(clone)){this.clonedReferenceElement=clone;}if(isBodyElement(clone)){createPseudoHideStyles(clone);}var counters=this.counters.parse(new CSSParsedCounterDeclaration(this.context,style));var before=this.resolvePseudoContent(node,clone,styleBefore,PseudoElementType.BEFORE);if(isCustomElement(node)){copyStyles=true;}if(!isVideoElement(node)){this.cloneChildNodes(node,clone,copyStyles);}if(before){clone.insertBefore(before,clone.firstChild);}var after=this.resolvePseudoContent(node,clone,styleAfter,PseudoElementType.AFTER);if(after){clone.appendChild(after);}this.counters.pop(counters);if(style&&(this.options.copyStyles||isSVGElementNode(node))&&!isIFrameElement(node)||copyStyles){copyCSSStyles(style,clone);}if(node.scrollTop!==0||node.scrollLeft!==0){this.scrolledElements.push([clone,node.scrollLeft,node.scrollTop]);}if((isTextareaElement(node)||isSelectElement(node))&&(isTextareaElement(clone)||isSelectElement(clone))){clone.value=node.value;}return clone;}return node.cloneNode(false);};DocumentCloner.prototype.resolvePseudoContent=function(node,clone,style,pseudoElt){var _this=this;if(!style){return;}var value=style.content;var document=clone.ownerDocument;if(!document||!value||value==='none'||value==='-moz-alt-content'||style.display==='none'){return;}this.counters.parse(new CSSParsedCounterDeclaration(this.context,style));var declaration=new CSSParsedPseudoDeclaration(this.context,style);var anonymousReplacedElement=document.createElement('html2canvaspseudoelement');copyCSSStyles(style,anonymousReplacedElement);declaration.content.forEach(function(token){if(token.type===0/* STRING_TOKEN */){anonymousReplacedElement.appendChild(document.createTextNode(token.value));}else if(token.type===22/* URL_TOKEN */){var img=document.createElement('img');img.src=token.value;img.style.opacity='1';anonymousReplacedElement.appendChild(img);}else if(token.type===18/* FUNCTION */){if(token.name==='attr'){var attr=token.values.filter(isIdentToken);if(attr.length){anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value)||''));}}else if(token.name==='counter'){var _a=token.values.filter(nonFunctionArgSeparator),counter=_a[0],counterStyle=_a[1];if(counter&&isIdentToken(counter)){var counterState=_this.counters.getCounterValue(counter.value);var counterType=counterStyle&&isIdentToken(counterStyle)?listStyleType.parse(_this.context,counterStyle.value):3/* DECIMAL */;anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState,counterType,false)));}}else if(token.name==='counters'){var _b=token.values.filter(nonFunctionArgSeparator),counter=_b[0],delim=_b[1],counterStyle=_b[2];if(counter&&isIdentToken(counter)){var counterStates=_this.counters.getCounterValues(counter.value);var counterType_1=counterStyle&&isIdentToken(counterStyle)?listStyleType.parse(_this.context,counterStyle.value):3/* DECIMAL */;var separator=delim&&delim.type===0/* STRING_TOKEN */?delim.value:'';var text=counterStates.map(function(value){return createCounterText(value,counterType_1,false);}).join(separator);anonymousReplacedElement.appendChild(document.createTextNode(text));}}else;}else if(token.type===20/* IDENT_TOKEN */){switch(token.value){case'open-quote':anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes,_this.quoteDepth++,true)));break;case'close-quote':anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes,--_this.quoteDepth,false)));break;default:// safari doesn't parse string tokens correctly because of lack of quotes
anonymousReplacedElement.appendChild(document.createTextNode(token.value));}}});anonymousReplacedElement.className=PSEUDO_HIDE_ELEMENT_CLASS_BEFORE+" "+PSEUDO_HIDE_ELEMENT_CLASS_AFTER;var newClassName=pseudoElt===PseudoElementType.BEFORE?" "+PSEUDO_HIDE_ELEMENT_CLASS_BEFORE:" "+PSEUDO_HIDE_ELEMENT_CLASS_AFTER;if(isSVGElementNode(clone)){clone.className.baseValue+=newClassName;}else{clone.className+=newClassName;}return anonymousReplacedElement;};DocumentCloner.destroy=function(container){if(container.parentNode){container.parentNode.removeChild(container);return true;}return false;};return DocumentCloner;}();var PseudoElementType;(function(PseudoElementType){PseudoElementType[PseudoElementType["BEFORE"]=0]="BEFORE";PseudoElementType[PseudoElementType["AFTER"]=1]="AFTER";})(PseudoElementType||(PseudoElementType={}));var createIFrameContainer=function createIFrameContainer(ownerDocument,bounds){var cloneIframeContainer=ownerDocument.createElement('iframe');cloneIframeContainer.className='html2canvas-container';cloneIframeContainer.style.visibility='hidden';cloneIframeContainer.style.position='fixed';cloneIframeContainer.style.left='-10000px';cloneIframeContainer.style.top='0px';cloneIframeContainer.style.border='0';cloneIframeContainer.width=bounds.width.toString();cloneIframeContainer.height=bounds.height.toString();cloneIframeContainer.scrolling='no';// ios won't scroll without it
cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE,'true');ownerDocument.body.appendChild(cloneIframeContainer);return cloneIframeContainer;};var imageReady=function imageReady(img){return new Promise(function(resolve){if(img.complete){resolve();return;}if(!img.src){resolve();return;}img.onload=resolve;img.onerror=resolve;});};var imagesReady=function imagesReady(document){return Promise.all([].slice.call(document.images,0).map(imageReady));};var iframeLoader=function iframeLoader(iframe){return new Promise(function(resolve,reject){var cloneWindow=iframe.contentWindow;if(!cloneWindow){return reject("No window assigned for iframe");}var documentClone=cloneWindow.document;cloneWindow.onload=iframe.onload=function(){cloneWindow.onload=iframe.onload=null;var interval=setInterval(function(){if(documentClone.body.childNodes.length>0&&documentClone.readyState==='complete'){clearInterval(interval);resolve(iframe);}},50);};});};var ignoredStyleProperties=['all','d','content'// Safari shows pseudoelements if content is set
];var copyCSSStyles=function copyCSSStyles(style,target){// Edge does not provide value for cssText
for(var i=style.length-1;i>=0;i--){var property=style.item(i);if(ignoredStyleProperties.indexOf(property)===-1){target.style.setProperty(property,style.getPropertyValue(property));}}return target;};var serializeDoctype=function serializeDoctype(doctype){var str='';if(doctype){str+='<!DOCTYPE ';if(doctype.name){str+=doctype.name;}if(doctype.internalSubset){str+=doctype.internalSubset;}if(doctype.publicId){str+="\""+doctype.publicId+"\"";}if(doctype.systemId){str+="\""+doctype.systemId+"\"";}str+='>';}return str;};var restoreOwnerScroll=function restoreOwnerScroll(ownerDocument,x,y){if(ownerDocument&&ownerDocument.defaultView&&(x!==ownerDocument.defaultView.pageXOffset||y!==ownerDocument.defaultView.pageYOffset)){ownerDocument.defaultView.scrollTo(x,y);}};var restoreNodeScroll=function restoreNodeScroll(_a){var element=_a[0],x=_a[1],y=_a[2];element.scrollLeft=x;element.scrollTop=y;};var PSEUDO_BEFORE=':before';var PSEUDO_AFTER=':after';var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE='___html2canvas___pseudoelement_before';var PSEUDO_HIDE_ELEMENT_CLASS_AFTER='___html2canvas___pseudoelement_after';var PSEUDO_HIDE_ELEMENT_STYLE="{\n    content: \"\" !important;\n    display: none !important;\n}";var createPseudoHideStyles=function createPseudoHideStyles(body){createStyles(body,"."+PSEUDO_HIDE_ELEMENT_CLASS_BEFORE+PSEUDO_BEFORE+PSEUDO_HIDE_ELEMENT_STYLE+"\n         ."+PSEUDO_HIDE_ELEMENT_CLASS_AFTER+PSEUDO_AFTER+PSEUDO_HIDE_ELEMENT_STYLE);};var createStyles=function createStyles(body,styles){var document=body.ownerDocument;if(document){var style=document.createElement('style');style.textContent=styles;body.appendChild(style);}};var CacheStorage=/** @class */function(){function CacheStorage(){}CacheStorage.getOrigin=function(url){var link=CacheStorage._link;if(!link){return'about:blank';}link.href=url;link.href=link.href;// IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
return link.protocol+link.hostname+link.port;};CacheStorage.isSameOrigin=function(src){return CacheStorage.getOrigin(src)===CacheStorage._origin;};CacheStorage.setContext=function(window){CacheStorage._link=window.document.createElement('a');CacheStorage._origin=CacheStorage.getOrigin(window.location.href);};CacheStorage._origin='about:blank';return CacheStorage;}();var Cache=/** @class */function(){function Cache(context,_options){this.context=context;this._options=_options;// eslint-disable-next-line @typescript-eslint/no-explicit-any
this._cache={};}Cache.prototype.addImage=function(src){var result=Promise.resolve();if(this.has(src)){return result;}if(isBlobImage(src)||isRenderable(src)){(this._cache[src]=this.loadImage(src))["catch"](function(){// prevent unhandled rejection
});return result;}return result;};// eslint-disable-next-line @typescript-eslint/no-explicit-any
Cache.prototype.match=function(src){return this._cache[src];};Cache.prototype.loadImage=function(key){return __awaiter(this,void 0,void 0,function(){var isSameOrigin,useCORS,useProxy,src;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:isSameOrigin=CacheStorage.isSameOrigin(key);useCORS=!isInlineImage(key)&&this._options.useCORS===true&&FEATURES.SUPPORT_CORS_IMAGES&&!isSameOrigin;useProxy=!isInlineImage(key)&&!isSameOrigin&&!isBlobImage(key)&&typeof this._options.proxy==='string'&&FEATURES.SUPPORT_CORS_XHR&&!useCORS;if(!isSameOrigin&&this._options.allowTaint===false&&!isInlineImage(key)&&!isBlobImage(key)&&!useProxy&&!useCORS){return[2/*return*/];}src=key;if(!useProxy)return[3/*break*/,2];return[4/*yield*/,this.proxy(src)];case 1:src=_a.sent();_a.label=2;case 2:this.context.logger.debug("Added image "+key.substring(0,256));return[4/*yield*/,new Promise(function(resolve,reject){var img=new Image();img.onload=function(){return resolve(img);};img.onerror=reject;//ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
if(isInlineBase64Image(src)||useCORS){img.crossOrigin='anonymous';}img.src=src;if(img.complete===true){// Inline XML images may fail to parse, throwing an Error later on
setTimeout(function(){return resolve(img);},500);}if(_this._options.imageTimeout>0){setTimeout(function(){return reject("Timed out ("+_this._options.imageTimeout+"ms) loading image");},_this._options.imageTimeout);}})];case 3:return[2/*return*/,_a.sent()];}});});};Cache.prototype.has=function(key){return typeof this._cache[key]!=='undefined';};Cache.prototype.keys=function(){return Promise.resolve(Object.keys(this._cache));};Cache.prototype.proxy=function(src){var _this=this;var proxy=this._options.proxy;if(!proxy){throw new Error('No proxy defined');}var key=src.substring(0,256);return new Promise(function(resolve,reject){var responseType=FEATURES.SUPPORT_RESPONSE_TYPE?'blob':'text';var xhr=new XMLHttpRequest();xhr.onload=function(){if(xhr.status===200){if(responseType==='text'){resolve(xhr.response);}else{var reader_1=new FileReader();reader_1.addEventListener('load',function(){return resolve(reader_1.result);},false);reader_1.addEventListener('error',function(e){return reject(e);},false);reader_1.readAsDataURL(xhr.response);}}else{reject("Failed to proxy resource "+key+" with status code "+xhr.status);}};xhr.onerror=reject;var queryString=proxy.indexOf('?')>-1?'&':'?';xhr.open('GET',""+proxy+queryString+"url="+encodeURIComponent(src)+"&responseType="+responseType);if(responseType!=='text'&&xhr instanceof XMLHttpRequest){xhr.responseType=responseType;}if(_this._options.imageTimeout){var timeout_1=_this._options.imageTimeout;xhr.timeout=timeout_1;xhr.ontimeout=function(){return reject("Timed out ("+timeout_1+"ms) proxying "+key);};}xhr.send();});};return Cache;}();var INLINE_SVG=/^data:image\/svg\+xml/i;var INLINE_BASE64=/^data:image\/.*;base64,/i;var INLINE_IMG=/^data:image\/.*/i;var isRenderable=function isRenderable(src){return FEATURES.SUPPORT_SVG_DRAWING||!isSVG$1(src);};var isInlineImage=function isInlineImage(src){return INLINE_IMG.test(src);};var isInlineBase64Image=function isInlineBase64Image(src){return INLINE_BASE64.test(src);};var isBlobImage=function isBlobImage(src){return src.substr(0,4)==='blob';};var isSVG$1=function isSVG$1(src){return src.substr(-3).toLowerCase()==='svg'||INLINE_SVG.test(src);};var Vector=/** @class */function(){function Vector(x,y){this.type=0/* VECTOR */;this.x=x;this.y=y;}Vector.prototype.add=function(deltaX,deltaY){return new Vector(this.x+deltaX,this.y+deltaY);};return Vector;}();var lerp=function lerp(a,b,t){return new Vector(a.x+(b.x-a.x)*t,a.y+(b.y-a.y)*t);};var BezierCurve=/** @class */function(){function BezierCurve(start,startControl,endControl,end){this.type=1/* BEZIER_CURVE */;this.start=start;this.startControl=startControl;this.endControl=endControl;this.end=end;}BezierCurve.prototype.subdivide=function(t,firstHalf){var ab=lerp(this.start,this.startControl,t);var bc=lerp(this.startControl,this.endControl,t);var cd=lerp(this.endControl,this.end,t);var abbc=lerp(ab,bc,t);var bccd=lerp(bc,cd,t);var dest=lerp(abbc,bccd,t);return firstHalf?new BezierCurve(this.start,ab,abbc,dest):new BezierCurve(dest,bccd,cd,this.end);};BezierCurve.prototype.add=function(deltaX,deltaY){return new BezierCurve(this.start.add(deltaX,deltaY),this.startControl.add(deltaX,deltaY),this.endControl.add(deltaX,deltaY),this.end.add(deltaX,deltaY));};BezierCurve.prototype.reverse=function(){return new BezierCurve(this.end,this.endControl,this.startControl,this.start);};return BezierCurve;}();var isBezierCurve=function isBezierCurve(path){return path.type===1/* BEZIER_CURVE */;};var BoundCurves=/** @class */function(){function BoundCurves(element){var styles=element.styles;var bounds=element.bounds;var _a=getAbsoluteValueForTuple(styles.borderTopLeftRadius,bounds.width,bounds.height),tlh=_a[0],tlv=_a[1];var _b=getAbsoluteValueForTuple(styles.borderTopRightRadius,bounds.width,bounds.height),trh=_b[0],trv=_b[1];var _c=getAbsoluteValueForTuple(styles.borderBottomRightRadius,bounds.width,bounds.height),brh=_c[0],brv=_c[1];var _d=getAbsoluteValueForTuple(styles.borderBottomLeftRadius,bounds.width,bounds.height),blh=_d[0],blv=_d[1];var factors=[];factors.push((tlh+trh)/bounds.width);factors.push((blh+brh)/bounds.width);factors.push((tlv+blv)/bounds.height);factors.push((trv+brv)/bounds.height);var maxFactor=Math.max.apply(Math,factors);if(maxFactor>1){tlh/=maxFactor;tlv/=maxFactor;trh/=maxFactor;trv/=maxFactor;brh/=maxFactor;brv/=maxFactor;blh/=maxFactor;blv/=maxFactor;}var topWidth=bounds.width-trh;var rightHeight=bounds.height-brv;var bottomWidth=bounds.width-brh;var leftHeight=bounds.height-blv;var borderTopWidth=styles.borderTopWidth;var borderRightWidth=styles.borderRightWidth;var borderBottomWidth=styles.borderBottomWidth;var borderLeftWidth=styles.borderLeftWidth;var paddingTop=getAbsoluteValue(styles.paddingTop,element.bounds.width);var paddingRight=getAbsoluteValue(styles.paddingRight,element.bounds.width);var paddingBottom=getAbsoluteValue(styles.paddingBottom,element.bounds.width);var paddingLeft=getAbsoluteValue(styles.paddingLeft,element.bounds.width);this.topLeftBorderDoubleOuterBox=tlh>0||tlv>0?getCurvePoints(bounds.left+borderLeftWidth/3,bounds.top+borderTopWidth/3,tlh-borderLeftWidth/3,tlv-borderTopWidth/3,CORNER.TOP_LEFT):new Vector(bounds.left+borderLeftWidth/3,bounds.top+borderTopWidth/3);this.topRightBorderDoubleOuterBox=tlh>0||tlv>0?getCurvePoints(bounds.left+topWidth,bounds.top+borderTopWidth/3,trh-borderRightWidth/3,trv-borderTopWidth/3,CORNER.TOP_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth/3,bounds.top+borderTopWidth/3);this.bottomRightBorderDoubleOuterBox=brh>0||brv>0?getCurvePoints(bounds.left+bottomWidth,bounds.top+rightHeight,brh-borderRightWidth/3,brv-borderBottomWidth/3,CORNER.BOTTOM_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth/3,bounds.top+bounds.height-borderBottomWidth/3);this.bottomLeftBorderDoubleOuterBox=blh>0||blv>0?getCurvePoints(bounds.left+borderLeftWidth/3,bounds.top+leftHeight,blh-borderLeftWidth/3,blv-borderBottomWidth/3,CORNER.BOTTOM_LEFT):new Vector(bounds.left+borderLeftWidth/3,bounds.top+bounds.height-borderBottomWidth/3);this.topLeftBorderDoubleInnerBox=tlh>0||tlv>0?getCurvePoints(bounds.left+borderLeftWidth*2/3,bounds.top+borderTopWidth*2/3,tlh-borderLeftWidth*2/3,tlv-borderTopWidth*2/3,CORNER.TOP_LEFT):new Vector(bounds.left+borderLeftWidth*2/3,bounds.top+borderTopWidth*2/3);this.topRightBorderDoubleInnerBox=tlh>0||tlv>0?getCurvePoints(bounds.left+topWidth,bounds.top+borderTopWidth*2/3,trh-borderRightWidth*2/3,trv-borderTopWidth*2/3,CORNER.TOP_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth*2/3,bounds.top+borderTopWidth*2/3);this.bottomRightBorderDoubleInnerBox=brh>0||brv>0?getCurvePoints(bounds.left+bottomWidth,bounds.top+rightHeight,brh-borderRightWidth*2/3,brv-borderBottomWidth*2/3,CORNER.BOTTOM_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth*2/3,bounds.top+bounds.height-borderBottomWidth*2/3);this.bottomLeftBorderDoubleInnerBox=blh>0||blv>0?getCurvePoints(bounds.left+borderLeftWidth*2/3,bounds.top+leftHeight,blh-borderLeftWidth*2/3,blv-borderBottomWidth*2/3,CORNER.BOTTOM_LEFT):new Vector(bounds.left+borderLeftWidth*2/3,bounds.top+bounds.height-borderBottomWidth*2/3);this.topLeftBorderStroke=tlh>0||tlv>0?getCurvePoints(bounds.left+borderLeftWidth/2,bounds.top+borderTopWidth/2,tlh-borderLeftWidth/2,tlv-borderTopWidth/2,CORNER.TOP_LEFT):new Vector(bounds.left+borderLeftWidth/2,bounds.top+borderTopWidth/2);this.topRightBorderStroke=tlh>0||tlv>0?getCurvePoints(bounds.left+topWidth,bounds.top+borderTopWidth/2,trh-borderRightWidth/2,trv-borderTopWidth/2,CORNER.TOP_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth/2,bounds.top+borderTopWidth/2);this.bottomRightBorderStroke=brh>0||brv>0?getCurvePoints(bounds.left+bottomWidth,bounds.top+rightHeight,brh-borderRightWidth/2,brv-borderBottomWidth/2,CORNER.BOTTOM_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth/2,bounds.top+bounds.height-borderBottomWidth/2);this.bottomLeftBorderStroke=blh>0||blv>0?getCurvePoints(bounds.left+borderLeftWidth/2,bounds.top+leftHeight,blh-borderLeftWidth/2,blv-borderBottomWidth/2,CORNER.BOTTOM_LEFT):new Vector(bounds.left+borderLeftWidth/2,bounds.top+bounds.height-borderBottomWidth/2);this.topLeftBorderBox=tlh>0||tlv>0?getCurvePoints(bounds.left,bounds.top,tlh,tlv,CORNER.TOP_LEFT):new Vector(bounds.left,bounds.top);this.topRightBorderBox=trh>0||trv>0?getCurvePoints(bounds.left+topWidth,bounds.top,trh,trv,CORNER.TOP_RIGHT):new Vector(bounds.left+bounds.width,bounds.top);this.bottomRightBorderBox=brh>0||brv>0?getCurvePoints(bounds.left+bottomWidth,bounds.top+rightHeight,brh,brv,CORNER.BOTTOM_RIGHT):new Vector(bounds.left+bounds.width,bounds.top+bounds.height);this.bottomLeftBorderBox=blh>0||blv>0?getCurvePoints(bounds.left,bounds.top+leftHeight,blh,blv,CORNER.BOTTOM_LEFT):new Vector(bounds.left,bounds.top+bounds.height);this.topLeftPaddingBox=tlh>0||tlv>0?getCurvePoints(bounds.left+borderLeftWidth,bounds.top+borderTopWidth,Math.max(0,tlh-borderLeftWidth),Math.max(0,tlv-borderTopWidth),CORNER.TOP_LEFT):new Vector(bounds.left+borderLeftWidth,bounds.top+borderTopWidth);this.topRightPaddingBox=trh>0||trv>0?getCurvePoints(bounds.left+Math.min(topWidth,bounds.width-borderRightWidth),bounds.top+borderTopWidth,topWidth>bounds.width+borderRightWidth?0:Math.max(0,trh-borderRightWidth),Math.max(0,trv-borderTopWidth),CORNER.TOP_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth,bounds.top+borderTopWidth);this.bottomRightPaddingBox=brh>0||brv>0?getCurvePoints(bounds.left+Math.min(bottomWidth,bounds.width-borderLeftWidth),bounds.top+Math.min(rightHeight,bounds.height-borderBottomWidth),Math.max(0,brh-borderRightWidth),Math.max(0,brv-borderBottomWidth),CORNER.BOTTOM_RIGHT):new Vector(bounds.left+bounds.width-borderRightWidth,bounds.top+bounds.height-borderBottomWidth);this.bottomLeftPaddingBox=blh>0||blv>0?getCurvePoints(bounds.left+borderLeftWidth,bounds.top+Math.min(leftHeight,bounds.height-borderBottomWidth),Math.max(0,blh-borderLeftWidth),Math.max(0,blv-borderBottomWidth),CORNER.BOTTOM_LEFT):new Vector(bounds.left+borderLeftWidth,bounds.top+bounds.height-borderBottomWidth);this.topLeftContentBox=tlh>0||tlv>0?getCurvePoints(bounds.left+borderLeftWidth+paddingLeft,bounds.top+borderTopWidth+paddingTop,Math.max(0,tlh-(borderLeftWidth+paddingLeft)),Math.max(0,tlv-(borderTopWidth+paddingTop)),CORNER.TOP_LEFT):new Vector(bounds.left+borderLeftWidth+paddingLeft,bounds.top+borderTopWidth+paddingTop);this.topRightContentBox=trh>0||trv>0?getCurvePoints(bounds.left+Math.min(topWidth,bounds.width+borderLeftWidth+paddingLeft),bounds.top+borderTopWidth+paddingTop,topWidth>bounds.width+borderLeftWidth+paddingLeft?0:trh-borderLeftWidth+paddingLeft,trv-(borderTopWidth+paddingTop),CORNER.TOP_RIGHT):new Vector(bounds.left+bounds.width-(borderRightWidth+paddingRight),bounds.top+borderTopWidth+paddingTop);this.bottomRightContentBox=brh>0||brv>0?getCurvePoints(bounds.left+Math.min(bottomWidth,bounds.width-(borderLeftWidth+paddingLeft)),bounds.top+Math.min(rightHeight,bounds.height+borderTopWidth+paddingTop),Math.max(0,brh-(borderRightWidth+paddingRight)),brv-(borderBottomWidth+paddingBottom),CORNER.BOTTOM_RIGHT):new Vector(bounds.left+bounds.width-(borderRightWidth+paddingRight),bounds.top+bounds.height-(borderBottomWidth+paddingBottom));this.bottomLeftContentBox=blh>0||blv>0?getCurvePoints(bounds.left+borderLeftWidth+paddingLeft,bounds.top+leftHeight,Math.max(0,blh-(borderLeftWidth+paddingLeft)),blv-(borderBottomWidth+paddingBottom),CORNER.BOTTOM_LEFT):new Vector(bounds.left+borderLeftWidth+paddingLeft,bounds.top+bounds.height-(borderBottomWidth+paddingBottom));}return BoundCurves;}();var CORNER;(function(CORNER){CORNER[CORNER["TOP_LEFT"]=0]="TOP_LEFT";CORNER[CORNER["TOP_RIGHT"]=1]="TOP_RIGHT";CORNER[CORNER["BOTTOM_RIGHT"]=2]="BOTTOM_RIGHT";CORNER[CORNER["BOTTOM_LEFT"]=3]="BOTTOM_LEFT";})(CORNER||(CORNER={}));var getCurvePoints=function getCurvePoints(x,y,r1,r2,position){var kappa=4*((Math.sqrt(2)-1)/3);var ox=r1*kappa;// control point offset horizontal
var oy=r2*kappa;// control point offset vertical
var xm=x+r1;// x-middle
var ym=y+r2;// y-middle
switch(position){case CORNER.TOP_LEFT:return new BezierCurve(new Vector(x,ym),new Vector(x,ym-oy),new Vector(xm-ox,y),new Vector(xm,y));case CORNER.TOP_RIGHT:return new BezierCurve(new Vector(x,y),new Vector(x+ox,y),new Vector(xm,ym-oy),new Vector(xm,ym));case CORNER.BOTTOM_RIGHT:return new BezierCurve(new Vector(xm,y),new Vector(xm,y+oy),new Vector(x+ox,ym),new Vector(x,ym));case CORNER.BOTTOM_LEFT:default:return new BezierCurve(new Vector(xm,ym),new Vector(xm-ox,ym),new Vector(x,y+oy),new Vector(x,y));}};var calculateBorderBoxPath=function calculateBorderBoxPath(curves){return[curves.topLeftBorderBox,curves.topRightBorderBox,curves.bottomRightBorderBox,curves.bottomLeftBorderBox];};var calculateContentBoxPath=function calculateContentBoxPath(curves){return[curves.topLeftContentBox,curves.topRightContentBox,curves.bottomRightContentBox,curves.bottomLeftContentBox];};var calculatePaddingBoxPath=function calculatePaddingBoxPath(curves){return[curves.topLeftPaddingBox,curves.topRightPaddingBox,curves.bottomRightPaddingBox,curves.bottomLeftPaddingBox];};var TransformEffect=/** @class */function(){function TransformEffect(offsetX,offsetY,matrix){this.offsetX=offsetX;this.offsetY=offsetY;this.matrix=matrix;this.type=0/* TRANSFORM */;this.target=2/* BACKGROUND_BORDERS */|4/* CONTENT */;}return TransformEffect;}();var ClipEffect=/** @class */function(){function ClipEffect(path,target){this.path=path;this.target=target;this.type=1/* CLIP */;}return ClipEffect;}();var OpacityEffect=/** @class */function(){function OpacityEffect(opacity){this.opacity=opacity;this.type=2/* OPACITY */;this.target=2/* BACKGROUND_BORDERS */|4/* CONTENT */;}return OpacityEffect;}();var isTransformEffect=function isTransformEffect(effect){return effect.type===0/* TRANSFORM */;};var isClipEffect=function isClipEffect(effect){return effect.type===1/* CLIP */;};var isOpacityEffect=function isOpacityEffect(effect){return effect.type===2/* OPACITY */;};var equalPath=function equalPath(a,b){if(a.length===b.length){return a.some(function(v,i){return v===b[i];});}return false;};var transformPath=function transformPath(path,deltaX,deltaY,deltaW,deltaH){return path.map(function(point,index){switch(index){case 0:return point.add(deltaX,deltaY);case 1:return point.add(deltaX+deltaW,deltaY);case 2:return point.add(deltaX+deltaW,deltaY+deltaH);case 3:return point.add(deltaX,deltaY+deltaH);}return point;});};var StackingContext=/** @class */function(){function StackingContext(container){this.element=container;this.inlineLevel=[];this.nonInlineLevel=[];this.negativeZIndex=[];this.zeroOrAutoZIndexOrTransformedOrOpacity=[];this.positiveZIndex=[];this.nonPositionedFloats=[];this.nonPositionedInlineLevel=[];}return StackingContext;}();var ElementPaint=/** @class */function(){function ElementPaint(container,parent){this.container=container;this.parent=parent;this.effects=[];this.curves=new BoundCurves(this.container);if(this.container.styles.opacity<1){this.effects.push(new OpacityEffect(this.container.styles.opacity));}if(this.container.styles.transform!==null){var offsetX=this.container.bounds.left+this.container.styles.transformOrigin[0].number;var offsetY=this.container.bounds.top+this.container.styles.transformOrigin[1].number;var matrix=this.container.styles.transform;this.effects.push(new TransformEffect(offsetX,offsetY,matrix));}if(this.container.styles.overflowX!==0/* VISIBLE */){var borderBox=calculateBorderBoxPath(this.curves);var paddingBox=calculatePaddingBoxPath(this.curves);if(equalPath(borderBox,paddingBox)){this.effects.push(new ClipEffect(borderBox,2/* BACKGROUND_BORDERS */|4/* CONTENT */));}else{this.effects.push(new ClipEffect(borderBox,2/* BACKGROUND_BORDERS */));this.effects.push(new ClipEffect(paddingBox,4/* CONTENT */));}}}ElementPaint.prototype.getEffects=function(target){var inFlow=[2/* ABSOLUTE */,3/* FIXED */].indexOf(this.container.styles.position)===-1;var parent=this.parent;var effects=this.effects.slice(0);while(parent){var croplessEffects=parent.effects.filter(function(effect){return!isClipEffect(effect);});if(inFlow||parent.container.styles.position!==0/* STATIC */||!parent.parent){effects.unshift.apply(effects,croplessEffects);inFlow=[2/* ABSOLUTE */,3/* FIXED */].indexOf(parent.container.styles.position)===-1;if(parent.container.styles.overflowX!==0/* VISIBLE */){var borderBox=calculateBorderBoxPath(parent.curves);var paddingBox=calculatePaddingBoxPath(parent.curves);if(!equalPath(borderBox,paddingBox)){effects.unshift(new ClipEffect(paddingBox,2/* BACKGROUND_BORDERS */|4/* CONTENT */));}}}else{effects.unshift.apply(effects,croplessEffects);}parent=parent.parent;}return effects.filter(function(effect){return contains(effect.target,target);});};return ElementPaint;}();var parseStackTree=function parseStackTree(parent,stackingContext,realStackingContext,listItems){parent.container.elements.forEach(function(child){var treatAsRealStackingContext=contains(child.flags,4/* CREATES_REAL_STACKING_CONTEXT */);var createsStackingContext=contains(child.flags,2/* CREATES_STACKING_CONTEXT */);var paintContainer=new ElementPaint(child,parent);if(contains(child.styles.display,2048/* LIST_ITEM */)){listItems.push(paintContainer);}var listOwnerItems=contains(child.flags,8/* IS_LIST_OWNER */)?[]:listItems;if(treatAsRealStackingContext||createsStackingContext){var parentStack=treatAsRealStackingContext||child.styles.isPositioned()?realStackingContext:stackingContext;var stack=new StackingContext(paintContainer);if(child.styles.isPositioned()||child.styles.opacity<1||child.styles.isTransformed()){var order_1=child.styles.zIndex.order;if(order_1<0){var index_1=0;parentStack.negativeZIndex.some(function(current,i){if(order_1>current.element.container.styles.zIndex.order){index_1=i;return false;}else if(index_1>0){return true;}return false;});parentStack.negativeZIndex.splice(index_1,0,stack);}else if(order_1>0){var index_2=0;parentStack.positiveZIndex.some(function(current,i){if(order_1>=current.element.container.styles.zIndex.order){index_2=i+1;return false;}else if(index_2>0){return true;}return false;});parentStack.positiveZIndex.splice(index_2,0,stack);}else{parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);}}else{if(child.styles.isFloating()){parentStack.nonPositionedFloats.push(stack);}else{parentStack.nonPositionedInlineLevel.push(stack);}}parseStackTree(paintContainer,stack,treatAsRealStackingContext?stack:realStackingContext,listOwnerItems);}else{if(child.styles.isInlineLevel()){stackingContext.inlineLevel.push(paintContainer);}else{stackingContext.nonInlineLevel.push(paintContainer);}parseStackTree(paintContainer,stackingContext,realStackingContext,listOwnerItems);}if(contains(child.flags,8/* IS_LIST_OWNER */)){processListItems(child,listOwnerItems);}});};var processListItems=function processListItems(owner,elements){var numbering=owner instanceof OLElementContainer?owner.start:1;var reversed=owner instanceof OLElementContainer?owner.reversed:false;for(var i=0;i<elements.length;i++){var item=elements[i];if(item.container instanceof LIElementContainer&&typeof item.container.value==='number'&&item.container.value!==0){numbering=item.container.value;}item.listValue=createCounterText(numbering,item.container.styles.listStyleType,true);numbering+=reversed?-1:1;}};var parseStackingContexts=function parseStackingContexts(container){var paintContainer=new ElementPaint(container,null);var root=new StackingContext(paintContainer);var listItems=[];parseStackTree(paintContainer,root,root,listItems);processListItems(paintContainer.container,listItems);return root;};var parsePathForBorder=function parsePathForBorder(curves,borderSide){switch(borderSide){case 0:return createPathFromCurves(curves.topLeftBorderBox,curves.topLeftPaddingBox,curves.topRightBorderBox,curves.topRightPaddingBox);case 1:return createPathFromCurves(curves.topRightBorderBox,curves.topRightPaddingBox,curves.bottomRightBorderBox,curves.bottomRightPaddingBox);case 2:return createPathFromCurves(curves.bottomRightBorderBox,curves.bottomRightPaddingBox,curves.bottomLeftBorderBox,curves.bottomLeftPaddingBox);case 3:default:return createPathFromCurves(curves.bottomLeftBorderBox,curves.bottomLeftPaddingBox,curves.topLeftBorderBox,curves.topLeftPaddingBox);}};var parsePathForBorderDoubleOuter=function parsePathForBorderDoubleOuter(curves,borderSide){switch(borderSide){case 0:return createPathFromCurves(curves.topLeftBorderBox,curves.topLeftBorderDoubleOuterBox,curves.topRightBorderBox,curves.topRightBorderDoubleOuterBox);case 1:return createPathFromCurves(curves.topRightBorderBox,curves.topRightBorderDoubleOuterBox,curves.bottomRightBorderBox,curves.bottomRightBorderDoubleOuterBox);case 2:return createPathFromCurves(curves.bottomRightBorderBox,curves.bottomRightBorderDoubleOuterBox,curves.bottomLeftBorderBox,curves.bottomLeftBorderDoubleOuterBox);case 3:default:return createPathFromCurves(curves.bottomLeftBorderBox,curves.bottomLeftBorderDoubleOuterBox,curves.topLeftBorderBox,curves.topLeftBorderDoubleOuterBox);}};var parsePathForBorderDoubleInner=function parsePathForBorderDoubleInner(curves,borderSide){switch(borderSide){case 0:return createPathFromCurves(curves.topLeftBorderDoubleInnerBox,curves.topLeftPaddingBox,curves.topRightBorderDoubleInnerBox,curves.topRightPaddingBox);case 1:return createPathFromCurves(curves.topRightBorderDoubleInnerBox,curves.topRightPaddingBox,curves.bottomRightBorderDoubleInnerBox,curves.bottomRightPaddingBox);case 2:return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox,curves.bottomRightPaddingBox,curves.bottomLeftBorderDoubleInnerBox,curves.bottomLeftPaddingBox);case 3:default:return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox,curves.bottomLeftPaddingBox,curves.topLeftBorderDoubleInnerBox,curves.topLeftPaddingBox);}};var parsePathForBorderStroke=function parsePathForBorderStroke(curves,borderSide){switch(borderSide){case 0:return createStrokePathFromCurves(curves.topLeftBorderStroke,curves.topRightBorderStroke);case 1:return createStrokePathFromCurves(curves.topRightBorderStroke,curves.bottomRightBorderStroke);case 2:return createStrokePathFromCurves(curves.bottomRightBorderStroke,curves.bottomLeftBorderStroke);case 3:default:return createStrokePathFromCurves(curves.bottomLeftBorderStroke,curves.topLeftBorderStroke);}};var createStrokePathFromCurves=function createStrokePathFromCurves(outer1,outer2){var path=[];if(isBezierCurve(outer1)){path.push(outer1.subdivide(0.5,false));}else{path.push(outer1);}if(isBezierCurve(outer2)){path.push(outer2.subdivide(0.5,true));}else{path.push(outer2);}return path;};var createPathFromCurves=function createPathFromCurves(outer1,inner1,outer2,inner2){var path=[];if(isBezierCurve(outer1)){path.push(outer1.subdivide(0.5,false));}else{path.push(outer1);}if(isBezierCurve(outer2)){path.push(outer2.subdivide(0.5,true));}else{path.push(outer2);}if(isBezierCurve(inner2)){path.push(inner2.subdivide(0.5,true).reverse());}else{path.push(inner2);}if(isBezierCurve(inner1)){path.push(inner1.subdivide(0.5,false).reverse());}else{path.push(inner1);}return path;};var paddingBox=function paddingBox(element){var bounds=element.bounds;var styles=element.styles;return bounds.add(styles.borderLeftWidth,styles.borderTopWidth,-(styles.borderRightWidth+styles.borderLeftWidth),-(styles.borderTopWidth+styles.borderBottomWidth));};var contentBox=function contentBox(element){var styles=element.styles;var bounds=element.bounds;var paddingLeft=getAbsoluteValue(styles.paddingLeft,bounds.width);var paddingRight=getAbsoluteValue(styles.paddingRight,bounds.width);var paddingTop=getAbsoluteValue(styles.paddingTop,bounds.width);var paddingBottom=getAbsoluteValue(styles.paddingBottom,bounds.width);return bounds.add(paddingLeft+styles.borderLeftWidth,paddingTop+styles.borderTopWidth,-(styles.borderRightWidth+styles.borderLeftWidth+paddingLeft+paddingRight),-(styles.borderTopWidth+styles.borderBottomWidth+paddingTop+paddingBottom));};var calculateBackgroundPositioningArea=function calculateBackgroundPositioningArea(backgroundOrigin,element){if(backgroundOrigin===0/* BORDER_BOX */){return element.bounds;}if(backgroundOrigin===2/* CONTENT_BOX */){return contentBox(element);}return paddingBox(element);};var calculateBackgroundPaintingArea=function calculateBackgroundPaintingArea(backgroundClip,element){if(backgroundClip===0/* BORDER_BOX */){return element.bounds;}if(backgroundClip===2/* CONTENT_BOX */){return contentBox(element);}return paddingBox(element);};var calculateBackgroundRendering=function calculateBackgroundRendering(container,index,intrinsicSize){var backgroundPositioningArea=calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin,index),container);var backgroundPaintingArea=calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip,index),container);var backgroundImageSize=calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize,index),intrinsicSize,backgroundPositioningArea);var sizeWidth=backgroundImageSize[0],sizeHeight=backgroundImageSize[1];var position=getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition,index),backgroundPositioningArea.width-sizeWidth,backgroundPositioningArea.height-sizeHeight);var path=calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat,index),position,backgroundImageSize,backgroundPositioningArea,backgroundPaintingArea);var offsetX=Math.round(backgroundPositioningArea.left+position[0]);var offsetY=Math.round(backgroundPositioningArea.top+position[1]);return[path,offsetX,offsetY,sizeWidth,sizeHeight];};var isAuto=function isAuto(token){return isIdentToken(token)&&token.value===BACKGROUND_SIZE.AUTO;};var hasIntrinsicValue=function hasIntrinsicValue(value){return typeof value==='number';};var calculateBackgroundSize=function calculateBackgroundSize(size,_a,bounds){var intrinsicWidth=_a[0],intrinsicHeight=_a[1],intrinsicProportion=_a[2];var first=size[0],second=size[1];if(!first){return[0,0];}if(isLengthPercentage(first)&&second&&isLengthPercentage(second)){return[getAbsoluteValue(first,bounds.width),getAbsoluteValue(second,bounds.height)];}var hasIntrinsicProportion=hasIntrinsicValue(intrinsicProportion);if(isIdentToken(first)&&(first.value===BACKGROUND_SIZE.CONTAIN||first.value===BACKGROUND_SIZE.COVER)){if(hasIntrinsicValue(intrinsicProportion)){var targetRatio=bounds.width/bounds.height;return targetRatio<intrinsicProportion!==(first.value===BACKGROUND_SIZE.COVER)?[bounds.width,bounds.width/intrinsicProportion]:[bounds.height*intrinsicProportion,bounds.height];}return[bounds.width,bounds.height];}var hasIntrinsicWidth=hasIntrinsicValue(intrinsicWidth);var hasIntrinsicHeight=hasIntrinsicValue(intrinsicHeight);var hasIntrinsicDimensions=hasIntrinsicWidth||hasIntrinsicHeight;// If the background-size is auto or auto auto:
if(isAuto(first)&&(!second||isAuto(second))){// If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
if(hasIntrinsicWidth&&hasIntrinsicHeight){return[intrinsicWidth,intrinsicHeight];}// If the image has no intrinsic dimensions and has no intrinsic proportions,
// it's rendered at the size of the background positioning area.
if(!hasIntrinsicProportion&&!hasIntrinsicDimensions){return[bounds.width,bounds.height];}// TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
// If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
// The other dimension is computed using the specified dimension and the intrinsic proportions.
if(hasIntrinsicDimensions&&hasIntrinsicProportion){var width_1=hasIntrinsicWidth?intrinsicWidth:intrinsicHeight*intrinsicProportion;var height_1=hasIntrinsicHeight?intrinsicHeight:intrinsicWidth/intrinsicProportion;return[width_1,height_1];}// If the image has only one intrinsic dimension but has no intrinsic proportions,
// it's rendered using the specified dimension and the other dimension of the background positioning area.
var width_2=hasIntrinsicWidth?intrinsicWidth:bounds.width;var height_2=hasIntrinsicHeight?intrinsicHeight:bounds.height;return[width_2,height_2];}// If the image has intrinsic proportions, it's stretched to the specified dimension.
// The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
if(hasIntrinsicProportion){var width_3=0;var height_3=0;if(isLengthPercentage(first)){width_3=getAbsoluteValue(first,bounds.width);}else if(isLengthPercentage(second)){height_3=getAbsoluteValue(second,bounds.height);}if(isAuto(first)){width_3=height_3*intrinsicProportion;}else if(!second||isAuto(second)){height_3=width_3/intrinsicProportion;}return[width_3,height_3];}// If the image has no intrinsic proportions, it's stretched to the specified dimension.
// The unspecified dimension is computed using the image's corresponding intrinsic dimension,
// if there is one. If there is no such intrinsic dimension,
// it becomes the corresponding dimension of the background positioning area.
var width=null;var height=null;if(isLengthPercentage(first)){width=getAbsoluteValue(first,bounds.width);}else if(second&&isLengthPercentage(second)){height=getAbsoluteValue(second,bounds.height);}if(width!==null&&(!second||isAuto(second))){height=hasIntrinsicWidth&&hasIntrinsicHeight?width/intrinsicWidth*intrinsicHeight:bounds.height;}if(height!==null&&isAuto(first)){width=hasIntrinsicWidth&&hasIntrinsicHeight?height/intrinsicHeight*intrinsicWidth:bounds.width;}if(width!==null&&height!==null){return[width,height];}throw new Error("Unable to calculate background-size for element");};var getBackgroundValueForIndex=function getBackgroundValueForIndex(values,index){var value=values[index];if(typeof value==='undefined'){return values[0];}return value;};var calculateBackgroundRepeatPath=function calculateBackgroundRepeatPath(repeat,_a,_b,backgroundPositioningArea,backgroundPaintingArea){var x=_a[0],y=_a[1];var width=_b[0],height=_b[1];switch(repeat){case 2/* REPEAT_X */:return[new Vector(Math.round(backgroundPositioningArea.left),Math.round(backgroundPositioningArea.top+y)),new Vector(Math.round(backgroundPositioningArea.left+backgroundPositioningArea.width),Math.round(backgroundPositioningArea.top+y)),new Vector(Math.round(backgroundPositioningArea.left+backgroundPositioningArea.width),Math.round(height+backgroundPositioningArea.top+y)),new Vector(Math.round(backgroundPositioningArea.left),Math.round(height+backgroundPositioningArea.top+y))];case 3/* REPEAT_Y */:return[new Vector(Math.round(backgroundPositioningArea.left+x),Math.round(backgroundPositioningArea.top)),new Vector(Math.round(backgroundPositioningArea.left+x+width),Math.round(backgroundPositioningArea.top)),new Vector(Math.round(backgroundPositioningArea.left+x+width),Math.round(backgroundPositioningArea.height+backgroundPositioningArea.top)),new Vector(Math.round(backgroundPositioningArea.left+x),Math.round(backgroundPositioningArea.height+backgroundPositioningArea.top))];case 1/* NO_REPEAT */:return[new Vector(Math.round(backgroundPositioningArea.left+x),Math.round(backgroundPositioningArea.top+y)),new Vector(Math.round(backgroundPositioningArea.left+x+width),Math.round(backgroundPositioningArea.top+y)),new Vector(Math.round(backgroundPositioningArea.left+x+width),Math.round(backgroundPositioningArea.top+y+height)),new Vector(Math.round(backgroundPositioningArea.left+x),Math.round(backgroundPositioningArea.top+y+height))];default:return[new Vector(Math.round(backgroundPaintingArea.left),Math.round(backgroundPaintingArea.top)),new Vector(Math.round(backgroundPaintingArea.left+backgroundPaintingArea.width),Math.round(backgroundPaintingArea.top)),new Vector(Math.round(backgroundPaintingArea.left+backgroundPaintingArea.width),Math.round(backgroundPaintingArea.height+backgroundPaintingArea.top)),new Vector(Math.round(backgroundPaintingArea.left),Math.round(backgroundPaintingArea.height+backgroundPaintingArea.top))];}};var SMALL_IMAGE='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';var SAMPLE_TEXT='Hidden Text';var FontMetrics=/** @class */function(){function FontMetrics(document){this._data={};this._document=document;}FontMetrics.prototype.parseMetrics=function(fontFamily,fontSize){var container=this._document.createElement('div');var img=this._document.createElement('img');var span=this._document.createElement('span');var body=this._document.body;container.style.visibility='hidden';container.style.fontFamily=fontFamily;container.style.fontSize=fontSize;container.style.margin='0';container.style.padding='0';container.style.whiteSpace='nowrap';body.appendChild(container);img.src=SMALL_IMAGE;img.width=1;img.height=1;img.style.margin='0';img.style.padding='0';img.style.verticalAlign='baseline';span.style.fontFamily=fontFamily;span.style.fontSize=fontSize;span.style.margin='0';span.style.padding='0';span.appendChild(this._document.createTextNode(SAMPLE_TEXT));container.appendChild(span);container.appendChild(img);var baseline=img.offsetTop-span.offsetTop+2;container.removeChild(span);container.appendChild(this._document.createTextNode(SAMPLE_TEXT));container.style.lineHeight='normal';img.style.verticalAlign='super';var middle=img.offsetTop-container.offsetTop+2;body.removeChild(container);return{baseline:baseline,middle:middle};};FontMetrics.prototype.getMetrics=function(fontFamily,fontSize){var key=fontFamily+" "+fontSize;if(typeof this._data[key]==='undefined'){this._data[key]=this.parseMetrics(fontFamily,fontSize);}return this._data[key];};return FontMetrics;}();var Renderer=/** @class */function(){function Renderer(context,options){this.context=context;this.options=options;}return Renderer;}();var MASK_OFFSET=10000;var CanvasRenderer=/** @class */function(_super){__extends(CanvasRenderer,_super);function CanvasRenderer(context,options){var _this=_super.call(this,context,options)||this;_this._activeEffects=[];_this.canvas=options.canvas?options.canvas:document.createElement('canvas');_this.ctx=_this.canvas.getContext('2d');if(!options.canvas){_this.canvas.width=Math.floor(options.width*options.scale);_this.canvas.height=Math.floor(options.height*options.scale);_this.canvas.style.width=options.width+"px";_this.canvas.style.height=options.height+"px";}_this.fontMetrics=new FontMetrics(document);_this.ctx.scale(_this.options.scale,_this.options.scale);_this.ctx.translate(-options.x,-options.y);_this.ctx.textBaseline='bottom';_this._activeEffects=[];_this.context.logger.debug("Canvas renderer initialized ("+options.width+"x"+options.height+") with scale "+options.scale);return _this;}CanvasRenderer.prototype.applyEffects=function(effects){var _this=this;while(this._activeEffects.length){this.popEffect();}effects.forEach(function(effect){return _this.applyEffect(effect);});};CanvasRenderer.prototype.applyEffect=function(effect){this.ctx.save();if(isOpacityEffect(effect)){this.ctx.globalAlpha=effect.opacity;}if(isTransformEffect(effect)){this.ctx.translate(effect.offsetX,effect.offsetY);this.ctx.transform(effect.matrix[0],effect.matrix[1],effect.matrix[2],effect.matrix[3],effect.matrix[4],effect.matrix[5]);this.ctx.translate(-effect.offsetX,-effect.offsetY);}if(isClipEffect(effect)){this.path(effect.path);this.ctx.clip();}this._activeEffects.push(effect);};CanvasRenderer.prototype.popEffect=function(){this._activeEffects.pop();this.ctx.restore();};CanvasRenderer.prototype.renderStack=function(stack){return __awaiter(this,void 0,void 0,function(){var styles;return __generator(this,function(_a){switch(_a.label){case 0:styles=stack.element.container.styles;if(!styles.isVisible())return[3/*break*/,2];return[4/*yield*/,this.renderStackContent(stack)];case 1:_a.sent();_a.label=2;case 2:return[2/*return*/];}});});};CanvasRenderer.prototype.renderNode=function(paint){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:if(contains(paint.container.flags,16/* DEBUG_RENDER */)){debugger;}if(!paint.container.styles.isVisible())return[3/*break*/,3];return[4/*yield*/,this.renderNodeBackgroundAndBorders(paint)];case 1:_a.sent();return[4/*yield*/,this.renderNodeContent(paint)];case 2:_a.sent();_a.label=3;case 3:return[2/*return*/];}});});};CanvasRenderer.prototype.renderTextWithLetterSpacing=function(text,letterSpacing,baseline){var _this=this;if(letterSpacing===0){this.ctx.fillText(text.text,text.bounds.left,text.bounds.top+baseline);}else{var letters=segmentGraphemes(text.text);letters.reduce(function(left,letter){_this.ctx.fillText(letter,left,text.bounds.top+baseline);return left+_this.ctx.measureText(letter).width;},text.bounds.left);}};CanvasRenderer.prototype.createFontStyle=function(styles){var fontVariant=styles.fontVariant.filter(function(variant){return variant==='normal'||variant==='small-caps';}).join('');var fontFamily=fixIOSSystemFonts(styles.fontFamily).join(', ');var fontSize=isDimensionToken(styles.fontSize)?""+styles.fontSize.number+styles.fontSize.unit:styles.fontSize.number+"px";return[[styles.fontStyle,fontVariant,styles.fontWeight,fontSize,fontFamily].join(' '),fontFamily,fontSize];};CanvasRenderer.prototype.renderTextNode=function(text,styles){return __awaiter(this,void 0,void 0,function(){var _a,font,fontFamily,fontSize,_b,baseline,middle,paintOrder;var _this=this;return __generator(this,function(_c){_a=this.createFontStyle(styles),font=_a[0],fontFamily=_a[1],fontSize=_a[2];this.ctx.font=font;this.ctx.direction=styles.direction===1/* RTL */?'rtl':'ltr';this.ctx.textAlign='left';this.ctx.textBaseline='alphabetic';_b=this.fontMetrics.getMetrics(fontFamily,fontSize),baseline=_b.baseline,middle=_b.middle;paintOrder=styles.paintOrder;text.textBounds.forEach(function(text){paintOrder.forEach(function(paintOrderLayer){switch(paintOrderLayer){case 0/* FILL */:_this.ctx.fillStyle=asString(styles.color);_this.renderTextWithLetterSpacing(text,styles.letterSpacing,baseline);var textShadows=styles.textShadow;if(textShadows.length&&text.text.trim().length){textShadows.slice(0).reverse().forEach(function(textShadow){_this.ctx.shadowColor=asString(textShadow.color);_this.ctx.shadowOffsetX=textShadow.offsetX.number*_this.options.scale;_this.ctx.shadowOffsetY=textShadow.offsetY.number*_this.options.scale;_this.ctx.shadowBlur=textShadow.blur.number;_this.renderTextWithLetterSpacing(text,styles.letterSpacing,baseline);});_this.ctx.shadowColor='';_this.ctx.shadowOffsetX=0;_this.ctx.shadowOffsetY=0;_this.ctx.shadowBlur=0;}if(styles.textDecorationLine.length){_this.ctx.fillStyle=asString(styles.textDecorationColor||styles.color);styles.textDecorationLine.forEach(function(textDecorationLine){switch(textDecorationLine){case 1/* UNDERLINE */:// Draws a line at the baseline of the font
// TODO As some browsers display the line as more than 1px if the font-size is big,
// need to take that into account both in position and size
_this.ctx.fillRect(text.bounds.left,Math.round(text.bounds.top+baseline),text.bounds.width,1);break;case 2/* OVERLINE */:_this.ctx.fillRect(text.bounds.left,Math.round(text.bounds.top),text.bounds.width,1);break;case 3/* LINE_THROUGH */:// TODO try and find exact position for line-through
_this.ctx.fillRect(text.bounds.left,Math.ceil(text.bounds.top+middle),text.bounds.width,1);break;}});}break;case 1/* STROKE */:if(styles.webkitTextStrokeWidth&&text.text.trim().length){_this.ctx.strokeStyle=asString(styles.webkitTextStrokeColor);_this.ctx.lineWidth=styles.webkitTextStrokeWidth;// eslint-disable-next-line @typescript-eslint/no-explicit-any
_this.ctx.lineJoin=!!window.chrome?'miter':'round';_this.ctx.strokeText(text.text,text.bounds.left,text.bounds.top+baseline);}_this.ctx.strokeStyle='';_this.ctx.lineWidth=0;_this.ctx.lineJoin='miter';break;}});});return[2/*return*/];});});};CanvasRenderer.prototype.renderReplacedElement=function(container,curves,image){if(image&&container.intrinsicWidth>0&&container.intrinsicHeight>0){var box=contentBox(container);var path=calculatePaddingBoxPath(curves);this.path(path);this.ctx.save();this.ctx.clip();this.ctx.drawImage(image,0,0,container.intrinsicWidth,container.intrinsicHeight,box.left,box.top,box.width,box.height);this.ctx.restore();}};CanvasRenderer.prototype.renderNodeContent=function(paint){return __awaiter(this,void 0,void 0,function(){var container,curves,styles,_i,_a,child,image,image,iframeRenderer,canvas,size,_b,fontFamily,fontSize,baseline,bounds,x,textBounds,img,image,url,fontFamily,bounds;return __generator(this,function(_c){switch(_c.label){case 0:this.applyEffects(paint.getEffects(4/* CONTENT */));container=paint.container;curves=paint.curves;styles=container.styles;_i=0,_a=container.textNodes;_c.label=1;case 1:if(!(_i<_a.length))return[3/*break*/,4];child=_a[_i];return[4/*yield*/,this.renderTextNode(child,styles)];case 2:_c.sent();_c.label=3;case 3:_i++;return[3/*break*/,1];case 4:if(!(container instanceof ImageElementContainer))return[3/*break*/,8];_c.label=5;case 5:_c.trys.push([5,7,,8]);return[4/*yield*/,this.context.cache.match(container.src)];case 6:image=_c.sent();this.renderReplacedElement(container,curves,image);return[3/*break*/,8];case 7:_c.sent();this.context.logger.error("Error loading image "+container.src);return[3/*break*/,8];case 8:if(container instanceof CanvasElementContainer){this.renderReplacedElement(container,curves,container.canvas);}if(!(container instanceof SVGElementContainer))return[3/*break*/,12];_c.label=9;case 9:_c.trys.push([9,11,,12]);return[4/*yield*/,this.context.cache.match(container.svg)];case 10:image=_c.sent();this.renderReplacedElement(container,curves,image);return[3/*break*/,12];case 11:_c.sent();this.context.logger.error("Error loading svg "+container.svg.substring(0,255));return[3/*break*/,12];case 12:if(!(container instanceof IFrameElementContainer&&container.tree))return[3/*break*/,14];iframeRenderer=new CanvasRenderer(this.context,{scale:this.options.scale,backgroundColor:container.backgroundColor,x:0,y:0,width:container.width,height:container.height});return[4/*yield*/,iframeRenderer.render(container.tree)];case 13:canvas=_c.sent();if(container.width&&container.height){this.ctx.drawImage(canvas,0,0,container.width,container.height,container.bounds.left,container.bounds.top,container.bounds.width,container.bounds.height);}_c.label=14;case 14:if(container instanceof InputElementContainer){size=Math.min(container.bounds.width,container.bounds.height);if(container.type===CHECKBOX){if(container.checked){this.ctx.save();this.path([new Vector(container.bounds.left+size*0.39363,container.bounds.top+size*0.79),new Vector(container.bounds.left+size*0.16,container.bounds.top+size*0.5549),new Vector(container.bounds.left+size*0.27347,container.bounds.top+size*0.44071),new Vector(container.bounds.left+size*0.39694,container.bounds.top+size*0.5649),new Vector(container.bounds.left+size*0.72983,container.bounds.top+size*0.23),new Vector(container.bounds.left+size*0.84,container.bounds.top+size*0.34085),new Vector(container.bounds.left+size*0.39363,container.bounds.top+size*0.79)]);this.ctx.fillStyle=asString(INPUT_COLOR);this.ctx.fill();this.ctx.restore();}}else if(container.type===RADIO){if(container.checked){this.ctx.save();this.ctx.beginPath();this.ctx.arc(container.bounds.left+size/2,container.bounds.top+size/2,size/4,0,Math.PI*2,true);this.ctx.fillStyle=asString(INPUT_COLOR);this.ctx.fill();this.ctx.restore();}}}if(isTextInputElement(container)&&container.value.length){_b=this.createFontStyle(styles),fontFamily=_b[0],fontSize=_b[1];baseline=this.fontMetrics.getMetrics(fontFamily,fontSize).baseline;this.ctx.font=fontFamily;this.ctx.fillStyle=asString(styles.color);this.ctx.textBaseline='alphabetic';this.ctx.textAlign=canvasTextAlign(container.styles.textAlign);bounds=contentBox(container);x=0;switch(container.styles.textAlign){case 1/* CENTER */:x+=bounds.width/2;break;case 2/* RIGHT */:x+=bounds.width;break;}textBounds=bounds.add(x,0,0,-bounds.height/2+1);this.ctx.save();this.path([new Vector(bounds.left,bounds.top),new Vector(bounds.left+bounds.width,bounds.top),new Vector(bounds.left+bounds.width,bounds.top+bounds.height),new Vector(bounds.left,bounds.top+bounds.height)]);this.ctx.clip();this.renderTextWithLetterSpacing(new TextBounds(container.value,textBounds),styles.letterSpacing,baseline);this.ctx.restore();this.ctx.textBaseline='alphabetic';this.ctx.textAlign='left';}if(!contains(container.styles.display,2048/* LIST_ITEM */))return[3/*break*/,20];if(!(container.styles.listStyleImage!==null))return[3/*break*/,19];img=container.styles.listStyleImage;if(!(img.type===0/* URL */))return[3/*break*/,18];image=void 0;url=img.url;_c.label=15;case 15:_c.trys.push([15,17,,18]);return[4/*yield*/,this.context.cache.match(url)];case 16:image=_c.sent();this.ctx.drawImage(image,container.bounds.left-(image.width+10),container.bounds.top);return[3/*break*/,18];case 17:_c.sent();this.context.logger.error("Error loading list-style-image "+url);return[3/*break*/,18];case 18:return[3/*break*/,20];case 19:if(paint.listValue&&container.styles.listStyleType!==-1/* NONE */){fontFamily=this.createFontStyle(styles)[0];this.ctx.font=fontFamily;this.ctx.fillStyle=asString(styles.color);this.ctx.textBaseline='middle';this.ctx.textAlign='right';bounds=new Bounds(container.bounds.left,container.bounds.top+getAbsoluteValue(container.styles.paddingTop,container.bounds.width),container.bounds.width,computeLineHeight(styles.lineHeight,styles.fontSize.number)/2+1);this.renderTextWithLetterSpacing(new TextBounds(paint.listValue,bounds),styles.letterSpacing,computeLineHeight(styles.lineHeight,styles.fontSize.number)/2+2);this.ctx.textBaseline='bottom';this.ctx.textAlign='left';}_c.label=20;case 20:return[2/*return*/];}});});};CanvasRenderer.prototype.renderStackContent=function(stack){return __awaiter(this,void 0,void 0,function(){var _i,_a,child,_b,_c,child,_d,_e,child,_f,_g,child,_h,_j,child,_k,_l,child,_m,_o,child;return __generator(this,function(_p){switch(_p.label){case 0:if(contains(stack.element.container.flags,16/* DEBUG_RENDER */)){debugger;}// https://www.w3.org/TR/css-position-3/#painting-order
// 1. the background and borders of the element forming the stacking context.
return[4/*yield*/,this.renderNodeBackgroundAndBorders(stack.element)];case 1:// https://www.w3.org/TR/css-position-3/#painting-order
// 1. the background and borders of the element forming the stacking context.
_p.sent();_i=0,_a=stack.negativeZIndex;_p.label=2;case 2:if(!(_i<_a.length))return[3/*break*/,5];child=_a[_i];return[4/*yield*/,this.renderStack(child)];case 3:_p.sent();_p.label=4;case 4:_i++;return[3/*break*/,2];case 5:// 3. For all its in-flow, non-positioned, block-level descendants in tree order:
return[4/*yield*/,this.renderNodeContent(stack.element)];case 6:// 3. For all its in-flow, non-positioned, block-level descendants in tree order:
_p.sent();_b=0,_c=stack.nonInlineLevel;_p.label=7;case 7:if(!(_b<_c.length))return[3/*break*/,10];child=_c[_b];return[4/*yield*/,this.renderNode(child)];case 8:_p.sent();_p.label=9;case 9:_b++;return[3/*break*/,7];case 10:_d=0,_e=stack.nonPositionedFloats;_p.label=11;case 11:if(!(_d<_e.length))return[3/*break*/,14];child=_e[_d];return[4/*yield*/,this.renderStack(child)];case 12:_p.sent();_p.label=13;case 13:_d++;return[3/*break*/,11];case 14:_f=0,_g=stack.nonPositionedInlineLevel;_p.label=15;case 15:if(!(_f<_g.length))return[3/*break*/,18];child=_g[_f];return[4/*yield*/,this.renderStack(child)];case 16:_p.sent();_p.label=17;case 17:_f++;return[3/*break*/,15];case 18:_h=0,_j=stack.inlineLevel;_p.label=19;case 19:if(!(_h<_j.length))return[3/*break*/,22];child=_j[_h];return[4/*yield*/,this.renderNode(child)];case 20:_p.sent();_p.label=21;case 21:_h++;return[3/*break*/,19];case 22:_k=0,_l=stack.zeroOrAutoZIndexOrTransformedOrOpacity;_p.label=23;case 23:if(!(_k<_l.length))return[3/*break*/,26];child=_l[_k];return[4/*yield*/,this.renderStack(child)];case 24:_p.sent();_p.label=25;case 25:_k++;return[3/*break*/,23];case 26:_m=0,_o=stack.positiveZIndex;_p.label=27;case 27:if(!(_m<_o.length))return[3/*break*/,30];child=_o[_m];return[4/*yield*/,this.renderStack(child)];case 28:_p.sent();_p.label=29;case 29:_m++;return[3/*break*/,27];case 30:return[2/*return*/];}});});};CanvasRenderer.prototype.mask=function(paths){this.ctx.beginPath();this.ctx.moveTo(0,0);this.ctx.lineTo(this.canvas.width,0);this.ctx.lineTo(this.canvas.width,this.canvas.height);this.ctx.lineTo(0,this.canvas.height);this.ctx.lineTo(0,0);this.formatPath(paths.slice(0).reverse());this.ctx.closePath();};CanvasRenderer.prototype.path=function(paths){this.ctx.beginPath();this.formatPath(paths);this.ctx.closePath();};CanvasRenderer.prototype.formatPath=function(paths){var _this=this;paths.forEach(function(point,index){var start=isBezierCurve(point)?point.start:point;if(index===0){_this.ctx.moveTo(start.x,start.y);}else{_this.ctx.lineTo(start.x,start.y);}if(isBezierCurve(point)){_this.ctx.bezierCurveTo(point.startControl.x,point.startControl.y,point.endControl.x,point.endControl.y,point.end.x,point.end.y);}});};CanvasRenderer.prototype.renderRepeat=function(path,pattern,offsetX,offsetY){this.path(path);this.ctx.fillStyle=pattern;this.ctx.translate(offsetX,offsetY);this.ctx.fill();this.ctx.translate(-offsetX,-offsetY);};CanvasRenderer.prototype.resizeImage=function(image,width,height){var _a;if(image.width===width&&image.height===height){return image;}var ownerDocument=(_a=this.canvas.ownerDocument)!==null&&_a!==void 0?_a:document;var canvas=ownerDocument.createElement('canvas');canvas.width=Math.max(1,width);canvas.height=Math.max(1,height);var ctx=canvas.getContext('2d');ctx.drawImage(image,0,0,image.width,image.height,0,0,width,height);return canvas;};CanvasRenderer.prototype.renderBackgroundImage=function(container){return __awaiter(this,void 0,void 0,function(){var index,_loop_1,this_1,_i,_a,backgroundImage;return __generator(this,function(_b){switch(_b.label){case 0:index=container.styles.backgroundImage.length-1;_loop_1=function _loop_1(backgroundImage){var image,url,_c,path,x,y,width,height,pattern,_d,path,x,y,width,height,_e,lineLength,x0,x1,y0,y1,canvas,ctx,gradient_1,pattern,_f,path,left,top_1,width,height,position,x,y,_g,rx,ry,radialGradient_1,midX,midY,f,invF;return __generator(this,function(_h){switch(_h.label){case 0:if(!(backgroundImage.type===0/* URL */))return[3/*break*/,5];image=void 0;url=backgroundImage.url;_h.label=1;case 1:_h.trys.push([1,3,,4]);return[4/*yield*/,this_1.context.cache.match(url)];case 2:image=_h.sent();return[3/*break*/,4];case 3:_h.sent();this_1.context.logger.error("Error loading background-image "+url);return[3/*break*/,4];case 4:if(image){_c=calculateBackgroundRendering(container,index,[image.width,image.height,image.width/image.height]),path=_c[0],x=_c[1],y=_c[2],width=_c[3],height=_c[4];pattern=this_1.ctx.createPattern(this_1.resizeImage(image,width,height),'repeat');this_1.renderRepeat(path,pattern,x,y);}return[3/*break*/,6];case 5:if(isLinearGradient(backgroundImage)){_d=calculateBackgroundRendering(container,index,[null,null,null]),path=_d[0],x=_d[1],y=_d[2],width=_d[3],height=_d[4];_e=calculateGradientDirection(backgroundImage.angle,width,height),lineLength=_e[0],x0=_e[1],x1=_e[2],y0=_e[3],y1=_e[4];canvas=document.createElement('canvas');canvas.width=width;canvas.height=height;ctx=canvas.getContext('2d');gradient_1=ctx.createLinearGradient(x0,y0,x1,y1);processColorStops(backgroundImage.stops,lineLength).forEach(function(colorStop){return gradient_1.addColorStop(colorStop.stop,asString(colorStop.color));});ctx.fillStyle=gradient_1;ctx.fillRect(0,0,width,height);if(width>0&&height>0){pattern=this_1.ctx.createPattern(canvas,'repeat');this_1.renderRepeat(path,pattern,x,y);}}else if(isRadialGradient(backgroundImage)){_f=calculateBackgroundRendering(container,index,[null,null,null]),path=_f[0],left=_f[1],top_1=_f[2],width=_f[3],height=_f[4];position=backgroundImage.position.length===0?[FIFTY_PERCENT]:backgroundImage.position;x=getAbsoluteValue(position[0],width);y=getAbsoluteValue(position[position.length-1],height);_g=calculateRadius(backgroundImage,x,y,width,height),rx=_g[0],ry=_g[1];if(rx>0&&ry>0){radialGradient_1=this_1.ctx.createRadialGradient(left+x,top_1+y,0,left+x,top_1+y,rx);processColorStops(backgroundImage.stops,rx*2).forEach(function(colorStop){return radialGradient_1.addColorStop(colorStop.stop,asString(colorStop.color));});this_1.path(path);this_1.ctx.fillStyle=radialGradient_1;if(rx!==ry){midX=container.bounds.left+0.5*container.bounds.width;midY=container.bounds.top+0.5*container.bounds.height;f=ry/rx;invF=1/f;this_1.ctx.save();this_1.ctx.translate(midX,midY);this_1.ctx.transform(1,0,0,f,0,0);this_1.ctx.translate(-midX,-midY);this_1.ctx.fillRect(left,invF*(top_1-midY)+midY,width,height*invF);this_1.ctx.restore();}else{this_1.ctx.fill();}}}_h.label=6;case 6:index--;return[2/*return*/];}});};this_1=this;_i=0,_a=container.styles.backgroundImage.slice(0).reverse();_b.label=1;case 1:if(!(_i<_a.length))return[3/*break*/,4];backgroundImage=_a[_i];return[5/*yield**/,_loop_1(backgroundImage)];case 2:_b.sent();_b.label=3;case 3:_i++;return[3/*break*/,1];case 4:return[2/*return*/];}});});};CanvasRenderer.prototype.renderSolidBorder=function(color,side,curvePoints){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){this.path(parsePathForBorder(curvePoints,side));this.ctx.fillStyle=asString(color);this.ctx.fill();return[2/*return*/];});});};CanvasRenderer.prototype.renderDoubleBorder=function(color,width,side,curvePoints){return __awaiter(this,void 0,void 0,function(){var outerPaths,innerPaths;return __generator(this,function(_a){switch(_a.label){case 0:if(!(width<3))return[3/*break*/,2];return[4/*yield*/,this.renderSolidBorder(color,side,curvePoints)];case 1:_a.sent();return[2/*return*/];case 2:outerPaths=parsePathForBorderDoubleOuter(curvePoints,side);this.path(outerPaths);this.ctx.fillStyle=asString(color);this.ctx.fill();innerPaths=parsePathForBorderDoubleInner(curvePoints,side);this.path(innerPaths);this.ctx.fill();return[2/*return*/];}});});};CanvasRenderer.prototype.renderNodeBackgroundAndBorders=function(paint){return __awaiter(this,void 0,void 0,function(){var styles,hasBackground,borders,backgroundPaintingArea,side,_i,borders_1,border;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:this.applyEffects(paint.getEffects(2/* BACKGROUND_BORDERS */));styles=paint.container.styles;hasBackground=!isTransparent(styles.backgroundColor)||styles.backgroundImage.length;borders=[{style:styles.borderTopStyle,color:styles.borderTopColor,width:styles.borderTopWidth},{style:styles.borderRightStyle,color:styles.borderRightColor,width:styles.borderRightWidth},{style:styles.borderBottomStyle,color:styles.borderBottomColor,width:styles.borderBottomWidth},{style:styles.borderLeftStyle,color:styles.borderLeftColor,width:styles.borderLeftWidth}];backgroundPaintingArea=calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip,0),paint.curves);if(!(hasBackground||styles.boxShadow.length))return[3/*break*/,2];this.ctx.save();this.path(backgroundPaintingArea);this.ctx.clip();if(!isTransparent(styles.backgroundColor)){this.ctx.fillStyle=asString(styles.backgroundColor);this.ctx.fill();}return[4/*yield*/,this.renderBackgroundImage(paint.container)];case 1:_a.sent();this.ctx.restore();styles.boxShadow.slice(0).reverse().forEach(function(shadow){_this.ctx.save();var borderBoxArea=calculateBorderBoxPath(paint.curves);var maskOffset=shadow.inset?0:MASK_OFFSET;var shadowPaintingArea=transformPath(borderBoxArea,-maskOffset+(shadow.inset?1:-1)*shadow.spread.number,(shadow.inset?1:-1)*shadow.spread.number,shadow.spread.number*(shadow.inset?-2:2),shadow.spread.number*(shadow.inset?-2:2));if(shadow.inset){_this.path(borderBoxArea);_this.ctx.clip();_this.mask(shadowPaintingArea);}else{_this.mask(borderBoxArea);_this.ctx.clip();_this.path(shadowPaintingArea);}_this.ctx.shadowOffsetX=shadow.offsetX.number+maskOffset;_this.ctx.shadowOffsetY=shadow.offsetY.number;_this.ctx.shadowColor=asString(shadow.color);_this.ctx.shadowBlur=shadow.blur.number;_this.ctx.fillStyle=shadow.inset?asString(shadow.color):'rgba(0,0,0,1)';_this.ctx.fill();_this.ctx.restore();});_a.label=2;case 2:side=0;_i=0,borders_1=borders;_a.label=3;case 3:if(!(_i<borders_1.length))return[3/*break*/,13];border=borders_1[_i];if(!(border.style!==0/* NONE */&&!isTransparent(border.color)&&border.width>0))return[3/*break*/,11];if(!(border.style===2/* DASHED */))return[3/*break*/,5];return[4/*yield*/,this.renderDashedDottedBorder(border.color,border.width,side,paint.curves,2/* DASHED */)];case 4:_a.sent();return[3/*break*/,11];case 5:if(!(border.style===3/* DOTTED */))return[3/*break*/,7];return[4/*yield*/,this.renderDashedDottedBorder(border.color,border.width,side,paint.curves,3/* DOTTED */)];case 6:_a.sent();return[3/*break*/,11];case 7:if(!(border.style===4/* DOUBLE */))return[3/*break*/,9];return[4/*yield*/,this.renderDoubleBorder(border.color,border.width,side,paint.curves)];case 8:_a.sent();return[3/*break*/,11];case 9:return[4/*yield*/,this.renderSolidBorder(border.color,side,paint.curves)];case 10:_a.sent();_a.label=11;case 11:side++;_a.label=12;case 12:_i++;return[3/*break*/,3];case 13:return[2/*return*/];}});});};CanvasRenderer.prototype.renderDashedDottedBorder=function(color,width,side,curvePoints,style){return __awaiter(this,void 0,void 0,function(){var strokePaths,boxPaths,startX,startY,endX,endY,length,dashLength,spaceLength,useLineDash,multiplier,numberOfDashes,minSpace,maxSpace,path1,path2,path1,path2;return __generator(this,function(_a){this.ctx.save();strokePaths=parsePathForBorderStroke(curvePoints,side);boxPaths=parsePathForBorder(curvePoints,side);if(style===2/* DASHED */){this.path(boxPaths);this.ctx.clip();}if(isBezierCurve(boxPaths[0])){startX=boxPaths[0].start.x;startY=boxPaths[0].start.y;}else{startX=boxPaths[0].x;startY=boxPaths[0].y;}if(isBezierCurve(boxPaths[1])){endX=boxPaths[1].end.x;endY=boxPaths[1].end.y;}else{endX=boxPaths[1].x;endY=boxPaths[1].y;}if(side===0||side===2){length=Math.abs(startX-endX);}else{length=Math.abs(startY-endY);}this.ctx.beginPath();if(style===3/* DOTTED */){this.formatPath(strokePaths);}else{this.formatPath(boxPaths.slice(0,2));}dashLength=width<3?width*3:width*2;spaceLength=width<3?width*2:width;if(style===3/* DOTTED */){dashLength=width;spaceLength=width;}useLineDash=true;if(length<=dashLength*2){useLineDash=false;}else if(length<=dashLength*2+spaceLength){multiplier=length/(2*dashLength+spaceLength);dashLength*=multiplier;spaceLength*=multiplier;}else{numberOfDashes=Math.floor((length+spaceLength)/(dashLength+spaceLength));minSpace=(length-numberOfDashes*dashLength)/(numberOfDashes-1);maxSpace=(length-(numberOfDashes+1)*dashLength)/numberOfDashes;spaceLength=maxSpace<=0||Math.abs(spaceLength-minSpace)<Math.abs(spaceLength-maxSpace)?minSpace:maxSpace;}if(useLineDash){if(style===3/* DOTTED */){this.ctx.setLineDash([0,dashLength+spaceLength]);}else{this.ctx.setLineDash([dashLength,spaceLength]);}}if(style===3/* DOTTED */){this.ctx.lineCap='round';this.ctx.lineWidth=width;}else{this.ctx.lineWidth=width*2+1.1;}this.ctx.strokeStyle=asString(color);this.ctx.stroke();this.ctx.setLineDash([]);// dashed round edge gap
if(style===2/* DASHED */){if(isBezierCurve(boxPaths[0])){path1=boxPaths[3];path2=boxPaths[0];this.ctx.beginPath();this.formatPath([new Vector(path1.end.x,path1.end.y),new Vector(path2.start.x,path2.start.y)]);this.ctx.stroke();}if(isBezierCurve(boxPaths[1])){path1=boxPaths[1];path2=boxPaths[2];this.ctx.beginPath();this.formatPath([new Vector(path1.end.x,path1.end.y),new Vector(path2.start.x,path2.start.y)]);this.ctx.stroke();}}this.ctx.restore();return[2/*return*/];});});};CanvasRenderer.prototype.render=function(element){return __awaiter(this,void 0,void 0,function(){var stack;return __generator(this,function(_a){switch(_a.label){case 0:if(this.options.backgroundColor){this.ctx.fillStyle=asString(this.options.backgroundColor);this.ctx.fillRect(this.options.x,this.options.y,this.options.width,this.options.height);}stack=parseStackingContexts(element);return[4/*yield*/,this.renderStack(stack)];case 1:_a.sent();this.applyEffects([]);return[2/*return*/,this.canvas];}});});};return CanvasRenderer;}(Renderer);var isTextInputElement=function isTextInputElement(container){if(container instanceof TextareaElementContainer){return true;}else if(container instanceof SelectElementContainer){return true;}else if(container instanceof InputElementContainer&&container.type!==RADIO&&container.type!==CHECKBOX){return true;}return false;};var calculateBackgroundCurvedPaintingArea=function calculateBackgroundCurvedPaintingArea(clip,curves){switch(clip){case 0/* BORDER_BOX */:return calculateBorderBoxPath(curves);case 2/* CONTENT_BOX */:return calculateContentBoxPath(curves);case 1/* PADDING_BOX */:default:return calculatePaddingBoxPath(curves);}};var canvasTextAlign=function canvasTextAlign(textAlign){switch(textAlign){case 1/* CENTER */:return'center';case 2/* RIGHT */:return'right';case 0/* LEFT */:default:return'left';}};// see https://github.com/niklasvh/html2canvas/pull/2645
var iOSBrokenFonts=['-apple-system','system-ui'];var fixIOSSystemFonts=function fixIOSSystemFonts(fontFamilies){return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)?fontFamilies.filter(function(fontFamily){return iOSBrokenFonts.indexOf(fontFamily)===-1;}):fontFamilies;};var ForeignObjectRenderer=/** @class */function(_super){__extends(ForeignObjectRenderer,_super);function ForeignObjectRenderer(context,options){var _this=_super.call(this,context,options)||this;_this.canvas=options.canvas?options.canvas:document.createElement('canvas');_this.ctx=_this.canvas.getContext('2d');_this.options=options;_this.canvas.width=Math.floor(options.width*options.scale);_this.canvas.height=Math.floor(options.height*options.scale);_this.canvas.style.width=options.width+"px";_this.canvas.style.height=options.height+"px";_this.ctx.scale(_this.options.scale,_this.options.scale);_this.ctx.translate(-options.x,-options.y);_this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized ("+options.width+"x"+options.height+" at "+options.x+","+options.y+") with scale "+options.scale);return _this;}ForeignObjectRenderer.prototype.render=function(element){return __awaiter(this,void 0,void 0,function(){var svg,img;return __generator(this,function(_a){switch(_a.label){case 0:svg=createForeignObjectSVG(this.options.width*this.options.scale,this.options.height*this.options.scale,this.options.scale,this.options.scale,element);return[4/*yield*/,loadSerializedSVG(svg)];case 1:img=_a.sent();if(this.options.backgroundColor){this.ctx.fillStyle=asString(this.options.backgroundColor);this.ctx.fillRect(0,0,this.options.width*this.options.scale,this.options.height*this.options.scale);}this.ctx.drawImage(img,-this.options.x*this.options.scale,-this.options.y*this.options.scale);return[2/*return*/,this.canvas];}});});};return ForeignObjectRenderer;}(Renderer);var loadSerializedSVG=function loadSerializedSVG(svg){return new Promise(function(resolve,reject){var img=new Image();img.onload=function(){resolve(img);};img.onerror=reject;img.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(new XMLSerializer().serializeToString(svg));});};var Logger=/** @class */function(){function Logger(_a){var id=_a.id,enabled=_a.enabled;this.id=id;this.enabled=enabled;this.start=Date.now();}// eslint-disable-next-line @typescript-eslint/no-explicit-any
Logger.prototype.debug=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this.enabled){// eslint-disable-next-line no-console
if(typeof window!=='undefined'&&window.console&&typeof console.debug==='function'){// eslint-disable-next-line no-console
console.debug.apply(console,__spreadArray([this.id,this.getTime()+"ms"],args));}else{this.info.apply(this,args);}}};Logger.prototype.getTime=function(){return Date.now()-this.start;};// eslint-disable-next-line @typescript-eslint/no-explicit-any
Logger.prototype.info=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this.enabled){// eslint-disable-next-line no-console
if(typeof window!=='undefined'&&window.console&&typeof console.info==='function'){// eslint-disable-next-line no-console
console.info.apply(console,__spreadArray([this.id,this.getTime()+"ms"],args));}}};// eslint-disable-next-line @typescript-eslint/no-explicit-any
Logger.prototype.warn=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this.enabled){// eslint-disable-next-line no-console
if(typeof window!=='undefined'&&window.console&&typeof console.warn==='function'){// eslint-disable-next-line no-console
console.warn.apply(console,__spreadArray([this.id,this.getTime()+"ms"],args));}else{this.info.apply(this,args);}}};// eslint-disable-next-line @typescript-eslint/no-explicit-any
Logger.prototype.error=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this.enabled){// eslint-disable-next-line no-console
if(typeof window!=='undefined'&&window.console&&typeof console.error==='function'){// eslint-disable-next-line no-console
console.error.apply(console,__spreadArray([this.id,this.getTime()+"ms"],args));}else{this.info.apply(this,args);}}};Logger.instances={};return Logger;}();var Context=/** @class */function(){function Context(options,windowBounds){var _a;this.windowBounds=windowBounds;this.instanceName="#"+Context.instanceCount++;this.logger=new Logger({id:this.instanceName,enabled:options.logging});this.cache=(_a=options.cache)!==null&&_a!==void 0?_a:new Cache(this,options);}Context.instanceCount=1;return Context;}();var html2canvas=function html2canvas(element,options){if(options===void 0){options={};}return renderElement(element,options);};if(typeof window!=='undefined'){CacheStorage.setContext(window);}var renderElement=function renderElement(element,opts){return __awaiter(void 0,void 0,void 0,function(){var ownerDocument,defaultView,resourceOptions,contextOptions,windowOptions,windowBounds,context,foreignObjectRendering,cloneOptions,documentCloner,clonedElement,container,_a,width,height,left,top,backgroundColor,renderOptions,canvas,renderer,root,renderer;var _b,_c,_d,_e,_f,_g,_h,_j,_k,_l,_m,_o,_p,_q,_r,_s,_t;return __generator(this,function(_u){switch(_u.label){case 0:if(!element||_typeof(element)!=='object'){return[2/*return*/,Promise.reject('Invalid element provided as first argument')];}ownerDocument=element.ownerDocument;if(!ownerDocument){throw new Error("Element is not attached to a Document");}defaultView=ownerDocument.defaultView;if(!defaultView){throw new Error("Document is not attached to a Window");}resourceOptions={allowTaint:(_b=opts.allowTaint)!==null&&_b!==void 0?_b:false,imageTimeout:(_c=opts.imageTimeout)!==null&&_c!==void 0?_c:15000,proxy:opts.proxy,useCORS:(_d=opts.useCORS)!==null&&_d!==void 0?_d:false};contextOptions=_assign({logging:(_e=opts.logging)!==null&&_e!==void 0?_e:true,cache:opts.cache},resourceOptions);windowOptions={windowWidth:(_f=opts.windowWidth)!==null&&_f!==void 0?_f:defaultView.innerWidth,windowHeight:(_g=opts.windowHeight)!==null&&_g!==void 0?_g:defaultView.innerHeight,scrollX:(_h=opts.scrollX)!==null&&_h!==void 0?_h:defaultView.pageXOffset,scrollY:(_j=opts.scrollY)!==null&&_j!==void 0?_j:defaultView.pageYOffset};windowBounds=new Bounds(windowOptions.scrollX,windowOptions.scrollY,windowOptions.windowWidth,windowOptions.windowHeight);context=new Context(contextOptions,windowBounds);foreignObjectRendering=(_k=opts.foreignObjectRendering)!==null&&_k!==void 0?_k:false;cloneOptions={allowTaint:(_l=opts.allowTaint)!==null&&_l!==void 0?_l:false,onclone:opts.onclone,ignoreElements:opts.ignoreElements,inlineImages:foreignObjectRendering,copyStyles:foreignObjectRendering};context.logger.debug("Starting document clone with size "+windowBounds.width+"x"+windowBounds.height+" scrolled to "+-windowBounds.left+","+-windowBounds.top);documentCloner=new DocumentCloner(context,element,cloneOptions);clonedElement=documentCloner.clonedReferenceElement;if(!clonedElement){return[2/*return*/,Promise.reject("Unable to find element in cloned iframe")];}return[4/*yield*/,documentCloner.toIFrame(ownerDocument,windowBounds)];case 1:container=_u.sent();_a=isBodyElement(clonedElement)||isHTMLElement(clonedElement)?parseDocumentSize(clonedElement.ownerDocument):parseBounds(context,clonedElement),width=_a.width,height=_a.height,left=_a.left,top=_a.top;backgroundColor=parseBackgroundColor(context,clonedElement,opts.backgroundColor);renderOptions={canvas:opts.canvas,backgroundColor:backgroundColor,scale:(_o=(_m=opts.scale)!==null&&_m!==void 0?_m:defaultView.devicePixelRatio)!==null&&_o!==void 0?_o:1,x:((_p=opts.x)!==null&&_p!==void 0?_p:0)+left,y:((_q=opts.y)!==null&&_q!==void 0?_q:0)+top,width:(_r=opts.width)!==null&&_r!==void 0?_r:Math.ceil(width),height:(_s=opts.height)!==null&&_s!==void 0?_s:Math.ceil(height)};if(!foreignObjectRendering)return[3/*break*/,3];context.logger.debug("Document cloned, using foreign object rendering");renderer=new ForeignObjectRenderer(context,renderOptions);return[4/*yield*/,renderer.render(clonedElement)];case 2:canvas=_u.sent();return[3/*break*/,5];case 3:context.logger.debug("Document cloned, element located at "+left+","+top+" with size "+width+"x"+height+" using computed rendering");context.logger.debug("Starting DOM parsing");root=parseTree(context,clonedElement);if(backgroundColor===root.styles.backgroundColor){root.styles.backgroundColor=COLORS.TRANSPARENT;}context.logger.debug("Starting renderer for element at "+renderOptions.x+","+renderOptions.y+" with size "+renderOptions.width+"x"+renderOptions.height);renderer=new CanvasRenderer(context,renderOptions);return[4/*yield*/,renderer.render(root)];case 4:canvas=_u.sent();_u.label=5;case 5:if((_t=opts.removeContainer)!==null&&_t!==void 0?_t:true){if(!DocumentCloner.destroy(container)){context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");}}context.logger.debug("Finished rendering");return[2/*return*/,canvas];}});});};var parseBackgroundColor=function parseBackgroundColor(context,element,backgroundColorOverride){var ownerDocument=element.ownerDocument;// http://www.w3.org/TR/css3-background/#special-backgrounds
var documentBackgroundColor=ownerDocument.documentElement?parseColor(context,getComputedStyle(ownerDocument.documentElement).backgroundColor):COLORS.TRANSPARENT;var bodyBackgroundColor=ownerDocument.body?parseColor(context,getComputedStyle(ownerDocument.body).backgroundColor):COLORS.TRANSPARENT;var defaultBackgroundColor=typeof backgroundColorOverride==='string'?parseColor(context,backgroundColorOverride):backgroundColorOverride===null?COLORS.TRANSPARENT:0xffffffff;return element===ownerDocument.documentElement?isTransparent(documentBackgroundColor)?isTransparent(bodyBackgroundColor)?defaultBackgroundColor:bodyBackgroundColor:documentBackgroundColor:defaultBackgroundColor;};/**
 * The 3D Viewer at the heart of the xeokit SDK.
 *
 * * A Viewer wraps a single {@link Scene}
 * * Add {@link Plugin}s to a Viewer to extend its functionality.
 * * {@link Viewer#metaScene} holds metadata about models in the
 * Viewer's {@link MetaScene}.
 * * Use {@link Viewer#cameraFlight} to fly or jump the {@link Scene}'s
 * {@link Camera} to target positions, boundaries or {@link Entity}s.
 *
 * @public
 */var Viewer=/*#__PURE__*/function(){/**
     * @constructor
     * @param {Object} cfg Viewer configuration.
     * @param {String} [cfg.id] Optional ID for this Viewer, defaults to the ID of {@link Viewer#scene}, which xeokit automatically generates.
     * @param {String} [cfg.canvasId]  ID of an existing HTML canvas for the {@link Viewer#scene} - either this or canvasElement is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLCanvasElement} [cfg.canvasElement] Reference of an existing HTML canvas for the {@link Viewer#scene} - either this or canvasId is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLElement} [cfg.keyboardEventsElement] Optional reference to HTML element on which key events should be handled. Defaults to the HTML Document.
     * @param {String} [cfg.spinnerElementId]  ID of existing HTML element to show the {@link Spinner} - internally creates a default element automatically if this is omitted.
     * @param {Number} [cfg.passes=1] The number of times the {@link Viewer#scene} renders per frame.
     * @param {Boolean} [cfg.clearEachPass=false] When doing multiple passes per frame, specifies if to clear the canvas before each pass (true) or just before the first pass (false).
     * @param {Boolean} [cfg.preserveDrawingBuffer=true]  Whether or not to preserve the WebGL drawing buffer. This needs to be ````true```` for {@link Viewer#getSnapshot} to work.
     * @param {Boolean} [cfg.transparent=true]  Whether or not the canvas is transparent.
     * @param {Boolean} [cfg.premultipliedAlpha=false]  Whether or not you want alpha composition with premultiplied alpha. Highlighting and selection works best when this is ````false````.
     * @param {Boolean} [cfg.gammaInput=true]  When true, expects that all textures and colors are premultiplied gamma.
     * @param {Boolean} [cfg.gammaOutput=false]  Whether or not to render with pre-multiplied gama.
     * @param {Number} [cfg.gammaFactor=2.2] The gamma factor to use when rendering with pre-multiplied gamma.
     * @param {Number[]} [cfg.backgroundColor=[1,1,1]] Sets the canvas background color to use when ````transparent```` is false.
     * @param {Boolean} [cfg.backgroundColorFromAmbientLight=true] When ````transparent```` is false, set this ````true````
     * to derive the canvas background color from {@link AmbientLight#color}, or ````false```` to set the canvas background to ````backgroundColor````.
     * @param {String} [cfg.units="meters"] The measurement unit type. Accepted values are ````"meters"````, ````"metres"````, , ````"centimeters"````, ````"centimetres"````, ````"millimeters"````,  ````"millimetres"````, ````"yards"````, ````"feet"```` and ````"inches"````.
     * @param {Number} [cfg.scale=1] The number of Real-space units in each World-space coordinate system unit.
     * @param {Number[]} [cfg.origin=[0,0,0]] The Real-space 3D origin, in current measurement units, at which the World-space coordinate origin ````[0,0,0]```` sits.
     * @param {Boolean} [cfg.saoEnabled=false] Whether to enable Scalable Ambient Obscurance (SAO) effect. See {@link SAO} for more info.
     * @param {Boolean} [cfg.antialias=true] Whether to enable anti-aliasing.
     * @throws {String} Throws an exception when both canvasId or canvasElement are missing or they aren't pointing to a valid HTMLCanvasElement.
     * @param {Boolean} [cfg.alphaDepthMask=true] Whether writing into the depth buffer is enabled or disabled when rendering transparent objects.
     * @param {Boolean} [cfg.entityOffsetsEnabled=false] Whether to enable {@link Entity#offset}. For best performance, only set this ````true```` when you need to use {@link Entity#offset}.
     * @param {Boolean} [cfg.pickSurfacePrecisionEnabled=false] Whether to enable full-precision accuracy when surface picking with {@link Scene#pick}. Note that when ````true````, this configuration will increase the amount of browser memory used by the Viewer. The ````pickSurfacePrecision```` option for ````Scene#pick```` only works if this is set ````true````.
     * @param {Boolean} [cfg.logarithmicDepthBufferEnabled=false] Whether to enable logarithmic depth buffer. When this is true,
     * you can set huge values for {@link Perspective#far} and {@link Ortho#far}, to push the far clipping plane back so
     * that it does not clip huge models.
     * @param {Boolean} [cfg.colorTextureEnabled=true] Whether to enable base color texture rendering.
     * @param {Boolean} [cfg.pbrEnabled=false] Whether to enable physically-based rendering.
     * @param {LocaleService} [cfg.localeService=null] Optional locale-based translation service.
     * @param {Boolean} [cfg.dtxEnabled=false] Whether to enable data texture-based (DTX) scene representation within the Viewer. When this is true, the Viewer will use data textures to
     * store geometry on the GPU for triangle meshes that don't have textures. This gives a much lower memory footprint for these types of model element. This mode may not perform well on low-end GPUs that are optimized
     * to use textures to hold geometry data. Works great on most medium/high-end GPUs found in desktop computers, including the nVIDIA and Intel HD chipsets. Set this false to use the default vertex buffer object (VBO)
     * mode for storing geometry, which is the standard technique used in most graphics engines, and will work adequately on most low-end GPUs.
     * @param {number} [cfg.numCachedSectionPlanes=0] Enhances the efficiency of SectionPlane creation by proactively allocating Viewer resources for a specified quantity
     * of SectionPlanes. Introducing this parameter streamlines the initial creation speed of SectionPlanes, particularly up to the designated quantity. This parameter internally
     * configures renderer logic for the specified number of SectionPlanes, eliminating the need for setting up logic with each SectionPlane creation and thereby enhancing
     * responsiveness. It is important to consider that each SectionPlane impacts rendering performance, so it is recommended to set this value to a quantity that aligns with
     * your expected usage.
     */function Viewer(cfg){_classCallCheck(this,Viewer);/**
         * The Viewer's current language setting.
         * @property language
         * @deprecated
         * @type {String}
         */this.language="en";/**
         * The viewer's locale service.
         *
         * This is configured via the Viewer's constructor.
         *
         * By default, this service will be an instance of {@link LocaleService}, which will just return
         * null translations for all given strings and phrases.
         *
         * @property localeService
         * @type {LocaleService}
         * @since 2.0
         */this.localeService=cfg.localeService||new LocaleService();/**
         * The Viewer's {@link Scene}.
         * @property scene
         * @type {Scene}
         */this.scene=new Scene(this,{canvasId:cfg.canvasId,canvasElement:cfg.canvasElement,keyboardEventsElement:cfg.keyboardEventsElement,contextAttr:{preserveDrawingBuffer:cfg.preserveDrawingBuffer!==false,premultipliedAlpha:!!cfg.premultipliedAlpha,antialias:cfg.antialias!==false},spinnerElementId:cfg.spinnerElementId,transparent:cfg.transparent!==false,gammaInput:true,gammaOutput:false,backgroundColor:cfg.backgroundColor,backgroundColorFromAmbientLight:cfg.backgroundColorFromAmbientLight,ticksPerRender:1,ticksPerOcclusionTest:20,units:cfg.units,scale:cfg.scale,origin:cfg.origin,saoEnabled:cfg.saoEnabled,alphaDepthMask:cfg.alphaDepthMask!==false,entityOffsetsEnabled:!!cfg.entityOffsetsEnabled,pickSurfacePrecisionEnabled:!!cfg.pickSurfacePrecisionEnabled,logarithmicDepthBufferEnabled:!!cfg.logarithmicDepthBufferEnabled,pbrEnabled:!!cfg.pbrEnabled,colorTextureEnabled:cfg.colorTextureEnabled!==false,dtxEnabled:!!cfg.dtxEnabled,numCachedSectionPlanes:cfg.numCachedSectionPlanes});/**
         * Metadata about the {@link Scene} and the models and objects within it.
         * @property metaScene
         * @type {MetaScene}
         * @readonly
         */this.metaScene=new MetaScene(this,this.scene);/**
         * The Viewer's ID.
         * @property id
         *
         * @type {String|Number}
         */this.id=cfg.id||this.scene.id;/**
         * The Viewer's {@link Camera}. This is also found on {@link Scene#camera}.
         * @property camera
         * @type {Camera}
         */this.camera=this.scene.camera;/**
         * The Viewer's {@link CameraFlightAnimation}, which
         * is used to fly the {@link Scene}'s {@link Camera} to given targets.
         * @property cameraFlight
         * @type {CameraFlightAnimation}
         */this.cameraFlight=new CameraFlightAnimation(this.scene,{duration:0.5});/**
         * The Viewer's {@link CameraControl}, which
         * controls the {@link Scene}'s {@link Camera} with mouse,  touch and keyboard input.
         * @property cameraControl
         * @type {CameraControl}
         */this.cameraControl=new CameraControl(this.scene,{// panToPointer: true,
doublePickFlyTo:true});this._plugins=[];/**
         * Subscriptions to events sent with {@link fire}.
         * @private
         */this._eventSubs={};}/**
     * Returns the capabilities of this Viewer.
     *
     * @returns {{astcSupported: boolean, etc1Supported: boolean, pvrtcSupported: boolean, etc2Supported: boolean, dxtSupported: boolean, bptcSupported: boolean}}
     */_createClass(Viewer,[{key:"capabilities",get:function get(){return this.scene.capabilities;}/**
     * Subscribes to an event fired at this Viewer.
     *
     * @param {String} event The event
     * @param {Function} callback Callback fired on the event
     */},{key:"on",value:function on(event,callback){var subs=this._eventSubs[event];if(!subs){subs=[];this._eventSubs[event]=subs;}subs.push(callback);}/**
     * Fires an event at this Viewer.
     *
     * @param {String} event Event name
     * @param {Object} value Event parameters
     */},{key:"fire",value:function fire(event,value){var subs=this._eventSubs[event];if(subs){for(var _i486=0,len=subs.length;_i486<len;_i486++){subs[_i486](value);}}}/**
     * Unsubscribes from an event fired at this Viewer.
     * @param event
     */},{key:"off",value:function off(event){// TODO
}/**
     * Logs a message to the JavaScript developer console, prefixed with the ID of this Viewer.
     *
     * @param {String} msg The message
     */},{key:"log",value:function log(msg){console.log("[xeokit viewer ".concat(this.id,"]: ").concat(msg));}/**
     * Logs an error message to the JavaScript developer console, prefixed with the ID of this Viewer.
     *
     * @param {String} msg The error message
     */},{key:"error",value:function error(msg){console.error("[xeokit viewer ".concat(this.id,"]: ").concat(msg));}/**
     * Installs a Plugin.
     *
     * @private
     */},{key:"addPlugin",value:function addPlugin(plugin){this._plugins.push(plugin);}/**
     * Uninstalls a Plugin, clearing content from it first.
     *
     * @private
     */},{key:"removePlugin",value:function removePlugin(plugin){for(var _i487=0,len=this._plugins.length;_i487<len;_i487++){var _p2=this._plugins[_i487];if(_p2===plugin){if(_p2.clear){_p2.clear();}this._plugins.splice(_i487,1);return;}}}/**
     * Sends a message to installed Plugins.
     *
     * The message can optionally be accompanied by a value.
     * @private
     */},{key:"sendToPlugins",value:function sendToPlugins(name,value){for(var _i488=0,len=this._plugins.length;_i488<len;_i488++){var _p3=this._plugins[_i488];if(_p3.send){_p3.send(name,value);}}}/**
     * @private
     * @deprecated
     */},{key:"clear",value:function clear(){throw"Viewer#clear() no longer implemented - use '#sendToPlugins(\"clear\") instead";}/**
     * @private
     * @deprecated
     */},{key:"resetView",value:function resetView(){throw"Viewer#resetView() no longer implemented - use CameraMemento & ObjectsMemento classes instead";}/**
     * Enter snapshot mode.
     *
     * Switches rendering to a hidden snapshot canvas.
     *
     * Exit snapshot mode using {@link Viewer#endSnapshot}.
     */},{key:"beginSnapshot",value:function beginSnapshot(){if(this._snapshotBegun){return;}this.scene._renderer.beginSnapshot();this._snapshotBegun=true;}/**
     * Gets a snapshot of this Viewer's {@link Scene} as a Base64-encoded image.
     *
     * #### Usage:
     *
     * ````javascript
     * const imageData = viewer.getSnapshot({
     *    width: 500,
     *    height: 500,
     *    format: "png"
     * });
     * ````
     * @param {*} [params] Capture options.
     * @param {Number} [params.width] Desired width of result in pixels - defaults to width of canvas.
     * @param {Number} [params.height] Desired height of result in pixels - defaults to height of canvas.
     * @param {String} [params.format="jpeg"] Desired format; "jpeg", "png" or "bmp".
     * @param {Boolean} [params.includeGizmos=false] When true, will include gizmos like {@link SectionPlane} in the snapshot.
     * @returns {String} String-encoded image data URI.
     */},{key:"getSnapshot",value:function getSnapshot(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var needFinishSnapshot=!this._snapshotBegun;var resize=params.width!==undefined&&params.height!==undefined;var canvas=this.scene.canvas.canvas;var saveWidth=canvas.clientWidth;var saveHeight=canvas.clientHeight;var width=params.width?Math.floor(params.width):canvas.width;var height=params.height?Math.floor(params.height):canvas.height;if(resize){canvas.width=width;canvas.height=height;}if(!this._snapshotBegun){this.beginSnapshot({width:width,height:height});}if(!params.includeGizmos){this.sendToPlugins("snapshotStarting");// Tells plugins to hide things that shouldn't be in snapshot
}var captured={};for(var _i489=0,len=this._plugins.length;_i489<len;_i489++){var plugin=this._plugins[_i489];if(plugin.getContainerElement){var container=plugin.getContainerElement();if(container!==document.body){if(!captured[container.id]){captured[container.id]=true;html2canvas(container).then(function(canvas){document.body.appendChild(canvas);});}}}}this.scene._renderer.renderSnapshot();var imageDataURI=this.scene._renderer.readSnapshot(params);if(resize){canvas.width=saveWidth;canvas.height=saveHeight;this.scene.glRedraw();}if(!params.includeGizmos){this.sendToPlugins("snapshotFinished");}if(needFinishSnapshot){this.endSnapshot();}return imageDataURI;}/**
     * Gets a snapshot of this Viewer's {@link Scene} as a Base64-encoded image which includes
     * the HTML elements created by various plugins.
     *
     * The snapshot image is composed of an image of the viewer canvas, overlaid with an image
     * of the HTML container element belonging to each installed Viewer plugin. Each container
     * element is only rendered once, so it's OK for plugins to share the same container.
     *
     * #### Usage:
     *
     * ````javascript
     * viewer.getSnapshotWithPlugins({
     *    width: 500,
     *    height: 500,
     *    format: "png"
     * }).then((imageData)=>{
     *
     * });
     * ````
     * @param {*} [params] Capture options.
     * @param {Number} [params.width] Desired width of result in pixels - defaults to width of canvas.
     * @param {Number} [params.height] Desired height of result in pixels - defaults to height of canvas.
     * @param {String} [params.format="jpeg"] Desired format; "jpeg", "png" or "bmp".
     * @param {Boolean} [params.includeGizmos=false] When true, will include gizmos like {@link SectionPlane} in the snapshot.
     * @returns {Promise} Promise which returns a string-encoded image data URI.
     */},{key:"getSnapshotWithPlugins",value:function(){var _getSnapshotWithPlugins=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){var params,needFinishSnapshot,resize,canvas,saveWidth,saveHeight,snapshotWidth,snapshotHeight,snapshotCanvas,pluginToCapture,pluginContainerElements,_i490,len,plugin,containerElement,_i491,_len100,_containerElement,format,_args=arguments;return _regeneratorRuntime().wrap(function _callee$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:params=_args.length>0&&_args[0]!==undefined?_args[0]:{};// We use gl.readPixels to get the WebGL canvas snapshot in a new
// HTMLCanvas element, scaled to the target snapshot size, then
// use html2canvas to render each plugin's container element into
// that HTMLCanvas. Finally, we save the HTMLCanvas to a bitmap.
// We don't rely on html2canvas to up-scale our WebGL canvas
// when we want a higher-resolution snapshot, which would cause
// blurring. Instead, we manage the scale and redraw of the WebGL
// canvas ourselves, in order to allow the Viewer to render the
// right amount of pixels, for a sharper image.
needFinishSnapshot=!this._snapshotBegun;resize=params.width!==undefined&&params.height!==undefined;canvas=this.scene.canvas.canvas;saveWidth=canvas.clientWidth;saveHeight=canvas.clientHeight;snapshotWidth=params.width?Math.floor(params.width):canvas.width;snapshotHeight=params.height?Math.floor(params.height):canvas.height;if(resize){canvas.width=snapshotWidth;canvas.height=snapshotHeight;}if(!this._snapshotBegun){this.beginSnapshot();}if(!params.includeGizmos){this.sendToPlugins("snapshotStarting");// Tells plugins to hide things that shouldn't be in snapshot
}this.scene._renderer.renderSnapshot();snapshotCanvas=this.scene._renderer.readSnapshotAsCanvas();if(resize){canvas.width=saveWidth;canvas.height=saveHeight;this.scene.glRedraw();}pluginToCapture={};pluginContainerElements=[];for(_i490=0,len=this._plugins.length;_i490<len;_i490++){// Find plugin container elements
plugin=this._plugins[_i490];if(plugin.getContainerElement){containerElement=plugin.getContainerElement();if(containerElement!==document.body){if(!pluginToCapture[containerElement.id]){pluginToCapture[containerElement.id]=true;pluginContainerElements.push(containerElement);}}}}_i491=0,_len100=pluginContainerElements.length;case 18:if(!(_i491<_len100)){_context2.next=25;break;}_containerElement=pluginContainerElements[_i491];_context2.next=22;return html2canvas(_containerElement,{canvas:snapshotCanvas,backgroundColor:null,scale:snapshotCanvas.width/_containerElement.clientWidth});case 22:_i491++;_context2.next=18;break;case 25:if(!params.includeGizmos){this.sendToPlugins("snapshotFinished");}if(needFinishSnapshot){this.endSnapshot();}format=params.format||"png";if(format!=="jpeg"&&format!=="png"&&format!=="bmp"){console.error("Unsupported image format: '"+format+"' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'png'");format="png";}if(!params.includeGizmos){this.sendToPlugins("snapshotFinished");}if(needFinishSnapshot){this.endSnapshot();}return _context2.abrupt("return",snapshotCanvas.toDataURL("image/".concat(format)));case 32:case"end":return _context2.stop();}}},_callee,this);}));function getSnapshotWithPlugins(){return _getSnapshotWithPlugins.apply(this,arguments);}return getSnapshotWithPlugins;}()/**
     * Exits snapshot mode.
     *
     * Switches rendering back to the main canvas.
     *
     */},{key:"endSnapshot",value:function endSnapshot(){if(!this._snapshotBegun){return;}this.scene._renderer.endSnapshot();this.scene._renderer.render({force:true});this._snapshotBegun=false;}/** Destroys this Viewer.
     */},{key:"destroy",value:function destroy(){var plugins=this._plugins.slice();// Array will modify as we delete plugins
for(var _i492=0,len=plugins.length;_i492<len;_i492++){var plugin=plugins[_i492];plugin.destroy();}this.scene.destroy();}}]);return Viewer;}();function assert$5(condition,message){if(!condition){throw new Error(message||'loader assertion failed.');}}var isBrowser$4=Boolean((typeof process==="undefined"?"undefined":_typeof(process))!=='object'||String(process)!=='[object process]'||process.browser);var matches$1=typeof process!=='undefined'&&process.version&&/v([0-9]*)/.exec(process.version);matches$1&&parseFloat(matches$1[1])||0;var VERSION$9="3.2.6";function assert$4(condition,message){if(!condition){throw new Error(message||'loaders.gl assertion failed.');}}var globals$2={self:typeof self!=='undefined'&&self,window:typeof window!=='undefined'&&window,global:typeof global!=='undefined'&&global,document:typeof document!=='undefined'&&document};var global_=globals$2.global||globals$2.self||globals$2.window||{};var isBrowser$3=(typeof process==="undefined"?"undefined":_typeof(process))!=='object'||String(process)!=='[object process]'||process.browser;var isWorker=typeof importScripts==='function';var isMobile=typeof window!=='undefined'&&typeof window.orientation!=='undefined';var matches=typeof process!=='undefined'&&process.version&&/v([0-9]*)/.exec(process.version);matches&&parseFloat(matches[1])||0;function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var WorkerJob=/*#__PURE__*/function(){function WorkerJob(jobName,workerThread){var _this106=this;_classCallCheck(this,WorkerJob);_defineProperty(this,"name",void 0);_defineProperty(this,"workerThread",void 0);_defineProperty(this,"isRunning",true);_defineProperty(this,"result",void 0);_defineProperty(this,"_resolve",function(){});_defineProperty(this,"_reject",function(){});this.name=jobName;this.workerThread=workerThread;this.result=new Promise(function(resolve,reject){_this106._resolve=resolve;_this106._reject=reject;});}_createClass(WorkerJob,[{key:"postMessage",value:function postMessage(type,payload){this.workerThread.postMessage({source:'loaders.gl',type:type,payload:payload});}},{key:"done",value:function done(value){assert$4(this.isRunning);this.isRunning=false;this._resolve(value);}},{key:"error",value:function error(_error){assert$4(this.isRunning);this.isRunning=false;this._reject(_error);}}]);return WorkerJob;}();var Worker$1=/*#__PURE__*/_createClass(function Worker$1(){_classCallCheck(this,Worker$1);});var workerURLCache=new Map();function getLoadableWorkerURL(props){assert$4(props.source&&!props.url||!props.source&&props.url);var workerURL=workerURLCache.get(props.source||props.url);if(!workerURL){if(props.url){workerURL=getLoadableWorkerURLFromURL(props.url);workerURLCache.set(props.url,workerURL);}if(props.source){workerURL=getLoadableWorkerURLFromSource(props.source);workerURLCache.set(props.source,workerURL);}}assert$4(workerURL);return workerURL;}function getLoadableWorkerURLFromURL(url){if(!url.startsWith('http')){return url;}var workerSource=buildScriptSource(url);return getLoadableWorkerURLFromSource(workerSource);}function getLoadableWorkerURLFromSource(workerSource){var blob=new Blob([workerSource],{type:'application/javascript'});return URL.createObjectURL(blob);}function buildScriptSource(workerUrl){return"try {\n  importScripts('".concat(workerUrl,"');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");}function getTransferList(object){var recursive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var transfers=arguments.length>2?arguments[2]:undefined;var transfersSet=transfers||new Set();if(!object);else if(isTransferable(object)){transfersSet.add(object);}else if(isTransferable(object.buffer)){transfersSet.add(object.buffer);}else if(ArrayBuffer.isView(object));else if(recursive&&_typeof(object)==='object'){for(var key in object){getTransferList(object[key],recursive,transfersSet);}}return transfers===undefined?Array.from(transfersSet):[];}function isTransferable(object){if(!object){return false;}if(object instanceof ArrayBuffer){return true;}if(typeof MessagePort!=='undefined'&&object instanceof MessagePort){return true;}if(typeof ImageBitmap!=='undefined'&&object instanceof ImageBitmap){return true;}if(typeof OffscreenCanvas!=='undefined'&&object instanceof OffscreenCanvas){return true;}return false;}var NOOP=function NOOP(){};var WorkerThread=/*#__PURE__*/function(){function WorkerThread(props){_classCallCheck(this,WorkerThread);_defineProperty(this,"name",void 0);_defineProperty(this,"source",void 0);_defineProperty(this,"url",void 0);_defineProperty(this,"terminated",false);_defineProperty(this,"worker",void 0);_defineProperty(this,"onMessage",void 0);_defineProperty(this,"onError",void 0);_defineProperty(this,"_loadableURL",'');var name=props.name,source=props.source,url=props.url;assert$4(source||url);this.name=name;this.source=source;this.url=url;this.onMessage=NOOP;this.onError=function(error){return console.log(error);};this.worker=isBrowser$3?this._createBrowserWorker():this._createNodeWorker();}_createClass(WorkerThread,[{key:"destroy",value:function destroy(){this.onMessage=NOOP;this.onError=NOOP;this.worker.terminate();this.terminated=true;}},{key:"isRunning",get:function get(){return Boolean(this.onMessage);}},{key:"postMessage",value:function postMessage(data,transferList){transferList=transferList||getTransferList(data);this.worker.postMessage(data,transferList);}},{key:"_getErrorFromErrorEvent",value:function _getErrorFromErrorEvent(event){var message='Failed to load ';message+="worker ".concat(this.name," from ").concat(this.url,". ");if(event.message){message+="".concat(event.message," in ");}if(event.lineno){message+=":".concat(event.lineno,":").concat(event.colno);}return new Error(message);}},{key:"_createBrowserWorker",value:function _createBrowserWorker(){var _this107=this;this._loadableURL=getLoadableWorkerURL({source:this.source,url:this.url});var worker=new Worker(this._loadableURL,{name:this.name});worker.onmessage=function(event){if(!event.data){_this107.onError(new Error('No data received'));}else{_this107.onMessage(event.data);}};worker.onerror=function(error){_this107.onError(_this107._getErrorFromErrorEvent(error));_this107.terminated=true;};worker.onmessageerror=function(event){return console.error(event);};return worker;}},{key:"_createNodeWorker",value:function _createNodeWorker(){var _this108=this;var worker;if(this.url){var absolute=this.url.includes(':/')||this.url.startsWith('/');var url=absolute?this.url:"./".concat(this.url);worker=new Worker$1(url,{eval:false});}else if(this.source){worker=new Worker$1(this.source,{eval:true});}else{throw new Error('no worker');}worker.on('message',function(data){_this108.onMessage(data);});worker.on('error',function(error){_this108.onError(error);});worker.on('exit',function(code){});return worker;}}],[{key:"isSupported",value:function isSupported(){return typeof Worker!=='undefined'&&isBrowser$3||_typeof(Worker$1)!==undefined;}}]);return WorkerThread;}();var WorkerPool=/*#__PURE__*/function(){function WorkerPool(props){_classCallCheck(this,WorkerPool);_defineProperty(this,"name",'unnamed');_defineProperty(this,"source",void 0);_defineProperty(this,"url",void 0);_defineProperty(this,"maxConcurrency",1);_defineProperty(this,"maxMobileConcurrency",1);_defineProperty(this,"onDebug",function(){});_defineProperty(this,"reuseWorkers",true);_defineProperty(this,"props",{});_defineProperty(this,"jobQueue",[]);_defineProperty(this,"idleQueue",[]);_defineProperty(this,"count",0);_defineProperty(this,"isDestroyed",false);this.source=props.source;this.url=props.url;this.setProps(props);}_createClass(WorkerPool,[{key:"destroy",value:function destroy(){this.idleQueue.forEach(function(worker){return worker.destroy();});this.isDestroyed=true;}},{key:"setProps",value:function setProps(props){this.props=_objectSpread(_objectSpread({},this.props),props);if(props.name!==undefined){this.name=props.name;}if(props.maxConcurrency!==undefined){this.maxConcurrency=props.maxConcurrency;}if(props.maxMobileConcurrency!==undefined){this.maxMobileConcurrency=props.maxMobileConcurrency;}if(props.reuseWorkers!==undefined){this.reuseWorkers=props.reuseWorkers;}if(props.onDebug!==undefined){this.onDebug=props.onDebug;}}},{key:"startJob",value:function(){var _startJob=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name){var _this109=this;var onMessage,onError,startPromise,_args2=arguments;return _regeneratorRuntime().wrap(function _callee2$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:onMessage=_args2.length>1&&_args2[1]!==undefined?_args2[1]:function(job,type,data){return job.done(data);};onError=_args2.length>2&&_args2[2]!==undefined?_args2[2]:function(job,error){return job.error(error);};startPromise=new Promise(function(onStart){_this109.jobQueue.push({name:name,onMessage:onMessage,onError:onError,onStart:onStart});return _this109;});this._startQueuedJob();_context3.next=6;return startPromise;case 6:return _context3.abrupt("return",_context3.sent);case 7:case"end":return _context3.stop();}}},_callee2,this);}));function startJob(_x7){return _startJob.apply(this,arguments);}return startJob;}()},{key:"_startQueuedJob",value:function(){var _startQueuedJob2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(){var workerThread,queuedJob,job;return _regeneratorRuntime().wrap(function _callee3$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(this.jobQueue.length){_context4.next=2;break;}return _context4.abrupt("return");case 2:workerThread=this._getAvailableWorker();if(workerThread){_context4.next=5;break;}return _context4.abrupt("return");case 5:queuedJob=this.jobQueue.shift();if(!queuedJob){_context4.next=18;break;}this.onDebug({message:'Starting job',name:queuedJob.name,workerThread:workerThread,backlog:this.jobQueue.length});job=new WorkerJob(queuedJob.name,workerThread);workerThread.onMessage=function(data){return queuedJob.onMessage(job,data.type,data.payload);};workerThread.onError=function(error){return queuedJob.onError(job,error);};queuedJob.onStart(job);_context4.prev=12;_context4.next=15;return job.result;case 15:_context4.prev=15;this.returnWorkerToQueue(workerThread);return _context4.finish(15);case 18:case"end":return _context4.stop();}}},_callee3,this,[[12,,15,18]]);}));function _startQueuedJob(){return _startQueuedJob2.apply(this,arguments);}return _startQueuedJob;}()},{key:"returnWorkerToQueue",value:function returnWorkerToQueue(worker){var shouldDestroyWorker=this.isDestroyed||!this.reuseWorkers||this.count>this._getMaxConcurrency();if(shouldDestroyWorker){worker.destroy();this.count--;}else{this.idleQueue.push(worker);}if(!this.isDestroyed){this._startQueuedJob();}}},{key:"_getAvailableWorker",value:function _getAvailableWorker(){if(this.idleQueue.length>0){return this.idleQueue.shift()||null;}if(this.count<this._getMaxConcurrency()){this.count++;var _name5="".concat(this.name.toLowerCase()," (#").concat(this.count," of ").concat(this.maxConcurrency,")");return new WorkerThread({name:_name5,source:this.source,url:this.url});}return null;}},{key:"_getMaxConcurrency",value:function _getMaxConcurrency(){return isMobile?this.maxMobileConcurrency:this.maxConcurrency;}}],[{key:"isSupported",value:function isSupported(){return WorkerThread.isSupported();}}]);return WorkerPool;}();var DEFAULT_PROPS={maxConcurrency:3,maxMobileConcurrency:1,reuseWorkers:true,onDebug:function onDebug(){}};var WorkerFarm=/*#__PURE__*/function(){function WorkerFarm(props){_classCallCheck(this,WorkerFarm);_defineProperty(this,"props",void 0);_defineProperty(this,"workerPools",new Map());this.props=_objectSpread({},DEFAULT_PROPS);this.setProps(props);this.workerPools=new Map();}_createClass(WorkerFarm,[{key:"destroy",value:function destroy(){var _iterator4=_createForOfIteratorHelper(this.workerPools.values()),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var workerPool=_step4.value;workerPool.destroy();}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}this.workerPools=new Map();}},{key:"setProps",value:function setProps(props){this.props=_objectSpread(_objectSpread({},this.props),props);var _iterator5=_createForOfIteratorHelper(this.workerPools.values()),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var workerPool=_step5.value;workerPool.setProps(this._getWorkerPoolProps());}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}},{key:"getWorkerPool",value:function getWorkerPool(options){var name=options.name,source=options.source,url=options.url;var workerPool=this.workerPools.get(name);if(!workerPool){workerPool=new WorkerPool({name:name,source:source,url:url});workerPool.setProps(this._getWorkerPoolProps());this.workerPools.set(name,workerPool);}return workerPool;}},{key:"_getWorkerPoolProps",value:function _getWorkerPoolProps(){return{maxConcurrency:this.props.maxConcurrency,maxMobileConcurrency:this.props.maxMobileConcurrency,reuseWorkers:this.props.reuseWorkers,onDebug:this.props.onDebug};}}],[{key:"isSupported",value:function isSupported(){return WorkerThread.isSupported();}},{key:"getWorkerFarm",value:function getWorkerFarm(){var props=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};WorkerFarm._workerFarm=WorkerFarm._workerFarm||new WorkerFarm({});WorkerFarm._workerFarm.setProps(props);return WorkerFarm._workerFarm;}}]);return WorkerFarm;}();_defineProperty(WorkerFarm,"_workerFarm",void 0);var NPM_TAG='latest';function getWorkerURL(worker){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var workerOptions=options[worker.id]||{};var workerFile="".concat(worker.id,"-worker.js");var url=workerOptions.workerUrl;if(!url&&worker.id==='compression'){url=options.workerUrl;}if(options._workerType==='test'){url="modules/".concat(worker.module,"/dist/").concat(workerFile);}if(!url){var version=worker.version;if(version==='latest'){version=NPM_TAG;}var versionTag=version?"@".concat(version):'';url="https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag,"/dist/").concat(workerFile);}assert$4(url);return url;}function validateWorkerVersion(worker){var coreVersion=arguments.length>1&&arguments[1]!==undefined?arguments[1]:VERSION$9;assert$4(worker,'no worker provided');var workerVersion=worker.version;if(!coreVersion||!workerVersion){return false;}return true;}var ChildProcessProxy={};var node=/*#__PURE__*/Object.freeze({__proto__:null,'default':ChildProcessProxy});var VERSION$8="3.2.6";var loadLibraryPromises={};function loadLibrary(_x8){return _loadLibrary.apply(this,arguments);}function _loadLibrary(){_loadLibrary=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(libraryUrl){var moduleName,options,_args4=arguments;return _regeneratorRuntime().wrap(function _callee7$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:moduleName=_args4.length>1&&_args4[1]!==undefined?_args4[1]:null;options=_args4.length>2&&_args4[2]!==undefined?_args4[2]:{};if(moduleName){libraryUrl=getLibraryUrl(libraryUrl,moduleName,options);}loadLibraryPromises[libraryUrl]=loadLibraryPromises[libraryUrl]||loadLibraryFromFile(libraryUrl);_context11.next=6;return loadLibraryPromises[libraryUrl];case 6:return _context11.abrupt("return",_context11.sent);case 7:case"end":return _context11.stop();}}},_callee7);}));return _loadLibrary.apply(this,arguments);}function getLibraryUrl(library,moduleName,options){if(library.startsWith('http')){return library;}var modules=options.modules||{};if(modules[library]){return modules[library];}if(!isBrowser$3){return"modules/".concat(moduleName,"/dist/libs/").concat(library);}if(options.CDN){assert$4(options.CDN.startsWith('http'));return"".concat(options.CDN,"/").concat(moduleName,"@").concat(VERSION$8,"/dist/libs/").concat(library);}if(isWorker){return"../src/libs/".concat(library);}return"modules/".concat(moduleName,"/src/libs/").concat(library);}function loadLibraryFromFile(_x9){return _loadLibraryFromFile.apply(this,arguments);}function _loadLibraryFromFile(){_loadLibraryFromFile=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(libraryUrl){var _response,response,scriptSource;return _regeneratorRuntime().wrap(function _callee8$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:if(!libraryUrl.endsWith('wasm')){_context12.next=7;break;}_context12.next=3;return fetch(libraryUrl);case 3:_response=_context12.sent;_context12.next=6;return _response.arrayBuffer();case 6:return _context12.abrupt("return",_context12.sent);case 7:if(isBrowser$3){_context12.next=20;break;}_context12.prev=8;_context12.t0=node&&undefined;if(!_context12.t0){_context12.next=14;break;}_context12.next=13;return undefined(libraryUrl);case 13:_context12.t0=_context12.sent;case 14:return _context12.abrupt("return",_context12.t0);case 17:_context12.prev=17;_context12.t1=_context12["catch"](8);return _context12.abrupt("return",null);case 20:if(!isWorker){_context12.next=22;break;}return _context12.abrupt("return",importScripts(libraryUrl));case 22:_context12.next=24;return fetch(libraryUrl);case 24:response=_context12.sent;_context12.next=27;return response.text();case 27:scriptSource=_context12.sent;return _context12.abrupt("return",loadLibraryFromString(scriptSource,libraryUrl));case 29:case"end":return _context12.stop();}}},_callee8,null,[[8,17]]);}));return _loadLibraryFromFile.apply(this,arguments);}function loadLibraryFromString(scriptSource,id){if(!isBrowser$3){return undefined&&undefined(scriptSource,id);}if(isWorker){eval.call(global_,scriptSource);return null;}var script=document.createElement('script');script.id=id;try{script.appendChild(document.createTextNode(scriptSource));}catch(e){script.text=scriptSource;}document.body.appendChild(script);return null;}function canParseWithWorker(loader,options){if(!WorkerFarm.isSupported()){return false;}if(!isBrowser$3&&!(options!==null&&options!==void 0&&options._nodeWorkers)){return false;}return loader.worker&&(options===null||options===void 0?void 0:options.worker);}function parseWithWorker(_x10,_x11,_x12,_x13,_x14){return _parseWithWorker.apply(this,arguments);}function _parseWithWorker(){_parseWithWorker=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(loader,data,options,context,parseOnMainThread){var name,url,workerFarm,workerPool,job,result;return _regeneratorRuntime().wrap(function _callee9$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:name=loader.id;url=getWorkerURL(loader,options);workerFarm=WorkerFarm.getWorkerFarm(options);workerPool=workerFarm.getWorkerPool({name:name,url:url});options=JSON.parse(JSON.stringify(options));context=JSON.parse(JSON.stringify(context||{}));_context13.next=8;return workerPool.startJob('process-on-worker',onMessage.bind(null,parseOnMainThread));case 8:job=_context13.sent;job.postMessage('process',{input:data,options:options,context:context});_context13.next=12;return job.result;case 12:result=_context13.sent;_context13.next=15;return result.result;case 15:return _context13.abrupt("return",_context13.sent);case 16:case"end":return _context13.stop();}}},_callee9);}));return _parseWithWorker.apply(this,arguments);}function onMessage(_x15,_x16,_x17,_x18){return _onMessage2.apply(this,arguments);}function _onMessage2(){_onMessage2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(parseOnMainThread,job,type,payload){var id,input,options,result,message;return _regeneratorRuntime().wrap(function _callee10$(_context14){while(1){switch(_context14.prev=_context14.next){case 0:_context14.t0=type;_context14.next=_context14.t0==='done'?3:_context14.t0==='error'?5:_context14.t0==='process'?7:20;break;case 3:job.done(payload);return _context14.abrupt("break",21);case 5:job.error(new Error(payload.error));return _context14.abrupt("break",21);case 7:id=payload.id,input=payload.input,options=payload.options;_context14.prev=8;_context14.next=11;return parseOnMainThread(input,options);case 11:result=_context14.sent;job.postMessage('done',{id:id,result:result});_context14.next=19;break;case 15:_context14.prev=15;_context14.t1=_context14["catch"](8);message=_context14.t1 instanceof Error?_context14.t1.message:'unknown error';job.postMessage('error',{id:id,error:message});case 19:return _context14.abrupt("break",21);case 20:console.warn("parse-with-worker unknown message ".concat(type));case 21:case"end":return _context14.stop();}}},_callee10,null,[[8,15]]);}));return _onMessage2.apply(this,arguments);}function getFirstCharacters$1(data){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:5;if(typeof data==='string'){return data.slice(0,length);}else if(ArrayBuffer.isView(data)){return getMagicString$2(data.buffer,data.byteOffset,length);}else if(data instanceof ArrayBuffer){var byteOffset=0;return getMagicString$2(data,byteOffset,length);}return'';}function getMagicString$2(arrayBuffer,byteOffset,length){if(arrayBuffer.byteLength<=byteOffset+length){return'';}var dataView=new DataView(arrayBuffer);var magic='';for(var _i493=0;_i493<length;_i493++){magic+=String.fromCharCode(dataView.getUint8(byteOffset+_i493));}return magic;}function parseJSON(string){try{return JSON.parse(string);}catch(_){throw new Error("Failed to parse JSON from data starting with \"".concat(getFirstCharacters$1(string),"\""));}}function isBuffer$1(value){return value&&_typeof(value)==='object'&&value.isBuffer;}function bufferToArrayBuffer(buffer){if(isBuffer$1(buffer)){var typedArray=new Uint8Array(buffer.buffer,buffer.byteOffset,buffer.length);return typedArray.slice().buffer;}return buffer;}function toArrayBuffer(data){if(isBuffer$1(data)){return bufferToArrayBuffer(data);}if(data instanceof ArrayBuffer){return data;}if(ArrayBuffer.isView(data)){if(data.byteOffset===0&&data.byteLength===data.buffer.byteLength){return data.buffer;}return data.buffer.slice(data.byteOffset,data.byteOffset+data.byteLength);}if(typeof data==='string'){var text=data;var uint8Array=new TextEncoder().encode(text);return uint8Array.buffer;}if(data&&_typeof(data)==='object'&&data._toArrayBuffer){return data._toArrayBuffer();}throw new Error('toArrayBuffer');}function compareArrayBuffers(arrayBuffer1,arrayBuffer2,byteLength){byteLength=byteLength||arrayBuffer1.byteLength;if(arrayBuffer1.byteLength<byteLength||arrayBuffer2.byteLength<byteLength){return false;}var array1=new Uint8Array(arrayBuffer1);var array2=new Uint8Array(arrayBuffer2);for(var _i494=0;_i494<array1.length;++_i494){if(array1[_i494]!==array2[_i494]){return false;}}return true;}function concatenateArrayBuffers(){for(var _len101=arguments.length,sources=new Array(_len101),_key6=0;_key6<_len101;_key6++){sources[_key6]=arguments[_key6];}var sourceArrays=sources.map(function(source2){return source2 instanceof ArrayBuffer?new Uint8Array(source2):source2;});var byteLength=sourceArrays.reduce(function(length,typedArray){return length+typedArray.byteLength;},0);var result=new Uint8Array(byteLength);var offset=0;var _iterator6=_createForOfIteratorHelper(sourceArrays),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var sourceArray=_step6.value;result.set(sourceArray,offset);offset+=sourceArray.byteLength;}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return result.buffer;}function sliceArrayBuffer(arrayBuffer,byteOffset,byteLength){var subArray=byteLength!==undefined?new Uint8Array(arrayBuffer).subarray(byteOffset,byteOffset+byteLength):new Uint8Array(arrayBuffer).subarray(byteOffset);var arrayCopy=new Uint8Array(subArray);return arrayCopy.buffer;}function padToNBytes(byteLength,padding){assert$5(byteLength>=0);assert$5(padding>0);return byteLength+(padding-1)&~(padding-1);}function copyToArray(source,target,targetOffset){var sourceArray;if(source instanceof ArrayBuffer){sourceArray=new Uint8Array(source);}else{var srcByteOffset=source.byteOffset;var srcByteLength=source.byteLength;sourceArray=new Uint8Array(source.buffer||source.arrayBuffer,srcByteOffset,srcByteLength);}target.set(sourceArray,targetOffset);return targetOffset+padToNBytes(sourceArray.byteLength,4);}function concatenateArrayBuffersAsync(_x19){return _concatenateArrayBuffersAsync.apply(this,arguments);}function _concatenateArrayBuffersAsync(){_concatenateArrayBuffersAsync=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(asyncIterator){var arrayBuffers,_iteratorAbruptCompletion,_didIteratorError,_iteratorError,_iterator,_step,chunk;return _regeneratorRuntime().wrap(function _callee11$(_context15){while(1){switch(_context15.prev=_context15.next){case 0:arrayBuffers=[];_iteratorAbruptCompletion=false;_didIteratorError=false;_context15.prev=3;_iterator=_asyncIterator(asyncIterator);case 5:_context15.next=7;return _iterator.next();case 7:if(!(_iteratorAbruptCompletion=!(_step=_context15.sent).done)){_context15.next=13;break;}chunk=_step.value;arrayBuffers.push(chunk);case 10:_iteratorAbruptCompletion=false;_context15.next=5;break;case 13:_context15.next=19;break;case 15:_context15.prev=15;_context15.t0=_context15["catch"](3);_didIteratorError=true;_iteratorError=_context15.t0;case 19:_context15.prev=19;_context15.prev=20;if(!(_iteratorAbruptCompletion&&_iterator["return"]!=null)){_context15.next=24;break;}_context15.next=24;return _iterator["return"]();case 24:_context15.prev=24;if(!_didIteratorError){_context15.next=27;break;}throw _iteratorError;case 27:return _context15.finish(24);case 28:return _context15.finish(19);case 29:return _context15.abrupt("return",concatenateArrayBuffers.apply(void 0,arrayBuffers));case 30:case"end":return _context15.stop();}}},_callee11,null,[[3,15,19,29],[20,,24,28]]);}));return _concatenateArrayBuffersAsync.apply(this,arguments);}var pathPrefix='';var fileAliases={};function resolvePath(filename){for(var alias in fileAliases){if(filename.startsWith(alias)){var replacement=fileAliases[alias];filename=filename.replace(alias,replacement);}}if(!filename.startsWith('http://')&&!filename.startsWith('https://')){filename="".concat(pathPrefix).concat(filename);}return filename;}function filename(url){var slashIndex=url&&url.lastIndexOf('/');return slashIndex>=0?url.substr(slashIndex+1):'';}var isBoolean=function isBoolean(x){return typeof x==='boolean';};var isFunction=function isFunction(x){return typeof x==='function';};var isObject=function isObject(x){return x!==null&&_typeof(x)==='object';};var isPureObject=function isPureObject(x){return isObject(x)&&x.constructor==={}.constructor;};var isIterable=function isIterable(x){return x&&typeof x[Symbol.iterator]==='function';};var isAsyncIterable=function isAsyncIterable(x){return x&&typeof x[Symbol.asyncIterator]==='function';};var isResponse=function isResponse(x){return typeof Response!=='undefined'&&x instanceof Response||x&&x.arrayBuffer&&x.text&&x.json;};var isBlob=function isBlob(x){return typeof Blob!=='undefined'&&x instanceof Blob;};var isBuffer=function isBuffer(x){return x&&_typeof(x)==='object'&&x.isBuffer;};var isReadableDOMStream=function isReadableDOMStream(x){return typeof ReadableStream!=='undefined'&&x instanceof ReadableStream||isObject(x)&&isFunction(x.tee)&&isFunction(x.cancel)&&isFunction(x.getReader);};var isReadableNodeStream=function isReadableNodeStream(x){return isObject(x)&&isFunction(x.read)&&isFunction(x.pipe)&&isBoolean(x.readable);};var isReadableStream=function isReadableStream(x){return isReadableDOMStream(x)||isReadableNodeStream(x);};var DATA_URL_PATTERN=/^data:([-\w.]+\/[-\w.+]+)(;|,)/;var MIME_TYPE_PATTERN=/^([-\w.]+\/[-\w.+]+)/;function parseMIMEType(mimeString){var matches=MIME_TYPE_PATTERN.exec(mimeString);if(matches){return matches[1];}return mimeString;}function parseMIMETypeFromURL(url){var matches=DATA_URL_PATTERN.exec(url);if(matches){return matches[1];}return'';}var QUERY_STRING_PATTERN=/\?.*/;function getResourceUrlAndType(resource){if(isResponse(resource)){var url=stripQueryString(resource.url||'');var contentTypeHeader=resource.headers.get('content-type')||'';return{url:url,type:parseMIMEType(contentTypeHeader)||parseMIMETypeFromURL(url)};}if(isBlob(resource)){return{url:stripQueryString(resource.name||''),type:resource.type||''};}if(typeof resource==='string'){return{url:stripQueryString(resource),type:parseMIMETypeFromURL(resource)};}return{url:'',type:''};}function getResourceContentLength(resource){if(isResponse(resource)){return resource.headers['content-length']||-1;}if(isBlob(resource)){return resource.size;}if(typeof resource==='string'){return resource.length;}if(resource instanceof ArrayBuffer){return resource.byteLength;}if(ArrayBuffer.isView(resource)){return resource.byteLength;}return-1;}function stripQueryString(url){return url.replace(QUERY_STRING_PATTERN,'');}function makeResponse(_x20){return _makeResponse.apply(this,arguments);}function _makeResponse(){_makeResponse=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(resource){var headers,contentLength,_getResourceUrlAndTyp3,url,type,initialDataUrl,response;return _regeneratorRuntime().wrap(function _callee12$(_context16){while(1){switch(_context16.prev=_context16.next){case 0:if(!isResponse(resource)){_context16.next=2;break;}return _context16.abrupt("return",resource);case 2:headers={};contentLength=getResourceContentLength(resource);if(contentLength>=0){headers['content-length']=String(contentLength);}_getResourceUrlAndTyp3=getResourceUrlAndType(resource),url=_getResourceUrlAndTyp3.url,type=_getResourceUrlAndTyp3.type;if(type){headers['content-type']=type;}_context16.next=9;return getInitialDataUrl(resource);case 9:initialDataUrl=_context16.sent;if(initialDataUrl){headers['x-first-bytes']=initialDataUrl;}if(typeof resource==='string'){resource=new TextEncoder().encode(resource);}response=new Response(resource,{headers:headers});Object.defineProperty(response,'url',{value:url});return _context16.abrupt("return",response);case 15:case"end":return _context16.stop();}}},_callee12);}));return _makeResponse.apply(this,arguments);}function checkResponse(_x21){return _checkResponse.apply(this,arguments);}function _checkResponse(){_checkResponse=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(response){var message;return _regeneratorRuntime().wrap(function _callee13$(_context17){while(1){switch(_context17.prev=_context17.next){case 0:if(response.ok){_context17.next=5;break;}_context17.next=3;return getResponseError(response);case 3:message=_context17.sent;throw new Error(message);case 5:case"end":return _context17.stop();}}},_callee13);}));return _checkResponse.apply(this,arguments);}function getResponseError(_x22){return _getResponseError.apply(this,arguments);}function _getResponseError(){_getResponseError=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(response){var message,contentType,text;return _regeneratorRuntime().wrap(function _callee14$(_context18){while(1){switch(_context18.prev=_context18.next){case 0:message="Failed to fetch resource ".concat(response.url," (").concat(response.status,"): ");_context18.prev=1;contentType=response.headers.get('Content-Type');text=response.statusText;if(!contentType.includes('application/json')){_context18.next=11;break;}_context18.t0=text;_context18.t1=" ";_context18.next=9;return response.text();case 9:_context18.t2=_context18.sent;text=_context18.t0+=_context18.t1.concat.call(_context18.t1,_context18.t2);case 11:message+=text;message=message.length>60?"".concat(message.slice(0,60),"..."):message;_context18.next=17;break;case 15:_context18.prev=15;_context18.t3=_context18["catch"](1);case 17:return _context18.abrupt("return",message);case 18:case"end":return _context18.stop();}}},_callee14,null,[[1,15]]);}));return _getResponseError.apply(this,arguments);}function getInitialDataUrl(_x23){return _getInitialDataUrl.apply(this,arguments);}function _getInitialDataUrl(){_getInitialDataUrl=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(resource){var INITIAL_DATA_LENGTH,blobSlice,slice,_base;return _regeneratorRuntime().wrap(function _callee15$(_context19){while(1){switch(_context19.prev=_context19.next){case 0:INITIAL_DATA_LENGTH=5;if(!(typeof resource==='string')){_context19.next=3;break;}return _context19.abrupt("return","data:,".concat(resource.slice(0,INITIAL_DATA_LENGTH)));case 3:if(!(resource instanceof Blob)){_context19.next=8;break;}blobSlice=resource.slice(0,5);_context19.next=7;return new Promise(function(resolve){var reader=new FileReader();reader.onload=function(event){var _event$target;return resolve(event===null||event===void 0?void 0:(_event$target=event.target)===null||_event$target===void 0?void 0:_event$target.result);};reader.readAsDataURL(blobSlice);});case 7:return _context19.abrupt("return",_context19.sent);case 8:if(!(resource instanceof ArrayBuffer)){_context19.next=12;break;}slice=resource.slice(0,INITIAL_DATA_LENGTH);_base=arrayBufferToBase64(slice);return _context19.abrupt("return","data:base64,".concat(_base));case 12:return _context19.abrupt("return",null);case 13:case"end":return _context19.stop();}}},_callee15);}));return _getInitialDataUrl.apply(this,arguments);}function arrayBufferToBase64(buffer){var binary='';var bytes=new Uint8Array(buffer);for(var _i495=0;_i495<bytes.byteLength;_i495++){binary+=String.fromCharCode(bytes[_i495]);}return btoa(binary);}function fetchFile(_x24,_x25){return _fetchFile.apply(this,arguments);}function _fetchFile(){_fetchFile=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(url,options){var fetchOptions;return _regeneratorRuntime().wrap(function _callee16$(_context20){while(1){switch(_context20.prev=_context20.next){case 0:if(!(typeof url==='string')){_context20.next=7;break;}url=resolvePath(url);fetchOptions=options;if(options!==null&&options!==void 0&&options.fetch&&typeof(options===null||options===void 0?void 0:options.fetch)!=='function'){fetchOptions=options.fetch;}_context20.next=6;return fetch(url,fetchOptions);case 6:return _context20.abrupt("return",_context20.sent);case 7:_context20.next=9;return makeResponse(url);case 9:return _context20.abrupt("return",_context20.sent);case 10:case"end":return _context20.stop();}}},_callee16);}));return _fetchFile.apply(this,arguments);}function isElectron$1(mockUserAgent){if(typeof window!=='undefined'&&_typeof(window.process)==='object'&&window.process.type==='renderer'){return true;}if(typeof process!=='undefined'&&_typeof(process.versions)==='object'&&Boolean(process.versions.electron)){return true;}var realUserAgent=(typeof navigator==="undefined"?"undefined":_typeof(navigator))==='object'&&typeof navigator.userAgent==='string'&&navigator.userAgent;var userAgent=mockUserAgent||realUserAgent;if(userAgent&&userAgent.indexOf('Electron')>=0){return true;}return false;}function isBrowser$2(){var isNode=(typeof process==="undefined"?"undefined":_typeof(process))==='object'&&String(process)==='[object process]'&&!process.browser;return!isNode||isElectron$1();}var globals$1={self:typeof self!=='undefined'&&self,window:typeof window!=='undefined'&&window,global:typeof global!=='undefined'&&global,document:typeof document!=='undefined'&&document,process:(typeof process==="undefined"?"undefined":_typeof(process))==='object'&&process};var window_$1=globals$1.window||globals$1.self||globals$1.global;var process_$1=globals$1.process||{};var VERSION$7=typeof __VERSION__!=='undefined'?__VERSION__:'untranspiled source';var isBrowser$1=isBrowser$2();function getStorage$1(type){try{var storage=window[type];var x='__storage_test__';storage.setItem(x,x);storage.removeItem(x);return storage;}catch(e){return null;}}var LocalStorage$1=/*#__PURE__*/function(){function LocalStorage$1(id,defaultSettings){var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'sessionStorage';_classCallCheck(this,LocalStorage$1);this.storage=getStorage$1(type);this.id=id;this.config={};Object.assign(this.config,defaultSettings);this._loadConfiguration();}_createClass(LocalStorage$1,[{key:"getConfiguration",value:function getConfiguration(){return this.config;}},{key:"setConfiguration",value:function setConfiguration(configuration){this.config={};return this.updateConfiguration(configuration);}},{key:"updateConfiguration",value:function updateConfiguration(configuration){Object.assign(this.config,configuration);if(this.storage){var serialized=JSON.stringify(this.config);this.storage.setItem(this.id,serialized);}return this;}},{key:"_loadConfiguration",value:function _loadConfiguration(){var configuration={};if(this.storage){var serializedConfiguration=this.storage.getItem(this.id);configuration=serializedConfiguration?JSON.parse(serializedConfiguration):{};}Object.assign(this.config,configuration);return this;}}]);return LocalStorage$1;}();function formatTime$1(ms){var formatted;if(ms<10){formatted="".concat(ms.toFixed(2),"ms");}else if(ms<100){formatted="".concat(ms.toFixed(1),"ms");}else if(ms<1000){formatted="".concat(ms.toFixed(0),"ms");}else{formatted="".concat((ms/1000).toFixed(2),"s");}return formatted;}function leftPad$1(string){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:8;var padLength=Math.max(length-string.length,0);return"".concat(' '.repeat(padLength)).concat(string);}function formatImage$1(image,message,scale){var maxWidth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:600;var imageUrl=image.src.replace(/\(/g,'%28').replace(/\)/g,'%29');if(image.width>maxWidth){scale=Math.min(scale,maxWidth/image.width);}var width=image.width*scale;var height=image.height*scale;var style=['font-size:1px;',"padding:".concat(Math.floor(height/2),"px ").concat(Math.floor(width/2),"px;"),"line-height:".concat(height,"px;"),"background:url(".concat(imageUrl,");"),"background-size:".concat(width,"px ").concat(height,"px;"),'color:transparent;'].join('');return["".concat(message," %c+"),style];}var COLOR$1={BLACK:30,RED:31,GREEN:32,YELLOW:33,BLUE:34,MAGENTA:35,CYAN:36,WHITE:37,BRIGHT_BLACK:90,BRIGHT_RED:91,BRIGHT_GREEN:92,BRIGHT_YELLOW:93,BRIGHT_BLUE:94,BRIGHT_MAGENTA:95,BRIGHT_CYAN:96,BRIGHT_WHITE:97};function getColor$1(color){return typeof color==='string'?COLOR$1[color.toUpperCase()]||COLOR$1.WHITE:color;}function addColor$1(string,color,background){if(!isBrowser$1&&typeof string==='string'){if(color){color=getColor$1(color);string="\x1B[".concat(color,"m").concat(string,"\x1B[39m");}if(background){color=getColor$1(background);string="\x1B[".concat(background+10,"m").concat(string,"\x1B[49m");}}return string;}function autobind$1(obj){var predefined=arguments.length>1&&arguments[1]!==undefined?arguments[1]:['constructor'];var proto=Object.getPrototypeOf(obj);var propNames=Object.getOwnPropertyNames(proto);var _iterator7=_createForOfIteratorHelper(propNames),_step7;try{var _loop4=function _loop4(){var key=_step7.value;if(typeof obj[key]==='function'){if(!predefined.find(function(name){return key===name;})){obj[key]=obj[key].bind(obj);}}};for(_iterator7.s();!(_step7=_iterator7.n()).done;){_loop4();}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}}function assert$3(condition,message){if(!condition){throw new Error(message||'Assertion failed');}}function getHiResTimestamp$1(){var timestamp;if(isBrowser$1&&window_$1.performance){timestamp=window_$1.performance.now();}else if(process_$1.hrtime){var timeParts=process_$1.hrtime();timestamp=timeParts[0]*1000+timeParts[1]/1e6;}else{timestamp=Date.now();}return timestamp;}var originalConsole$1={debug:isBrowser$1?console.debug||console.log:console.log,log:console.log,info:console.info,warn:console.warn,error:console.error};var DEFAULT_SETTINGS$1={enabled:true,level:0};function noop$1(){}var cache$1={};var ONCE$1={once:true};function getTableHeader$1(table){for(var key in table){for(var title in table[key]){return title||'untitled';}}return'empty';}var Log$1=/*#__PURE__*/function(){function Log$1(){var _ref16=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{id:''},id=_ref16.id;_classCallCheck(this,Log$1);this.id=id;this.VERSION=VERSION$7;this._startTs=getHiResTimestamp$1();this._deltaTs=getHiResTimestamp$1();this.LOG_THROTTLE_TIMEOUT=0;this._storage=new LocalStorage$1("__probe-".concat(this.id,"__"),DEFAULT_SETTINGS$1);this.userData={};this.timeStamp("".concat(this.id," started"));autobind$1(this);Object.seal(this);}_createClass(Log$1,[{key:"level",get:function get(){return this.getLevel();},set:function set(newLevel){this.setLevel(newLevel);}},{key:"isEnabled",value:function isEnabled(){return this._storage.config.enabled;}},{key:"getLevel",value:function getLevel(){return this._storage.config.level;}},{key:"getTotal",value:function getTotal(){return Number((getHiResTimestamp$1()-this._startTs).toPrecision(10));}},{key:"getDelta",value:function getDelta(){return Number((getHiResTimestamp$1()-this._deltaTs).toPrecision(10));}},{key:"priority",get:function get(){return this.level;},set:function set(newPriority){this.level=newPriority;}},{key:"getPriority",value:function getPriority(){return this.level;}},{key:"enable",value:function enable(){var enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this._storage.updateConfiguration({enabled:enabled});return this;}},{key:"setLevel",value:function setLevel(level){this._storage.updateConfiguration({level:level});return this;}},{key:"assert",value:function assert(condition,message){assert$3(condition,message);}},{key:"warn",value:function warn(message){return this._getLogFunction(0,message,originalConsole$1.warn,arguments,ONCE$1);}},{key:"error",value:function error(message){return this._getLogFunction(0,message,originalConsole$1.error,arguments);}},{key:"deprecated",value:function deprecated(oldUsage,newUsage){return this.warn("`".concat(oldUsage,"` is deprecated and will be removed in a later version. Use `").concat(newUsage,"` instead"));}},{key:"removed",value:function removed(oldUsage,newUsage){return this.error("`".concat(oldUsage,"` has been removed. Use `").concat(newUsage,"` instead"));}},{key:"probe",value:function probe(logLevel,message){return this._getLogFunction(logLevel,message,originalConsole$1.log,arguments,{time:true,once:true});}},{key:"log",value:function log(logLevel,message){return this._getLogFunction(logLevel,message,originalConsole$1.debug,arguments);}},{key:"info",value:function info(logLevel,message){return this._getLogFunction(logLevel,message,console.info,arguments);}},{key:"once",value:function once(logLevel,message){return this._getLogFunction(logLevel,message,originalConsole$1.debug||originalConsole$1.info,arguments,ONCE$1);}},{key:"table",value:function table(logLevel,_table,columns){if(_table){return this._getLogFunction(logLevel,_table,console.table||noop$1,columns&&[columns],{tag:getTableHeader$1(_table)});}return noop$1;}},{key:"image",value:function(_image6){function image(_x26){return _image6.apply(this,arguments);}image.toString=function(){return _image6.toString();};return image;}(function(_ref17){var logLevel=_ref17.logLevel,priority=_ref17.priority,image=_ref17.image,_ref17$message=_ref17.message,message=_ref17$message===void 0?'':_ref17$message,_ref17$scale=_ref17.scale,scale=_ref17$scale===void 0?1:_ref17$scale;if(!this._shouldLog(logLevel||priority)){return noop$1;}return isBrowser$1?logImageInBrowser$1({image:image,message:message,scale:scale}):logImageInNode$1({image:image,message:message,scale:scale});})},{key:"settings",value:function settings(){if(console.table){console.table(this._storage.config);}else{console.log(this._storage.config);}}},{key:"get",value:function get(setting){return this._storage.config[setting];}},{key:"set",value:function set(setting,value){this._storage.updateConfiguration(_defineProperty2({},setting,value));}},{key:"time",value:function time(logLevel,message){return this._getLogFunction(logLevel,message,console.time?console.time:console.info);}},{key:"timeEnd",value:function timeEnd(logLevel,message){return this._getLogFunction(logLevel,message,console.timeEnd?console.timeEnd:console.info);}},{key:"timeStamp",value:function timeStamp(logLevel,message){return this._getLogFunction(logLevel,message,console.timeStamp||noop$1);}},{key:"group",value:function group(logLevel,message){var opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{collapsed:false};opts=normalizeArguments$1({logLevel:logLevel,message:message,opts:opts});var _opts=opts,collapsed=_opts.collapsed;opts.method=(collapsed?console.groupCollapsed:console.group)||console.info;return this._getLogFunction(opts);}},{key:"groupCollapsed",value:function groupCollapsed(logLevel,message){var opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return this.group(logLevel,message,Object.assign({},opts,{collapsed:true}));}},{key:"groupEnd",value:function groupEnd(logLevel){return this._getLogFunction(logLevel,'',console.groupEnd||noop$1);}},{key:"withGroup",value:function withGroup(logLevel,message,func){this.group(logLevel,message)();try{func();}finally{this.groupEnd(logLevel)();}}},{key:"trace",value:function trace(){if(console.trace){console.trace();}}},{key:"_shouldLog",value:function _shouldLog(logLevel){return this.isEnabled()&&this.getLevel()>=normalizeLogLevel$1(logLevel);}},{key:"_getLogFunction",value:function _getLogFunction(logLevel,message,method){var args=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var opts=arguments.length>4?arguments[4]:undefined;if(this._shouldLog(logLevel)){var _method;opts=normalizeArguments$1({logLevel:logLevel,message:message,args:args,opts:opts});method=method||opts.method;assert$3(method);opts.total=this.getTotal();opts.delta=this.getDelta();this._deltaTs=getHiResTimestamp$1();var tag=opts.tag||opts.message;if(opts.once){if(!cache$1[tag]){cache$1[tag]=getHiResTimestamp$1();}else{return noop$1;}}message=decorateMessage$1(this.id,opts.message,opts);return(_method=method).bind.apply(_method,[console,message].concat(_toConsumableArray(opts.args)));}return noop$1;}}]);return Log$1;}();Log$1.VERSION=VERSION$7;function normalizeLogLevel$1(logLevel){if(!logLevel){return 0;}var resolvedLevel;switch(_typeof(logLevel)){case'number':resolvedLevel=logLevel;break;case'object':resolvedLevel=logLevel.logLevel||logLevel.priority||0;break;default:return 0;}assert$3(Number.isFinite(resolvedLevel)&&resolvedLevel>=0);return resolvedLevel;}function normalizeArguments$1(opts){var logLevel=opts.logLevel,message=opts.message;opts.logLevel=normalizeLogLevel$1(logLevel);var args=opts.args?Array.from(opts.args):[];while(args.length&&args.shift()!==message){}opts.args=args;switch(_typeof(logLevel)){case'string':case'function':if(message!==undefined){args.unshift(message);}opts.message=logLevel;break;case'object':Object.assign(opts,logLevel);break;}if(typeof opts.message==='function'){opts.message=opts.message();}var messageType=_typeof(opts.message);assert$3(messageType==='string'||messageType==='object');return Object.assign(opts,opts.opts);}function decorateMessage$1(id,message,opts){if(typeof message==='string'){var _time=opts.time?leftPad$1(formatTime$1(opts.total)):'';message=opts.time?"".concat(id,": ").concat(_time,"  ").concat(message):"".concat(id,": ").concat(message);message=addColor$1(message,opts.color,opts.background);}return message;}function logImageInNode$1(_ref18){var image=_ref18.image,_ref18$message=_ref18.message,message=_ref18$message===void 0?'':_ref18$message,_ref18$scale=_ref18.scale,scale=_ref18$scale===void 0?1:_ref18$scale;var asciify=null;try{asciify=module.require('asciify-image');}catch(error){}if(asciify){return function(){return asciify(image,{fit:'box',width:"".concat(Math.round(80*scale),"%")}).then(function(data){return console.log(data);});};}return noop$1;}function logImageInBrowser$1(_ref19){var image=_ref19.image,_ref19$message=_ref19.message,message=_ref19$message===void 0?'':_ref19$message,_ref19$scale=_ref19.scale,scale=_ref19$scale===void 0?1:_ref19$scale;if(typeof image==='string'){var img=new Image();img.onload=function(){var _console;var args=formatImage$1(img,message,scale);(_console=console).log.apply(_console,_toConsumableArray(args));};img.src=image;return noop$1;}var element=image.nodeName||'';if(element.toLowerCase()==='img'){var _console2;(_console2=console).log.apply(_console2,_toConsumableArray(formatImage$1(image,message,scale)));return noop$1;}if(element.toLowerCase()==='canvas'){var _img=new Image();_img.onload=function(){var _console3;return(_console3=console).log.apply(_console3,_toConsumableArray(formatImage$1(_img,message,scale)));};_img.src=image.toDataURL();return noop$1;}return noop$1;}var probeLog=new Log$1({id:'loaders.gl'});var NullLog=/*#__PURE__*/function(){function NullLog(){_classCallCheck(this,NullLog);}_createClass(NullLog,[{key:"log",value:function log(){return function(){};}},{key:"info",value:function info(){return function(){};}},{key:"warn",value:function warn(){return function(){};}},{key:"error",value:function error(){return function(){};}}]);return NullLog;}();var ConsoleLog=/*#__PURE__*/function(){function ConsoleLog(){_classCallCheck(this,ConsoleLog);_defineProperty(this,"console",void 0);this.console=console;}_createClass(ConsoleLog,[{key:"log",value:function log(){var _this$console$log;for(var _len102=arguments.length,args=new Array(_len102),_key7=0;_key7<_len102;_key7++){args[_key7]=arguments[_key7];}return(_this$console$log=this.console.log).bind.apply(_this$console$log,[this.console].concat(args));}},{key:"info",value:function info(){var _this$console$info;for(var _len103=arguments.length,args=new Array(_len103),_key8=0;_key8<_len103;_key8++){args[_key8]=arguments[_key8];}return(_this$console$info=this.console.info).bind.apply(_this$console$info,[this.console].concat(args));}},{key:"warn",value:function warn(){var _this$console$warn;for(var _len104=arguments.length,args=new Array(_len104),_key9=0;_key9<_len104;_key9++){args[_key9]=arguments[_key9];}return(_this$console$warn=this.console.warn).bind.apply(_this$console$warn,[this.console].concat(args));}},{key:"error",value:function error(){var _this$console$error;for(var _len105=arguments.length,args=new Array(_len105),_key10=0;_key10<_len105;_key10++){args[_key10]=arguments[_key10];}return(_this$console$error=this.console.error).bind.apply(_this$console$error,[this.console].concat(args));}}]);return ConsoleLog;}();var DEFAULT_LOADER_OPTIONS={fetch:null,mimeType:undefined,nothrow:false,log:new ConsoleLog(),CDN:'https://unpkg.com/@loaders.gl',worker:true,maxConcurrency:3,maxMobileConcurrency:1,reuseWorkers:isBrowser$4,_nodeWorkers:false,_workerType:'',limit:0,_limitMB:0,batchSize:'auto',batchDebounceMs:0,metadata:false,transforms:[]};var REMOVED_LOADER_OPTIONS={"throws":'nothrow',dataType:'(no longer used)',uri:'baseUri',method:'fetch.method',headers:'fetch.headers',body:'fetch.body',mode:'fetch.mode',credentials:'fetch.credentials',cache:'fetch.cache',redirect:'fetch.redirect',referrer:'fetch.referrer',referrerPolicy:'fetch.referrerPolicy',integrity:'fetch.integrity',keepalive:'fetch.keepalive',signal:'fetch.signal'};function getGlobalLoaderState(){globalThis.loaders=globalThis.loaders||{};var loaders=globalThis.loaders;loaders._state=loaders._state||{};return loaders._state;}var getGlobalLoaderOptions=function getGlobalLoaderOptions(){var state=getGlobalLoaderState();state.globalOptions=state.globalOptions||_objectSpread({},DEFAULT_LOADER_OPTIONS);return state.globalOptions;};function normalizeOptions(options,loader,loaders,url){loaders=loaders||[];loaders=Array.isArray(loaders)?loaders:[loaders];validateOptions(options,loaders);return normalizeOptionsInternal(loader,options,url);}function getFetchFunction(options,context){var globalOptions=getGlobalLoaderOptions();var fetchOptions=options||globalOptions;if(typeof fetchOptions.fetch==='function'){return fetchOptions.fetch;}if(isObject(fetchOptions.fetch)){return function(url){return fetchFile(url,fetchOptions);};}if(context!==null&&context!==void 0&&context.fetch){return context===null||context===void 0?void 0:context.fetch;}return fetchFile;}function validateOptions(options,loaders){validateOptionsObject(options,null,DEFAULT_LOADER_OPTIONS,REMOVED_LOADER_OPTIONS,loaders);var _iterator8=_createForOfIteratorHelper(loaders),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var loader=_step8.value;var idOptions=options&&options[loader.id]||{};var loaderOptions=loader.options&&loader.options[loader.id]||{};var deprecatedOptions=loader.deprecatedOptions&&loader.deprecatedOptions[loader.id]||{};validateOptionsObject(idOptions,loader.id,loaderOptions,deprecatedOptions,loaders);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}}function validateOptionsObject(options,id,defaultOptions,deprecatedOptions,loaders){var loaderName=id||'Top level';var prefix=id?"".concat(id,"."):'';for(var key in options){var isSubOptions=!id&&isObject(options[key]);var isBaseUriOption=key==='baseUri'&&!id;var isWorkerUrlOption=key==='workerUrl'&&id;if(!(key in defaultOptions)&&!isBaseUriOption&&!isWorkerUrlOption){if(key in deprecatedOptions){probeLog.warn("".concat(loaderName," loader option '").concat(prefix).concat(key,"' no longer supported, use '").concat(deprecatedOptions[key],"'"))();}else if(!isSubOptions){var suggestion=findSimilarOption(key,loaders);probeLog.warn("".concat(loaderName," loader option '").concat(prefix).concat(key,"' not recognized. ").concat(suggestion))();}}}}function findSimilarOption(optionKey,loaders){var lowerCaseOptionKey=optionKey.toLowerCase();var bestSuggestion='';var _iterator9=_createForOfIteratorHelper(loaders),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var loader=_step9.value;for(var key in loader.options){if(optionKey===key){return"Did you mean '".concat(loader.id,".").concat(key,"'?");}var lowerCaseKey=key.toLowerCase();var isPartialMatch=lowerCaseOptionKey.startsWith(lowerCaseKey)||lowerCaseKey.startsWith(lowerCaseOptionKey);if(isPartialMatch){bestSuggestion=bestSuggestion||"Did you mean '".concat(loader.id,".").concat(key,"'?");}}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}return bestSuggestion;}function normalizeOptionsInternal(loader,options,url){var loaderDefaultOptions=loader.options||{};var mergedOptions=_objectSpread({},loaderDefaultOptions);addUrlOptions(mergedOptions,url);if(mergedOptions.log===null){mergedOptions.log=new NullLog();}mergeNestedFields(mergedOptions,getGlobalLoaderOptions());mergeNestedFields(mergedOptions,options);return mergedOptions;}function mergeNestedFields(mergedOptions,options){for(var key in options){if(key in options){var value=options[key];if(isPureObject(value)&&isPureObject(mergedOptions[key])){mergedOptions[key]=_objectSpread(_objectSpread({},mergedOptions[key]),options[key]);}else{mergedOptions[key]=options[key];}}}}function addUrlOptions(options,url){if(url&&!('baseUri'in options)){options.baseUri=url;}}function isLoaderObject(loader){var _loader;if(!loader){return false;}if(Array.isArray(loader)){loader=loader[0];}var hasExtensions=Array.isArray((_loader=loader)===null||_loader===void 0?void 0:_loader.extensions);return hasExtensions;}function normalizeLoader(loader){var _loader2,_loader3;assert$5(loader,'null loader');assert$5(isLoaderObject(loader),'invalid loader');var options;if(Array.isArray(loader)){options=loader[1];loader=loader[0];loader=_objectSpread(_objectSpread({},loader),{},{options:_objectSpread(_objectSpread({},loader.options),options)});}if((_loader2=loader)!==null&&_loader2!==void 0&&_loader2.parseTextSync||(_loader3=loader)!==null&&_loader3!==void 0&&_loader3.parseText){loader.text=true;}if(!loader.text){loader.binary=true;}return loader;}var getGlobalLoaderRegistry=function getGlobalLoaderRegistry(){var state=getGlobalLoaderState();state.loaderRegistry=state.loaderRegistry||[];return state.loaderRegistry;};function getRegisteredLoaders(){return getGlobalLoaderRegistry();}function isElectron(mockUserAgent){if(typeof window!=='undefined'&&_typeof(window.process)==='object'&&window.process.type==='renderer'){return true;}if(typeof process!=='undefined'&&_typeof(process.versions)==='object'&&Boolean(process.versions.electron)){return true;}var realUserAgent=(typeof navigator==="undefined"?"undefined":_typeof(navigator))==='object'&&typeof navigator.userAgent==='string'&&navigator.userAgent;var userAgent=mockUserAgent||realUserAgent;if(userAgent&&userAgent.indexOf('Electron')>=0){return true;}return false;}function isBrowser(){var isNode=(typeof process==="undefined"?"undefined":_typeof(process))==='object'&&String(process)==='[object process]'&&!process.browser;return!isNode||isElectron();}var globals={self:typeof self!=='undefined'&&self,window:typeof window!=='undefined'&&window,global:typeof global!=='undefined'&&global,document:typeof document!=='undefined'&&document,process:(typeof process==="undefined"?"undefined":_typeof(process))==='object'&&process};var window_=globals.window||globals.self||globals.global;var process_=globals.process||{};var VERSION$6=typeof __VERSION__!=='undefined'?__VERSION__:'untranspiled source';isBrowser();function getStorage(type){try{var storage=window[type];var x='__storage_test__';storage.setItem(x,x);storage.removeItem(x);return storage;}catch(e){return null;}}var LocalStorage=/*#__PURE__*/function(){function LocalStorage(id){_classCallCheck(this,LocalStorage);var defaultSettings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'sessionStorage';_defineProperty(this,"storage",void 0);_defineProperty(this,"id",void 0);_defineProperty(this,"config",{});this.storage=getStorage(type);this.id=id;this.config={};Object.assign(this.config,defaultSettings);this._loadConfiguration();}_createClass(LocalStorage,[{key:"getConfiguration",value:function getConfiguration(){return this.config;}},{key:"setConfiguration",value:function setConfiguration(configuration){this.config={};return this.updateConfiguration(configuration);}},{key:"updateConfiguration",value:function updateConfiguration(configuration){Object.assign(this.config,configuration);if(this.storage){var serialized=JSON.stringify(this.config);this.storage.setItem(this.id,serialized);}return this;}},{key:"_loadConfiguration",value:function _loadConfiguration(){var configuration={};if(this.storage){var serializedConfiguration=this.storage.getItem(this.id);configuration=serializedConfiguration?JSON.parse(serializedConfiguration):{};}Object.assign(this.config,configuration);return this;}}]);return LocalStorage;}();function formatTime(ms){var formatted;if(ms<10){formatted="".concat(ms.toFixed(2),"ms");}else if(ms<100){formatted="".concat(ms.toFixed(1),"ms");}else if(ms<1000){formatted="".concat(ms.toFixed(0),"ms");}else{formatted="".concat((ms/1000).toFixed(2),"s");}return formatted;}function leftPad(string){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:8;var padLength=Math.max(length-string.length,0);return"".concat(' '.repeat(padLength)).concat(string);}function formatImage(image,message,scale){var maxWidth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:600;var imageUrl=image.src.replace(/\(/g,'%28').replace(/\)/g,'%29');if(image.width>maxWidth){scale=Math.min(scale,maxWidth/image.width);}var width=image.width*scale;var height=image.height*scale;var style=['font-size:1px;',"padding:".concat(Math.floor(height/2),"px ").concat(Math.floor(width/2),"px;"),"line-height:".concat(height,"px;"),"background:url(".concat(imageUrl,");"),"background-size:".concat(width,"px ").concat(height,"px;"),'color:transparent;'].join('');return["".concat(message," %c+"),style];}var COLOR;(function(COLOR){COLOR[COLOR["BLACK"]=30]="BLACK";COLOR[COLOR["RED"]=31]="RED";COLOR[COLOR["GREEN"]=32]="GREEN";COLOR[COLOR["YELLOW"]=33]="YELLOW";COLOR[COLOR["BLUE"]=34]="BLUE";COLOR[COLOR["MAGENTA"]=35]="MAGENTA";COLOR[COLOR["CYAN"]=36]="CYAN";COLOR[COLOR["WHITE"]=37]="WHITE";COLOR[COLOR["BRIGHT_BLACK"]=90]="BRIGHT_BLACK";COLOR[COLOR["BRIGHT_RED"]=91]="BRIGHT_RED";COLOR[COLOR["BRIGHT_GREEN"]=92]="BRIGHT_GREEN";COLOR[COLOR["BRIGHT_YELLOW"]=93]="BRIGHT_YELLOW";COLOR[COLOR["BRIGHT_BLUE"]=94]="BRIGHT_BLUE";COLOR[COLOR["BRIGHT_MAGENTA"]=95]="BRIGHT_MAGENTA";COLOR[COLOR["BRIGHT_CYAN"]=96]="BRIGHT_CYAN";COLOR[COLOR["BRIGHT_WHITE"]=97]="BRIGHT_WHITE";})(COLOR||(COLOR={}));function getColor(color){return typeof color==='string'?COLOR[color.toUpperCase()]||COLOR.WHITE:color;}function addColor(string,color,background){if(!isBrowser&&typeof string==='string'){if(color){color=getColor(color);string="\x1B[".concat(color,"m").concat(string,"\x1B[39m");}if(background){color=getColor(background);string="\x1B[".concat(background+10,"m").concat(string,"\x1B[49m");}}return string;}function autobind(obj){var predefined=arguments.length>1&&arguments[1]!==undefined?arguments[1]:['constructor'];var proto=Object.getPrototypeOf(obj);var propNames=Object.getOwnPropertyNames(proto);var _iterator10=_createForOfIteratorHelper(propNames),_step10;try{var _loop5=function _loop5(){var key=_step10.value;if(typeof obj[key]==='function'){if(!predefined.find(function(name){return key===name;})){obj[key]=obj[key].bind(obj);}}};for(_iterator10.s();!(_step10=_iterator10.n()).done;){_loop5();}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}}function assert$2(condition,message){if(!condition){throw new Error(message||'Assertion failed');}}function getHiResTimestamp(){var timestamp;if(isBrowser&&'performance'in window_){var _window$performance,_window$performance$n;timestamp=window_===null||window_===void 0?void 0:(_window$performance=window_.performance)===null||_window$performance===void 0?void 0:(_window$performance$n=_window$performance.now)===null||_window$performance$n===void 0?void 0:_window$performance$n.call(_window$performance);}else if('hrtime'in process_){var _process$hrtime;var timeParts=process_===null||process_===void 0?void 0:(_process$hrtime=process_.hrtime)===null||_process$hrtime===void 0?void 0:_process$hrtime.call(process_);timestamp=timeParts[0]*1000+timeParts[1]/1e6;}else{timestamp=Date.now();}return timestamp;}var originalConsole={debug:isBrowser?console.debug||console.log:console.log,log:console.log,info:console.info,warn:console.warn,error:console.error};var DEFAULT_SETTINGS={enabled:true,level:0};function noop(){}var cache={};var ONCE={once:true};var Log=/*#__PURE__*/function(){function Log(){_classCallCheck(this,Log);var _ref20=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{id:''},id=_ref20.id;_defineProperty(this,"id",void 0);_defineProperty(this,"VERSION",VERSION$6);_defineProperty(this,"_startTs",getHiResTimestamp());_defineProperty(this,"_deltaTs",getHiResTimestamp());_defineProperty(this,"_storage",void 0);_defineProperty(this,"userData",{});_defineProperty(this,"LOG_THROTTLE_TIMEOUT",0);this.id=id;this._storage=new LocalStorage("__probe-".concat(this.id,"__"),DEFAULT_SETTINGS);this.userData={};this.timeStamp("".concat(this.id," started"));autobind(this);Object.seal(this);}_createClass(Log,[{key:"level",get:function get(){return this.getLevel();},set:function set(newLevel){this.setLevel(newLevel);}},{key:"isEnabled",value:function isEnabled(){return this._storage.config.enabled;}},{key:"getLevel",value:function getLevel(){return this._storage.config.level;}},{key:"getTotal",value:function getTotal(){return Number((getHiResTimestamp()-this._startTs).toPrecision(10));}},{key:"getDelta",value:function getDelta(){return Number((getHiResTimestamp()-this._deltaTs).toPrecision(10));}},{key:"priority",get:function get(){return this.level;},set:function set(newPriority){this.level=newPriority;}},{key:"getPriority",value:function getPriority(){return this.level;}},{key:"enable",value:function enable(){var enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this._storage.updateConfiguration({enabled:enabled});return this;}},{key:"setLevel",value:function setLevel(level){this._storage.updateConfiguration({level:level});return this;}},{key:"get",value:function get(setting){return this._storage.config[setting];}},{key:"set",value:function set(setting,value){this._storage.updateConfiguration(_defineProperty2({},setting,value));}},{key:"settings",value:function settings(){if(console.table){console.table(this._storage.config);}else{console.log(this._storage.config);}}},{key:"assert",value:function assert(condition,message){assert$2(condition,message);}},{key:"warn",value:function warn(message){return this._getLogFunction(0,message,originalConsole.warn,arguments,ONCE);}},{key:"error",value:function error(message){return this._getLogFunction(0,message,originalConsole.error,arguments);}},{key:"deprecated",value:function deprecated(oldUsage,newUsage){return this.warn("`".concat(oldUsage,"` is deprecated and will be removed in a later version. Use `").concat(newUsage,"` instead"));}},{key:"removed",value:function removed(oldUsage,newUsage){return this.error("`".concat(oldUsage,"` has been removed. Use `").concat(newUsage,"` instead"));}},{key:"probe",value:function probe(logLevel,message){return this._getLogFunction(logLevel,message,originalConsole.log,arguments,{time:true,once:true});}},{key:"log",value:function log(logLevel,message){return this._getLogFunction(logLevel,message,originalConsole.debug,arguments);}},{key:"info",value:function info(logLevel,message){return this._getLogFunction(logLevel,message,console.info,arguments);}},{key:"once",value:function once(logLevel,message){for(var _len=arguments.length,args=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}return this._getLogFunction(logLevel,message,originalConsole.debug||originalConsole.info,arguments,ONCE);}},{key:"table",value:function table(logLevel,_table2,columns){if(_table2){return this._getLogFunction(logLevel,_table2,console.table||noop,columns&&[columns],{tag:getTableHeader(_table2)});}return noop;}},{key:"image",value:function image(_ref){var logLevel=_ref.logLevel,priority=_ref.priority,image=_ref.image,_ref$message=_ref.message,message=_ref$message===void 0?'':_ref$message,_ref$scale=_ref.scale,scale=_ref$scale===void 0?1:_ref$scale;if(!this._shouldLog(logLevel||priority)){return noop;}return isBrowser?logImageInBrowser({image:image,message:message,scale:scale}):logImageInNode({image:image,message:message,scale:scale});}},{key:"time",value:function time(logLevel,message){return this._getLogFunction(logLevel,message,console.time?console.time:console.info);}},{key:"timeEnd",value:function timeEnd(logLevel,message){return this._getLogFunction(logLevel,message,console.timeEnd?console.timeEnd:console.info);}},{key:"timeStamp",value:function timeStamp(logLevel,message){return this._getLogFunction(logLevel,message,console.timeStamp||noop);}},{key:"group",value:function group(logLevel,message){var opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{collapsed:false};var options=normalizeArguments({logLevel:logLevel,message:message,opts:opts});var collapsed=opts.collapsed;options.method=(collapsed?console.groupCollapsed:console.group)||console.info;return this._getLogFunction(options);}},{key:"groupCollapsed",value:function groupCollapsed(logLevel,message){var opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return this.group(logLevel,message,Object.assign({},opts,{collapsed:true}));}},{key:"groupEnd",value:function groupEnd(logLevel){return this._getLogFunction(logLevel,'',console.groupEnd||noop);}},{key:"withGroup",value:function withGroup(logLevel,message,func){this.group(logLevel,message)();try{func();}finally{this.groupEnd(logLevel)();}}},{key:"trace",value:function trace(){if(console.trace){console.trace();}}},{key:"_shouldLog",value:function _shouldLog(logLevel){return this.isEnabled()&&this.getLevel()>=normalizeLogLevel(logLevel);}},{key:"_getLogFunction",value:function _getLogFunction(logLevel,message,method,args,opts){if(this._shouldLog(logLevel)){var _method2;opts=normalizeArguments({logLevel:logLevel,message:message,args:args,opts:opts});method=method||opts.method;assert$2(method);opts.total=this.getTotal();opts.delta=this.getDelta();this._deltaTs=getHiResTimestamp();var tag=opts.tag||opts.message;if(opts.once){if(!cache[tag]){cache[tag]=getHiResTimestamp();}else{return noop;}}message=decorateMessage(this.id,opts.message,opts);return(_method2=method).bind.apply(_method2,[console,message].concat(_toConsumableArray(opts.args)));}return noop;}}]);return Log;}();_defineProperty(Log,"VERSION",VERSION$6);function normalizeLogLevel(logLevel){if(!logLevel){return 0;}var resolvedLevel;switch(_typeof(logLevel)){case'number':resolvedLevel=logLevel;break;case'object':resolvedLevel=logLevel.logLevel||logLevel.priority||0;break;default:return 0;}assert$2(Number.isFinite(resolvedLevel)&&resolvedLevel>=0);return resolvedLevel;}function normalizeArguments(opts){var logLevel=opts.logLevel,message=opts.message;opts.logLevel=normalizeLogLevel(logLevel);var args=opts.args?Array.from(opts.args):[];while(args.length&&args.shift()!==message){}switch(_typeof(logLevel)){case'string':case'function':if(message!==undefined){args.unshift(message);}opts.message=logLevel;break;case'object':Object.assign(opts,logLevel);break;}if(typeof opts.message==='function'){opts.message=opts.message();}var messageType=_typeof(opts.message);assert$2(messageType==='string'||messageType==='object');return Object.assign(opts,{args:args},opts.opts);}function decorateMessage(id,message,opts){if(typeof message==='string'){var _time2=opts.time?leftPad(formatTime(opts.total)):'';message=opts.time?"".concat(id,": ").concat(_time2,"  ").concat(message):"".concat(id,": ").concat(message);message=addColor(message,opts.color,opts.background);}return message;}function logImageInNode(_ref2){var image=_ref2.image,_ref2$message=_ref2.message,message=_ref2$message===void 0?'':_ref2$message,_ref2$scale=_ref2.scale,scale=_ref2$scale===void 0?1:_ref2$scale;var asciify=null;try{asciify=module.require('asciify-image');}catch(error){}if(asciify){return function(){return asciify(image,{fit:'box',width:"".concat(Math.round(80*scale),"%")}).then(function(data){return console.log(data);});};}return noop;}function logImageInBrowser(_ref3){var image=_ref3.image,_ref3$message=_ref3.message,message=_ref3$message===void 0?'':_ref3$message,_ref3$scale=_ref3.scale,scale=_ref3$scale===void 0?1:_ref3$scale;if(typeof image==='string'){var img=new Image();img.onload=function(){var _console4;var args=formatImage(img,message,scale);(_console4=console).log.apply(_console4,_toConsumableArray(args));};img.src=image;return noop;}var element=image.nodeName||'';if(element.toLowerCase()==='img'){var _console5;(_console5=console).log.apply(_console5,_toConsumableArray(formatImage(image,message,scale)));return noop;}if(element.toLowerCase()==='canvas'){var _img2=new Image();_img2.onload=function(){var _console6;return(_console6=console).log.apply(_console6,_toConsumableArray(formatImage(_img2,message,scale)));};_img2.src=image.toDataURL();return noop;}return noop;}function getTableHeader(table){for(var key in table){for(var title in table[key]){return title||'untitled';}}return'empty';}var log=new Log({id:'loaders.gl'});var EXT_PATTERN=/\.([^.]+)$/;function selectLoader(_x27){return _selectLoader.apply(this,arguments);}function _selectLoader(){_selectLoader=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(data){var loaders,options,context,loader,_args15=arguments;return _regeneratorRuntime().wrap(function _callee17$(_context21){while(1){switch(_context21.prev=_context21.next){case 0:loaders=_args15.length>1&&_args15[1]!==undefined?_args15[1]:[];options=_args15.length>2?_args15[2]:undefined;context=_args15.length>3?_args15[3]:undefined;if(validHTTPResponse(data)){_context21.next=5;break;}return _context21.abrupt("return",null);case 5:loader=selectLoaderSync(data,loaders,_objectSpread(_objectSpread({},options),{},{nothrow:true}),context);if(!loader){_context21.next=8;break;}return _context21.abrupt("return",loader);case 8:if(!isBlob(data)){_context21.next=13;break;}_context21.next=11;return data.slice(0,10).arrayBuffer();case 11:data=_context21.sent;loader=selectLoaderSync(data,loaders,options,context);case 13:if(!(!loader&&!(options!==null&&options!==void 0&&options.nothrow))){_context21.next=15;break;}throw new Error(getNoValidLoaderMessage(data));case 15:return _context21.abrupt("return",loader);case 16:case"end":return _context21.stop();}}},_callee17);}));return _selectLoader.apply(this,arguments);}function selectLoaderSync(data){var loaders=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var options=arguments.length>2?arguments[2]:undefined;var context=arguments.length>3?arguments[3]:undefined;if(!validHTTPResponse(data)){return null;}if(loaders&&!Array.isArray(loaders)){return normalizeLoader(loaders);}var candidateLoaders=[];if(loaders){candidateLoaders=candidateLoaders.concat(loaders);}if(!(options!==null&&options!==void 0&&options.ignoreRegisteredLoaders)){var _candidateLoaders;(_candidateLoaders=candidateLoaders).push.apply(_candidateLoaders,_toConsumableArray(getRegisteredLoaders()));}normalizeLoaders(candidateLoaders);var loader=selectLoaderInternal(data,candidateLoaders,options,context);if(!loader&&!(options!==null&&options!==void 0&&options.nothrow)){throw new Error(getNoValidLoaderMessage(data));}return loader;}function selectLoaderInternal(data,loaders,options,context){var _getResourceUrlAndTyp=getResourceUrlAndType(data),url=_getResourceUrlAndTyp.url,type=_getResourceUrlAndTyp.type;var testUrl=url||(context===null||context===void 0?void 0:context.url);var loader=null;var reason='';if(options!==null&&options!==void 0&&options.mimeType){loader=findLoaderByMIMEType(loaders,options===null||options===void 0?void 0:options.mimeType);reason="match forced by supplied MIME type ".concat(options===null||options===void 0?void 0:options.mimeType);}loader=loader||findLoaderByUrl(loaders,testUrl);reason=reason||(loader?"matched url ".concat(testUrl):'');loader=loader||findLoaderByMIMEType(loaders,type);reason=reason||(loader?"matched MIME type ".concat(type):'');loader=loader||findLoaderByInitialBytes(loaders,data);reason=reason||(loader?"matched initial data ".concat(getFirstCharacters(data)):'');loader=loader||findLoaderByMIMEType(loaders,options===null||options===void 0?void 0:options.fallbackMimeType);reason=reason||(loader?"matched fallback MIME type ".concat(type):'');if(reason){var _loader;log.log(1,"selectLoader selected ".concat((_loader=loader)===null||_loader===void 0?void 0:_loader.name,": ").concat(reason,"."));}return loader;}function validHTTPResponse(data){if(data instanceof Response){if(data.status===204){return false;}}return true;}function getNoValidLoaderMessage(data){var _getResourceUrlAndTyp2=getResourceUrlAndType(data),url=_getResourceUrlAndTyp2.url,type=_getResourceUrlAndTyp2.type;var message='No valid loader found (';message+=url?"".concat(filename(url),", "):'no url provided, ';message+="MIME type: ".concat(type?"\"".concat(type,"\""):'not provided',", ");var firstCharacters=data?getFirstCharacters(data):'';message+=firstCharacters?" first bytes: \"".concat(firstCharacters,"\""):'first bytes: not available';message+=')';return message;}function normalizeLoaders(loaders){var _iterator11=_createForOfIteratorHelper(loaders),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var loader=_step11.value;normalizeLoader(loader);}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}}function findLoaderByUrl(loaders,url){var match=url&&EXT_PATTERN.exec(url);var extension=match&&match[1];return extension?findLoaderByExtension(loaders,extension):null;}function findLoaderByExtension(loaders,extension){extension=extension.toLowerCase();var _iterator12=_createForOfIteratorHelper(loaders),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var loader=_step12.value;var _iterator13=_createForOfIteratorHelper(loader.extensions),_step13;try{for(_iterator13.s();!(_step13=_iterator13.n()).done;){var loaderExtension=_step13.value;if(loaderExtension.toLowerCase()===extension){return loader;}}}catch(err){_iterator13.e(err);}finally{_iterator13.f();}}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}return null;}function findLoaderByMIMEType(loaders,mimeType){var _iterator14=_createForOfIteratorHelper(loaders),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var loader=_step14.value;if(loader.mimeTypes&&loader.mimeTypes.includes(mimeType)){return loader;}if(mimeType==="application/x.".concat(loader.id)){return loader;}}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}return null;}function findLoaderByInitialBytes(loaders,data){if(!data){return null;}var _iterator15=_createForOfIteratorHelper(loaders),_step15;try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){var loader=_step15.value;if(typeof data==='string'){if(testDataAgainstText(data,loader)){return loader;}}else if(ArrayBuffer.isView(data)){if(testDataAgainstBinary(data.buffer,data.byteOffset,loader)){return loader;}}else if(data instanceof ArrayBuffer){var byteOffset=0;if(testDataAgainstBinary(data,byteOffset,loader)){return loader;}}}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}return null;}function testDataAgainstText(data,loader){if(loader.testText){return loader.testText(data);}var tests=Array.isArray(loader.tests)?loader.tests:[loader.tests];return tests.some(function(test){return data.startsWith(test);});}function testDataAgainstBinary(data,byteOffset,loader){var tests=Array.isArray(loader.tests)?loader.tests:[loader.tests];return tests.some(function(test){return testBinary(data,byteOffset,loader,test);});}function testBinary(data,byteOffset,loader,test){if(test instanceof ArrayBuffer){return compareArrayBuffers(test,data,test.byteLength);}switch(_typeof(test)){case'function':return test(data,loader);case'string':var magic=getMagicString$1(data,byteOffset,test.length);return test===magic;default:return false;}}function getFirstCharacters(data){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:5;if(typeof data==='string'){return data.slice(0,length);}else if(ArrayBuffer.isView(data)){return getMagicString$1(data.buffer,data.byteOffset,length);}else if(data instanceof ArrayBuffer){var byteOffset=0;return getMagicString$1(data,byteOffset,length);}return'';}function getMagicString$1(arrayBuffer,byteOffset,length){if(arrayBuffer.byteLength<byteOffset+length){return'';}var dataView=new DataView(arrayBuffer);var magic='';for(var _i496=0;_i496<length;_i496++){magic+=String.fromCharCode(dataView.getUint8(byteOffset+_i496));}return magic;}var DEFAULT_CHUNK_SIZE$2=256*1024;function makeStringIterator(string,options){var chunkSize,offset,textEncoder,chunkLength,chunk;return _regeneratorRuntime().wrap(function makeStringIterator$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:chunkSize=(options===null||options===void 0?void 0:options.chunkSize)||DEFAULT_CHUNK_SIZE$2;offset=0;textEncoder=new TextEncoder();case 3:if(!(offset<string.length)){_context5.next=11;break;}chunkLength=Math.min(string.length-offset,chunkSize);chunk=string.slice(offset,offset+chunkLength);offset+=chunkLength;_context5.next=9;return textEncoder.encode(chunk);case 9:_context5.next=3;break;case 11:case"end":return _context5.stop();}}},_marked);}var DEFAULT_CHUNK_SIZE$1=256*1024;function makeArrayBufferIterator(arrayBuffer){var options,_options$chunkSize,chunkSize,byteOffset,chunkByteLength,chunk,sourceArray,_chunkArray,_args5=arguments;return _regeneratorRuntime().wrap(function makeArrayBufferIterator$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:options=_args5.length>1&&_args5[1]!==undefined?_args5[1]:{};_options$chunkSize=options.chunkSize,chunkSize=_options$chunkSize===void 0?DEFAULT_CHUNK_SIZE$1:_options$chunkSize;byteOffset=0;case 3:if(!(byteOffset<arrayBuffer.byteLength)){_context6.next=14;break;}chunkByteLength=Math.min(arrayBuffer.byteLength-byteOffset,chunkSize);chunk=new ArrayBuffer(chunkByteLength);sourceArray=new Uint8Array(arrayBuffer,byteOffset,chunkByteLength);_chunkArray=new Uint8Array(chunk);_chunkArray.set(sourceArray);byteOffset+=chunkByteLength;_context6.next=12;return chunk;case 12:_context6.next=3;break;case 14:case"end":return _context6.stop();}}},_marked2);}var DEFAULT_CHUNK_SIZE=1024*1024;function makeBlobIterator(_x,_x2){return _makeBlobIterator.apply(this,arguments);}function _makeBlobIterator(){_makeBlobIterator=_wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(blob,options){var chunkSize,offset,end,chunk;return _regeneratorRuntime().wrap(function _callee4$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:chunkSize=(options===null||options===void 0?void 0:options.chunkSize)||DEFAULT_CHUNK_SIZE;offset=0;case 2:if(!(offset<blob.size)){_context7.next=12;break;}end=offset+chunkSize;_context7.next=6;return _awaitAsyncGenerator(blob.slice(offset,end).arrayBuffer());case 6:chunk=_context7.sent;offset=end;_context7.next=10;return chunk;case 10:_context7.next=2;break;case 12:case"end":return _context7.stop();}}},_callee4);}));return _makeBlobIterator.apply(this,arguments);}function makeStreamIterator(stream,options){return isBrowser$4?makeBrowserStreamIterator(stream,options):makeNodeStreamIterator(stream);}function makeBrowserStreamIterator(_x3,_x4){return _makeBrowserStreamIterator.apply(this,arguments);}function _makeBrowserStreamIterator(){_makeBrowserStreamIterator=_wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(stream,options){var reader,nextBatchPromise,currentBatchPromise,_yield$_awaitAsyncGen,done,value;return _regeneratorRuntime().wrap(function _callee5$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:reader=stream.getReader();_context8.prev=1;case 2:if(!true){_context8.next=16;break;}currentBatchPromise=nextBatchPromise||reader.read();if(options!==null&&options!==void 0&&options._streamReadAhead){nextBatchPromise=reader.read();}_context8.next=7;return _awaitAsyncGenerator(currentBatchPromise);case 7:_yield$_awaitAsyncGen=_context8.sent;done=_yield$_awaitAsyncGen.done;value=_yield$_awaitAsyncGen.value;if(!done){_context8.next=12;break;}return _context8.abrupt("return");case 12:_context8.next=14;return toArrayBuffer(value);case 14:_context8.next=2;break;case 16:_context8.next=21;break;case 18:_context8.prev=18;_context8.t0=_context8["catch"](1);reader.releaseLock();case 21:case"end":return _context8.stop();}}},_callee5,null,[[1,18]]);}));return _makeBrowserStreamIterator.apply(this,arguments);}function makeNodeStreamIterator(_x5,_x6){return _makeNodeStreamIterator.apply(this,arguments);}function _makeNodeStreamIterator(){_makeNodeStreamIterator=_wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(stream,options){var _iteratorAbruptCompletion2,_didIteratorError2,_iteratorError2,_iterator2,_step2,chunk;return _regeneratorRuntime().wrap(function _callee6$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_iteratorAbruptCompletion2=false;_didIteratorError2=false;_context9.prev=2;_iterator2=_asyncIterator(stream);case 4:_context9.next=6;return _awaitAsyncGenerator(_iterator2.next());case 6:if(!(_iteratorAbruptCompletion2=!(_step2=_context9.sent).done)){_context9.next=13;break;}chunk=_step2.value;_context9.next=10;return toArrayBuffer(chunk);case 10:_iteratorAbruptCompletion2=false;_context9.next=4;break;case 13:_context9.next=19;break;case 15:_context9.prev=15;_context9.t0=_context9["catch"](2);_didIteratorError2=true;_iteratorError2=_context9.t0;case 19:_context9.prev=19;_context9.prev=20;if(!(_iteratorAbruptCompletion2&&_iterator2["return"]!=null)){_context9.next=24;break;}_context9.next=24;return _awaitAsyncGenerator(_iterator2["return"]());case 24:_context9.prev=24;if(!_didIteratorError2){_context9.next=27;break;}throw _iteratorError2;case 27:return _context9.finish(24);case 28:return _context9.finish(19);case 29:case"end":return _context9.stop();}}},_callee6,null,[[2,15,19,29],[20,,24,28]]);}));return _makeNodeStreamIterator.apply(this,arguments);}function makeIterator(data,options){if(typeof data==='string'){return makeStringIterator(data,options);}if(data instanceof ArrayBuffer){return makeArrayBufferIterator(data,options);}if(isBlob(data)){return makeBlobIterator(data,options);}if(isReadableStream(data)){return makeStreamIterator(data,options);}if(isResponse(data)){var response=data;return makeStreamIterator(response.body,options);}throw new Error('makeIterator');}var ERR_DATA='Cannot convert supplied data type';function getArrayBufferOrStringFromDataSync(data,loader,options){if(loader.text&&typeof data==='string'){return data;}if(isBuffer(data)){data=data.buffer;}if(data instanceof ArrayBuffer){var arrayBuffer=data;if(loader.text&&!loader.binary){var textDecoder=new TextDecoder('utf8');return textDecoder.decode(arrayBuffer);}return arrayBuffer;}if(ArrayBuffer.isView(data)){if(loader.text&&!loader.binary){var _textDecoder=new TextDecoder('utf8');return _textDecoder.decode(data);}var _arrayBuffer=data.buffer;var byteLength=data.byteLength||data.length;if(data.byteOffset!==0||byteLength!==_arrayBuffer.byteLength){_arrayBuffer=_arrayBuffer.slice(data.byteOffset,data.byteOffset+byteLength);}return _arrayBuffer;}throw new Error(ERR_DATA);}function getArrayBufferOrStringFromData(_x28,_x29,_x30){return _getArrayBufferOrStringFromData.apply(this,arguments);}function _getArrayBufferOrStringFromData(){_getArrayBufferOrStringFromData=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(data,loader,options){var isArrayBuffer,response;return _regeneratorRuntime().wrap(function _callee18$(_context22){while(1){switch(_context22.prev=_context22.next){case 0:isArrayBuffer=data instanceof ArrayBuffer||ArrayBuffer.isView(data);if(!(typeof data==='string'||isArrayBuffer)){_context22.next=3;break;}return _context22.abrupt("return",getArrayBufferOrStringFromDataSync(data,loader));case 3:if(!isBlob(data)){_context22.next=7;break;}_context22.next=6;return makeResponse(data);case 6:data=_context22.sent;case 7:if(!isResponse(data)){_context22.next=21;break;}response=data;_context22.next=11;return checkResponse(response);case 11:if(!loader.binary){_context22.next=17;break;}_context22.next=14;return response.arrayBuffer();case 14:_context22.t0=_context22.sent;_context22.next=20;break;case 17:_context22.next=19;return response.text();case 19:_context22.t0=_context22.sent;case 20:return _context22.abrupt("return",_context22.t0);case 21:if(isReadableStream(data)){data=makeIterator(data,options);}if(!(isIterable(data)||isAsyncIterable(data))){_context22.next=24;break;}return _context22.abrupt("return",concatenateArrayBuffersAsync(data));case 24:throw new Error(ERR_DATA);case 25:case"end":return _context22.stop();}}},_callee18);}));return _getArrayBufferOrStringFromData.apply(this,arguments);}function getLoaderContext(context,options){var previousContext=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(previousContext){return previousContext;}var resolvedContext=_objectSpread({fetch:getFetchFunction(options,context)},context);if(!Array.isArray(resolvedContext.loaders)){resolvedContext.loaders=null;}return resolvedContext;}function getLoadersFromContext(loaders,context){if(!context&&loaders&&!Array.isArray(loaders)){return loaders;}var candidateLoaders;if(loaders){candidateLoaders=Array.isArray(loaders)?loaders:[loaders];}if(context&&context.loaders){var contextLoaders=Array.isArray(context.loaders)?context.loaders:[context.loaders];candidateLoaders=candidateLoaders?[].concat(_toConsumableArray(candidateLoaders),_toConsumableArray(contextLoaders)):contextLoaders;}return candidateLoaders&&candidateLoaders.length?candidateLoaders:null;}function parse$3(_x31,_x32,_x33,_x34){return _parse$.apply(this,arguments);}function _parse$(){_parse$=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(data,loaders,options,context){var _getResourceUrlAndTyp4,url,typedLoaders,candidateLoaders,loader;return _regeneratorRuntime().wrap(function _callee19$(_context23){while(1){switch(_context23.prev=_context23.next){case 0:assert$4(!context||_typeof(context)==='object');if(loaders&&!Array.isArray(loaders)&&!isLoaderObject(loaders)){context=undefined;options=loaders;loaders=undefined;}_context23.next=4;return data;case 4:data=_context23.sent;options=options||{};_getResourceUrlAndTyp4=getResourceUrlAndType(data),url=_getResourceUrlAndTyp4.url;typedLoaders=loaders;candidateLoaders=getLoadersFromContext(typedLoaders,context);_context23.next=11;return selectLoader(data,candidateLoaders,options);case 11:loader=_context23.sent;if(loader){_context23.next=14;break;}return _context23.abrupt("return",null);case 14:options=normalizeOptions(options,loader,candidateLoaders,url);context=getLoaderContext({url:url,parse:parse$3,loaders:candidateLoaders},options,context);_context23.next=18;return parseWithLoader(loader,data,options,context);case 18:return _context23.abrupt("return",_context23.sent);case 19:case"end":return _context23.stop();}}},_callee19);}));return _parse$.apply(this,arguments);}function parseWithLoader(_x35,_x36,_x37,_x38){return _parseWithLoader.apply(this,arguments);}function _parseWithLoader(){_parseWithLoader=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(loader,data,options,context){var response,ok,redirected,status,statusText,type,url,headers;return _regeneratorRuntime().wrap(function _callee20$(_context24){while(1){switch(_context24.prev=_context24.next){case 0:validateWorkerVersion(loader);if(isResponse(data)){response=data;ok=response.ok,redirected=response.redirected,status=response.status,statusText=response.statusText,type=response.type,url=response.url;headers=Object.fromEntries(response.headers.entries());context.response={headers:headers,ok:ok,redirected:redirected,status:status,statusText:statusText,type:type,url:url};}_context24.next=4;return getArrayBufferOrStringFromData(data,loader,options);case 4:data=_context24.sent;if(!(loader.parseTextSync&&typeof data==='string')){_context24.next=8;break;}options.dataType='text';return _context24.abrupt("return",loader.parseTextSync(data,options,context,loader));case 8:if(!canParseWithWorker(loader,options)){_context24.next=12;break;}_context24.next=11;return parseWithWorker(loader,data,options,context,parse$3);case 11:return _context24.abrupt("return",_context24.sent);case 12:if(!(loader.parseText&&typeof data==='string')){_context24.next=16;break;}_context24.next=15;return loader.parseText(data,options,context,loader);case 15:return _context24.abrupt("return",_context24.sent);case 16:if(!loader.parse){_context24.next=20;break;}_context24.next=19;return loader.parse(data,options,context,loader);case 19:return _context24.abrupt("return",_context24.sent);case 20:assert$4(!loader.parseSync);throw new Error("".concat(loader.id," loader - no parser found and worker is disabled"));case 22:case"end":return _context24.stop();}}},_callee20);}));return _parseWithLoader.apply(this,arguments);}var VERSION$5="3.2.6";var VERSION$4="3.2.6";var VERSION$3="3.2.6";var BASIS_CDN_ENCODER_WASM="https://unpkg.com/@loaders.gl/textures@".concat(VERSION$3,"/dist/libs/basis_encoder.wasm");var BASIS_CDN_ENCODER_JS="https://unpkg.com/@loaders.gl/textures@".concat(VERSION$3,"/dist/libs/basis_encoder.js");var loadBasisTranscoderPromise;function loadBasisTrascoderModule(_x39){return _loadBasisTrascoderModule.apply(this,arguments);}function _loadBasisTrascoderModule(){_loadBasisTrascoderModule=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(options){var modules;return _regeneratorRuntime().wrap(function _callee21$(_context25){while(1){switch(_context25.prev=_context25.next){case 0:modules=options.modules||{};if(!modules.basis){_context25.next=3;break;}return _context25.abrupt("return",modules.basis);case 3:loadBasisTranscoderPromise=loadBasisTranscoderPromise||loadBasisTrascoder(options);_context25.next=6;return loadBasisTranscoderPromise;case 6:return _context25.abrupt("return",_context25.sent);case 7:case"end":return _context25.stop();}}},_callee21);}));return _loadBasisTrascoderModule.apply(this,arguments);}function loadBasisTrascoder(_x40){return _loadBasisTrascoder.apply(this,arguments);}function _loadBasisTrascoder(){_loadBasisTrascoder=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(options){var BASIS,wasmBinary,_yield$Promise$all,_yield$Promise$all2;return _regeneratorRuntime().wrap(function _callee22$(_context26){while(1){switch(_context26.prev=_context26.next){case 0:BASIS=null;wasmBinary=null;_context26.t0=Promise;_context26.next=5;return loadLibrary('basis_transcoder.js','textures',options);case 5:_context26.t1=_context26.sent;_context26.next=8;return loadLibrary('basis_transcoder.wasm','textures',options);case 8:_context26.t2=_context26.sent;_context26.t3=[_context26.t1,_context26.t2];_context26.next=12;return _context26.t0.all.call(_context26.t0,_context26.t3);case 12:_yield$Promise$all=_context26.sent;_yield$Promise$all2=_slicedToArray(_yield$Promise$all,2);BASIS=_yield$Promise$all2[0];wasmBinary=_yield$Promise$all2[1];BASIS=BASIS||globalThis.BASIS;_context26.next=19;return initializeBasisTrascoderModule(BASIS,wasmBinary);case 19:return _context26.abrupt("return",_context26.sent);case 20:case"end":return _context26.stop();}}},_callee22);}));return _loadBasisTrascoder.apply(this,arguments);}function initializeBasisTrascoderModule(BasisModule,wasmBinary){var options={};if(wasmBinary){options.wasmBinary=wasmBinary;}return new Promise(function(resolve){BasisModule(options).then(function(module){var BasisFile=module.BasisFile,initializeBasis=module.initializeBasis;initializeBasis();resolve({BasisFile:BasisFile});});});}var loadBasisEncoderPromise;function loadBasisEncoderModule(_x41){return _loadBasisEncoderModule.apply(this,arguments);}function _loadBasisEncoderModule(){_loadBasisEncoderModule=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(options){var modules;return _regeneratorRuntime().wrap(function _callee23$(_context27){while(1){switch(_context27.prev=_context27.next){case 0:modules=options.modules||{};if(!modules.basisEncoder){_context27.next=3;break;}return _context27.abrupt("return",modules.basisEncoder);case 3:loadBasisEncoderPromise=loadBasisEncoderPromise||loadBasisEncoder(options);_context27.next=6;return loadBasisEncoderPromise;case 6:return _context27.abrupt("return",_context27.sent);case 7:case"end":return _context27.stop();}}},_callee23);}));return _loadBasisEncoderModule.apply(this,arguments);}function loadBasisEncoder(_x42){return _loadBasisEncoder.apply(this,arguments);}function _loadBasisEncoder(){_loadBasisEncoder=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(options){var BASIS_ENCODER,wasmBinary,_yield$Promise$all3,_yield$Promise$all4;return _regeneratorRuntime().wrap(function _callee24$(_context28){while(1){switch(_context28.prev=_context28.next){case 0:BASIS_ENCODER=null;wasmBinary=null;_context28.t0=Promise;_context28.next=5;return loadLibrary(BASIS_CDN_ENCODER_JS,'textures',options);case 5:_context28.t1=_context28.sent;_context28.next=8;return loadLibrary(BASIS_CDN_ENCODER_WASM,'textures',options);case 8:_context28.t2=_context28.sent;_context28.t3=[_context28.t1,_context28.t2];_context28.next=12;return _context28.t0.all.call(_context28.t0,_context28.t3);case 12:_yield$Promise$all3=_context28.sent;_yield$Promise$all4=_slicedToArray(_yield$Promise$all3,2);BASIS_ENCODER=_yield$Promise$all4[0];wasmBinary=_yield$Promise$all4[1];BASIS_ENCODER=BASIS_ENCODER||globalThis.BASIS;_context28.next=19;return initializeBasisEncoderModule(BASIS_ENCODER,wasmBinary);case 19:return _context28.abrupt("return",_context28.sent);case 20:case"end":return _context28.stop();}}},_callee24);}));return _loadBasisEncoder.apply(this,arguments);}function initializeBasisEncoderModule(BasisEncoderModule,wasmBinary){var options={};if(wasmBinary){options.wasmBinary=wasmBinary;}return new Promise(function(resolve){BasisEncoderModule(options).then(function(module){var BasisFile=module.BasisFile,KTX2File=module.KTX2File,initializeBasis=module.initializeBasis,BasisEncoder=module.BasisEncoder;initializeBasis();resolve({BasisFile:BasisFile,KTX2File:KTX2File,BasisEncoder:BasisEncoder});});});}var GL_EXTENSIONS_CONSTANTS={COMPRESSED_RGB_S3TC_DXT1_EXT:0x83f0,COMPRESSED_RGBA_S3TC_DXT1_EXT:0x83f1,COMPRESSED_RGBA_S3TC_DXT3_EXT:0x83f2,COMPRESSED_RGBA_S3TC_DXT5_EXT:0x83f3,COMPRESSED_R11_EAC:0x9270,COMPRESSED_SIGNED_R11_EAC:0x9271,COMPRESSED_RG11_EAC:0x9272,COMPRESSED_SIGNED_RG11_EAC:0x9273,COMPRESSED_RGB8_ETC2:0x9274,COMPRESSED_RGBA8_ETC2_EAC:0x9275,COMPRESSED_SRGB8_ETC2:0x9276,COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:0x9277,COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:0x9278,COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:0x9279,COMPRESSED_RGB_PVRTC_4BPPV1_IMG:0x8c00,COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:0x8c02,COMPRESSED_RGB_PVRTC_2BPPV1_IMG:0x8c01,COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:0x8c03,COMPRESSED_RGB_ETC1_WEBGL:0x8d64,COMPRESSED_RGB_ATC_WEBGL:0x8c92,COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:0x8c93,COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:0x87ee,COMPRESSED_RGBA_ASTC_4X4_KHR:0x93b0,COMPRESSED_RGBA_ASTC_5X4_KHR:0x93b1,COMPRESSED_RGBA_ASTC_5X5_KHR:0x93b2,COMPRESSED_RGBA_ASTC_6X5_KHR:0x93b3,COMPRESSED_RGBA_ASTC_6X6_KHR:0x93b4,COMPRESSED_RGBA_ASTC_8X5_KHR:0x93b5,COMPRESSED_RGBA_ASTC_8X6_KHR:0x93b6,COMPRESSED_RGBA_ASTC_8X8_KHR:0x93b7,COMPRESSED_RGBA_ASTC_10X5_KHR:0x93b8,COMPRESSED_RGBA_ASTC_10X6_KHR:0x93b9,COMPRESSED_RGBA_ASTC_10X8_KHR:0x93ba,COMPRESSED_RGBA_ASTC_10X10_KHR:0x93bb,COMPRESSED_RGBA_ASTC_12X10_KHR:0x93bc,COMPRESSED_RGBA_ASTC_12X12_KHR:0x93bd,COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR:0x93d0,COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR:0x93d1,COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR:0x93d2,COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR:0x93d3,COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR:0x93d4,COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR:0x93d5,COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR:0x93d6,COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR:0x93d7,COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR:0x93d8,COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR:0x93d9,COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR:0x93da,COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR:0x93db,COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR:0x93dc,COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR:0x93dd,COMPRESSED_RED_RGTC1_EXT:0x8dbb,COMPRESSED_SIGNED_RED_RGTC1_EXT:0x8dbc,COMPRESSED_RED_GREEN_RGTC2_EXT:0x8dbd,COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT:0x8dbe,COMPRESSED_SRGB_S3TC_DXT1_EXT:0x8c4c,COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:0x8c4d,COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:0x8c4e,COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:0x8c4f};var BROWSER_PREFIXES=['','WEBKIT_','MOZ_'];var WEBGL_EXTENSIONS={WEBGL_compressed_texture_s3tc:'dxt',WEBGL_compressed_texture_s3tc_srgb:'dxt-srgb',WEBGL_compressed_texture_etc1:'etc1',WEBGL_compressed_texture_etc:'etc2',WEBGL_compressed_texture_pvrtc:'pvrtc',WEBGL_compressed_texture_atc:'atc',WEBGL_compressed_texture_astc:'astc',EXT_texture_compression_rgtc:'rgtc'};var formats=null;function getSupportedGPUTextureFormats(gl){if(!formats){gl=gl||getWebGLContext()||undefined;formats=new Set();var _iterator16=_createForOfIteratorHelper(BROWSER_PREFIXES),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var prefix=_step16.value;for(var extension in WEBGL_EXTENSIONS){if(gl&&gl.getExtension("".concat(prefix).concat(extension))){var gpuTextureFormat=WEBGL_EXTENSIONS[extension];formats.add(gpuTextureFormat);}}}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}}return formats;}function getWebGLContext(){try{var _canvas6=document.createElement('canvas');return _canvas6.getContext('webgl');}catch(error){return null;}}var n,i,s,a,r,o,l,f;!function(t){t[t.NONE=0]="NONE",t[t.BASISLZ=1]="BASISLZ",t[t.ZSTD=2]="ZSTD",t[t.ZLIB=3]="ZLIB";}(n||(n={})),function(t){t[t.BASICFORMAT=0]="BASICFORMAT";}(i||(i={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.ETC1S=163]="ETC1S",t[t.UASTC=166]="UASTC";}(s||(s={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.SRGB=1]="SRGB";}(a||(a={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.LINEAR=1]="LINEAR",t[t.SRGB=2]="SRGB",t[t.ITU=3]="ITU",t[t.NTSC=4]="NTSC",t[t.SLOG=5]="SLOG",t[t.SLOG2=6]="SLOG2";}(r||(r={})),function(t){t[t.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",t[t.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED";}(o||(o={})),function(t){t[t.RGB=0]="RGB",t[t.RRR=3]="RRR",t[t.GGG=4]="GGG",t[t.AAA=15]="AAA";}(l||(l={})),function(t){t[t.RGB=0]="RGB",t[t.RGBA=3]="RGBA",t[t.RRR=4]="RRR",t[t.RRRG=5]="RRRG";}(f||(f={}));var KTX2_ID=[0xab,0x4b,0x54,0x58,0x20,0x32,0x30,0xbb,0x0d,0x0a,0x1a,0x0a];function isKTX(data){var id=new Uint8Array(data);var notKTX=id.byteLength<KTX2_ID.length||id[0]!==KTX2_ID[0]||id[1]!==KTX2_ID[1]||id[2]!==KTX2_ID[2]||id[3]!==KTX2_ID[3]||id[4]!==KTX2_ID[4]||id[5]!==KTX2_ID[5]||id[6]!==KTX2_ID[6]||id[7]!==KTX2_ID[7]||id[8]!==KTX2_ID[8]||id[9]!==KTX2_ID[9]||id[10]!==KTX2_ID[10]||id[11]!==KTX2_ID[11];return!notKTX;}var OutputFormat={etc1:{basisFormat:0,compressed:true,format:GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL},etc2:{basisFormat:1,compressed:true},bc1:{basisFormat:2,compressed:true,format:GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT},bc3:{basisFormat:3,compressed:true,format:GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT},bc4:{basisFormat:4,compressed:true},bc5:{basisFormat:5,compressed:true},'bc7-m6-opaque-only':{basisFormat:6,compressed:true},'bc7-m5':{basisFormat:7,compressed:true},'pvrtc1-4-rgb':{basisFormat:8,compressed:true,format:GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG},'pvrtc1-4-rgba':{basisFormat:9,compressed:true,format:GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG},'astc-4x4':{basisFormat:10,compressed:true,format:GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR},'atc-rgb':{basisFormat:11,compressed:true},'atc-rgba-interpolated-alpha':{basisFormat:12,compressed:true},rgba32:{basisFormat:13,compressed:false},rgb565:{basisFormat:14,compressed:false},bgr565:{basisFormat:15,compressed:false},rgba4444:{basisFormat:16,compressed:false}};function parseBasis(_x43,_x44){return _parseBasis.apply(this,arguments);}function _parseBasis(){_parseBasis=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(data,options){var fileConstructors,_yield$loadBasisTrasc,BasisFile,_fileConstructors,_yield$loadBasisTrasc2,_BasisFile;return _regeneratorRuntime().wrap(function _callee25$(_context29){while(1){switch(_context29.prev=_context29.next){case 0:if(!(options.basis.containerFormat==='auto')){_context29.next=11;break;}if(!isKTX(data)){_context29.next=6;break;}_context29.next=4;return loadBasisEncoderModule(options);case 4:fileConstructors=_context29.sent;return _context29.abrupt("return",parseKTX2File(fileConstructors.KTX2File,data,options));case 6:_context29.next=8;return loadBasisTrascoderModule(options);case 8:_yield$loadBasisTrasc=_context29.sent;BasisFile=_yield$loadBasisTrasc.BasisFile;return _context29.abrupt("return",parseBasisFile(BasisFile,data,options));case 11:_context29.t0=options.basis.module;_context29.next=_context29.t0==='encoder'?14:_context29.t0==='transcoder'?22:22;break;case 14:_context29.next=16;return loadBasisEncoderModule(options);case 16:_fileConstructors=_context29.sent;_context29.t1=options.basis.containerFormat;_context29.next=_context29.t1==='ktx2'?20:_context29.t1==='basis'?21:21;break;case 20:return _context29.abrupt("return",parseKTX2File(_fileConstructors.KTX2File,data,options));case 21:return _context29.abrupt("return",parseBasisFile(_fileConstructors.BasisFile,data,options));case 22:_context29.next=24;return loadBasisTrascoderModule(options);case 24:_yield$loadBasisTrasc2=_context29.sent;_BasisFile=_yield$loadBasisTrasc2.BasisFile;return _context29.abrupt("return",parseBasisFile(_BasisFile,data,options));case 27:case"end":return _context29.stop();}}},_callee25);}));return _parseBasis.apply(this,arguments);}function parseBasisFile(BasisFile,data,options){var basisFile=new BasisFile(new Uint8Array(data));try{if(!basisFile.startTranscoding()){throw new Error('Failed to start basis transcoding');}var imageCount=basisFile.getNumImages();var images=[];for(var imageIndex=0;imageIndex<imageCount;imageIndex++){var levelsCount=basisFile.getNumLevels(imageIndex);var levels=[];for(var levelIndex=0;levelIndex<levelsCount;levelIndex++){levels.push(transcodeImage(basisFile,imageIndex,levelIndex,options));}images.push(levels);}return images;}finally{basisFile.close();basisFile["delete"]();}}function transcodeImage(basisFile,imageIndex,levelIndex,options){var width=basisFile.getImageWidth(imageIndex,levelIndex);var height=basisFile.getImageHeight(imageIndex,levelIndex);var hasAlpha=basisFile.getHasAlpha();var _getBasisOptions=getBasisOptions(options,hasAlpha),compressed=_getBasisOptions.compressed,format=_getBasisOptions.format,basisFormat=_getBasisOptions.basisFormat;var decodedSize=basisFile.getImageTranscodedSizeInBytes(imageIndex,levelIndex,basisFormat);var decodedData=new Uint8Array(decodedSize);if(!basisFile.transcodeImage(decodedData,imageIndex,levelIndex,basisFormat,0,0)){throw new Error('failed to start Basis transcoding');}return{width:width,height:height,data:decodedData,compressed:compressed,format:format,hasAlpha:hasAlpha};}function parseKTX2File(KTX2File,data,options){var ktx2File=new KTX2File(new Uint8Array(data));try{if(!ktx2File.startTranscoding()){throw new Error('failed to start KTX2 transcoding');}var levelsCount=ktx2File.getLevels();var levels=[];for(var levelIndex=0;levelIndex<levelsCount;levelIndex++){levels.push(transcodeKTX2Image(ktx2File,levelIndex,options));break;}return[levels];}finally{ktx2File.close();ktx2File["delete"]();}}function transcodeKTX2Image(ktx2File,levelIndex,options){var _ktx2File$getImageLev=ktx2File.getImageLevelInfo(levelIndex,0,0),alphaFlag=_ktx2File$getImageLev.alphaFlag,height=_ktx2File$getImageLev.height,width=_ktx2File$getImageLev.width;var _getBasisOptions2=getBasisOptions(options,alphaFlag),compressed=_getBasisOptions2.compressed,format=_getBasisOptions2.format,basisFormat=_getBasisOptions2.basisFormat;var decodedSize=ktx2File.getImageTranscodedSizeInBytes(levelIndex,0,0,basisFormat);var decodedData=new Uint8Array(decodedSize);if(!ktx2File.transcodeImage(decodedData,levelIndex,0,0,basisFormat,0,-1,-1)){throw new Error('Failed to transcode KTX2 image');}return{width:width,height:height,data:decodedData,compressed:compressed,hasAlpha:alphaFlag,format:format};}function getBasisOptions(options,hasAlpha){var format=options&&options.basis&&options.basis.format;if(format==='auto'){format=selectSupportedBasisFormat();}if(_typeof(format)==='object'){format=hasAlpha?format.alpha:format.noAlpha;}format=format.toLowerCase();return OutputFormat[format];}function selectSupportedBasisFormat(){var supportedFormats=getSupportedGPUTextureFormats();if(supportedFormats.has('astc')){return'astc-4x4';}else if(supportedFormats.has('dxt')){return{alpha:'bc3',noAlpha:'bc1'};}else if(supportedFormats.has('pvrtc')){return{alpha:'pvrtc1-4-rgba',noAlpha:'pvrtc1-4-rgb'};}else if(supportedFormats.has('etc1')){return'etc1';}else if(supportedFormats.has('etc2')){return'etc2';}return'rgb565';}var BasisWorkerLoader={name:'Basis',id:'basis',module:'textures',version:VERSION$4,worker:true,extensions:['basis','ktx2'],mimeTypes:['application/octet-stream','image/ktx2'],tests:['sB'],binary:true,options:{basis:{format:'auto',libraryPath:'libs/',containerFormat:'auto',module:'transcoder'}}};var BasisLoader=_objectSpread(_objectSpread({},BasisWorkerLoader),{},{parse:parseBasis});var VERSION$2="3.2.6";var _parseImageNode=globalThis._parseImageNode;var IMAGE_SUPPORTED=typeof Image!=='undefined';var IMAGE_BITMAP_SUPPORTED=typeof ImageBitmap!=='undefined';var NODE_IMAGE_SUPPORTED=Boolean(_parseImageNode);var DATA_SUPPORTED=isBrowser$4?true:NODE_IMAGE_SUPPORTED;function isImageTypeSupported(type){switch(type){case'auto':return IMAGE_BITMAP_SUPPORTED||IMAGE_SUPPORTED||DATA_SUPPORTED;case'imagebitmap':return IMAGE_BITMAP_SUPPORTED;case'image':return IMAGE_SUPPORTED;case'data':return DATA_SUPPORTED;default:throw new Error("@loaders.gl/images: image ".concat(type," not supported in this environment"));}}function getDefaultImageType(){if(IMAGE_BITMAP_SUPPORTED){return'imagebitmap';}if(IMAGE_SUPPORTED){return'image';}if(DATA_SUPPORTED){return'data';}throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');}function getImageType(image){var format=getImageTypeOrNull(image);if(!format){throw new Error('Not an image');}return format;}function getImageData(image){switch(getImageType(image)){case'data':return image;case'image':case'imagebitmap':var _canvas7=document.createElement('canvas');var context=_canvas7.getContext('2d');if(!context){throw new Error('getImageData');}_canvas7.width=image.width;_canvas7.height=image.height;context.drawImage(image,0,0);return context.getImageData(0,0,image.width,image.height);default:throw new Error('getImageData');}}function getImageTypeOrNull(image){if(typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){return'imagebitmap';}if(typeof Image!=='undefined'&&image instanceof Image){return'image';}if(image&&_typeof(image)==='object'&&image.data&&image.width&&image.height){return'data';}return null;}var SVG_DATA_URL_PATTERN=/^data:image\/svg\+xml/;var SVG_URL_PATTERN=/\.svg((\?|#).*)?$/;function isSVG(url){return url&&(SVG_DATA_URL_PATTERN.test(url)||SVG_URL_PATTERN.test(url));}function getBlobOrSVGDataUrl(arrayBuffer,url){if(isSVG(url)){var textDecoder=new TextDecoder();var xmlText=textDecoder.decode(arrayBuffer);try{if(typeof unescape==='function'&&typeof encodeURIComponent==='function'){xmlText=unescape(encodeURIComponent(xmlText));}}catch(error){throw new Error(error.message);}var src="data:image/svg+xml;base64,".concat(btoa(xmlText));return src;}return getBlob(arrayBuffer,url);}function getBlob(arrayBuffer,url){if(isSVG(url)){throw new Error('SVG cannot be parsed directly to imagebitmap');}return new Blob([new Uint8Array(arrayBuffer)]);}function parseToImage(_x45,_x46,_x47){return _parseToImage.apply(this,arguments);}function _parseToImage(){_parseToImage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(arrayBuffer,options,url){var blobOrDataUrl,URL,objectUrl;return _regeneratorRuntime().wrap(function _callee26$(_context30){while(1){switch(_context30.prev=_context30.next){case 0:blobOrDataUrl=getBlobOrSVGDataUrl(arrayBuffer,url);URL=self.URL||self.webkitURL;objectUrl=typeof blobOrDataUrl!=='string'&&URL.createObjectURL(blobOrDataUrl);_context30.prev=3;_context30.next=6;return loadToImage(objectUrl||blobOrDataUrl,options);case 6:return _context30.abrupt("return",_context30.sent);case 7:_context30.prev=7;if(objectUrl){URL.revokeObjectURL(objectUrl);}return _context30.finish(7);case 10:case"end":return _context30.stop();}}},_callee26,null,[[3,,7,10]]);}));return _parseToImage.apply(this,arguments);}function loadToImage(_x48,_x49){return _loadToImage.apply(this,arguments);}function _loadToImage(){_loadToImage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(url,options){var image;return _regeneratorRuntime().wrap(function _callee27$(_context31){while(1){switch(_context31.prev=_context31.next){case 0:image=new Image();image.src=url;if(!(options.image&&options.image.decode&&image.decode)){_context31.next=6;break;}_context31.next=5;return image.decode();case 5:return _context31.abrupt("return",image);case 6:_context31.next=8;return new Promise(function(resolve,reject){try{image.onload=function(){return resolve(image);};image.onerror=function(err){return reject(new Error("Could not load image ".concat(url,": ").concat(err)));};}catch(error){reject(error);}});case 8:return _context31.abrupt("return",_context31.sent);case 9:case"end":return _context31.stop();}}},_callee27);}));return _loadToImage.apply(this,arguments);}var EMPTY_OBJECT={};var imagebitmapOptionsSupported=true;function parseToImageBitmap(_x50,_x51,_x52){return _parseToImageBitmap.apply(this,arguments);}function _parseToImageBitmap(){_parseToImageBitmap=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(arrayBuffer,options,url){var blob,_image8,imagebitmapOptions;return _regeneratorRuntime().wrap(function _callee28$(_context32){while(1){switch(_context32.prev=_context32.next){case 0:if(!isSVG(url)){_context32.next=7;break;}_context32.next=3;return parseToImage(arrayBuffer,options,url);case 3:_image8=_context32.sent;blob=_image8;_context32.next=8;break;case 7:blob=getBlob(arrayBuffer,url);case 8:imagebitmapOptions=options&&options.imagebitmap;_context32.next=11;return safeCreateImageBitmap(blob,imagebitmapOptions);case 11:return _context32.abrupt("return",_context32.sent);case 12:case"end":return _context32.stop();}}},_callee28);}));return _parseToImageBitmap.apply(this,arguments);}function safeCreateImageBitmap(_x53){return _safeCreateImageBitmap.apply(this,arguments);}function _safeCreateImageBitmap(){_safeCreateImageBitmap=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(blob){var imagebitmapOptions,_args27=arguments;return _regeneratorRuntime().wrap(function _callee29$(_context33){while(1){switch(_context33.prev=_context33.next){case 0:imagebitmapOptions=_args27.length>1&&_args27[1]!==undefined?_args27[1]:null;if(isEmptyObject(imagebitmapOptions)||!imagebitmapOptionsSupported){imagebitmapOptions=null;}if(!imagebitmapOptions){_context33.next=13;break;}_context33.prev=3;_context33.next=6;return createImageBitmap(blob,imagebitmapOptions);case 6:return _context33.abrupt("return",_context33.sent);case 9:_context33.prev=9;_context33.t0=_context33["catch"](3);console.warn(_context33.t0);imagebitmapOptionsSupported=false;case 13:_context33.next=15;return createImageBitmap(blob);case 15:return _context33.abrupt("return",_context33.sent);case 16:case"end":return _context33.stop();}}},_callee29,null,[[3,9]]);}));return _safeCreateImageBitmap.apply(this,arguments);}function isEmptyObject(object){for(var key in object||EMPTY_OBJECT){return false;}return true;}var BIG_ENDIAN=false;var LITTLE_ENDIAN=true;function getBinaryImageMetadata(binaryData){var dataView=toDataView(binaryData);return getPngMetadata(dataView)||getJpegMetadata(dataView)||getGifMetadata(dataView)||getBmpMetadata(dataView);}function getPngMetadata(binaryData){var dataView=toDataView(binaryData);var isPng=dataView.byteLength>=24&&dataView.getUint32(0,BIG_ENDIAN)===0x89504e47;if(!isPng){return null;}return{mimeType:'image/png',width:dataView.getUint32(16,BIG_ENDIAN),height:dataView.getUint32(20,BIG_ENDIAN)};}function getGifMetadata(binaryData){var dataView=toDataView(binaryData);var isGif=dataView.byteLength>=10&&dataView.getUint32(0,BIG_ENDIAN)===0x47494638;if(!isGif){return null;}return{mimeType:'image/gif',width:dataView.getUint16(6,LITTLE_ENDIAN),height:dataView.getUint16(8,LITTLE_ENDIAN)};}function getBmpMetadata(binaryData){var dataView=toDataView(binaryData);var isBmp=dataView.byteLength>=14&&dataView.getUint16(0,BIG_ENDIAN)===0x424d&&dataView.getUint32(2,LITTLE_ENDIAN)===dataView.byteLength;if(!isBmp){return null;}return{mimeType:'image/bmp',width:dataView.getUint32(18,LITTLE_ENDIAN),height:dataView.getUint32(22,LITTLE_ENDIAN)};}function getJpegMetadata(binaryData){var dataView=toDataView(binaryData);var isJpeg=dataView.byteLength>=3&&dataView.getUint16(0,BIG_ENDIAN)===0xffd8&&dataView.getUint8(2)===0xff;if(!isJpeg){return null;}var _getJpegMarkers=getJpegMarkers(),tableMarkers=_getJpegMarkers.tableMarkers,sofMarkers=_getJpegMarkers.sofMarkers;var i=2;while(i+9<dataView.byteLength){var marker=dataView.getUint16(i,BIG_ENDIAN);if(sofMarkers.has(marker)){return{mimeType:'image/jpeg',height:dataView.getUint16(i+5,BIG_ENDIAN),width:dataView.getUint16(i+7,BIG_ENDIAN)};}if(!tableMarkers.has(marker)){return null;}i+=2;i+=dataView.getUint16(i,BIG_ENDIAN);}return null;}function getJpegMarkers(){var tableMarkers=new Set([0xffdb,0xffc4,0xffcc,0xffdd,0xfffe]);for(var _i497=0xffe0;_i497<0xfff0;++_i497){tableMarkers.add(_i497);}var sofMarkers=new Set([0xffc0,0xffc1,0xffc2,0xffc3,0xffc5,0xffc6,0xffc7,0xffc9,0xffca,0xffcb,0xffcd,0xffce,0xffcf,0xffde]);return{tableMarkers:tableMarkers,sofMarkers:sofMarkers};}function toDataView(data){if(data instanceof DataView){return data;}if(ArrayBuffer.isView(data)){return new DataView(data.buffer);}if(data instanceof ArrayBuffer){return new DataView(data);}throw new Error('toDataView');}function parseToNodeImage(_x54,_x55){return _parseToNodeImage.apply(this,arguments);}function _parseToNodeImage(){_parseToNodeImage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(arrayBuffer,options){var _ref22,mimeType,_parseImageNode;return _regeneratorRuntime().wrap(function _callee30$(_context34){while(1){switch(_context34.prev=_context34.next){case 0:_ref22=getBinaryImageMetadata(arrayBuffer)||{},mimeType=_ref22.mimeType;_parseImageNode=globalThis._parseImageNode;assert$5(_parseImageNode);_context34.next=5;return _parseImageNode(arrayBuffer,mimeType);case 5:return _context34.abrupt("return",_context34.sent);case 6:case"end":return _context34.stop();}}},_callee30);}));return _parseToNodeImage.apply(this,arguments);}function parseImage(_x56,_x57,_x58){return _parseImage.apply(this,arguments);}function _parseImage(){_parseImage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(arrayBuffer,options,context){var imageOptions,imageType,_ref23,url,loadType,image;return _regeneratorRuntime().wrap(function _callee31$(_context35){while(1){switch(_context35.prev=_context35.next){case 0:options=options||{};imageOptions=options.image||{};imageType=imageOptions.type||'auto';_ref23=context||{},url=_ref23.url;loadType=getLoadableImageType(imageType);_context35.t0=loadType;_context35.next=_context35.t0==='imagebitmap'?8:_context35.t0==='image'?12:_context35.t0==='data'?16:20;break;case 8:_context35.next=10;return parseToImageBitmap(arrayBuffer,options,url);case 10:image=_context35.sent;return _context35.abrupt("break",21);case 12:_context35.next=14;return parseToImage(arrayBuffer,options,url);case 14:image=_context35.sent;return _context35.abrupt("break",21);case 16:_context35.next=18;return parseToNodeImage(arrayBuffer);case 18:image=_context35.sent;return _context35.abrupt("break",21);case 20:assert$5(false);case 21:if(imageType==='data'){image=getImageData(image);}return _context35.abrupt("return",image);case 23:case"end":return _context35.stop();}}},_callee31);}));return _parseImage.apply(this,arguments);}function getLoadableImageType(type){switch(type){case'auto':case'data':return getDefaultImageType();default:isImageTypeSupported(type);return type;}}var EXTENSIONS$1=['png','jpg','jpeg','gif','webp','bmp','ico','svg'];var MIME_TYPES=['image/png','image/jpeg','image/gif','image/webp','image/bmp','image/vnd.microsoft.icon','image/svg+xml'];var DEFAULT_IMAGE_LOADER_OPTIONS={image:{type:'auto',decode:true}};var ImageLoader={id:'image',module:'images',name:'Images',version:VERSION$2,mimeTypes:MIME_TYPES,extensions:EXTENSIONS$1,parse:parseImage,tests:[function(arrayBuffer){return Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)));}],options:DEFAULT_IMAGE_LOADER_OPTIONS};var NODE_FORMAT_SUPPORT=['image/png','image/jpeg','image/gif'];var mimeTypeSupported={};function _isImageFormatSupported(mimeType){if(mimeTypeSupported[mimeType]===undefined){mimeTypeSupported[mimeType]=checkFormatSupport(mimeType);}return mimeTypeSupported[mimeType];}function checkFormatSupport(mimeType){switch(mimeType){case'image/webp':return checkWebPSupport();case'image/svg':return isBrowser$4;default:if(!isBrowser$4){var _parseImageNode2=globalThis._parseImageNode;return Boolean(_parseImageNode2)&&NODE_FORMAT_SUPPORT.includes(mimeType);}return true;}}function checkWebPSupport(){if(!isBrowser$4){return false;}try{var element=document.createElement('canvas');return element.toDataURL('image/webp').indexOf('data:image/webp')===0;}catch(_unused){return false;}}function assert$1(condition,message){if(!condition){throw new Error(message||'assert failed: gltf');}}function resolveUrl(url,options){var absolute=url.startsWith('data:')||url.startsWith('http:')||url.startsWith('https:');if(absolute){return url;}var baseUrl=options.baseUri||options.uri;if(!baseUrl){throw new Error("'baseUri' must be provided to resolve relative url ".concat(url));}return baseUrl.substr(0,baseUrl.lastIndexOf('/')+1)+url;}function getTypedArrayForBufferView(json,buffers,bufferViewIndex){var bufferView=json.bufferViews[bufferViewIndex];assert$1(bufferView);var bufferIndex=bufferView.buffer;var binChunk=buffers[bufferIndex];assert$1(binChunk);var byteOffset=(bufferView.byteOffset||0)+binChunk.byteOffset;return new Uint8Array(binChunk.arrayBuffer,byteOffset,bufferView.byteLength);}var TYPES=['SCALAR','VEC2','VEC3','VEC4'];var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT=[[Int8Array,5120],[Uint8Array,5121],[Int16Array,5122],[Uint16Array,5123],[Uint32Array,5125],[Float32Array,5126],[Float64Array,5130]];var ARRAY_TO_COMPONENT_TYPE=new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);var ATTRIBUTE_TYPE_TO_COMPONENTS={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16};var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4};var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function getAccessorTypeFromSize(size){var type=TYPES[size-1];return type||TYPES[0];}function getComponentTypeFromArray(typedArray){var componentType=ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);if(!componentType){throw new Error('Illegal typed array');}return componentType;}function getAccessorArrayTypeAndLength(accessor,bufferView){var ArrayType=ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];var components=ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];var bytesPerComponent=ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];var length=accessor.count*components;var byteLength=accessor.count*components*bytesPerComponent;assert$1(byteLength>=0&&byteLength<=bufferView.byteLength);return{ArrayType:ArrayType,length:length,byteLength:byteLength};}var DEFAULT_GLTF_JSON={asset:{version:'2.0',generator:'loaders.gl'},buffers:[]};var GLTFScenegraph=/*#__PURE__*/function(){function GLTFScenegraph(gltf){_classCallCheck(this,GLTFScenegraph);_defineProperty(this,"gltf",void 0);_defineProperty(this,"sourceBuffers",void 0);_defineProperty(this,"byteLength",void 0);this.gltf=gltf||{json:_objectSpread({},DEFAULT_GLTF_JSON),buffers:[]};this.sourceBuffers=[];this.byteLength=0;if(this.gltf.buffers&&this.gltf.buffers[0]){this.byteLength=this.gltf.buffers[0].byteLength;this.sourceBuffers=[this.gltf.buffers[0]];}}_createClass(GLTFScenegraph,[{key:"json",get:function get(){return this.gltf.json;}},{key:"getApplicationData",value:function getApplicationData(key){var data=this.json[key];return data;}},{key:"getExtraData",value:function getExtraData(key){var extras=this.json.extras||{};return extras[key];}},{key:"getExtension",value:function getExtension(extensionName){var isExtension=this.getUsedExtensions().find(function(name){return name===extensionName;});var extensions=this.json.extensions||{};return isExtension?extensions[extensionName]||true:null;}},{key:"getRequiredExtension",value:function getRequiredExtension(extensionName){var isRequired=this.getRequiredExtensions().find(function(name){return name===extensionName;});return isRequired?this.getExtension(extensionName):null;}},{key:"getRequiredExtensions",value:function getRequiredExtensions(){return this.json.extensionsRequired||[];}},{key:"getUsedExtensions",value:function getUsedExtensions(){return this.json.extensionsUsed||[];}},{key:"getObjectExtension",value:function getObjectExtension(object,extensionName){var extensions=object.extensions||{};return extensions[extensionName];}},{key:"getScene",value:function getScene(index){return this.getObject('scenes',index);}},{key:"getNode",value:function getNode(index){return this.getObject('nodes',index);}},{key:"getSkin",value:function getSkin(index){return this.getObject('skins',index);}},{key:"getMesh",value:function getMesh(index){return this.getObject('meshes',index);}},{key:"getMaterial",value:function getMaterial(index){return this.getObject('materials',index);}},{key:"getAccessor",value:function getAccessor(index){return this.getObject('accessors',index);}},{key:"getTexture",value:function getTexture(index){return this.getObject('textures',index);}},{key:"getSampler",value:function getSampler(index){return this.getObject('samplers',index);}},{key:"getImage",value:function getImage(index){return this.getObject('images',index);}},{key:"getBufferView",value:function getBufferView(index){return this.getObject('bufferViews',index);}},{key:"getBuffer",value:function getBuffer(index){return this.getObject('buffers',index);}},{key:"getObject",value:function getObject(array,index){if(_typeof(index)==='object'){return index;}var object=this.json[array]&&this.json[array][index];if(!object){throw new Error("glTF file error: Could not find ".concat(array,"[").concat(index,"]"));}return object;}},{key:"getTypedArrayForBufferView",value:function getTypedArrayForBufferView(bufferView){bufferView=this.getBufferView(bufferView);var bufferIndex=bufferView.buffer;var binChunk=this.gltf.buffers[bufferIndex];assert$1(binChunk);var byteOffset=(bufferView.byteOffset||0)+binChunk.byteOffset;return new Uint8Array(binChunk.arrayBuffer,byteOffset,bufferView.byteLength);}},{key:"getTypedArrayForAccessor",value:function getTypedArrayForAccessor(accessor){accessor=this.getAccessor(accessor);var bufferView=this.getBufferView(accessor.bufferView);var buffer=this.getBuffer(bufferView.buffer);var arrayBuffer=buffer.data;var _getAccessorArrayType=getAccessorArrayTypeAndLength(accessor,bufferView),ArrayType=_getAccessorArrayType.ArrayType,length=_getAccessorArrayType.length;var byteOffset=bufferView.byteOffset+accessor.byteOffset;return new ArrayType(arrayBuffer,byteOffset,length);}},{key:"getTypedArrayForImageData",value:function getTypedArrayForImageData(image){image=this.getAccessor(image);var bufferView=this.getBufferView(image.bufferView);var buffer=this.getBuffer(bufferView.buffer);var arrayBuffer=buffer.data;var byteOffset=bufferView.byteOffset||0;return new Uint8Array(arrayBuffer,byteOffset,bufferView.byteLength);}},{key:"addApplicationData",value:function addApplicationData(key,data){this.json[key]=data;return this;}},{key:"addExtraData",value:function addExtraData(key,data){this.json.extras=this.json.extras||{};this.json.extras[key]=data;return this;}},{key:"addObjectExtension",value:function addObjectExtension(object,extensionName,data){object.extensions=object.extensions||{};object.extensions[extensionName]=data;this.registerUsedExtension(extensionName);return this;}},{key:"setObjectExtension",value:function setObjectExtension(object,extensionName,data){var extensions=object.extensions||{};extensions[extensionName]=data;}},{key:"removeObjectExtension",value:function removeObjectExtension(object,extensionName){var extensions=object.extensions||{};var extension=extensions[extensionName];delete extensions[extensionName];return extension;}},{key:"addExtension",value:function addExtension(extensionName){var extensionData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};assert$1(extensionData);this.json.extensions=this.json.extensions||{};this.json.extensions[extensionName]=extensionData;this.registerUsedExtension(extensionName);return extensionData;}},{key:"addRequiredExtension",value:function addRequiredExtension(extensionName){var extensionData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};assert$1(extensionData);this.addExtension(extensionName,extensionData);this.registerRequiredExtension(extensionName);return extensionData;}},{key:"registerUsedExtension",value:function registerUsedExtension(extensionName){this.json.extensionsUsed=this.json.extensionsUsed||[];if(!this.json.extensionsUsed.find(function(ext){return ext===extensionName;})){this.json.extensionsUsed.push(extensionName);}}},{key:"registerRequiredExtension",value:function registerRequiredExtension(extensionName){this.registerUsedExtension(extensionName);this.json.extensionsRequired=this.json.extensionsRequired||[];if(!this.json.extensionsRequired.find(function(ext){return ext===extensionName;})){this.json.extensionsRequired.push(extensionName);}}},{key:"removeExtension",value:function removeExtension(extensionName){if(this.json.extensionsRequired){this._removeStringFromArray(this.json.extensionsRequired,extensionName);}if(this.json.extensionsUsed){this._removeStringFromArray(this.json.extensionsUsed,extensionName);}if(this.json.extensions){delete this.json.extensions[extensionName];}}},{key:"setDefaultScene",value:function setDefaultScene(sceneIndex){this.json.scene=sceneIndex;}},{key:"addScene",value:function addScene(scene){var nodeIndices=scene.nodeIndices;this.json.scenes=this.json.scenes||[];this.json.scenes.push({nodes:nodeIndices});return this.json.scenes.length-1;}},{key:"addNode",value:function addNode(node){var meshIndex=node.meshIndex,matrix=node.matrix;this.json.nodes=this.json.nodes||[];var nodeData={mesh:meshIndex};if(matrix){nodeData.matrix=matrix;}this.json.nodes.push(nodeData);return this.json.nodes.length-1;}},{key:"addMesh",value:function addMesh(mesh){var attributes=mesh.attributes,indices=mesh.indices,material=mesh.material,_mesh$mode=mesh.mode,mode=_mesh$mode===void 0?4:_mesh$mode;var accessors=this._addAttributes(attributes);var glTFMesh={primitives:[{attributes:accessors,mode:mode}]};if(indices){var indicesAccessor=this._addIndices(indices);glTFMesh.primitives[0].indices=indicesAccessor;}if(Number.isFinite(material)){glTFMesh.primitives[0].material=material;}this.json.meshes=this.json.meshes||[];this.json.meshes.push(glTFMesh);return this.json.meshes.length-1;}},{key:"addPointCloud",value:function addPointCloud(attributes){var accessorIndices=this._addAttributes(attributes);var glTFMesh={primitives:[{attributes:accessorIndices,mode:0}]};this.json.meshes=this.json.meshes||[];this.json.meshes.push(glTFMesh);return this.json.meshes.length-1;}},{key:"addImage",value:function addImage(imageData,mimeTypeOpt){var metadata=getBinaryImageMetadata(imageData);var mimeType=mimeTypeOpt||(metadata===null||metadata===void 0?void 0:metadata.mimeType);var bufferViewIndex=this.addBufferView(imageData);var glTFImage={bufferView:bufferViewIndex,mimeType:mimeType};this.json.images=this.json.images||[];this.json.images.push(glTFImage);return this.json.images.length-1;}},{key:"addBufferView",value:function addBufferView(buffer){var byteLength=buffer.byteLength;assert$1(Number.isFinite(byteLength));this.sourceBuffers=this.sourceBuffers||[];this.sourceBuffers.push(buffer);var glTFBufferView={buffer:0,byteOffset:this.byteLength,byteLength:byteLength};this.byteLength+=padToNBytes(byteLength,4);this.json.bufferViews=this.json.bufferViews||[];this.json.bufferViews.push(glTFBufferView);return this.json.bufferViews.length-1;}},{key:"addAccessor",value:function addAccessor(bufferViewIndex,accessor){var glTFAccessor={bufferView:bufferViewIndex,type:getAccessorTypeFromSize(accessor.size),componentType:accessor.componentType,count:accessor.count,max:accessor.max,min:accessor.min};this.json.accessors=this.json.accessors||[];this.json.accessors.push(glTFAccessor);return this.json.accessors.length-1;}},{key:"addBinaryBuffer",value:function addBinaryBuffer(sourceBuffer){var accessor=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{size:3};var bufferViewIndex=this.addBufferView(sourceBuffer);var minMax={min:accessor.min,max:accessor.max};if(!minMax.min||!minMax.max){minMax=this._getAccessorMinMax(sourceBuffer,accessor.size);}var accessorDefaults={size:accessor.size,componentType:getComponentTypeFromArray(sourceBuffer),count:Math.round(sourceBuffer.length/accessor.size),min:minMax.min,max:minMax.max};return this.addAccessor(bufferViewIndex,Object.assign(accessorDefaults,accessor));}},{key:"addTexture",value:function addTexture(texture){var imageIndex=texture.imageIndex;var glTFTexture={source:imageIndex};this.json.textures=this.json.textures||[];this.json.textures.push(glTFTexture);return this.json.textures.length-1;}},{key:"addMaterial",value:function addMaterial(pbrMaterialInfo){this.json.materials=this.json.materials||[];this.json.materials.push(pbrMaterialInfo);return this.json.materials.length-1;}},{key:"createBinaryChunk",value:function createBinaryChunk(){var _this$json,_this$json$buffers;this.gltf.buffers=[];var totalByteLength=this.byteLength;var arrayBuffer=new ArrayBuffer(totalByteLength);var targetArray=new Uint8Array(arrayBuffer);var dstByteOffset=0;var _iterator17=_createForOfIteratorHelper(this.sourceBuffers||[]),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var sourceBuffer=_step17.value;dstByteOffset=copyToArray(sourceBuffer,targetArray,dstByteOffset);}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}if((_this$json=this.json)!==null&&_this$json!==void 0&&(_this$json$buffers=_this$json.buffers)!==null&&_this$json$buffers!==void 0&&_this$json$buffers[0]){this.json.buffers[0].byteLength=totalByteLength;}else{this.json.buffers=[{byteLength:totalByteLength}];}this.gltf.binary=arrayBuffer;this.sourceBuffers=[arrayBuffer];}},{key:"_removeStringFromArray",value:function _removeStringFromArray(array,string){var found=true;while(found){var index=array.indexOf(string);if(index>-1){array.splice(index,1);}else{found=false;}}}},{key:"_addAttributes",value:function _addAttributes(){var attributes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var result={};for(var attributeKey in attributes){var attributeData=attributes[attributeKey];var attrName=this._getGltfAttributeName(attributeKey);var accessor=this.addBinaryBuffer(attributeData.value,attributeData);result[attrName]=accessor;}return result;}},{key:"_addIndices",value:function _addIndices(indices){return this.addBinaryBuffer(indices,{size:1});}},{key:"_getGltfAttributeName",value:function _getGltfAttributeName(attributeName){switch(attributeName.toLowerCase()){case'position':case'positions':case'vertices':return'POSITION';case'normal':case'normals':return'NORMAL';case'color':case'colors':return'COLOR_0';case'texcoord':case'texcoords':return'TEXCOORD_0';default:return attributeName;}}},{key:"_getAccessorMinMax",value:function _getAccessorMinMax(buffer,size){var result={min:null,max:null};if(buffer.length<size){return result;}result.min=[];result.max=[];var initValues=buffer.subarray(0,size);var _iterator18=_createForOfIteratorHelper(initValues),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var value=_step18.value;result.min.push(value);result.max.push(value);}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}for(var index=size;index<buffer.length;index+=size){for(var componentIndex=0;componentIndex<size;componentIndex++){result.min[0+componentIndex]=Math.min(result.min[0+componentIndex],buffer[index+componentIndex]);result.max[0+componentIndex]=Math.max(result.max[0+componentIndex],buffer[index+componentIndex]);}}return result;}}]);return GLTFScenegraph;}();var wasm_base='B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB';var wasm_simd='B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB';var detector=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]);var wasmpack=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);var FILTERS={0:'',1:'meshopt_decodeFilterOct',2:'meshopt_decodeFilterQuat',3:'meshopt_decodeFilterExp',NONE:'',OCTAHEDRAL:'meshopt_decodeFilterOct',QUATERNION:'meshopt_decodeFilterQuat',EXPONENTIAL:'meshopt_decodeFilterExp'};var DECODERS={0:'meshopt_decodeVertexBuffer',1:'meshopt_decodeIndexBuffer',2:'meshopt_decodeIndexSequence',ATTRIBUTES:'meshopt_decodeVertexBuffer',TRIANGLES:'meshopt_decodeIndexBuffer',INDICES:'meshopt_decodeIndexSequence'};function meshoptDecodeGltfBuffer(_x59,_x60,_x61,_x62,_x63){return _meshoptDecodeGltfBuffer.apply(this,arguments);}function _meshoptDecodeGltfBuffer(){_meshoptDecodeGltfBuffer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(target,count,size,source,mode){var filter,instance,_args30=arguments;return _regeneratorRuntime().wrap(function _callee32$(_context36){while(1){switch(_context36.prev=_context36.next){case 0:filter=_args30.length>5&&_args30[5]!==undefined?_args30[5]:'NONE';_context36.next=3;return loadWasmInstance();case 3:instance=_context36.sent;decode$5(instance,instance.exports[DECODERS[mode]],target,count,size,source,instance.exports[FILTERS[filter||'NONE']]);case 5:case"end":return _context36.stop();}}},_callee32);}));return _meshoptDecodeGltfBuffer.apply(this,arguments);}var wasmPromise;function loadWasmInstance(){return _loadWasmInstance.apply(this,arguments);}function _loadWasmInstance(){_loadWasmInstance=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(){return _regeneratorRuntime().wrap(function _callee33$(_context37){while(1){switch(_context37.prev=_context37.next){case 0:if(!wasmPromise){wasmPromise=loadWasmModule();}return _context37.abrupt("return",wasmPromise);case 2:case"end":return _context37.stop();}}},_callee33);}));return _loadWasmInstance.apply(this,arguments);}function loadWasmModule(){return _loadWasmModule.apply(this,arguments);}function _loadWasmModule(){_loadWasmModule=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(){var wasm,result;return _regeneratorRuntime().wrap(function _callee34$(_context38){while(1){switch(_context38.prev=_context38.next){case 0:wasm=wasm_base;if(WebAssembly.validate(detector)){wasm=wasm_simd;console.log('Warning: meshopt_decoder is using experimental SIMD support');}_context38.next=4;return WebAssembly.instantiate(unpack(wasm),{});case 4:result=_context38.sent;_context38.next=7;return result.instance.exports.__wasm_call_ctors();case 7:return _context38.abrupt("return",result.instance);case 8:case"end":return _context38.stop();}}},_callee34);}));return _loadWasmModule.apply(this,arguments);}function unpack(data){var result=new Uint8Array(data.length);for(var _i498=0;_i498<data.length;++_i498){var ch=data.charCodeAt(_i498);result[_i498]=ch>96?ch-71:ch>64?ch-65:ch>47?ch+4:ch>46?63:62;}var write=0;for(var _i499=0;_i499<data.length;++_i499){result[write++]=result[_i499]<60?wasmpack[result[_i499]]:(result[_i499]-60)*64+result[++_i499];}return result.buffer.slice(0,write);}function decode$5(instance,fun,target,count,size,source,filter){var sbrk=instance.exports.sbrk;var count4=count+3&~3;var tp=sbrk(count4*size);var sp=sbrk(source.length);var heap=new Uint8Array(instance.exports.memory.buffer);heap.set(source,sp);var res=fun(tp,count,size,sp,source.length);if(res===0&&filter){filter(tp,count4,size);}target.set(heap.subarray(tp,tp+count*size));sbrk(tp-sbrk(0));if(res!==0){throw new Error("Malformed buffer data: ".concat(res));}}var EXT_MESHOPT_COMPRESSION='EXT_meshopt_compression';var name$6=EXT_MESHOPT_COMPRESSION;function decode$4(_x64,_x65){return _decode$.apply(this,arguments);}function _decode$(){_decode$=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(gltfData,options){var _options$gltf,scenegraph,promises,_iterator41,_step41,bufferViewIndex;return _regeneratorRuntime().wrap(function _callee35$(_context39){while(1){switch(_context39.prev=_context39.next){case 0:scenegraph=new GLTFScenegraph(gltfData);if(options!==null&&options!==void 0&&(_options$gltf=options.gltf)!==null&&_options$gltf!==void 0&&_options$gltf.decompressMeshes){_context39.next=3;break;}return _context39.abrupt("return");case 3:promises=[];_iterator41=_createForOfIteratorHelper(gltfData.json.bufferViews||[]);try{for(_iterator41.s();!(_step41=_iterator41.n()).done;){bufferViewIndex=_step41.value;promises.push(decodeMeshoptBufferView(scenegraph,bufferViewIndex));}}catch(err){_iterator41.e(err);}finally{_iterator41.f();}_context39.next=8;return Promise.all(promises);case 8:scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);case 9:case"end":return _context39.stop();}}},_callee35);}));return _decode$.apply(this,arguments);}function decodeMeshoptBufferView(_x66,_x67){return _decodeMeshoptBufferView.apply(this,arguments);}function _decodeMeshoptBufferView(){_decodeMeshoptBufferView=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(scenegraph,bufferView){var meshoptExtension,_meshoptExtension$byt,byteOffset,_meshoptExtension$byt2,byteLength,byteStride,count,mode,_meshoptExtension$fil,filter,bufferIndex,buffer,source,result;return _regeneratorRuntime().wrap(function _callee36$(_context40){while(1){switch(_context40.prev=_context40.next){case 0:meshoptExtension=scenegraph.getObjectExtension(bufferView,EXT_MESHOPT_COMPRESSION);if(!meshoptExtension){_context40.next=9;break;}_meshoptExtension$byt=meshoptExtension.byteOffset,byteOffset=_meshoptExtension$byt===void 0?0:_meshoptExtension$byt,_meshoptExtension$byt2=meshoptExtension.byteLength,byteLength=_meshoptExtension$byt2===void 0?0:_meshoptExtension$byt2,byteStride=meshoptExtension.byteStride,count=meshoptExtension.count,mode=meshoptExtension.mode,_meshoptExtension$fil=meshoptExtension.filter,filter=_meshoptExtension$fil===void 0?'NONE':_meshoptExtension$fil,bufferIndex=meshoptExtension.buffer;buffer=scenegraph.gltf.buffers[bufferIndex];source=new Uint8Array(buffer.arrayBuffer,buffer.byteOffset+byteOffset,byteLength);result=new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer,bufferView.byteOffset,bufferView.byteLength);_context40.next=8;return meshoptDecodeGltfBuffer(result,count,byteStride,source,mode,filter);case 8:return _context40.abrupt("return",result);case 9:return _context40.abrupt("return",null);case 10:case"end":return _context40.stop();}}},_callee36);}));return _decodeMeshoptBufferView.apply(this,arguments);}var EXT_meshopt_compression=/*#__PURE__*/Object.freeze({__proto__:null,name:name$6,decode:decode$4});var EXT_TEXTURE_WEBP='EXT_texture_webp';var name$5=EXT_TEXTURE_WEBP;function preprocess$3(gltfData,options){var scenegraph=new GLTFScenegraph(gltfData);if(!_isImageFormatSupported('image/webp')){if(scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)){throw new Error("gltf: Required extension ".concat(EXT_TEXTURE_WEBP," not supported by browser"));}return;}var json=scenegraph.json;var _iterator19=_createForOfIteratorHelper(json.textures||[]),_step19;try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){var texture=_step19.value;var extension=scenegraph.getObjectExtension(texture,EXT_TEXTURE_WEBP);if(extension){texture.source=extension.source;}scenegraph.removeObjectExtension(texture,EXT_TEXTURE_WEBP);}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}scenegraph.removeExtension(EXT_TEXTURE_WEBP);}var EXT_texture_webp=/*#__PURE__*/Object.freeze({__proto__:null,name:name$5,preprocess:preprocess$3});var KHR_TEXTURE_BASISU='KHR_texture_basisu';var name$4=KHR_TEXTURE_BASISU;function preprocess$2(gltfData,options){var scene=new GLTFScenegraph(gltfData);var json=scene.json;var _iterator20=_createForOfIteratorHelper(json.textures||[]),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var texture=_step20.value;var extension=scene.getObjectExtension(texture,KHR_TEXTURE_BASISU);if(extension){texture.source=extension.source;}scene.removeObjectExtension(texture,KHR_TEXTURE_BASISU);}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}scene.removeExtension(KHR_TEXTURE_BASISU);}var KHR_texture_basisu=/*#__PURE__*/Object.freeze({__proto__:null,name:name$4,preprocess:preprocess$2});var VERSION$1="3.2.6";var DEFAULT_DRACO_OPTIONS={draco:{decoderType:(typeof WebAssembly==="undefined"?"undefined":_typeof(WebAssembly))==='object'?'wasm':'js',libraryPath:'libs/',extraAttributes:{},attributeNameEntry:undefined}};var DracoLoader$1={name:'Draco',id:'draco',module:'draco',shapes:['mesh'],version:VERSION$1,worker:true,extensions:['drc'],mimeTypes:['application/octet-stream'],binary:true,tests:['DRACO'],options:DEFAULT_DRACO_OPTIONS};function getMeshBoundingBox(attributes){var minX=Infinity;var minY=Infinity;var minZ=Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;var positions=attributes.POSITION?attributes.POSITION.value:[];var len=positions&&positions.length;for(var _i500=0;_i500<len;_i500+=3){var x=positions[_i500];var y=positions[_i500+1];var _z4=positions[_i500+2];minX=x<minX?x:minX;minY=y<minY?y:minY;minZ=_z4<minZ?_z4:minZ;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;maxZ=_z4>maxZ?_z4:maxZ;}return[[minX,minY,minZ],[maxX,maxY,maxZ]];}function assert(condition,message){if(!condition){throw new Error(message||'loader assertion failed.');}}var Schema=/*#__PURE__*/function(){function Schema(fields,metadata){_classCallCheck(this,Schema);_defineProperty(this,"fields",void 0);_defineProperty(this,"metadata",void 0);assert(Array.isArray(fields));checkNames(fields);this.fields=fields;this.metadata=metadata||new Map();}_createClass(Schema,[{key:"compareTo",value:function compareTo(other){if(this.metadata!==other.metadata){return false;}if(this.fields.length!==other.fields.length){return false;}for(var _i501=0;_i501<this.fields.length;++_i501){if(!this.fields[_i501].compareTo(other.fields[_i501])){return false;}}return true;}},{key:"select",value:function select(){var nameMap=Object.create(null);for(var _len106=arguments.length,columnNames=new Array(_len106),_key11=0;_key11<_len106;_key11++){columnNames[_key11]=arguments[_key11];}for(var _i502=0,_columnNames=columnNames;_i502<_columnNames.length;_i502++){var _name6=_columnNames[_i502];nameMap[_name6]=true;}var selectedFields=this.fields.filter(function(field){return nameMap[field.name];});return new Schema(selectedFields,this.metadata);}},{key:"selectAt",value:function selectAt(){var _this110=this;for(var _len107=arguments.length,columnIndices=new Array(_len107),_key12=0;_key12<_len107;_key12++){columnIndices[_key12]=arguments[_key12];}var selectedFields=columnIndices.map(function(index){return _this110.fields[index];}).filter(Boolean);return new Schema(selectedFields,this.metadata);}},{key:"assign",value:function assign(schemaOrFields){var fields;var metadata=this.metadata;if(schemaOrFields instanceof Schema){var otherSchema=schemaOrFields;fields=otherSchema.fields;metadata=mergeMaps(mergeMaps(new Map(),this.metadata),otherSchema.metadata);}else{fields=schemaOrFields;}var fieldMap=Object.create(null);var _iterator21=_createForOfIteratorHelper(this.fields),_step21;try{for(_iterator21.s();!(_step21=_iterator21.n()).done;){var field=_step21.value;fieldMap[field.name]=field;}}catch(err){_iterator21.e(err);}finally{_iterator21.f();}var _iterator22=_createForOfIteratorHelper(fields),_step22;try{for(_iterator22.s();!(_step22=_iterator22.n()).done;){var _field=_step22.value;fieldMap[_field.name]=_field;}}catch(err){_iterator22.e(err);}finally{_iterator22.f();}var mergedFields=Object.values(fieldMap);return new Schema(mergedFields,metadata);}}]);return Schema;}();function checkNames(fields){var usedNames={};var _iterator23=_createForOfIteratorHelper(fields),_step23;try{for(_iterator23.s();!(_step23=_iterator23.n()).done;){var field=_step23.value;if(usedNames[field.name]){console.warn('Schema: duplicated field name',field.name,field);}usedNames[field.name]=true;}}catch(err){_iterator23.e(err);}finally{_iterator23.f();}}function mergeMaps(m1,m2){return new Map([].concat(_toConsumableArray(m1||new Map()),_toConsumableArray(m2||new Map())));}var Field=/*#__PURE__*/function(){function Field(name,type){var nullable=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var metadata=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Map();_classCallCheck(this,Field);_defineProperty(this,"name",void 0);_defineProperty(this,"type",void 0);_defineProperty(this,"nullable",void 0);_defineProperty(this,"metadata",void 0);this.name=name;this.type=type;this.nullable=nullable;this.metadata=metadata;}_createClass(Field,[{key:"typeId",get:function get(){return this.type&&this.type.typeId;}},{key:"clone",value:function clone(){return new Field(this.name,this.type,this.nullable,this.metadata);}},{key:"compareTo",value:function compareTo(other){return this.name===other.name&&this.type===other.type&&this.nullable===other.nullable&&this.metadata===other.metadata;}},{key:"toString",value:function toString(){return"".concat(this.type).concat(this.nullable?', nullable':'').concat(this.metadata?", metadata: ".concat(this.metadata):'');}}]);return Field;}();var Type;(function(Type){Type[Type["NONE"]=0]="NONE";Type[Type["Null"]=1]="Null";Type[Type["Int"]=2]="Int";Type[Type["Float"]=3]="Float";Type[Type["Binary"]=4]="Binary";Type[Type["Utf8"]=5]="Utf8";Type[Type["Bool"]=6]="Bool";Type[Type["Decimal"]=7]="Decimal";Type[Type["Date"]=8]="Date";Type[Type["Time"]=9]="Time";Type[Type["Timestamp"]=10]="Timestamp";Type[Type["Interval"]=11]="Interval";Type[Type["List"]=12]="List";Type[Type["Struct"]=13]="Struct";Type[Type["Union"]=14]="Union";Type[Type["FixedSizeBinary"]=15]="FixedSizeBinary";Type[Type["FixedSizeList"]=16]="FixedSizeList";Type[Type["Map"]=17]="Map";Type[Type["Dictionary"]=-1]="Dictionary";Type[Type["Int8"]=-2]="Int8";Type[Type["Int16"]=-3]="Int16";Type[Type["Int32"]=-4]="Int32";Type[Type["Int64"]=-5]="Int64";Type[Type["Uint8"]=-6]="Uint8";Type[Type["Uint16"]=-7]="Uint16";Type[Type["Uint32"]=-8]="Uint32";Type[Type["Uint64"]=-9]="Uint64";Type[Type["Float16"]=-10]="Float16";Type[Type["Float32"]=-11]="Float32";Type[Type["Float64"]=-12]="Float64";Type[Type["DateDay"]=-13]="DateDay";Type[Type["DateMillisecond"]=-14]="DateMillisecond";Type[Type["TimestampSecond"]=-15]="TimestampSecond";Type[Type["TimestampMillisecond"]=-16]="TimestampMillisecond";Type[Type["TimestampMicrosecond"]=-17]="TimestampMicrosecond";Type[Type["TimestampNanosecond"]=-18]="TimestampNanosecond";Type[Type["TimeSecond"]=-19]="TimeSecond";Type[Type["TimeMillisecond"]=-20]="TimeMillisecond";Type[Type["TimeMicrosecond"]=-21]="TimeMicrosecond";Type[Type["TimeNanosecond"]=-22]="TimeNanosecond";Type[Type["DenseUnion"]=-23]="DenseUnion";Type[Type["SparseUnion"]=-24]="SparseUnion";Type[Type["IntervalDayTime"]=-25]="IntervalDayTime";Type[Type["IntervalYearMonth"]=-26]="IntervalYearMonth";})(Type||(Type={}));var _Symbol$toStringTag,_Symbol$toStringTag2,_Symbol$toStringTag7;var DataType=/*#__PURE__*/function(){function DataType(){_classCallCheck(this,DataType);}_createClass(DataType,[{key:"typeId",get:function get(){return Type.NONE;}},{key:"compareTo",value:function compareTo(other){return this===other;}}],[{key:"isNull",value:function isNull(x){return x&&x.typeId===Type.Null;}},{key:"isInt",value:function isInt(x){return x&&x.typeId===Type.Int;}},{key:"isFloat",value:function isFloat(x){return x&&x.typeId===Type.Float;}},{key:"isBinary",value:function isBinary(x){return x&&x.typeId===Type.Binary;}},{key:"isUtf8",value:function isUtf8(x){return x&&x.typeId===Type.Utf8;}},{key:"isBool",value:function isBool(x){return x&&x.typeId===Type.Bool;}},{key:"isDecimal",value:function isDecimal(x){return x&&x.typeId===Type.Decimal;}},{key:"isDate",value:function isDate(x){return x&&x.typeId===Type.Date;}},{key:"isTime",value:function isTime(x){return x&&x.typeId===Type.Time;}},{key:"isTimestamp",value:function isTimestamp(x){return x&&x.typeId===Type.Timestamp;}},{key:"isInterval",value:function isInterval(x){return x&&x.typeId===Type.Interval;}},{key:"isList",value:function isList(x){return x&&x.typeId===Type.List;}},{key:"isStruct",value:function isStruct(x){return x&&x.typeId===Type.Struct;}},{key:"isUnion",value:function isUnion(x){return x&&x.typeId===Type.Union;}},{key:"isFixedSizeBinary",value:function isFixedSizeBinary(x){return x&&x.typeId===Type.FixedSizeBinary;}},{key:"isFixedSizeList",value:function isFixedSizeList(x){return x&&x.typeId===Type.FixedSizeList;}},{key:"isMap",value:function isMap(x){return x&&x.typeId===Type.Map;}},{key:"isDictionary",value:function isDictionary(x){return x&&x.typeId===Type.Dictionary;}}]);return DataType;}();_Symbol$toStringTag=Symbol.toStringTag;var Int=/*#__PURE__*/function(_DataType,_Symbol$toStringTag3){_inherits(Int,_DataType);var _super137=_createSuper(Int);function Int(isSigned,bitWidth){var _this111;_classCallCheck(this,Int);_this111=_super137.call(this);_defineProperty(_assertThisInitialized(_this111),"isSigned",void 0);_defineProperty(_assertThisInitialized(_this111),"bitWidth",void 0);_this111.isSigned=isSigned;_this111.bitWidth=bitWidth;return _this111;}_createClass(Int,[{key:"typeId",get:function get(){return Type.Int;}},{key:_Symbol$toStringTag3,get:function get(){return'Int';}},{key:"toString",value:function toString(){return"".concat(this.isSigned?'I':'Ui',"nt").concat(this.bitWidth);}}]);return Int;}(DataType,_Symbol$toStringTag);var Int8=/*#__PURE__*/function(_Int){_inherits(Int8,_Int);var _super138=_createSuper(Int8);function Int8(){_classCallCheck(this,Int8);return _super138.call(this,true,8);}return _createClass(Int8);}(Int);var Int16=/*#__PURE__*/function(_Int2){_inherits(Int16,_Int2);var _super139=_createSuper(Int16);function Int16(){_classCallCheck(this,Int16);return _super139.call(this,true,16);}return _createClass(Int16);}(Int);var Int32=/*#__PURE__*/function(_Int3){_inherits(Int32,_Int3);var _super140=_createSuper(Int32);function Int32(){_classCallCheck(this,Int32);return _super140.call(this,true,32);}return _createClass(Int32);}(Int);var Uint8=/*#__PURE__*/function(_Int4){_inherits(Uint8,_Int4);var _super141=_createSuper(Uint8);function Uint8(){_classCallCheck(this,Uint8);return _super141.call(this,false,8);}return _createClass(Uint8);}(Int);var Uint16=/*#__PURE__*/function(_Int5){_inherits(Uint16,_Int5);var _super142=_createSuper(Uint16);function Uint16(){_classCallCheck(this,Uint16);return _super142.call(this,false,16);}return _createClass(Uint16);}(Int);var Uint32=/*#__PURE__*/function(_Int6){_inherits(Uint32,_Int6);var _super143=_createSuper(Uint32);function Uint32(){_classCallCheck(this,Uint32);return _super143.call(this,false,32);}return _createClass(Uint32);}(Int);var Precision={HALF:16,SINGLE:32,DOUBLE:64};_Symbol$toStringTag2=Symbol.toStringTag;var Float=/*#__PURE__*/function(_DataType2,_Symbol$toStringTag4){_inherits(Float,_DataType2);var _super144=_createSuper(Float);function Float(precision){var _this112;_classCallCheck(this,Float);_this112=_super144.call(this);_defineProperty(_assertThisInitialized(_this112),"precision",void 0);_this112.precision=precision;return _this112;}_createClass(Float,[{key:"typeId",get:function get(){return Type.Float;}},{key:_Symbol$toStringTag4,get:function get(){return'Float';}},{key:"toString",value:function toString(){return"Float".concat(this.precision);}}]);return Float;}(DataType,_Symbol$toStringTag2);var Float32=/*#__PURE__*/function(_Float){_inherits(Float32,_Float);var _super145=_createSuper(Float32);function Float32(){_classCallCheck(this,Float32);return _super145.call(this,Precision.SINGLE);}return _createClass(Float32);}(Float);var Float64=/*#__PURE__*/function(_Float2){_inherits(Float64,_Float2);var _super146=_createSuper(Float64);function Float64(){_classCallCheck(this,Float64);return _super146.call(this,Precision.DOUBLE);}return _createClass(Float64);}(Float);_Symbol$toStringTag7=Symbol.toStringTag;var FixedSizeList=/*#__PURE__*/function(_DataType3,_Symbol$toStringTag5){_inherits(FixedSizeList,_DataType3);var _super147=_createSuper(FixedSizeList);function FixedSizeList(listSize,child){var _this113;_classCallCheck(this,FixedSizeList);_this113=_super147.call(this);_defineProperty(_assertThisInitialized(_this113),"listSize",void 0);_defineProperty(_assertThisInitialized(_this113),"children",void 0);_this113.listSize=listSize;_this113.children=[child];return _this113;}_createClass(FixedSizeList,[{key:"typeId",get:function get(){return Type.FixedSizeList;}},{key:"valueType",get:function get(){return this.children[0].type;}},{key:"valueField",get:function get(){return this.children[0];}},{key:_Symbol$toStringTag5,get:function get(){return'FixedSizeList';}},{key:"toString",value:function toString(){return"FixedSizeList[".concat(this.listSize,"]<").concat(this.valueType,">");}}]);return FixedSizeList;}(DataType,_Symbol$toStringTag7);function getArrowTypeFromTypedArray(array){switch(array.constructor){case Int8Array:return new Int8();case Uint8Array:return new Uint8();case Int16Array:return new Int16();case Uint16Array:return new Uint16();case Int32Array:return new Int32();case Uint32Array:return new Uint32();case Float32Array:return new Float32();case Float64Array:return new Float64();default:throw new Error('array type not supported');}}function deduceMeshField(attributeName,attribute,optionalMetadata){var type=getArrowTypeFromTypedArray(attribute.value);var metadata=optionalMetadata?optionalMetadata:makeMeshAttributeMetadata(attribute);var field=new Field(attributeName,new FixedSizeList(attribute.size,new Field('value',type)),false,metadata);return field;}function makeMeshAttributeMetadata(attribute){var result=new Map();if('byteOffset'in attribute){result.set('byteOffset',attribute.byteOffset.toString(10));}if('byteStride'in attribute){result.set('byteStride',attribute.byteStride.toString(10));}if('normalized'in attribute){result.set('normalized',attribute.normalized.toString());}return result;}function getDracoSchema(attributes,loaderData,indices){var metadataMap=makeMetadata(loaderData.metadata);var fields=[];var namedLoaderDataAttributes=transformAttributesLoaderData(loaderData.attributes);for(var attributeName in attributes){var attribute=attributes[attributeName];var field=getArrowFieldFromAttribute(attributeName,attribute,namedLoaderDataAttributes[attributeName]);fields.push(field);}if(indices){var indicesField=getArrowFieldFromAttribute('indices',indices);fields.push(indicesField);}return new Schema(fields,metadataMap);}function transformAttributesLoaderData(loaderData){var result={};for(var key in loaderData){var dracoAttribute=loaderData[key];result[dracoAttribute.name||'undefined']=dracoAttribute;}return result;}function getArrowFieldFromAttribute(attributeName,attribute,loaderData){var metadataMap=loaderData?makeMetadata(loaderData.metadata):undefined;var field=deduceMeshField(attributeName,attribute,metadataMap);return field;}function makeMetadata(metadata){var metadataMap=new Map();for(var key in metadata){metadataMap.set("".concat(key,".string"),JSON.stringify(metadata[key]));}return metadataMap;}var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP={POSITION:'POSITION',NORMAL:'NORMAL',COLOR:'COLOR_0',TEX_COORD:'TEXCOORD_0'};var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array};var INDEX_ITEM_SIZE=4;var DracoParser=/*#__PURE__*/function(){function DracoParser(draco){_classCallCheck(this,DracoParser);_defineProperty(this,"draco",void 0);_defineProperty(this,"decoder",void 0);_defineProperty(this,"metadataQuerier",void 0);this.draco=draco;this.decoder=new this.draco.Decoder();this.metadataQuerier=new this.draco.MetadataQuerier();}_createClass(DracoParser,[{key:"destroy",value:function destroy(){this.draco.destroy(this.decoder);this.draco.destroy(this.metadataQuerier);}},{key:"parseSync",value:function parseSync(arrayBuffer){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var buffer=new this.draco.DecoderBuffer();buffer.Init(new Int8Array(arrayBuffer),arrayBuffer.byteLength);this._disableAttributeTransforms(options);var geometry_type=this.decoder.GetEncodedGeometryType(buffer);var dracoGeometry=geometry_type===this.draco.TRIANGULAR_MESH?new this.draco.Mesh():new this.draco.PointCloud();try{var dracoStatus;switch(geometry_type){case this.draco.TRIANGULAR_MESH:dracoStatus=this.decoder.DecodeBufferToMesh(buffer,dracoGeometry);break;case this.draco.POINT_CLOUD:dracoStatus=this.decoder.DecodeBufferToPointCloud(buffer,dracoGeometry);break;default:throw new Error('DRACO: Unknown geometry type.');}if(!dracoStatus.ok()||!dracoGeometry.ptr){var message="DRACO decompression failed: ".concat(dracoStatus.error_msg());throw new Error(message);}var loaderData=this._getDracoLoaderData(dracoGeometry,geometry_type,options);var geometry=this._getMeshData(dracoGeometry,loaderData,options);var boundingBox=getMeshBoundingBox(geometry.attributes);var schema=getDracoSchema(geometry.attributes,loaderData,geometry.indices);var data=_objectSpread(_objectSpread({loader:'draco',loaderData:loaderData,header:{vertexCount:dracoGeometry.num_points(),boundingBox:boundingBox}},geometry),{},{schema:schema});return data;}finally{this.draco.destroy(buffer);if(dracoGeometry){this.draco.destroy(dracoGeometry);}}}},{key:"_getDracoLoaderData",value:function _getDracoLoaderData(dracoGeometry,geometry_type,options){var metadata=this._getTopLevelMetadata(dracoGeometry);var attributes=this._getDracoAttributes(dracoGeometry,options);return{geometry_type:geometry_type,num_attributes:dracoGeometry.num_attributes(),num_points:dracoGeometry.num_points(),num_faces:dracoGeometry instanceof this.draco.Mesh?dracoGeometry.num_faces():0,metadata:metadata,attributes:attributes};}},{key:"_getDracoAttributes",value:function _getDracoAttributes(dracoGeometry,options){var dracoAttributes={};for(var attributeId=0;attributeId<dracoGeometry.num_attributes();attributeId++){var dracoAttribute=this.decoder.GetAttribute(dracoGeometry,attributeId);var metadata=this._getAttributeMetadata(dracoGeometry,attributeId);dracoAttributes[dracoAttribute.unique_id()]={unique_id:dracoAttribute.unique_id(),attribute_type:dracoAttribute.attribute_type(),data_type:dracoAttribute.data_type(),num_components:dracoAttribute.num_components(),byte_offset:dracoAttribute.byte_offset(),byte_stride:dracoAttribute.byte_stride(),normalized:dracoAttribute.normalized(),attribute_index:attributeId,metadata:metadata};var quantization=this._getQuantizationTransform(dracoAttribute,options);if(quantization){dracoAttributes[dracoAttribute.unique_id()].quantization_transform=quantization;}var octahedron=this._getOctahedronTransform(dracoAttribute,options);if(octahedron){dracoAttributes[dracoAttribute.unique_id()].octahedron_transform=octahedron;}}return dracoAttributes;}},{key:"_getMeshData",value:function _getMeshData(dracoGeometry,loaderData,options){var attributes=this._getMeshAttributes(loaderData,dracoGeometry,options);var positionAttribute=attributes.POSITION;if(!positionAttribute){throw new Error('DRACO: No position attribute found.');}if(dracoGeometry instanceof this.draco.Mesh){switch(options.topology){case'triangle-strip':return{topology:'triangle-strip',mode:4,attributes:attributes,indices:{value:this._getTriangleStripIndices(dracoGeometry),size:1}};case'triangle-list':default:return{topology:'triangle-list',mode:5,attributes:attributes,indices:{value:this._getTriangleListIndices(dracoGeometry),size:1}};}}return{topology:'point-list',mode:0,attributes:attributes};}},{key:"_getMeshAttributes",value:function _getMeshAttributes(loaderData,dracoGeometry,options){var attributes={};for(var _i503=0,_Object$values=Object.values(loaderData.attributes);_i503<_Object$values.length;_i503++){var loaderAttribute=_Object$values[_i503];var attributeName=this._deduceAttributeName(loaderAttribute,options);loaderAttribute.name=attributeName;var _this$_getAttributeVa=this._getAttributeValues(dracoGeometry,loaderAttribute),value=_this$_getAttributeVa.value,size=_this$_getAttributeVa.size;attributes[attributeName]={value:value,size:size,byteOffset:loaderAttribute.byte_offset,byteStride:loaderAttribute.byte_stride,normalized:loaderAttribute.normalized};}return attributes;}},{key:"_getTriangleListIndices",value:function _getTriangleListIndices(dracoGeometry){var numFaces=dracoGeometry.num_faces();var numIndices=numFaces*3;var byteLength=numIndices*INDEX_ITEM_SIZE;var ptr=this.draco._malloc(byteLength);try{this.decoder.GetTrianglesUInt32Array(dracoGeometry,byteLength,ptr);return new Uint32Array(this.draco.HEAPF32.buffer,ptr,numIndices).slice();}finally{this.draco._free(ptr);}}},{key:"_getTriangleStripIndices",value:function _getTriangleStripIndices(dracoGeometry){var dracoArray=new this.draco.DracoInt32Array();try{this.decoder.GetTriangleStripsFromMesh(dracoGeometry,dracoArray);return getUint32Array(dracoArray);}finally{this.draco.destroy(dracoArray);}}},{key:"_getAttributeValues",value:function _getAttributeValues(dracoGeometry,attribute){var TypedArrayCtor=DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];var numComponents=attribute.num_components;var numPoints=dracoGeometry.num_points();var numValues=numPoints*numComponents;var byteLength=numValues*TypedArrayCtor.BYTES_PER_ELEMENT;var dataType=getDracoDataType(this.draco,TypedArrayCtor);var value;var ptr=this.draco._malloc(byteLength);try{var dracoAttribute=this.decoder.GetAttribute(dracoGeometry,attribute.attribute_index);this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,dracoAttribute,dataType,byteLength,ptr);value=new TypedArrayCtor(this.draco.HEAPF32.buffer,ptr,numValues).slice();}finally{this.draco._free(ptr);}return{value:value,size:numComponents};}},{key:"_deduceAttributeName",value:function _deduceAttributeName(attribute,options){var uniqueId=attribute.unique_id;for(var _i504=0,_Object$entries4=Object.entries(options.extraAttributes||{});_i504<_Object$entries4.length;_i504++){var _Object$entries4$_i=_slicedToArray(_Object$entries4[_i504],2),attributeName=_Object$entries4$_i[0],attributeUniqueId=_Object$entries4$_i[1];if(attributeUniqueId===uniqueId){return attributeName;}}var thisAttributeType=attribute.attribute_type;for(var dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP){var attributeType=this.draco[dracoAttributeConstant];if(attributeType===thisAttributeType){return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];}}var entryName=options.attributeNameEntry||'name';if(attribute.metadata[entryName]){return attribute.metadata[entryName].string;}return"CUSTOM_ATTRIBUTE_".concat(uniqueId);}},{key:"_getTopLevelMetadata",value:function _getTopLevelMetadata(dracoGeometry){var dracoMetadata=this.decoder.GetMetadata(dracoGeometry);return this._getDracoMetadata(dracoMetadata);}},{key:"_getAttributeMetadata",value:function _getAttributeMetadata(dracoGeometry,attributeId){var dracoMetadata=this.decoder.GetAttributeMetadata(dracoGeometry,attributeId);return this._getDracoMetadata(dracoMetadata);}},{key:"_getDracoMetadata",value:function _getDracoMetadata(dracoMetadata){if(!dracoMetadata||!dracoMetadata.ptr){return{};}var result={};var numEntries=this.metadataQuerier.NumEntries(dracoMetadata);for(var entryIndex=0;entryIndex<numEntries;entryIndex++){var entryName=this.metadataQuerier.GetEntryName(dracoMetadata,entryIndex);result[entryName]=this._getDracoMetadataField(dracoMetadata,entryName);}return result;}},{key:"_getDracoMetadataField",value:function _getDracoMetadataField(dracoMetadata,entryName){var dracoArray=new this.draco.DracoInt32Array();try{this.metadataQuerier.GetIntEntryArray(dracoMetadata,entryName,dracoArray);var intArray=getInt32Array(dracoArray);return{"int":this.metadataQuerier.GetIntEntry(dracoMetadata,entryName),string:this.metadataQuerier.GetStringEntry(dracoMetadata,entryName),"double":this.metadataQuerier.GetDoubleEntry(dracoMetadata,entryName),intArray:intArray};}finally{this.draco.destroy(dracoArray);}}},{key:"_disableAttributeTransforms",value:function _disableAttributeTransforms(options){var _options$quantizedAtt=options.quantizedAttributes,quantizedAttributes=_options$quantizedAtt===void 0?[]:_options$quantizedAtt,_options$octahedronAt=options.octahedronAttributes,octahedronAttributes=_options$octahedronAt===void 0?[]:_options$octahedronAt;var skipAttributes=[].concat(_toConsumableArray(quantizedAttributes),_toConsumableArray(octahedronAttributes));var _iterator24=_createForOfIteratorHelper(skipAttributes),_step24;try{for(_iterator24.s();!(_step24=_iterator24.n()).done;){var dracoAttributeName=_step24.value;this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);}}catch(err){_iterator24.e(err);}finally{_iterator24.f();}}},{key:"_getQuantizationTransform",value:function _getQuantizationTransform(dracoAttribute,options){var _this114=this;var _options$quantizedAtt2=options.quantizedAttributes,quantizedAttributes=_options$quantizedAtt2===void 0?[]:_options$quantizedAtt2;var attribute_type=dracoAttribute.attribute_type();var skip=quantizedAttributes.map(function(type){return _this114.decoder[type];}).includes(attribute_type);if(skip){var _transform2=new this.draco.AttributeQuantizationTransform();try{if(_transform2.InitFromAttribute(dracoAttribute)){return{quantization_bits:_transform2.quantization_bits(),range:_transform2.range(),min_values:new Float32Array([1,2,3]).map(function(i){return _transform2.min_value(i);})};}}finally{this.draco.destroy(_transform2);}}return null;}},{key:"_getOctahedronTransform",value:function _getOctahedronTransform(dracoAttribute,options){var _this115=this;var _options$octahedronAt2=options.octahedronAttributes,octahedronAttributes=_options$octahedronAt2===void 0?[]:_options$octahedronAt2;var attribute_type=dracoAttribute.attribute_type();var octahedron=octahedronAttributes.map(function(type){return _this115.decoder[type];}).includes(attribute_type);if(octahedron){var _transform3=new this.draco.AttributeQuantizationTransform();try{if(_transform3.InitFromAttribute(dracoAttribute)){return{quantization_bits:_transform3.quantization_bits()};}}finally{this.draco.destroy(_transform3);}}return null;}}]);return DracoParser;}();function getDracoDataType(draco,attributeType){switch(attributeType){case Float32Array:return draco.DT_FLOAT32;case Int8Array:return draco.DT_INT8;case Int16Array:return draco.DT_INT16;case Int32Array:return draco.DT_INT32;case Uint8Array:return draco.DT_UINT8;case Uint16Array:return draco.DT_UINT16;case Uint32Array:return draco.DT_UINT32;default:return draco.DT_INVALID;}}function getInt32Array(dracoArray){var numValues=dracoArray.size();var intArray=new Int32Array(numValues);for(var _i505=0;_i505<numValues;_i505++){intArray[_i505]=dracoArray.GetValue(_i505);}return intArray;}function getUint32Array(dracoArray){var numValues=dracoArray.size();var intArray=new Int32Array(numValues);for(var _i506=0;_i506<numValues;_i506++){intArray[_i506]=dracoArray.GetValue(_i506);}return intArray;}var DRACO_VERSION='1.4.1';var DRACO_JS_DECODER_URL="https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_VERSION,"/draco_decoder.js");var DRACO_WASM_WRAPPER_URL="https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_VERSION,"/draco_wasm_wrapper.js");var DRACO_WASM_DECODER_URL="https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_VERSION,"/draco_decoder.wasm");var loadDecoderPromise;function loadDracoDecoderModule(_x68){return _loadDracoDecoderModule.apply(this,arguments);}function _loadDracoDecoderModule(){_loadDracoDecoderModule=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37(options){var modules;return _regeneratorRuntime().wrap(function _callee37$(_context41){while(1){switch(_context41.prev=_context41.next){case 0:modules=options.modules||{};if(modules.draco3d){loadDecoderPromise=loadDecoderPromise||modules.draco3d.createDecoderModule({}).then(function(draco){return{draco:draco};});}else{loadDecoderPromise=loadDecoderPromise||loadDracoDecoder(options);}_context41.next=4;return loadDecoderPromise;case 4:return _context41.abrupt("return",_context41.sent);case 5:case"end":return _context41.stop();}}},_callee37);}));return _loadDracoDecoderModule.apply(this,arguments);}function loadDracoDecoder(_x69){return _loadDracoDecoder.apply(this,arguments);}function _loadDracoDecoder(){_loadDracoDecoder=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(options){var DracoDecoderModule,wasmBinary,_yield$Promise$all5,_yield$Promise$all6;return _regeneratorRuntime().wrap(function _callee38$(_context42){while(1){switch(_context42.prev=_context42.next){case 0:_context42.t0=options.draco&&options.draco.decoderType;_context42.next=_context42.t0==='js'?3:_context42.t0==='wasm'?7:7;break;case 3:_context42.next=5;return loadLibrary(DRACO_JS_DECODER_URL,'draco',options);case 5:DracoDecoderModule=_context42.sent;return _context42.abrupt("break",21);case 7:_context42.t1=Promise;_context42.next=10;return loadLibrary(DRACO_WASM_WRAPPER_URL,'draco',options);case 10:_context42.t2=_context42.sent;_context42.next=13;return loadLibrary(DRACO_WASM_DECODER_URL,'draco',options);case 13:_context42.t3=_context42.sent;_context42.t4=[_context42.t2,_context42.t3];_context42.next=17;return _context42.t1.all.call(_context42.t1,_context42.t4);case 17:_yield$Promise$all5=_context42.sent;_yield$Promise$all6=_slicedToArray(_yield$Promise$all5,2);DracoDecoderModule=_yield$Promise$all6[0];wasmBinary=_yield$Promise$all6[1];case 21:DracoDecoderModule=DracoDecoderModule||globalThis.DracoDecoderModule;_context42.next=24;return initializeDracoDecoder(DracoDecoderModule,wasmBinary);case 24:return _context42.abrupt("return",_context42.sent);case 25:case"end":return _context42.stop();}}},_callee38);}));return _loadDracoDecoder.apply(this,arguments);}function initializeDracoDecoder(DracoDecoderModule,wasmBinary){var options={};if(wasmBinary){options.wasmBinary=wasmBinary;}return new Promise(function(resolve){DracoDecoderModule(_objectSpread(_objectSpread({},options),{},{onModuleLoaded:function onModuleLoaded(draco){return resolve({draco:draco});}}));});}({id:isBrowser$3?'draco-writer':'draco-writer-nodejs',name:'Draco compressed geometry writer',module:'draco',version:VERSION$1,worker:true,options:{draco:{},source:null}});var DracoLoader=_objectSpread(_objectSpread({},DracoLoader$1),{},{parse:parse$2});function parse$2(_x70,_x71){return _parse$2.apply(this,arguments);}function _parse$2(){_parse$2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(arrayBuffer,options){var _yield$loadDracoDecod,draco,dracoParser;return _regeneratorRuntime().wrap(function _callee39$(_context43){while(1){switch(_context43.prev=_context43.next){case 0:_context43.next=2;return loadDracoDecoderModule(options);case 2:_yield$loadDracoDecod=_context43.sent;draco=_yield$loadDracoDecod.draco;dracoParser=new DracoParser(draco);_context43.prev=5;return _context43.abrupt("return",dracoParser.parseSync(arrayBuffer,options===null||options===void 0?void 0:options.draco));case 7:_context43.prev=7;dracoParser.destroy();return _context43.finish(7);case 10:case"end":return _context43.stop();}}},_callee39,null,[[5,,7,10]]);}));return _parse$2.apply(this,arguments);}function getGLTFAccessors(attributes){var accessors={};for(var _name7 in attributes){var attribute=attributes[_name7];if(_name7!=='indices'){var glTFAccessor=getGLTFAccessor(attribute);accessors[_name7]=glTFAccessor;}}return accessors;}function getGLTFAccessor(attribute){var _getAccessorData=getAccessorData(attribute),buffer=_getAccessorData.buffer,size=_getAccessorData.size,count=_getAccessorData.count;var glTFAccessor={value:buffer,size:size,byteOffset:0,count:count,type:getAccessorTypeFromSize(size),componentType:getComponentTypeFromArray(buffer)};return glTFAccessor;}function getAccessorData(attribute){var buffer=attribute;var size=1;var count=0;if(attribute&&attribute.value){buffer=attribute.value;size=attribute.size||1;}if(buffer){if(!ArrayBuffer.isView(buffer)){buffer=toTypedArray(buffer,Float32Array);}count=buffer.length/size;}return{buffer:buffer,size:size,count:count};}function toTypedArray(array,ArrayType){var convertTypedArrays=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!array){return null;}if(Array.isArray(array)){return new ArrayType(array);}if(convertTypedArrays&&!(array instanceof ArrayType)){return new ArrayType(array);}return array;}var KHR_DRACO_MESH_COMPRESSION='KHR_draco_mesh_compression';var name$3=KHR_DRACO_MESH_COMPRESSION;function preprocess$1(gltfData,options,context){var scenegraph=new GLTFScenegraph(gltfData);var _iterator25=_createForOfIteratorHelper(makeMeshPrimitiveIterator(scenegraph)),_step25;try{for(_iterator25.s();!(_step25=_iterator25.n()).done;){var _primitive=_step25.value;if(scenegraph.getObjectExtension(_primitive,KHR_DRACO_MESH_COMPRESSION));}}catch(err){_iterator25.e(err);}finally{_iterator25.f();}}function decode$3(_x72,_x73,_x74){return _decode$2.apply(this,arguments);}function _decode$2(){_decode$2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40(gltfData,options,context){var _options$gltf,scenegraph,promises,_iterator42,_step42,_primitive5;return _regeneratorRuntime().wrap(function _callee40$(_context44){while(1){switch(_context44.prev=_context44.next){case 0:if(options!==null&&options!==void 0&&(_options$gltf=options.gltf)!==null&&_options$gltf!==void 0&&_options$gltf.decompressMeshes){_context44.next=2;break;}return _context44.abrupt("return");case 2:scenegraph=new GLTFScenegraph(gltfData);promises=[];_iterator42=_createForOfIteratorHelper(makeMeshPrimitiveIterator(scenegraph));try{for(_iterator42.s();!(_step42=_iterator42.n()).done;){_primitive5=_step42.value;if(scenegraph.getObjectExtension(_primitive5,KHR_DRACO_MESH_COMPRESSION)){promises.push(decompressPrimitive(scenegraph,_primitive5,options,context));}}}catch(err){_iterator42.e(err);}finally{_iterator42.f();}_context44.next=8;return Promise.all(promises);case 8:scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);case 9:case"end":return _context44.stop();}}},_callee40);}));return _decode$2.apply(this,arguments);}function encode$3(gltfData){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var scenegraph=new GLTFScenegraph(gltfData);var _iterator26=_createForOfIteratorHelper(scenegraph.json.meshes||[]),_step26;try{for(_iterator26.s();!(_step26=_iterator26.n()).done;){var _mesh3=_step26.value;compressMesh(_mesh3);scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);}}catch(err){_iterator26.e(err);}finally{_iterator26.f();}}function decompressPrimitive(_x75,_x76,_x77,_x78){return _decompressPrimitive.apply(this,arguments);}function _decompressPrimitive(){_decompressPrimitive=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41(scenegraph,primitive,options,context){var dracoExtension,buffer,bufferCopy,parse,dracoOptions,decodedData,decodedAttributes,_i589,_Object$entries5,_Object$entries5$_i,attributeName,decodedAttribute,accessorIndex,accessor;return _regeneratorRuntime().wrap(function _callee41$(_context45){while(1){switch(_context45.prev=_context45.next){case 0:dracoExtension=scenegraph.getObjectExtension(primitive,KHR_DRACO_MESH_COMPRESSION);if(dracoExtension){_context45.next=3;break;}return _context45.abrupt("return");case 3:buffer=scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);bufferCopy=sliceArrayBuffer(buffer.buffer,buffer.byteOffset);parse=context.parse;dracoOptions=_objectSpread({},options);delete dracoOptions['3d-tiles'];_context45.next=10;return parse(bufferCopy,DracoLoader,dracoOptions,context);case 10:decodedData=_context45.sent;decodedAttributes=getGLTFAccessors(decodedData.attributes);for(_i589=0,_Object$entries5=Object.entries(decodedAttributes);_i589<_Object$entries5.length;_i589++){_Object$entries5$_i=_slicedToArray(_Object$entries5[_i589],2),attributeName=_Object$entries5$_i[0],decodedAttribute=_Object$entries5$_i[1];if(attributeName in primitive.attributes){accessorIndex=primitive.attributes[attributeName];accessor=scenegraph.getAccessor(accessorIndex);if(accessor!==null&&accessor!==void 0&&accessor.min&&accessor!==null&&accessor!==void 0&&accessor.max){decodedAttribute.min=accessor.min;decodedAttribute.max=accessor.max;}}}primitive.attributes=decodedAttributes;if(decodedData.indices){primitive.indices=getGLTFAccessor(decodedData.indices);}checkPrimitive(primitive);case 16:case"end":return _context45.stop();}}},_callee41);}));return _decompressPrimitive.apply(this,arguments);}function compressMesh(attributes,indices){var mode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:4;var options=arguments.length>3?arguments[3]:undefined;var context=arguments.length>4?arguments[4]:undefined;var _context$parseSync;if(!options.DracoWriter){throw new Error('options.gltf.DracoWriter not provided');}var compressedData=options.DracoWriter.encodeSync({attributes:attributes});var decodedData=context===null||context===void 0?void 0:(_context$parseSync=context.parseSync)===null||_context$parseSync===void 0?void 0:_context$parseSync.call(context,{attributes:attributes});var fauxAccessors=options._addFauxAttributes(decodedData.attributes);var bufferViewIndex=options.addBufferView(compressedData);var glTFMesh={primitives:[{attributes:fauxAccessors,mode:mode,extensions:_defineProperty2({},KHR_DRACO_MESH_COMPRESSION,{bufferView:bufferViewIndex,attributes:fauxAccessors})}]};return glTFMesh;}function checkPrimitive(primitive){if(!primitive.attributes&&Object.keys(primitive.attributes).length>0){throw new Error('glTF: Empty primitive detected: Draco decompression failure?');}}function makeMeshPrimitiveIterator(scenegraph){var _iterator27,_step27,_mesh4,_iterator28,_step28,_primitive2;return _regeneratorRuntime().wrap(function makeMeshPrimitiveIterator$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_iterator27=_createForOfIteratorHelper(scenegraph.json.meshes||[]);_context10.prev=1;_iterator27.s();case 3:if((_step27=_iterator27.n()).done){_context10.next=24;break;}_mesh4=_step27.value;_iterator28=_createForOfIteratorHelper(_mesh4.primitives);_context10.prev=6;_iterator28.s();case 8:if((_step28=_iterator28.n()).done){_context10.next=14;break;}_primitive2=_step28.value;_context10.next=12;return _primitive2;case 12:_context10.next=8;break;case 14:_context10.next=19;break;case 16:_context10.prev=16;_context10.t0=_context10["catch"](6);_iterator28.e(_context10.t0);case 19:_context10.prev=19;_iterator28.f();return _context10.finish(19);case 22:_context10.next=3;break;case 24:_context10.next=29;break;case 26:_context10.prev=26;_context10.t1=_context10["catch"](1);_iterator27.e(_context10.t1);case 29:_context10.prev=29;_iterator27.f();return _context10.finish(29);case 32:case"end":return _context10.stop();}}},_marked3,null,[[1,26,29,32],[6,16,19,22]]);}var KHR_draco_mesh_compression=/*#__PURE__*/Object.freeze({__proto__:null,name:name$3,preprocess:preprocess$1,decode:decode$3,encode:encode$3});var KHR_LIGHTS_PUNCTUAL='KHR_lights_punctual';var name$2=KHR_LIGHTS_PUNCTUAL;function decode$2(_x79){return _decode$3.apply(this,arguments);}function _decode$3(){_decode$3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42(gltfData){var gltfScenegraph,json,extension,_iterator43,_step43,_node12,nodeExtension;return _regeneratorRuntime().wrap(function _callee42$(_context46){while(1){switch(_context46.prev=_context46.next){case 0:gltfScenegraph=new GLTFScenegraph(gltfData);json=gltfScenegraph.json;extension=gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);if(extension){gltfScenegraph.json.lights=extension.lights;gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);}_iterator43=_createForOfIteratorHelper(json.nodes||[]);try{for(_iterator43.s();!(_step43=_iterator43.n()).done;){_node12=_step43.value;nodeExtension=gltfScenegraph.getObjectExtension(_node12,KHR_LIGHTS_PUNCTUAL);if(nodeExtension){_node12.light=nodeExtension.light;}gltfScenegraph.removeObjectExtension(_node12,KHR_LIGHTS_PUNCTUAL);}}catch(err){_iterator43.e(err);}finally{_iterator43.f();}case 6:case"end":return _context46.stop();}}},_callee42);}));return _decode$3.apply(this,arguments);}function encode$2(_x80){return _encode$.apply(this,arguments);}function _encode$(){_encode$=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43(gltfData){var gltfScenegraph,json,extension,_iterator44,_step44,light,_node13;return _regeneratorRuntime().wrap(function _callee43$(_context47){while(1){switch(_context47.prev=_context47.next){case 0:gltfScenegraph=new GLTFScenegraph(gltfData);json=gltfScenegraph.json;if(json.lights){extension=gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);assert$1(!extension.lights);extension.lights=json.lights;delete json.lights;}if(gltfScenegraph.json.lights){_iterator44=_createForOfIteratorHelper(gltfScenegraph.json.lights);try{for(_iterator44.s();!(_step44=_iterator44.n()).done;){light=_step44.value;_node13=light.node;gltfScenegraph.addObjectExtension(_node13,KHR_LIGHTS_PUNCTUAL,light);}}catch(err){_iterator44.e(err);}finally{_iterator44.f();}delete gltfScenegraph.json.lights;}case 4:case"end":return _context47.stop();}}},_callee43);}));return _encode$.apply(this,arguments);}var KHR_lights_punctual=/*#__PURE__*/Object.freeze({__proto__:null,name:name$2,decode:decode$2,encode:encode$2});var KHR_MATERIALS_UNLIT='KHR_materials_unlit';var name$1=KHR_MATERIALS_UNLIT;function decode$1(_x81){return _decode$4.apply(this,arguments);}function _decode$4(){_decode$4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(gltfData){var gltfScenegraph,json,_iterator45,_step45,material,extension;return _regeneratorRuntime().wrap(function _callee44$(_context48){while(1){switch(_context48.prev=_context48.next){case 0:gltfScenegraph=new GLTFScenegraph(gltfData);json=gltfScenegraph.json;gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);_iterator45=_createForOfIteratorHelper(json.materials||[]);try{for(_iterator45.s();!(_step45=_iterator45.n()).done;){material=_step45.value;extension=material.extensions&&material.extensions.KHR_materials_unlit;if(extension){material.unlit=true;}gltfScenegraph.removeObjectExtension(material,KHR_MATERIALS_UNLIT);}}catch(err){_iterator45.e(err);}finally{_iterator45.f();}case 5:case"end":return _context48.stop();}}},_callee44);}));return _decode$4.apply(this,arguments);}function encode$1(gltfData){var gltfScenegraph=new GLTFScenegraph(gltfData);var json=gltfScenegraph.json;if(gltfScenegraph.materials){var _iterator29=_createForOfIteratorHelper(json.materials||[]),_step29;try{for(_iterator29.s();!(_step29=_iterator29.n()).done;){var material=_step29.value;if(material.unlit){delete material.unlit;gltfScenegraph.addObjectExtension(material,KHR_MATERIALS_UNLIT,{});gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);}}}catch(err){_iterator29.e(err);}finally{_iterator29.f();}}}var KHR_materials_unlit=/*#__PURE__*/Object.freeze({__proto__:null,name:name$1,decode:decode$1,encode:encode$1});var KHR_TECHNIQUES_WEBGL='KHR_techniques_webgl';var name=KHR_TECHNIQUES_WEBGL;function decode(_x82){return _decode.apply(this,arguments);}function _decode(){_decode=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(gltfData){var gltfScenegraph,json,extension,techniques,_iterator46,_step46,material,materialExtension;return _regeneratorRuntime().wrap(function _callee45$(_context49){while(1){switch(_context49.prev=_context49.next){case 0:gltfScenegraph=new GLTFScenegraph(gltfData);json=gltfScenegraph.json;extension=gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);if(extension){techniques=resolveTechniques(extension,gltfScenegraph);_iterator46=_createForOfIteratorHelper(json.materials||[]);try{for(_iterator46.s();!(_step46=_iterator46.n()).done;){material=_step46.value;materialExtension=gltfScenegraph.getObjectExtension(material,KHR_TECHNIQUES_WEBGL);if(materialExtension){material.technique=Object.assign({},materialExtension,techniques[materialExtension.technique]);material.technique.values=resolveValues(material.technique,gltfScenegraph);}gltfScenegraph.removeObjectExtension(material,KHR_TECHNIQUES_WEBGL);}}catch(err){_iterator46.e(err);}finally{_iterator46.f();}gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);}case 4:case"end":return _context49.stop();}}},_callee45);}));return _decode.apply(this,arguments);}function encode(_x83,_x84){return _encode.apply(this,arguments);}function _encode(){_encode=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46(gltfData,options){return _regeneratorRuntime().wrap(function _callee46$(_context50){while(1){switch(_context50.prev=_context50.next){case 0:case"end":return _context50.stop();}}},_callee46);}));return _encode.apply(this,arguments);}function resolveTechniques(techniquesExtension,gltfScenegraph){var _techniquesExtension$=techniquesExtension.programs,programs=_techniquesExtension$===void 0?[]:_techniquesExtension$,_techniquesExtension$2=techniquesExtension.shaders,shaders=_techniquesExtension$2===void 0?[]:_techniquesExtension$2,_techniquesExtension$3=techniquesExtension.techniques,techniques=_techniquesExtension$3===void 0?[]:_techniquesExtension$3;var textDecoder=new TextDecoder();shaders.forEach(function(shader){if(Number.isFinite(shader.bufferView)){shader.code=textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));}else{throw new Error('KHR_techniques_webgl: no shader code');}});programs.forEach(function(program){program.fragmentShader=shaders[program.fragmentShader];program.vertexShader=shaders[program.vertexShader];});techniques.forEach(function(technique){technique.program=programs[technique.program];});return techniques;}function resolveValues(technique,gltfScenegraph){var values=Object.assign({},technique.values);Object.keys(technique.uniforms||{}).forEach(function(uniform){if(technique.uniforms[uniform].value&&!(uniform in values)){values[uniform]=technique.uniforms[uniform].value;}});Object.keys(values).forEach(function(uniform){if(_typeof(values[uniform])==='object'&&values[uniform].index!==undefined){values[uniform].texture=gltfScenegraph.getTexture(values[uniform].index);}});return values;}var KHR_techniques_webgl=/*#__PURE__*/Object.freeze({__proto__:null,name:name,decode:decode,encode:encode});var EXTENSIONS=[EXT_meshopt_compression,EXT_texture_webp,KHR_texture_basisu,KHR_draco_mesh_compression,KHR_lights_punctual,KHR_materials_unlit,KHR_techniques_webgl];function preprocessExtensions(gltf){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var context=arguments.length>2?arguments[2]:undefined;var extensions=EXTENSIONS.filter(function(extension){return useExtension(extension.name,options);});var _iterator30=_createForOfIteratorHelper(extensions),_step30;try{for(_iterator30.s();!(_step30=_iterator30.n()).done;){var extension=_step30.value;var _extension$preprocess;(_extension$preprocess=extension.preprocess)===null||_extension$preprocess===void 0?void 0:_extension$preprocess.call(extension,gltf,options,context);}}catch(err){_iterator30.e(err);}finally{_iterator30.f();}}function decodeExtensions(_x85){return _decodeExtensions.apply(this,arguments);}function _decodeExtensions(){_decodeExtensions=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(gltf){var options,context,extensions,_iterator47,_step47,extension,_extension$decode,_args45=arguments;return _regeneratorRuntime().wrap(function _callee47$(_context51){while(1){switch(_context51.prev=_context51.next){case 0:options=_args45.length>1&&_args45[1]!==undefined?_args45[1]:{};context=_args45.length>2?_args45[2]:undefined;extensions=EXTENSIONS.filter(function(extension){return useExtension(extension.name,options);});_iterator47=_createForOfIteratorHelper(extensions);_context51.prev=4;_iterator47.s();case 6:if((_step47=_iterator47.n()).done){_context51.next=12;break;}extension=_step47.value;_context51.next=10;return(_extension$decode=extension.decode)===null||_extension$decode===void 0?void 0:_extension$decode.call(extension,gltf,options,context);case 10:_context51.next=6;break;case 12:_context51.next=17;break;case 14:_context51.prev=14;_context51.t0=_context51["catch"](4);_iterator47.e(_context51.t0);case 17:_context51.prev=17;_iterator47.f();return _context51.finish(17);case 20:case"end":return _context51.stop();}}},_callee47,null,[[4,14,17,20]]);}));return _decodeExtensions.apply(this,arguments);}function useExtension(extensionName,options){var _options$gltf;var excludes=(options===null||options===void 0?void 0:(_options$gltf=options.gltf)===null||_options$gltf===void 0?void 0:_options$gltf.excludeExtensions)||{};var exclude=extensionName in excludes&&!excludes[extensionName];return!exclude;}var KHR_BINARY_GLTF='KHR_binary_glTF';function preprocess(gltfData){var gltfScenegraph=new GLTFScenegraph(gltfData);var json=gltfScenegraph.json;var _iterator31=_createForOfIteratorHelper(json.images||[]),_step31;try{for(_iterator31.s();!(_step31=_iterator31.n()).done;){var _image7=_step31.value;var extension=gltfScenegraph.getObjectExtension(_image7,KHR_BINARY_GLTF);if(extension){Object.assign(_image7,extension);}gltfScenegraph.removeObjectExtension(_image7,KHR_BINARY_GLTF);}}catch(err){_iterator31.e(err);}finally{_iterator31.f();}if(json.buffers&&json.buffers[0]){delete json.buffers[0].uri;}gltfScenegraph.removeExtension(KHR_BINARY_GLTF);}var GLTF_ARRAYS={accessors:'accessor',animations:'animation',buffers:'buffer',bufferViews:'bufferView',images:'image',materials:'material',meshes:'mesh',nodes:'node',samplers:'sampler',scenes:'scene',skins:'skin',textures:'texture'};var GLTF_KEYS={accessor:'accessors',animations:'animation',buffer:'buffers',bufferView:'bufferViews',image:'images',material:'materials',mesh:'meshes',node:'nodes',sampler:'samplers',scene:'scenes',skin:'skins',texture:'textures'};var GLTFV1Normalizer=/*#__PURE__*/function(){function GLTFV1Normalizer(){_classCallCheck(this,GLTFV1Normalizer);_defineProperty(this,"idToIndexMap",{animations:{},accessors:{},buffers:{},bufferViews:{},images:{},materials:{},meshes:{},nodes:{},samplers:{},scenes:{},skins:{},textures:{}});_defineProperty(this,"json",void 0);}_createClass(GLTFV1Normalizer,[{key:"normalize",value:function normalize(gltf,options){this.json=gltf.json;var json=gltf.json;switch(json.asset&&json.asset.version){case'2.0':return;case undefined:case'1.0':break;default:console.warn("glTF: Unknown version ".concat(json.asset.version));return;}if(!options.normalize){throw new Error('glTF v1 is not supported.');}console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');this._addAsset(json);this._convertTopLevelObjectsToArrays(json);preprocess(gltf);this._convertObjectIdsToArrayIndices(json);this._updateObjects(json);this._updateMaterial(json);}},{key:"_addAsset",value:function _addAsset(json){json.asset=json.asset||{};json.asset.version='2.0';json.asset.generator=json.asset.generator||'Normalized to glTF 2.0 by loaders.gl';}},{key:"_convertTopLevelObjectsToArrays",value:function _convertTopLevelObjectsToArrays(json){for(var arrayName in GLTF_ARRAYS){this._convertTopLevelObjectToArray(json,arrayName);}}},{key:"_convertTopLevelObjectToArray",value:function _convertTopLevelObjectToArray(json,mapName){var objectMap=json[mapName];if(!objectMap||Array.isArray(objectMap)){return;}json[mapName]=[];for(var id in objectMap){var object=objectMap[id];object.id=object.id||id;var index=json[mapName].length;json[mapName].push(object);this.idToIndexMap[mapName][id]=index;}}},{key:"_convertObjectIdsToArrayIndices",value:function _convertObjectIdsToArrayIndices(json){for(var arrayName in GLTF_ARRAYS){this._convertIdsToIndices(json,arrayName);}if('scene'in json){json.scene=this._convertIdToIndex(json.scene,'scene');}var _iterator32=_createForOfIteratorHelper(json.textures),_step32;try{for(_iterator32.s();!(_step32=_iterator32.n()).done;){var texture=_step32.value;this._convertTextureIds(texture);}}catch(err){_iterator32.e(err);}finally{_iterator32.f();}var _iterator33=_createForOfIteratorHelper(json.meshes),_step33;try{for(_iterator33.s();!(_step33=_iterator33.n()).done;){var _mesh5=_step33.value;this._convertMeshIds(_mesh5);}}catch(err){_iterator33.e(err);}finally{_iterator33.f();}var _iterator34=_createForOfIteratorHelper(json.nodes),_step34;try{for(_iterator34.s();!(_step34=_iterator34.n()).done;){var _node4=_step34.value;this._convertNodeIds(_node4);}}catch(err){_iterator34.e(err);}finally{_iterator34.f();}var _iterator35=_createForOfIteratorHelper(json.scenes),_step35;try{for(_iterator35.s();!(_step35=_iterator35.n()).done;){var _node5=_step35.value;this._convertSceneIds(_node5);}}catch(err){_iterator35.e(err);}finally{_iterator35.f();}}},{key:"_convertTextureIds",value:function _convertTextureIds(texture){if(texture.source){texture.source=this._convertIdToIndex(texture.source,'image');}}},{key:"_convertMeshIds",value:function _convertMeshIds(mesh){var _iterator36=_createForOfIteratorHelper(mesh.primitives),_step36;try{for(_iterator36.s();!(_step36=_iterator36.n()).done;){var _primitive3=_step36.value;var attributes=_primitive3.attributes,indices=_primitive3.indices,material=_primitive3.material;for(var attributeName in attributes){attributes[attributeName]=this._convertIdToIndex(attributes[attributeName],'accessor');}if(indices){_primitive3.indices=this._convertIdToIndex(indices,'accessor');}if(material){_primitive3.material=this._convertIdToIndex(material,'material');}}}catch(err){_iterator36.e(err);}finally{_iterator36.f();}}},{key:"_convertNodeIds",value:function _convertNodeIds(node){var _this116=this;if(node.children){node.children=node.children.map(function(child){return _this116._convertIdToIndex(child,'node');});}if(node.meshes){node.meshes=node.meshes.map(function(mesh){return _this116._convertIdToIndex(mesh,'mesh');});}}},{key:"_convertSceneIds",value:function _convertSceneIds(scene){var _this117=this;if(scene.nodes){scene.nodes=scene.nodes.map(function(node){return _this117._convertIdToIndex(node,'node');});}}},{key:"_convertIdsToIndices",value:function _convertIdsToIndices(json,topLevelArrayName){if(!json[topLevelArrayName]){console.warn("gltf v1: json doesn't contain attribute ".concat(topLevelArrayName));json[topLevelArrayName]=[];}var _iterator37=_createForOfIteratorHelper(json[topLevelArrayName]),_step37;try{for(_iterator37.s();!(_step37=_iterator37.n()).done;){var object=_step37.value;for(var key in object){var id=object[key];var index=this._convertIdToIndex(id,key);object[key]=index;}}}catch(err){_iterator37.e(err);}finally{_iterator37.f();}}},{key:"_convertIdToIndex",value:function _convertIdToIndex(id,key){var arrayName=GLTF_KEYS[key];if(arrayName in this.idToIndexMap){var index=this.idToIndexMap[arrayName][id];if(!Number.isFinite(index)){throw new Error("gltf v1: failed to resolve ".concat(key," with id ").concat(id));}return index;}return id;}},{key:"_updateObjects",value:function _updateObjects(json){var _iterator38=_createForOfIteratorHelper(this.json.buffers),_step38;try{for(_iterator38.s();!(_step38=_iterator38.n()).done;){var buffer=_step38.value;delete buffer.type;}}catch(err){_iterator38.e(err);}finally{_iterator38.f();}}},{key:"_updateMaterial",value:function _updateMaterial(json){var _iterator39=_createForOfIteratorHelper(json.materials),_step39;try{var _loop6=function _loop6(){var material=_step39.value;material.pbrMetallicRoughness={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1};var textureId=((_material$values=material.values)===null||_material$values===void 0?void 0:_material$values.tex)||((_material$values2=material.values)===null||_material$values2===void 0?void 0:_material$values2.texture2d_0);var textureIndex=json.textures.findIndex(function(texture){return texture.id===textureId;});if(textureIndex!==-1){material.pbrMetallicRoughness.baseColorTexture={index:textureIndex};}};for(_iterator39.s();!(_step39=_iterator39.n()).done;){var _material$values,_material$values2;_loop6();}}catch(err){_iterator39.e(err);}finally{_iterator39.f();}}}]);return GLTFV1Normalizer;}();function normalizeGLTFV1(gltf){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return new GLTFV1Normalizer().normalize(gltf,options);}var COMPONENTS={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16};var BYTES={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4};var GL_SAMPLER={TEXTURE_MAG_FILTER:0x2800,TEXTURE_MIN_FILTER:0x2801,TEXTURE_WRAP_S:0x2802,TEXTURE_WRAP_T:0x2803,REPEAT:0x2901,LINEAR:0x2601,NEAREST_MIPMAP_LINEAR:0x2702};var SAMPLER_PARAMETER_GLTF_TO_GL={magFilter:GL_SAMPLER.TEXTURE_MAG_FILTER,minFilter:GL_SAMPLER.TEXTURE_MIN_FILTER,wrapS:GL_SAMPLER.TEXTURE_WRAP_S,wrapT:GL_SAMPLER.TEXTURE_WRAP_T};var DEFAULT_SAMPLER=(_DEFAULT_SAMPLER={},_defineProperty2(_DEFAULT_SAMPLER,GL_SAMPLER.TEXTURE_MAG_FILTER,GL_SAMPLER.LINEAR),_defineProperty2(_DEFAULT_SAMPLER,GL_SAMPLER.TEXTURE_MIN_FILTER,GL_SAMPLER.NEAREST_MIPMAP_LINEAR),_defineProperty2(_DEFAULT_SAMPLER,GL_SAMPLER.TEXTURE_WRAP_S,GL_SAMPLER.REPEAT),_defineProperty2(_DEFAULT_SAMPLER,GL_SAMPLER.TEXTURE_WRAP_T,GL_SAMPLER.REPEAT),_DEFAULT_SAMPLER);function getBytesFromComponentType(componentType){return BYTES[componentType];}function getSizeFromAccessorType(type){return COMPONENTS[type];}var GLTFPostProcessor=/*#__PURE__*/function(){function GLTFPostProcessor(){_classCallCheck(this,GLTFPostProcessor);_defineProperty(this,"baseUri",'');_defineProperty(this,"json",{});_defineProperty(this,"buffers",[]);_defineProperty(this,"images",[]);}_createClass(GLTFPostProcessor,[{key:"postProcess",value:function postProcess(gltf){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var json=gltf.json,_gltf$buffers=gltf.buffers,buffers=_gltf$buffers===void 0?[]:_gltf$buffers,_gltf$images=gltf.images,images=_gltf$images===void 0?[]:_gltf$images,_gltf$baseUri=gltf.baseUri,baseUri=_gltf$baseUri===void 0?'':_gltf$baseUri;assert$1(json);this.baseUri=baseUri;this.json=json;this.buffers=buffers;this.images=images;this._resolveTree(this.json,options);return this.json;}},{key:"_resolveTree",value:function _resolveTree(json){var _this118=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(json.bufferViews){json.bufferViews=json.bufferViews.map(function(bufView,i){return _this118._resolveBufferView(bufView,i);});}if(json.images){json.images=json.images.map(function(image,i){return _this118._resolveImage(image,i);});}if(json.samplers){json.samplers=json.samplers.map(function(sampler,i){return _this118._resolveSampler(sampler,i);});}if(json.textures){json.textures=json.textures.map(function(texture,i){return _this118._resolveTexture(texture,i);});}if(json.accessors){json.accessors=json.accessors.map(function(accessor,i){return _this118._resolveAccessor(accessor,i);});}if(json.materials){json.materials=json.materials.map(function(material,i){return _this118._resolveMaterial(material,i);});}if(json.meshes){json.meshes=json.meshes.map(function(mesh,i){return _this118._resolveMesh(mesh,i);});}if(json.nodes){json.nodes=json.nodes.map(function(node,i){return _this118._resolveNode(node,i);});}if(json.skins){json.skins=json.skins.map(function(skin,i){return _this118._resolveSkin(skin,i);});}if(json.scenes){json.scenes=json.scenes.map(function(scene,i){return _this118._resolveScene(scene,i);});}if(json.scene!==undefined){json.scene=json.scenes[this.json.scene];}}},{key:"getScene",value:function getScene(index){return this._get('scenes',index);}},{key:"getNode",value:function getNode(index){return this._get('nodes',index);}},{key:"getSkin",value:function getSkin(index){return this._get('skins',index);}},{key:"getMesh",value:function getMesh(index){return this._get('meshes',index);}},{key:"getMaterial",value:function getMaterial(index){return this._get('materials',index);}},{key:"getAccessor",value:function getAccessor(index){return this._get('accessors',index);}},{key:"getCamera",value:function getCamera(index){return null;}},{key:"getTexture",value:function getTexture(index){return this._get('textures',index);}},{key:"getSampler",value:function getSampler(index){return this._get('samplers',index);}},{key:"getImage",value:function getImage(index){return this._get('images',index);}},{key:"getBufferView",value:function getBufferView(index){return this._get('bufferViews',index);}},{key:"getBuffer",value:function getBuffer(index){return this._get('buffers',index);}},{key:"_get",value:function _get(array,index){if(_typeof(index)==='object'){return index;}var object=this.json[array]&&this.json[array][index];if(!object){console.warn("glTF file error: Could not find ".concat(array,"[").concat(index,"]"));}return object;}},{key:"_resolveScene",value:function _resolveScene(scene,index){var _this119=this;scene.id=scene.id||"scene-".concat(index);scene.nodes=(scene.nodes||[]).map(function(node){return _this119.getNode(node);});return scene;}},{key:"_resolveNode",value:function _resolveNode(node,index){var _this120=this;node.id=node.id||"node-".concat(index);if(node.children){node.children=node.children.map(function(child){return _this120.getNode(child);});}if(node.mesh!==undefined){node.mesh=this.getMesh(node.mesh);}else if(node.meshes!==undefined&&node.meshes.length){node.mesh=node.meshes.reduce(function(accum,meshIndex){var mesh=_this120.getMesh(meshIndex);accum.id=mesh.id;accum.primitives=accum.primitives.concat(mesh.primitives);return accum;},{primitives:[]});}if(node.camera!==undefined){node.camera=this.getCamera(node.camera);}if(node.skin!==undefined){node.skin=this.getSkin(node.skin);}return node;}},{key:"_resolveSkin",value:function _resolveSkin(skin,index){skin.id=skin.id||"skin-".concat(index);skin.inverseBindMatrices=this.getAccessor(skin.inverseBindMatrices);return skin;}},{key:"_resolveMesh",value:function _resolveMesh(mesh,index){var _this121=this;mesh.id=mesh.id||"mesh-".concat(index);if(mesh.primitives){mesh.primitives=mesh.primitives.map(function(primitive){primitive=_objectSpread({},primitive);var attributes=primitive.attributes;primitive.attributes={};for(var attribute in attributes){primitive.attributes[attribute]=_this121.getAccessor(attributes[attribute]);}if(primitive.indices!==undefined){primitive.indices=_this121.getAccessor(primitive.indices);}if(primitive.material!==undefined){primitive.material=_this121.getMaterial(primitive.material);}return primitive;});}return mesh;}},{key:"_resolveMaterial",value:function _resolveMaterial(material,index){material.id=material.id||"material-".concat(index);if(material.normalTexture){material.normalTexture=_objectSpread({},material.normalTexture);material.normalTexture.texture=this.getTexture(material.normalTexture.index);}if(material.occlusionTexture){material.occlustionTexture=_objectSpread({},material.occlustionTexture);material.occlusionTexture.texture=this.getTexture(material.occlusionTexture.index);}if(material.emissiveTexture){material.emmisiveTexture=_objectSpread({},material.emmisiveTexture);material.emissiveTexture.texture=this.getTexture(material.emissiveTexture.index);}if(!material.emissiveFactor){material.emissiveFactor=material.emmisiveTexture?[1,1,1]:[0,0,0];}if(material.pbrMetallicRoughness){material.pbrMetallicRoughness=_objectSpread({},material.pbrMetallicRoughness);var mr=material.pbrMetallicRoughness;if(mr.baseColorTexture){mr.baseColorTexture=_objectSpread({},mr.baseColorTexture);mr.baseColorTexture.texture=this.getTexture(mr.baseColorTexture.index);}if(mr.metallicRoughnessTexture){mr.metallicRoughnessTexture=_objectSpread({},mr.metallicRoughnessTexture);mr.metallicRoughnessTexture.texture=this.getTexture(mr.metallicRoughnessTexture.index);}}return material;}},{key:"_resolveAccessor",value:function _resolveAccessor(accessor,index){accessor.id=accessor.id||"accessor-".concat(index);if(accessor.bufferView!==undefined){accessor.bufferView=this.getBufferView(accessor.bufferView);}accessor.bytesPerComponent=getBytesFromComponentType(accessor.componentType);accessor.components=getSizeFromAccessorType(accessor.type);accessor.bytesPerElement=accessor.bytesPerComponent*accessor.components;if(accessor.bufferView){var buffer=accessor.bufferView.buffer;var _getAccessorArrayType2=getAccessorArrayTypeAndLength(accessor,accessor.bufferView),ArrayType=_getAccessorArrayType2.ArrayType,byteLength=_getAccessorArrayType2.byteLength;var byteOffset=(accessor.bufferView.byteOffset||0)+(accessor.byteOffset||0)+buffer.byteOffset;var cutBuffer=buffer.arrayBuffer.slice(byteOffset,byteOffset+byteLength);if(accessor.bufferView.byteStride){cutBuffer=this._getValueFromInterleavedBuffer(buffer,byteOffset,accessor.bufferView.byteStride,accessor.bytesPerElement,accessor.count);}accessor.value=new ArrayType(cutBuffer);}return accessor;}},{key:"_getValueFromInterleavedBuffer",value:function _getValueFromInterleavedBuffer(buffer,byteOffset,byteStride,bytesPerElement,count){var result=new Uint8Array(count*bytesPerElement);for(var _i507=0;_i507<count;_i507++){var elementOffset=byteOffset+_i507*byteStride;result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset,elementOffset+bytesPerElement)),_i507*bytesPerElement);}return result.buffer;}},{key:"_resolveTexture",value:function _resolveTexture(texture,index){texture.id=texture.id||"texture-".concat(index);texture.sampler='sampler'in texture?this.getSampler(texture.sampler):DEFAULT_SAMPLER;texture.source=this.getImage(texture.source);return texture;}},{key:"_resolveSampler",value:function _resolveSampler(sampler,index){sampler.id=sampler.id||"sampler-".concat(index);sampler.parameters={};for(var key in sampler){var glEnum=this._enumSamplerParameter(key);if(glEnum!==undefined){sampler.parameters[glEnum]=sampler[key];}}return sampler;}},{key:"_enumSamplerParameter",value:function _enumSamplerParameter(key){return SAMPLER_PARAMETER_GLTF_TO_GL[key];}},{key:"_resolveImage",value:function _resolveImage(image,index){image.id=image.id||"image-".concat(index);if(image.bufferView!==undefined){image.bufferView=this.getBufferView(image.bufferView);}var preloadedImage=this.images[index];if(preloadedImage){image.image=preloadedImage;}return image;}},{key:"_resolveBufferView",value:function _resolveBufferView(bufferView,index){var bufferIndex=bufferView.buffer;var result=_objectSpread(_objectSpread({id:"bufferView-".concat(index)},bufferView),{},{buffer:this.buffers[bufferIndex]});var arrayBuffer=this.buffers[bufferIndex].arrayBuffer;var byteOffset=this.buffers[bufferIndex].byteOffset||0;if('byteOffset'in bufferView){byteOffset+=bufferView.byteOffset;}result.data=new Uint8Array(arrayBuffer,byteOffset,bufferView.byteLength);return result;}},{key:"_resolveCamera",value:function _resolveCamera(camera,index){camera.id=camera.id||"camera-".concat(index);if(camera.perspective);if(camera.orthographic);return camera;}}]);return GLTFPostProcessor;}();function postProcessGLTF(gltf,options){return new GLTFPostProcessor().postProcess(gltf,options);}var MAGIC_glTF=0x676c5446;var GLB_FILE_HEADER_SIZE=12;var GLB_CHUNK_HEADER_SIZE=8;var GLB_CHUNK_TYPE_JSON=0x4e4f534a;var GLB_CHUNK_TYPE_BIN=0x004e4942;var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED=0;var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED=1;var GLB_V1_CONTENT_FORMAT_JSON=0x0;var LE=true;function getMagicString(dataView){var byteOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return"".concat(String.fromCharCode(dataView.getUint8(byteOffset+0))).concat(String.fromCharCode(dataView.getUint8(byteOffset+1))).concat(String.fromCharCode(dataView.getUint8(byteOffset+2))).concat(String.fromCharCode(dataView.getUint8(byteOffset+3)));}function isGLB(arrayBuffer){var byteOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var dataView=new DataView(arrayBuffer);var _options$magic=options.magic,magic=_options$magic===void 0?MAGIC_glTF:_options$magic;var magic1=dataView.getUint32(byteOffset,false);return magic1===magic||magic1===MAGIC_glTF;}function parseGLBSync(glb,arrayBuffer){var byteOffset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var dataView=new DataView(arrayBuffer);var type=getMagicString(dataView,byteOffset+0);var version=dataView.getUint32(byteOffset+4,LE);var byteLength=dataView.getUint32(byteOffset+8,LE);Object.assign(glb,{header:{byteOffset:byteOffset,byteLength:byteLength,hasBinChunk:false},type:type,version:version,json:{},binChunks:[]});byteOffset+=GLB_FILE_HEADER_SIZE;switch(glb.version){case 1:return parseGLBV1(glb,dataView,byteOffset);case 2:return parseGLBV2(glb,dataView,byteOffset,options={});default:throw new Error("Invalid GLB version ".concat(glb.version,". Only supports v1 and v2."));}}function parseGLBV1(glb,dataView,byteOffset){assert$5(glb.header.byteLength>GLB_FILE_HEADER_SIZE+GLB_CHUNK_HEADER_SIZE);var contentLength=dataView.getUint32(byteOffset+0,LE);var contentFormat=dataView.getUint32(byteOffset+4,LE);byteOffset+=GLB_CHUNK_HEADER_SIZE;assert$5(contentFormat===GLB_V1_CONTENT_FORMAT_JSON);parseJSONChunk(glb,dataView,byteOffset,contentLength);byteOffset+=contentLength;byteOffset+=parseBINChunk(glb,dataView,byteOffset,glb.header.byteLength);return byteOffset;}function parseGLBV2(glb,dataView,byteOffset,options){assert$5(glb.header.byteLength>GLB_FILE_HEADER_SIZE+GLB_CHUNK_HEADER_SIZE);parseGLBChunksSync(glb,dataView,byteOffset,options);return byteOffset+glb.header.byteLength;}function parseGLBChunksSync(glb,dataView,byteOffset,options){while(byteOffset+8<=glb.header.byteLength){var chunkLength=dataView.getUint32(byteOffset+0,LE);var chunkFormat=dataView.getUint32(byteOffset+4,LE);byteOffset+=GLB_CHUNK_HEADER_SIZE;switch(chunkFormat){case GLB_CHUNK_TYPE_JSON:parseJSONChunk(glb,dataView,byteOffset,chunkLength);break;case GLB_CHUNK_TYPE_BIN:parseBINChunk(glb,dataView,byteOffset,chunkLength);break;case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:if(!options.strict){parseJSONChunk(glb,dataView,byteOffset,chunkLength);}break;case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:if(!options.strict){parseBINChunk(glb,dataView,byteOffset,chunkLength);}break;}byteOffset+=padToNBytes(chunkLength,4);}return byteOffset;}function parseJSONChunk(glb,dataView,byteOffset,chunkLength){var jsonChunk=new Uint8Array(dataView.buffer,byteOffset,chunkLength);var textDecoder=new TextDecoder('utf8');var jsonText=textDecoder.decode(jsonChunk);glb.json=JSON.parse(jsonText);return padToNBytes(chunkLength,4);}function parseBINChunk(glb,dataView,byteOffset,chunkLength){glb.header.hasBinChunk=true;glb.binChunks.push({byteOffset:byteOffset,byteLength:chunkLength,arrayBuffer:dataView.buffer});return padToNBytes(chunkLength,4);}function parseGLTF$1(_x86,_x87){return _parseGLTF$.apply(this,arguments);}function _parseGLTF$(){_parseGLTF$=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48(gltf,arrayBufferOrString){var byteOffset,options,context,_options$gltf,_options$gltf2,_options$gltf3,_options$gltf4,promises,_promise,promise,_args46=arguments;return _regeneratorRuntime().wrap(function _callee48$(_context52){while(1){switch(_context52.prev=_context52.next){case 0:byteOffset=_args46.length>2&&_args46[2]!==undefined?_args46[2]:0;options=_args46.length>3?_args46[3]:undefined;context=_args46.length>4?_args46[4]:undefined;parseGLTFContainerSync(gltf,arrayBufferOrString,byteOffset,options);normalizeGLTFV1(gltf,{normalize:options===null||options===void 0?void 0:(_options$gltf=options.gltf)===null||_options$gltf===void 0?void 0:_options$gltf.normalize});preprocessExtensions(gltf,options,context);promises=[];if(!(options!==null&&options!==void 0&&(_options$gltf2=options.gltf)!==null&&_options$gltf2!==void 0&&_options$gltf2.loadBuffers&&gltf.json.buffers)){_context52.next=10;break;}_context52.next=10;return loadBuffers(gltf,options,context);case 10:if(options!==null&&options!==void 0&&(_options$gltf3=options.gltf)!==null&&_options$gltf3!==void 0&&_options$gltf3.loadImages){_promise=loadImages(gltf,options,context);promises.push(_promise);}promise=decodeExtensions(gltf,options,context);promises.push(promise);_context52.next=15;return Promise.all(promises);case 15:return _context52.abrupt("return",options!==null&&options!==void 0&&(_options$gltf4=options.gltf)!==null&&_options$gltf4!==void 0&&_options$gltf4.postProcess?postProcessGLTF(gltf,options):gltf);case 16:case"end":return _context52.stop();}}},_callee48);}));return _parseGLTF$.apply(this,arguments);}function parseGLTFContainerSync(gltf,data,byteOffset,options){if(options.uri){gltf.baseUri=options.uri;}if(data instanceof ArrayBuffer&&!isGLB(data,byteOffset,options)){var textDecoder=new TextDecoder();data=textDecoder.decode(data);}if(typeof data==='string'){gltf.json=parseJSON(data);}else if(data instanceof ArrayBuffer){var glb={};byteOffset=parseGLBSync(glb,data,byteOffset,options.glb);assert$1(glb.type==='glTF',"Invalid GLB magic string ".concat(glb.type));gltf._glb=glb;gltf.json=glb.json;}else{assert$1(false,'GLTF: must be ArrayBuffer or string');}var buffers=gltf.json.buffers||[];gltf.buffers=new Array(buffers.length).fill(null);if(gltf._glb&&gltf._glb.header.hasBinChunk){var binChunks=gltf._glb.binChunks;gltf.buffers[0]={arrayBuffer:binChunks[0].arrayBuffer,byteOffset:binChunks[0].byteOffset,byteLength:binChunks[0].byteLength};}var images=gltf.json.images||[];gltf.images=new Array(images.length).fill({});}function loadBuffers(_x88,_x89,_x90){return _loadBuffers.apply(this,arguments);}function _loadBuffers(){_loadBuffers=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49(gltf,options,context){var buffers,_i590,buffer,_context$fetch,_response$arrayBuffer,_fetch,uri,response,arrayBuffer;return _regeneratorRuntime().wrap(function _callee49$(_context53){while(1){switch(_context53.prev=_context53.next){case 0:buffers=gltf.json.buffers||[];_i590=0;case 2:if(!(_i590<buffers.length)){_context53.next=22;break;}buffer=buffers[_i590];if(!buffer.uri){_context53.next=18;break;}_fetch=context.fetch;assert$1(_fetch);uri=resolveUrl(buffer.uri,options);_context53.next=10;return context===null||context===void 0?void 0:(_context$fetch=context.fetch)===null||_context$fetch===void 0?void 0:_context$fetch.call(context,uri);case 10:response=_context53.sent;_context53.next=13;return response===null||response===void 0?void 0:(_response$arrayBuffer=response.arrayBuffer)===null||_response$arrayBuffer===void 0?void 0:_response$arrayBuffer.call(response);case 13:arrayBuffer=_context53.sent;gltf.buffers[_i590]={arrayBuffer:arrayBuffer,byteOffset:0,byteLength:arrayBuffer.byteLength};delete buffer.uri;_context53.next=19;break;case 18:if(gltf.buffers[_i590]===null){gltf.buffers[_i590]={arrayBuffer:new ArrayBuffer(buffer.byteLength),byteOffset:0,byteLength:buffer.byteLength};}case 19:++_i590;_context53.next=2;break;case 22:case"end":return _context53.stop();}}},_callee49);}));return _loadBuffers.apply(this,arguments);}function loadImages(_x91,_x92,_x93){return _loadImages.apply(this,arguments);}function _loadImages(){_loadImages=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee50(gltf,options,context){var imageIndices,images,promises,_iterator48,_step48,imageIndex;return _regeneratorRuntime().wrap(function _callee50$(_context54){while(1){switch(_context54.prev=_context54.next){case 0:imageIndices=getReferencesImageIndices(gltf);images=gltf.json.images||[];promises=[];_iterator48=_createForOfIteratorHelper(imageIndices);try{for(_iterator48.s();!(_step48=_iterator48.n()).done;){imageIndex=_step48.value;promises.push(loadImage(gltf,images[imageIndex],imageIndex,options,context));}}catch(err){_iterator48.e(err);}finally{_iterator48.f();}_context54.next=7;return Promise.all(promises);case 7:return _context54.abrupt("return",_context54.sent);case 8:case"end":return _context54.stop();}}},_callee50);}));return _loadImages.apply(this,arguments);}function getReferencesImageIndices(gltf){var imageIndices=new Set();var textures=gltf.json.textures||[];var _iterator40=_createForOfIteratorHelper(textures),_step40;try{for(_iterator40.s();!(_step40=_iterator40.n()).done;){var texture=_step40.value;if(texture.source!==undefined){imageIndices.add(texture.source);}}}catch(err){_iterator40.e(err);}finally{_iterator40.f();}return Array.from(imageIndices).sort();}function loadImage(_x94,_x95,_x96,_x97,_x98){return _loadImage.apply(this,arguments);}function _loadImage(){_loadImage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee51(gltf,image,index,options,context){var fetch,parse,arrayBuffer,uri,response,array,parsedImage;return _regeneratorRuntime().wrap(function _callee51$(_context55){while(1){switch(_context55.prev=_context55.next){case 0:fetch=context.fetch,parse=context.parse;if(!image.uri){_context55.next=9;break;}uri=resolveUrl(image.uri,options);_context55.next=5;return fetch(uri);case 5:response=_context55.sent;_context55.next=8;return response.arrayBuffer();case 8:arrayBuffer=_context55.sent;case 9:if(Number.isFinite(image.bufferView)){array=getTypedArrayForBufferView(gltf.json,gltf.buffers,image.bufferView);arrayBuffer=sliceArrayBuffer(array.buffer,array.byteOffset,array.byteLength);}assert$1(arrayBuffer,'glTF image has no data');_context55.next=13;return parse(arrayBuffer,[ImageLoader,BasisLoader],{mimeType:image.mimeType,basis:options.basis||{format:selectSupportedBasisFormat()}},context);case 13:parsedImage=_context55.sent;if(parsedImage&&parsedImage[0]){parsedImage={compressed:true,mipmaps:false,width:parsedImage[0].width,height:parsedImage[0].height,data:parsedImage[0]};}gltf.images=gltf.images||[];gltf.images[index]=parsedImage;case 17:case"end":return _context55.stop();}}},_callee51);}));return _loadImage.apply(this,arguments);}var GLTFLoader={name:'glTF',id:'gltf',module:'gltf',version:VERSION$5,extensions:['gltf','glb'],mimeTypes:['model/gltf+json','model/gltf-binary'],text:true,binary:true,tests:['glTF'],parse:parse$1,options:{gltf:{normalize:true,loadBuffers:true,loadImages:true,decompressMeshes:true,postProcess:true},log:console},deprecatedOptions:{fetchImages:'gltf.loadImages',createImages:'gltf.loadImages',decompress:'gltf.decompressMeshes',postProcess:'gltf.postProcess',gltf:{decompress:'gltf.decompressMeshes'}}};function parse$1(_x99){return _parse$3.apply(this,arguments);}/**
 * @private
 */function _parse$3(){_parse$3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee52(arrayBuffer){var options,context,_options2,_options2$byteOffset,byteOffset,gltf,_args50=arguments;return _regeneratorRuntime().wrap(function _callee52$(_context56){while(1){switch(_context56.prev=_context56.next){case 0:options=_args50.length>1&&_args50[1]!==undefined?_args50[1]:{};context=_args50.length>2?_args50[2]:undefined;options=_objectSpread(_objectSpread({},GLTFLoader.options),options);options.gltf=_objectSpread(_objectSpread({},GLTFLoader.options.gltf),options.gltf);_options2=options,_options2$byteOffset=_options2.byteOffset,byteOffset=_options2$byteOffset===void 0?0:_options2$byteOffset;gltf={};_context56.next=8;return parseGLTF$1(gltf,arrayBuffer,byteOffset,options,context);case 8:return _context56.abrupt("return",_context56.sent);case 9:case"end":return _context56.stop();}}},_callee52);}));return _parse$3.apply(this,arguments);}var GLTFSceneModelLoader=/*#__PURE__*/function(){function GLTFSceneModelLoader(cfg){_classCallCheck(this,GLTFSceneModelLoader);}_createClass(GLTFSceneModelLoader,[{key:"load",value:function load(plugin,src,metaModelJSON,options,sceneModel,ok,error){options=options||{};loadGLTF(plugin,src,metaModelJSON,options,sceneModel,function(){core.scheduleTask(function(){sceneModel.scene.fire("modelLoaded",sceneModel.id);// FIXME: Assumes listeners know order of these two events
sceneModel.fire("loaded",true,false);});if(ok){ok();}},function(msg){plugin.error(msg);if(error){error(msg);}sceneModel.fire("error",msg);});}},{key:"parse",value:function parse(plugin,gltf,metaModelJSON,options,sceneModel,ok,error){options=options||{};parseGLTF(plugin,"",gltf,metaModelJSON,options,sceneModel,function(){sceneModel.scene.fire("modelLoaded",sceneModel.id);// FIXME: Assumes listeners know order of these two events
sceneModel.fire("loaded",true,false);if(ok){ok();}});}}]);return GLTFSceneModelLoader;}();function getMetaModelCorrections(metaModelJSON){var eachRootStats={};var eachChildRoot={};var metaObjects=metaModelJSON.metaObjects||[];var metaObjectsMap={};for(var _i508=0,len=metaObjects.length;_i508<len;_i508++){var metaObject=metaObjects[_i508];metaObjectsMap[metaObject.id]=metaObject;}for(var _i509=0,_len108=metaObjects.length;_i509<_len108;_i509++){var _metaObject12=metaObjects[_i509];if(_metaObject12.parent!==undefined&&_metaObject12.parent!==null){var metaObjectParent=metaObjectsMap[_metaObject12.parent];if(_metaObject12.type===metaObjectParent.type){var rootMetaObject=metaObjectParent;while(rootMetaObject.parent&&metaObjectsMap[rootMetaObject.parent].type===rootMetaObject.type){rootMetaObject=metaObjectsMap[rootMetaObject.parent];}var rootStats=eachRootStats[rootMetaObject.id]||(eachRootStats[rootMetaObject.id]={numChildren:0,countChildren:0});rootStats.numChildren++;eachChildRoot[_metaObject12.id]=rootMetaObject;}}}return{metaObjectsMap:metaObjectsMap,eachRootStats:eachRootStats,eachChildRoot:eachChildRoot};}function loadGLTF(plugin,src,metaModelJSON,options,sceneModel,ok,error){var spinner=plugin.viewer.scene.canvas.spinner;spinner.processes++;var isGLB=src.split('.').pop()==="glb";if(isGLB){plugin.dataSource.getGLB(src,function(arrayBuffer){// OK
options.basePath=getBasePath(src);parseGLTF(plugin,src,arrayBuffer,metaModelJSON,options,sceneModel,ok);spinner.processes--;},function(err){spinner.processes--;error(err);});}else{plugin.dataSource.getGLTF(src,function(gltf){// OK
options.basePath=getBasePath(src);parseGLTF(plugin,src,gltf,metaModelJSON,options,sceneModel,ok);spinner.processes--;},function(err){spinner.processes--;error(err);});}}function getBasePath(src){var i=src.lastIndexOf("/");return i!==0?src.substring(0,i+1):"";}function parseGLTF(plugin,src,gltf,metaModelJSON,options,sceneModel,ok){var spinner=plugin.viewer.scene.canvas.spinner;spinner.processes++;parse$3(gltf,GLTFLoader,{baseUri:options.basePath}).then(function(gltfData){var ctx={src:src,metaModelCorrections:metaModelJSON?getMetaModelCorrections(metaModelJSON):null,loadBuffer:options.loadBuffer,basePath:options.basePath,handlenode:options.handlenode,gltfData:gltfData,scene:sceneModel.scene,plugin:plugin,sceneModel:sceneModel,//geometryCreated: {},
numObjects:0,nodes:[],nextId:0,log:function log(msg){plugin.log(msg);}};loadTextures(ctx);loadMaterials(ctx);loadDefaultScene(ctx);sceneModel.finalize();spinner.processes--;ok();});}function loadTextures(ctx){var gltfData=ctx.gltfData;var textures=gltfData.textures;if(textures){for(var _i510=0,len=textures.length;_i510<len;_i510++){loadTexture(ctx,textures[_i510]);}}}function loadTexture(ctx,texture){if(!texture.source||!texture.source.image){return;}var textureId="texture-".concat(ctx.nextId++);var minFilter=NearestMipMapLinearFilter;switch(texture.sampler.minFilter){case 9728:minFilter=NearestFilter;break;case 9729:minFilter=LinearFilter;break;case 9984:minFilter=NearestMipMapNearestFilter;break;case 9985:minFilter=LinearMipMapNearestFilter;break;case 9986:minFilter=NearestMipMapLinearFilter;break;case 9987:minFilter=LinearMipMapLinearFilter;break;}var magFilter=LinearFilter;switch(texture.sampler.magFilter){case 9728:magFilter=NearestFilter;break;case 9729:magFilter=LinearFilter;break;}var wrapS=RepeatWrapping;switch(texture.sampler.wrapS){case 33071:wrapS=ClampToEdgeWrapping;break;case 33648:wrapS=MirroredRepeatWrapping;break;case 10497:wrapS=RepeatWrapping;break;}var wrapT=RepeatWrapping;switch(texture.sampler.wrapT){case 33071:wrapT=ClampToEdgeWrapping;break;case 33648:wrapT=MirroredRepeatWrapping;break;case 10497:wrapT=RepeatWrapping;break;}var wrapR=RepeatWrapping;switch(texture.sampler.wrapR){case 33071:wrapR=ClampToEdgeWrapping;break;case 33648:wrapR=MirroredRepeatWrapping;break;case 10497:wrapR=RepeatWrapping;break;}ctx.sceneModel.createTexture({id:textureId,image:texture.source.image,flipY:!!texture.flipY,minFilter:minFilter,magFilter:magFilter,wrapS:wrapS,wrapT:wrapT,wrapR:wrapR,encoding:sRGBEncoding});texture._textureId=textureId;}function loadMaterials(ctx){var gltfData=ctx.gltfData;var materials=gltfData.materials;if(materials){for(var _i511=0,len=materials.length;_i511<len;_i511++){var material=materials[_i511];material._textureSetId=loadTextureSet(ctx,material);material._attributes=loadMaterialAttributes(ctx,material);}}}function loadTextureSet(ctx,material){var textureSetCfg={};if(material.normalTexture){textureSetCfg.normalTextureId=material.normalTexture.texture._textureId;}if(material.occlusionTexture){textureSetCfg.occlusionTextureId=material.occlusionTexture.texture._textureId;}if(material.emissiveTexture){textureSetCfg.emissiveTextureId=material.emissiveTexture.texture._textureId;}// const alphaMode = material.alphaMode;
// switch (alphaMode) {
//     case "NORMAL_OPAQUE":
//         materialCfg.alphaMode = "opaque";
//         break;
//     case "MASK":
//         materialCfg.alphaMode = "mask";
//         break;
//     case "BLEND":
//         materialCfg.alphaMode = "blend";
//         break;
//     default:
// }
// const alphaCutoff = material.alphaCutoff;
// if (alphaCutoff !== undefined) {
//     materialCfg.alphaCutoff = alphaCutoff;
// }
var metallicPBR=material.pbrMetallicRoughness;if(material.pbrMetallicRoughness){var pbrMetallicRoughness=material.pbrMetallicRoughness;var baseColorTexture=pbrMetallicRoughness.baseColorTexture||pbrMetallicRoughness.colorTexture;if(baseColorTexture){if(baseColorTexture.texture){textureSetCfg.colorTextureId=baseColorTexture.texture._textureId;}else{textureSetCfg.colorTextureId=ctx.gltfData.textures[baseColorTexture.index]._textureId;}}if(metallicPBR.metallicRoughnessTexture){textureSetCfg.metallicRoughnessTextureId=metallicPBR.metallicRoughnessTexture.texture._textureId;}}var extensions=material.extensions;if(extensions){var specularPBR=extensions["KHR_materials_pbrSpecularGlossiness"];if(specularPBR){specularPBR.specularTexture;var specularColorTexture=specularPBR.specularColorTexture;if(specularColorTexture!==null&&specularColorTexture!==undefined){textureSetCfg.colorTextureId=ctx.gltfData.textures[specularColorTexture.index]._textureId;}}}if(textureSetCfg.normalTextureId!==undefined||textureSetCfg.occlusionTextureId!==undefined||textureSetCfg.emissiveTextureId!==undefined||textureSetCfg.colorTextureId!==undefined||textureSetCfg.metallicRoughnessTextureId!==undefined){textureSetCfg.id="textureSet-".concat(ctx.nextId++,";");ctx.sceneModel.createTextureSet(textureSetCfg);return textureSetCfg.id;}return null;}function loadMaterialAttributes(ctx,material){// Substitute RGBA for material, to use fast flat shading instead
var extensions=material.extensions;var materialAttributes={color:new Float32Array([1,1,1,1]),opacity:1,metallic:0,roughness:1};if(extensions){var specularPBR=extensions["KHR_materials_pbrSpecularGlossiness"];if(specularPBR){var diffuseFactor=specularPBR.diffuseFactor;if(diffuseFactor!==null&&diffuseFactor!==undefined){materialAttributes.color.set(diffuseFactor);}}var common=extensions["KHR_materials_common"];if(common){var technique=common.technique;var values=common.values||{};var blinn=technique==="BLINN";var phong=technique==="PHONG";var lambert=technique==="LAMBERT";var diffuse=values.diffuse;if(diffuse&&(blinn||phong||lambert)){if(!utils.isString(diffuse)){materialAttributes.color.set(diffuse);}}var transparency=values.transparency;if(transparency!==null&&transparency!==undefined){materialAttributes.opacity=transparency;}var transparent=values.transparent;if(transparent!==null&&transparent!==undefined){materialAttributes.opacity=transparent;}}}var metallicPBR=material.pbrMetallicRoughness;if(metallicPBR){var baseColorFactor=metallicPBR.baseColorFactor;if(baseColorFactor){materialAttributes.color[0]=baseColorFactor[0];materialAttributes.color[1]=baseColorFactor[1];materialAttributes.color[2]=baseColorFactor[2];materialAttributes.opacity=baseColorFactor[3];}var metallicFactor=metallicPBR.metallicFactor;if(metallicFactor!==null&&metallicFactor!==undefined){materialAttributes.metallic=metallicFactor;}var roughnessFactor=metallicPBR.roughnessFactor;if(roughnessFactor!==null&&roughnessFactor!==undefined){materialAttributes.roughness=roughnessFactor;}}return materialAttributes;}function loadDefaultScene(ctx){var gltfData=ctx.gltfData;var scene=gltfData.scene||gltfData.scenes[0];if(!scene){error(ctx,"glTF has no default scene");return;}loadScene(ctx,scene);}function loadScene(ctx,scene){var nodes=scene.nodes;if(!nodes){return;}for(var _i512=0,len=nodes.length;_i512<len;_i512++){var _node6=nodes[_i512];countMeshUsage(ctx,_node6);}for(var _i513=0,_len109=nodes.length;_i513<_len109;_i513++){var _node7=nodes[_i513];loadNode(ctx,_node7,0,null);}}function countMeshUsage(ctx,node){var mesh=node.mesh;if(mesh){mesh.instances=mesh.instances?mesh.instances+1:1;}if(node.children){var children=node.children;for(var _i514=0,len=children.length;_i514<len;_i514++){var childNode=children[_i514];if(!childNode){error(ctx,"Node not found: "+_i514);continue;}countMeshUsage(ctx,childNode);}}}var deferredMeshIds=[];function loadNode(ctx,node,depth,matrix){ctx.gltfData;var localMatrix;if(node.matrix){localMatrix=node.matrix;if(matrix){matrix=math.mulMat4(matrix,localMatrix,math.mat4());}else{matrix=localMatrix;}}if(node.translation){localMatrix=math.translationMat4v(node.translation);if(matrix){matrix=math.mulMat4(matrix,localMatrix,math.mat4());}else{matrix=localMatrix;}}if(node.rotation){localMatrix=math.quaternionToMat4(node.rotation);if(matrix){matrix=math.mulMat4(matrix,localMatrix,math.mat4());}else{matrix=localMatrix;}}if(node.scale){localMatrix=math.scalingMat4v(node.scale);if(matrix){matrix=math.mulMat4(matrix,localMatrix,math.mat4());}else{matrix=localMatrix;}}var sceneModel=ctx.sceneModel;if(node.mesh){var _mesh6=node.mesh;if(ctx.handlenode){var actions={};if(!ctx.handlenode(ctx.sceneModel.id,node,actions)){return;}if(actions.createEntity);}var worldMatrix=matrix?matrix.slice():math.identityMat4();var numPrimitives=_mesh6.primitives.length;if(numPrimitives>0){for(var _i515=0;_i515<numPrimitives;_i515++){var _primitive4=_mesh6.primitives[_i515];if(_primitive4.mode<4){continue;}var meshCfg={id:sceneModel.id+"."+ctx.numObjects++};switch(_primitive4.mode){case 0:// POINTS
meshCfg.primitive="points";break;case 1:// LINES
meshCfg.primitive="lines";break;case 2:// LINE_LOOP
meshCfg.primitive="lines";break;case 3:// LINE_STRIP
meshCfg.primitive="lines";break;case 4:// TRIANGLES
meshCfg.primitive="triangles";break;case 5:// TRIANGLE_STRIP
meshCfg.primitive="triangles";break;case 6:// TRIANGLE_FAN
meshCfg.primitive="triangles";break;default:meshCfg.primitive="triangles";}var POSITION=_primitive4.attributes.POSITION;if(!POSITION){continue;}meshCfg.localPositions=POSITION.value;meshCfg.positions=new Float64Array(meshCfg.localPositions.length);if(_primitive4.attributes.NORMAL){meshCfg.normals=_primitive4.attributes.NORMAL.value;}if(_primitive4.attributes.TEXCOORD_0){meshCfg.uv=_primitive4.attributes.TEXCOORD_0.value;}if(_primitive4.indices){meshCfg.indices=_primitive4.indices.value;}math.transformPositions3(worldMatrix,meshCfg.localPositions,meshCfg.positions);var origin=math.vec3();var rtcNeeded=worldToRTCPositions(meshCfg.positions,meshCfg.positions,origin);// Small cellsize guarantees better accuracy
if(rtcNeeded){meshCfg.origin=origin;}var material=_primitive4.material;if(material){meshCfg.textureSetId=material._textureSetId;meshCfg.color=material._attributes.color;meshCfg.opacity=material._attributes.opacity;meshCfg.metallic=material._attributes.metallic;meshCfg.roughness=material._attributes.roughness;}else{meshCfg.color=new Float32Array([1.0,1.0,1.0]);meshCfg.opacity=1.0;}// if (createEntity) {
//     if (createEntity.colorize) {
//         meshCfg.color = createEntity.colorize;
//     }
//     if (createEntity.opacity !== undefined && createEntity.opacity !== null) {
//         meshCfg.opacity = createEntity.opacity;
//     }
// }
sceneModel.createMesh(meshCfg);deferredMeshIds.push(meshCfg.id);}// if (createEntity) {
//     sceneModel.createEntity(utils.apply(createEntity, {
//         meshIds: deferredMeshIds,
//         isObject: true
//     }));
// } else {
//     sceneModel.createEntity({
//         meshIds: deferredMeshIds,
//         isObject: true
//     });
// }
}}if(node.children){var children=node.children;for(var _i516=0,len=children.length;_i516<len;_i516++){var childNode=children[_i516];loadNode(ctx,childNode,depth+1,matrix);}}// Post-order visit scene node
var nodeName=node.name;if((nodeName!==undefined&&nodeName!==null||depth===0)&&deferredMeshIds.length>0){if(nodeName===undefined||nodeName===null){ctx.log("Warning: 'name' properties not found on glTF scene nodes - will randomly-generate object IDs in XKT");}var entityId=nodeName;// Fall back on generated ID when `name` not found on glTF scene node(s)
// if (!!entityId && sceneModel.entities[entityId]) {
//     ctx.log(`Warning: Two or more glTF nodes found with same 'name' attribute: '${nodeName} - will randomly-generating an object ID in XKT`);
// }
// while (!entityId || sceneModel.entities[entityId]) {
//     entityId = "entity-" + ctx.nextId++;
// }
if(ctx.metaModelCorrections){// Merging meshes into XKTObjects that map to metaobjects
var rootMetaObject=ctx.metaModelCorrections.eachChildRoot[entityId];if(rootMetaObject){var rootMetaObjectStats=ctx.metaModelCorrections.eachRootStats[rootMetaObject.id];rootMetaObjectStats.countChildren++;if(rootMetaObjectStats.countChildren>=rootMetaObjectStats.numChildren){sceneModel.createEntity({id:rootMetaObject.id,meshIds:deferredMeshIds});deferredMeshIds.length=0;}}else{var metaObject=ctx.metaModelCorrections.metaObjectsMap[entityId];if(metaObject){sceneModel.createEntity({id:entityId,meshIds:deferredMeshIds});deferredMeshIds.length=0;}}}else{// Create an XKTObject from the meshes at each named glTF node, don't care about metaobjects
sceneModel.createEntity({id:entityId,meshIds:deferredMeshIds});deferredMeshIds.length=0;}}}function error(ctx,msg){ctx.plugin.error(msg);}/**
 * @desc Default initial properties for {@link Entity}s loaded from models accompanied by metadata.
 *
 * When loading a model, plugins such as {@link XKTLoaderPlugin} create
 * a tree of {@link Entity}s that represent the model. These loaders can optionally load metadata, to create
 * a {@link MetaModel} corresponding to the root {@link Entity}, with a {@link MetaObject} corresponding to each
 * object {@link Entity} within the tree.
 *
 * @type {{String:Object}}
 */var IFCObjectDefaults={DEFAULT:{}};/**
 * {@link Viewer} plugin that loads models from [glTF](https://www.khronos.org/gltf/).
 *
 * * Loads all glTF formats, including embedded and binary formats.
 * * Loads physically-based materials and textures.
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which is indicated by each glTF ````node```` that has a ````name```` attribute. Those Entities will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 * * Not recommended for large models. For best performance with large glTF datasets, we recommend first converting them
 * to ````.xkt```` format (eg. using [convert2xkt](https://github.com/xeokit/xeokit-convert)), then loading
 * the ````.xkt```` using {@link XKTLoaderPlugin}.
 *
 * ## Metadata
 *
 * GLTFLoaderPlugin can also load an accompanying JSON metadata file with each model, which creates a {@link MetaModel} corresponding
 * to the model {@link Entity} and a {@link MetaObject} corresponding to each object {@link Entity}.
 *
 * Each {@link MetaObject} has a {@link MetaObject#type}, which indicates the classification of its corresponding {@link Entity}. When loading
 * metadata, we can also provide GLTFLoaderPlugin with a custom lookup table of initial values to set on the properties of each type of {@link Entity}. By default, GLTFLoaderPlugin
 * uses its own map of default colors and visibilities for IFC element types.
 *
 * ## Usage
 *
 * In the example below we'll load a house plan model from a [binary glTF file](/examples/models/gltf/schependomlaan/), along
 * with an accompanying JSON [IFC metadata file](/examples/metaModels/schependomlaan/).
 *
 * This will create a bunch of {@link Entity}s that represents the model and its objects, along with a {@link MetaModel} and {@link MetaObject}s
 * that hold their metadata.
 *
 * Since this model contains IFC types, the GLTFLoaderPlugin will set the initial colors of object {@link Entity}s according
 * to the standard IFC element colors in the GLTFModel's current map. Override that with your own map via property {@link GLTFLoaderPlugin#objectDefaults}.
 *
 * Read more about this example in the user guide on [Viewing BIM Models Offline](https://www.notion.so/xeokit/Viewing-an-IFC-Model-with-xeokit-c373e48bc4094ff5b6e5c5700ff580ee).
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a Viewer,
 * // 2. Arrange the camera,
 * // 3. Tweak the selection material (tone it down a bit)
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // 2
 * viewer.camera.orbitPitch(20);
 * viewer.camera.orbitYaw(-45);
 *
 * // 3
 * viewer.scene.selectedMaterial.fillAlpha = 0.1;
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a glTF loader plugin,
 * // 2. Load a glTF building model and JSON IFC metadata
 * // 3. Emphasis the edges to make it look nice
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * // 2
 * var model = gltfLoader.load({                                    // Returns an Entity that represents the model
 *      id: "myModel",
 *      src: "./models/gltf/OTCConferenceCenter/scene.gltf",
 *      metaModelSrc: "./models/gltf/OTCConferenceCenter/metaModel.json",     // Creates a MetaModel (see below)
 *      edges: true
 * });
 *
 * model.on("loaded", () => {
 *
 *      //--------------------------------------------------------------------------------------------------------------
 *      // 1. Find metadata on the third storey
 *      // 2. Select all the objects in the building's third storey
 *      // 3. Fit the camera to all the objects on the third storey
 *      //--------------------------------------------------------------------------------------------------------------
 *
 *      // 1
 *      const metaModel = viewer.metaScene.metaModels["myModel"];       // MetaModel with ID "myModel"
 *      const metaObject
 *          = viewer.metaScene.metaObjects["0u4wgLe6n0ABVaiXyikbkA"];   // MetaObject with ID "0u4wgLe6n0ABVaiXyikbkA"
 *
 *      const name = metaObject.name;                                   // "01 eerste verdieping"
 *      const type = metaObject.type;                                   // "IfcBuildingStorey"
 *      const parent = metaObject.parent;                               // MetaObject with type "IfcBuilding"
 *      const children = metaObject.children;                           // Array of child MetaObjects
 *      const objectId = metaObject.id;                                 // "0u4wgLe6n0ABVaiXyikbkA"
 *      const objectIds = viewer.metaScene.getObjectIDsInSubtree(objectId);   // IDs of leaf sub-objects
 *      const aabb = viewer.scene.getAABB(objectIds);                   // Axis-aligned boundary of the leaf sub-objects
 *
 *      // 2
 *      viewer.scene.setObjectsSelected(objectIds, true);
 *
 *      // 3
 *      viewer.cameraFlight.flyTo(aabb);
 * });
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 *
 * ## Transforming
 *
 * We have the option to rotate, scale and translate each  *````.glTF````* model as we load it.
 *
 * This lets us load multiple models, or even multiple copies of the same model, and position them apart from each other.
 *
 * In the example below, we'll scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * translate it 100 units along its X axis.
 *
 * ````javascript
 * const model = gltfLoader.load({
 *      src: "./models/gltf/Duplex/scene.gltf",
 *      metaModelSrc: "./models/gltf/Duplex/Duplex.json",
 *      rotation: [90,0,0],
 *      scale: [0.5, 0.5, 0.5],
 *      position: [100, 0, 0]
 * });
 * ````
 *
 * ## Including and excluding IFC types
 *
 * We can also load only those objects that have the specified IFC types. In the example below, we'll load only the
 * objects that represent walls.
 *
 * ````javascript
 * const model = gltfLoader.load({
 *     id: "myModel",
 *      src: "./models/gltf/OTCConferenceCenter/scene.gltf",
 *      metaModelSrc: "./models/gltf/OTCConferenceCenter/metaModel.json",
 *      includeTypes: ["IfcWallStandardCase"]
 * });
 * ````
 *
 * We can also load only those objects that **don't** have the specified IFC types. In the example below, we'll load only the
 * objects that do not represent empty space.
 *
 * ````javascript
 * const model = gltfLoader.load({
 *     id: "myModel",
 *      src: "./models/gltf/OTCConferenceCenter/scene.gltf",
 *      metaModelSrc: "./models/gltf/OTCConferenceCenter/metaModel.json",
 *      excludeTypes: ["IfcSpace"]
 * });
 * ````
 * @class GLTFLoaderPlugin
 */var GLTFLoaderPlugin=/*#__PURE__*/function(_Plugin7){_inherits(GLTFLoaderPlugin,_Plugin7);var _super148=_createSuper(GLTFLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="GLTFLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Object} [cfg.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object.  Default value is {@link IFCObjectDefaults}.
     * @param {Object} [cfg.dataSource] A custom data source through which the GLTFLoaderPlugin can load metadata, glTF and binary attachments. Defaults to an instance of {@link GLTFDefaultDataSource}, which loads over HTTP.
     */function GLTFLoaderPlugin(viewer){var _this122;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,GLTFLoaderPlugin);_this122=_super148.call(this,"GLTFLoader",viewer,cfg);_this122._sceneModelLoader=new GLTFSceneModelLoader(_assertThisInitialized(_this122),cfg);_this122.dataSource=cfg.dataSource;_this122.objectDefaults=cfg.objectDefaults;return _this122;}/**
     * Sets a custom data source through which the GLTFLoaderPlugin can load metadata, glTF and binary attachments.
     *
     * Default value is {@link GLTFDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */_createClass(GLTFLoaderPlugin,[{key:"dataSource",get:/**
     * Gets the custom data source through which the GLTFLoaderPlugin can load metadata, glTF and binary attachments.
     *
     * Default value is {@link GLTFDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */function get(){return this._dataSource;}/**
     * Sets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */,set:function set(value){this._dataSource=value||new GLTFDefaultDataSource();}},{key:"objectDefaults",get:/**
     * Gets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */function get(){return this._objectDefaults;}/**
     * Loads a glTF model from a file into this GLTFLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path to a glTF file, as an alternative to the ````gltf```` parameter.
     * @param {*} [params.gltf] glTF JSON, as an alternative to the ````src```` parameter.
     * @param {String} [params.metaModelSrc] Path to an optional metadata file, as an alternative to the ````metaModelJSON```` parameter.
     * @param {*} [params.metaModelJSON] JSON model metadata, as an alternative to the ````metaModelSrc```` parameter.
     * @param {{String:Object}} [params.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object. Default value is {@link IFCObjectDefaults}.
     * @param {String[]} [params.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {String[]} [params.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the model with edges emphasized.
     * @param {Number[]} [params.origin=[0,0,0]] The double-precision World-space origin of the model's coordinates.
     * @param {Number[]} [params.position=[0,0,0]] The single-precision position, relative to ````origin````.
     * @param {Number[]} [params.scale=[1,1,1]] The model's scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's orientation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters. Relative to ````origin````.
     * @param {Boolean} [params.saoEnabled=true] Indicates if Scalable Ambient Obscurance (SAO) is enabled for the model. SAO is configured by the Scene's {@link SAO} component. Only works when {@link SAO#enabled} is also ````true````
     * @param {Boolean} [params.pbrEnabled=true] Indicates if physically-based rendering (PBR) is enabled for the model. Overrides ````colorTextureEnabled````. Only works when {@link Scene#pbrEnabled} is also ````true````.
     * @param {Boolean} [params.colorTextureEnabled=true] Indicates if base color texture rendering is enabled for the model. Overridden by ````pbrEnabled````.  Only works when {@link Scene#colorTextureEnabled} is also ````true````.
     * @param {Boolean} [params.backfaces=false] When true, allows visible backfaces, wherever specified in the glTF. When false, ignores backfaces.
     * @param {Number} [params.edgeThreshold=10] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Boolean} [params.dtxEnabled=true] When ````true```` (default) use data textures (DTX), where appropriate, to
     * represent the returned model. Set false to always use vertex buffer objects (VBOs). Note that DTX is only applicable
     * to non-textured triangle meshes, and that VBOs are always used for meshes that have textures, line segments, or point
     * primitives. Only works while {@link DTX#enabled} is also ````true````.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */,set:function set(value){this._objectDefaults=value||IFCObjectDefaults;}},{key:"load",value:function load(){var _this123=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var sceneModel=new SceneModel(this.viewer.scene,utils.apply(params,{isModel:true,dtxEnabled:params.dtxEnabled}));var modelId=sceneModel.id;// In case ID was auto-generated
if(!params.src&&!params.gltf){this.error("load() param expected: src or gltf");return sceneModel;// Return new empty model
}if(params.metaModelSrc||params.metaModelJSON){var objectDefaults=params.objectDefaults||this._objectDefaults||IFCObjectDefaults;var processMetaModelJSON=function processMetaModelJSON(metaModelJSON){_this123.viewer.metaScene.createMetaModel(modelId,metaModelJSON,{includeTypes:params.includeTypes,excludeTypes:params.excludeTypes});_this123.viewer.scene.canvas.spinner.processes--;var includeTypes;if(params.includeTypes){includeTypes={};for(var _i517=0,len=params.includeTypes.length;_i517<len;_i517++){includeTypes[params.includeTypes[_i517]]=true;}}if(params.excludeTypes){if(!includeTypes){includeTypes={};}for(var _i518=0,_len110=params.excludeTypes.length;_i518<_len110;_i518++){includeTypes[params.excludeTypes[_i518]]=true;}}params.readableGeometry=false;params.handleGLTFNode=function(modelId,glTFNode,actions){var name=glTFNode.name;if(!name){return true;// Continue descending this node subtree
}var nodeId=name;var metaObject=_this123.viewer.metaScene.metaObjects[nodeId];var type=(metaObject?metaObject.type:"DEFAULT")||"DEFAULT";actions.createEntity={id:nodeId,isObject:true// Registers the Entity in Scene#objects
};var props=objectDefaults[type];if(props){// Set Entity's initial rendering state for recognized type
if(props.visible===false){actions.createEntity.visible=false;}if(props.colorize){actions.createEntity.colorize=props.colorize;}if(props.pickable===false){actions.createEntity.pickable=false;}if(props.opacity!==undefined&&props.opacity!==null){actions.createEntity.opacity=props.opacity;}}return true;// Continue descending this glTF node subtree
};if(params.src){_this123._sceneModelLoader.load(_this123,params.src,metaModelJSON,params,sceneModel);}else{_this123._sceneModelLoader.parse(_this123,params.gltf,metaModelJSON,params,sceneModel);}};if(params.metaModelSrc){var metaModelSrc=params.metaModelSrc;this.viewer.scene.canvas.spinner.processes++;this._dataSource.getMetaModel(metaModelSrc,function(metaModelJSON){_this123.viewer.scene.canvas.spinner.processes--;processMetaModelJSON(metaModelJSON);},function(errMsg){_this123.error("load(): Failed to load model metadata for model '".concat(modelId," from  '").concat(metaModelSrc,"' - ").concat(errMsg));_this123.viewer.scene.canvas.spinner.processes--;});}else if(params.metaModelJSON){processMetaModelJSON(params.metaModelJSON);}}else{params.handleGLTFNode=function(modelId,glTFNode,actions){var name=glTFNode.name;if(!name){return true;// Continue descending this node subtree
}var id=name;actions.createEntity={// Create an Entity for this glTF scene node
id:id,isObject:true// Registers the Entity in Scene#objects
};return true;// Continue descending this glTF node subtree
};if(params.src){this._sceneModelLoader.load(this,params.src,null,params,sceneModel);}else{this._sceneModelLoader.parse(this,params.gltf,null,params,sceneModel);}}sceneModel.once("destroyed",function(){_this123.viewer.metaScene.destroyMetaModel(modelId);});return sceneModel;}/**
     * Destroys this GLTFLoaderPlugin.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(GLTFLoaderPlugin.prototype),"destroy",this).call(this);}}]);return GLTFLoaderPlugin;}(Plugin);/**
 * @private
 */function CubeTextureCanvas(viewer,navCubeScene){var cfg=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var cubeColor="lightgrey";var cubeHighlightColor=cfg.hoverColor||"rgba(0,0,0,0.4)";var textColor=cfg.textColor||"black";var height=500;var width=height+height/3;var scale=width/24;var facesZUp=[{boundary:[6,6,6,6],color:cfg.frontColor||cfg.color||"#55FF55"},{boundary:[18,6,6,6],color:cfg.backColor||cfg.color||"#55FF55"},{boundary:[12,6,6,6],color:cfg.rightColor||cfg.color||"#FF5555"},{boundary:[0,6,6,6],color:cfg.leftColor||cfg.color||"#FF5555"},{boundary:[6,0,6,6],color:cfg.topColor||cfg.color||"#7777FF"},{boundary:[6,12,6,6],color:cfg.bottomColor||cfg.color||"#7777FF"}];var areasZUp=[{label:"NavCube.front",boundaries:[[7,7,4,4]],dir:[0,1,0],up:[0,0,1]},{label:"NavCube.back",boundaries:[[19,7,4,4]],dir:[0,-1,0],up:[0,0,1]},{label:"NavCube.right",boundaries:[[13,7,4,4]],dir:[-1,0,0],up:[0,0,1]},{label:"NavCube.left",boundaries:[[1,7,4,4]],dir:[1,0,0],up:[0,0,1]},{label:"NavCube.top",boundaries:[[7,1,4,4]],dir:[0,0,-1],up:[0,1,0]},{label:"NavCube.bottom",boundaries:[[7,13,4,4]],dir:[0,0,1],up:[0,-1,0]},{boundaries:[[7,5,4,2]],dir:[0,1,-1],up:[0,1,1]},{boundaries:[[1,6,4,1],[6,1,1,4]],dir:[1,0,-1],up:[1,0,1]},{boundaries:[[7,0,4,1],[19,6,4,1]],dir:[0,-1,-1],up:[0,-1,1]},{boundaries:[[13,6,4,1],[11,1,1,4]],dir:[-1,0,-1],up:[-1,0,1]},{boundaries:[[7,11,4,2]],dir:[0,1,1],up:[0,-1,1]},{boundaries:[[1,11,4,1],[6,13,1,4]],dir:[1,0,1],up:[-1,0,1]},{boundaries:[[7,17,4,1],[19,11,4,1]],dir:[0,-1,1],up:[0,1,1]},{boundaries:[[13,11,4,1],[11,13,1,4]],dir:[-1,0,1],up:[1,0,1]},{boundaries:[[5,7,2,4]],dir:[1,1,0],up:[0,0,1]},{boundaries:[[11,7,2,4]],dir:[-1,1,0],up:[0,0,1]},{boundaries:[[17,7,2,4]],dir:[-1,-1,0],up:[0,0,1]},{boundaries:[[0,7,1,4],[23,7,1,4]],dir:[1,-1,0],up:[0,0,1]},{boundaries:[[5,11,2,2]],dir:[1,1,1],up:[-1,-1,1]},{boundaries:[[23,11,1,1],[6,17,1,1],[0,11,1,1]],dir:[1,-1,1],up:[-1,1,1]},{boundaries:[[5,5,2,2]],dir:[1,1,-1],up:[1,1,1]},{boundaries:[[11,17,1,1],[17,11,2,1]],dir:[-1,-1,1],up:[1,1,1]},{boundaries:[[17,6,2,1],[11,0,1,1]],dir:[-1,-1,-1],up:[-1,-1,1]},{boundaries:[[11,11,2,2]],dir:[-1,1,1],up:[1,-1,1]},{boundaries:[[0,6,1,1],[6,0,1,1],[23,6,1,1]],dir:[1,-1,-1],up:[1,-1,1]},{boundaries:[[11,5,2,2]],dir:[-1,1,-1],up:[-1,1,1]}];[{boundary:[6,6,6,6],color:cfg.frontColor||cfg.color||"#55FF55"},{boundary:[18,6,6,6],color:cfg.backColor||cfg.color||"#55FF55"},{boundary:[12,6,6,6],color:cfg.rightColor||cfg.color||"#FF5555"},{boundary:[0,6,6,6],color:cfg.leftColor||cfg.color||"#FF5555"},{boundary:[6,0,6,6],color:cfg.topColor||cfg.color||"#7777FF"},{boundary:[6,12,6,6],color:cfg.bottomColor||cfg.color||"#7777FF"}];var areasYUp=[// Faces
{yUp:"",label:"NavCube.front",boundaries:[[7,7,4,4]],dir:[0,0,-1],up:[0,1,0]},{label:"NavCube.back",boundaries:[[19,7,4,4]],dir:[0,0,1],up:[0,1,0]},{label:"NavCube.right",boundaries:[[13,7,4,4]],dir:[-1,0,0],up:[0,1,0]},{label:"NavCube.left",boundaries:[[1,7,4,4]],dir:[1,0,0],up:[0,1,0]},{label:"NavCube.top",boundaries:[[7,1,4,4]],dir:[0,-1,0],up:[0,0,-1]},{label:"NavCube.bottom",boundaries:[[7,13,4,4]],dir:[0,1,0],up:[0,0,1]},{boundaries:[[7,5,4,2]],dir:[0,-0.7071,-0.7071],up:[0,0.7071,-0.7071]},// Top-front edge
{boundaries:[[1,6,4,1],[6,1,1,4]],dir:[1,-1,0],up:[1,1,0]},// Top-left edge
{boundaries:[[7,0,4,1],[19,6,4,1]],dir:[0,-0.7071,0.7071],up:[0,0.7071,0.7071]},// Top-back edge
{boundaries:[[13,6,4,1],[11,1,1,4]],dir:[-1,-1,0],up:[-1,1,0]},// Top-right edge
{boundaries:[[7,11,4,2]],dir:[0,1,-1],up:[0,1,1]},// Bottom-front edge
{boundaries:[[1,11,4,1],[6,13,1,4]],dir:[1,1,0],up:[-1,1,0]},// Bottom-left edge
{boundaries:[[7,17,4,1],[19,11,4,1]],dir:[0,1,1],up:[0,1,-1]},// Bottom-back edge
{boundaries:[[13,11,4,1],[11,13,1,4]],dir:[-1,1,0],up:[1,1,0]},// Bottom-right edge
{boundaries:[[5,7,2,4]],dir:[1,0,-1],up:[0,1,0]},// Front-left edge
{boundaries:[[11,7,2,4]],dir:[-1,0,-1],up:[0,1,0]},// Front-right edge
{boundaries:[[17,7,2,4]],dir:[-1,0,1],up:[0,1,0]},// Back-right edge
{boundaries:[[0,7,1,4],[23,7,1,4]],dir:[1,0,1],up:[0,1,0]},// Back-left edge
{boundaries:[[5,11,2,2]],"dir":[0.5,0.7071,-0.5],"up":[-0.5,0.7071,0.5]},// Bottom-left-front corner
{boundaries:[[23,11,1,1],[6,17,1,1],[0,11,1,1]],"dir":[0.5,0.7071,0.5],"up":[-0.5,0.7071,-0.5]},// Bottom-back-left corner
{boundaries:[[5,5,2,2]],"dir":[0.5,-0.7071,-0.5],"up":[0.5,0.7071,-0.5]},// Left-front-top corner
{boundaries:[[11,17,1,1],[17,11,2,1]],"dir":[-0.5,0.7071,0.5],"up":[0.5,0.7071,-0.5]},// Bottom-back-right corner
{boundaries:[[17,6,2,1],[11,0,1,1]],"dir":[-0.5,-0.7071,0.5],"up":[-0.5,0.7071,0.5]},// Top-back-right corner
{boundaries:[[11,11,2,2]],"dir":[-0.5,0.7071,-0.5],"up":[0.5,0.7071,0.5]},// Bottom-front-right corner
{boundaries:[[0,6,1,1],[6,0,1,1],[23,6,1,1]],"dir":[0.5,-0.7071,0.5],"up":[0.5,0.7071,0.5]},// Top-back-left corner
{boundaries:[[11,5,2,2]],"dir":[-0.5,-0.7071,-0.5],"up":[-0.5,0.7071,-0.5]}// Top-front-right corner
];for(var _i519=0,len=areasZUp.length;_i519<len;_i519++){math.normalizeVec3(areasZUp[_i519].dir,areasZUp[_i519].dir);math.normalizeVec3(areasZUp[_i519].up,areasZUp[_i519].up);}for(var _i520=0,_len111=areasYUp.length;_i520<_len111;_i520++){math.normalizeVec3(areasYUp[_i520].dir,areasYUp[_i520].dir);math.normalizeVec3(areasYUp[_i520].up,areasYUp[_i520].up);}var areas=areasYUp;this._textureCanvas=document.createElement('canvas');this._textureCanvas.width=width;this._textureCanvas.height=height;this._textureCanvas.style.width=width+"px";this._textureCanvas.style.height=height+"px";this._textureCanvas.style.padding="0";this._textureCanvas.style.margin="0";this._textureCanvas.style.top="0";this._textureCanvas.style.background=cubeColor;this._textureCanvas.style.position="absolute";this._textureCanvas.style.opacity="1.0";this._textureCanvas.style.visibility="hidden";this._textureCanvas.style["z-index"]=2000000;var body=document.getElementsByTagName("body")[0];body.appendChild(this._textureCanvas);var context=this._textureCanvas.getContext("2d");var zUp=false;function paint(){for(var _i521=0,_len112=facesZUp.length;_i521<_len112;_i521++){var face=facesZUp[_i521];var boundary=face.boundary;var xmin=Math.round(boundary[0]*scale);var ymin=Math.round(boundary[1]*scale);var _width=Math.round(boundary[2]*scale);var _height=Math.round(boundary[3]*scale);context.fillStyle=face.color;context.fillRect(xmin,ymin,_width,_height);}for(var _i522=0,_len113=areas.length;_i522<_len113;_i522++){var _xmin=void 0;var _ymin=void 0;var _width2=void 0;var _height2=void 0;var _area=areas[_i522];var boundaries=_area.boundaries;for(var j=0,lenj=boundaries.length;j<lenj;j++){var _boundary=boundaries[j];_xmin=Math.round(_boundary[0]*scale);_ymin=Math.round(_boundary[1]*scale);_width2=Math.round(_boundary[2]*scale);_height2=Math.round(_boundary[3]*scale);if(_area.highlighted){context.fillStyle=_area.highlighted?cubeHighlightColor:_area.color||cubeColor;context.fillRect(_xmin,_ymin,_width2,_height2);}}if(_area.label){context.fillStyle=textColor;context.font='60px sans-serif';context.textAlign="center";var xcenter=_xmin+_width2*0.5;var ycenter=_ymin+_height2*0.7;context.fillText(translateLabel(_area.label),xcenter,ycenter,80);}}navCubeScene.glRedraw();}var translateLabel=function(){var swizzleYUp={"NavCube.front":"NavCube.front","NavCube.back":"NavCube.back","NavCube.right":"NavCube.right","NavCube.left":"NavCube.left","NavCube.top":"NavCube.top","NavCube.bottom":"NavCube.bottom"};var swizzleZUp={"NavCube.front":"NavCube.front","NavCube.back":"NavCube.back","NavCube.right":"NavCube.right","NavCube.left":"NavCube.left","NavCube.top":"NavCube.top","NavCube.bottom":"NavCube.bottom"};var defaultLabels={"NavCube.front":"FRONT","NavCube.back":"BACK","NavCube.right":"RIGHT","NavCube.left":"LEFT","NavCube.top":"TOP","NavCube.bottom":"BOTTOM"};return function(key){var swizzle=zUp?swizzleZUp:swizzleYUp;var swizzledKey=swizzle?swizzle[key]:null;if(swizzledKey){return viewer.localeService.translate(swizzledKey)||defaultLabels[swizzledKey]||swizzledKey;}return key;};}();this.setZUp=function(){zUp=true;areas=areasZUp;this.clear();};this.setYUp=function(){zUp=false;areas=areasYUp;this.clear();};this.clear=function(){context.fillStyle=cubeColor;context.fillRect(0,0,width,height);for(var i=0,len=areas.length;i<len;i++){var _area2=areas[i];_area2.highlighted=false;}paint();};this.getArea=function(uv){var s=uv[0]*width;var t=height-uv[1]*height;// Correct for our texture Y-flipping
for(var i=0,len=areas.length;i<len;i++){var _area3=areas[i];var boundaries=_area3.boundaries;for(var j=0,lenj=boundaries.length;j<lenj;j++){var boundary=boundaries[j];if(s>=boundary[0]*scale&&s<=(boundary[0]+boundary[2])*scale&&t>=boundary[1]*scale&&t<=(boundary[1]+boundary[3])*scale){return i;}}}return-1;};this.setAreaHighlighted=function(areaId,highlighted){var area=areas[areaId];if(!area){throw"Area not found: "+areaId;}area.highlighted=!!highlighted;paint();};this.getAreaDir=function(areaId){var area=areas[areaId];if(!area){throw"Unknown area: "+areaId;}return area.dir;};this.getAreaUp=function(areaId){var area=areas[areaId];if(!area){throw"Unknown area: "+areaId;}return area.up;};this.getImage=function(){return this._textureCanvas;};this.destroy=function(){if(this._textureCanvas){this._textureCanvas.parentNode.removeChild(this._textureCanvas);this._textureCanvas=null;}};}var tempVec3a$4=math.vec3();var tempVec3b$1=math.vec3();math.mat4();/**
 * {@link Viewer} plugin that lets us look at the entire {@link Scene} from along a chosen axis or diagonal.
 *
 *  [<img src="https://user-images.githubusercontent.com/83100/55674490-c93c2e00-58b5-11e9-8a28-eb08876947c0.gif">](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_NavCubePlugin)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_NavCubePlugin)]
 *
 * ## Overview
 *
 * * Rotating the NavCube causes the Viewer's {@link Camera} to orbit its current
 * point-of-interest. Conversely, orbiting the Camera causes the NavCube to rotate accordingly.
 * * The faces of the NavCube are aligned with the Viewer's {@link Scene}'s World-space coordinate axis. Clicking on a face moves
 * the Camera to look at the entire Scene along the corresponding axis. Clicking on an edge or a corner looks at
 * the entire Scene along a diagonal.
 * * The NavCube can be configured to either jump or fly the Camera to each new position. We can configure how tightly the
 * NavCube fits the Scene to view, and when flying, we can configure how fast it flies. We can also configure whether the
 * NavCube fits all objects to view, or just the currently visible objects. See below for a usage example.
 * * Clicking the NavCube also sets {@link CameraControl#pivotPos} to the center of the fitted objects.
 *
 * ## Usage
 *
 * In the example below, we'll create a Viewer and add a NavCubePlugin, which will create a NavCube gizmo in the canvas
 * with the given ID. Then we'll use the {@link XKTLoaderPlugin} to load a model into the Viewer's Scene. We can then
 * use the NavCube to look at the model along each axis or diagonal.
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, NavCubePlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-3.93, 2.85, 27.01];
 * viewer.camera.look = [4.40, 3.72, 8.89];
 * viewer.camera.up = [-0.01, 0.99, 0.03];
 *
 * const navCube = new NavCubePlugin(viewer, {
 *
 *     canvasID: "myNavCubeCanvas",
 *
 *     visible: true,         // Initially visible (default)
 *
 *     cameraFly: true,       // Fly camera to each selected axis/diagonal
 *     cameraFitFOV: 45,      // How much field-of-view the scene takes once camera has fitted it to view
 *     cameraFlyDuration: 0.5,// How long (in seconds) camera takes to fly to each new axis/diagonal
 *
 *     fitVisible: false,     // Fit whole scene, including invisible objects (default)
 *
 *     synchProjection: false // Keep NavCube in perspective projection, even when camera switches to ortho (default)
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Duplex.ifc.xkt",
 *     edges: true
 * });
 * ````
 */var NavCubePlugin=/*#__PURE__*/function(_Plugin8){_inherits(NavCubePlugin,_Plugin8);var _super149=_createSuper(NavCubePlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg NavCubePlugin configuration.
     * @param {String} [cfg.id="NavCube"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} [cfg.canvasId] ID of an existing HTML canvas to display the NavCube - either this or canvasElement is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLCanvasElement} [cfg.canvasElement] Reference of an existing HTML canvas to display the NavCube - either this or canvasId is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {Boolean} [cfg.visible=true] Initial visibility.
     * @param {Boolean} [cfg.shadowVisible=true] Whether the shadow of the cube is visible.
     * @param {String} [cfg.cameraFly=true] Whether the {@link Camera} flies or jumps to each selected axis or diagonal.
     * @param {String} [cfg.cameraFitFOV=45] How much of the field-of-view, in degrees, that the 3D scene should fill the {@link Canvas} when the {@link Camera} moves to an axis or diagonal.
     * @param {String} [cfg.cameraFlyDuration=0.5] When flying the {@link Camera} to each new axis or diagonal, how long, in seconds, that the Camera takes to get there.
     * @param {String} [cfg.color="lightgrey"] Custom uniform color for the faces of the NavCube.
     * @param {String} [cfg.frontColor="#55FF55"] Custom color for the front face of the NavCube. Overrides ````color````.
     * @param {String} [cfg.backColor="#55FF55"] Custom color for the back face of the NavCube. Overrides ````color````.
     * @param {String} [cfg.leftColor="#FF5555"] Custom color for the left face of the NavCube. Overrides ````color````.
     * @param {String} [cfg.rightColor="#FF5555"] Custom color for the right face of the NavCube. Overrides ````color````.
     * @param {String} [cfg.topColor="#5555FF"] Custom color for the top face of the NavCube. Overrides ````color````.
     * @param {String} [cfg.bottomColor="#5555FF"] Custom color for the bottom face of the NavCube. Overrides ````color````.
     * @param {String} [cfg.hoverColor="rgba(0,0,0,0.4)"] Custom color for highlighting regions on the NavCube as we hover the pointer over them.
     * @param {String} [cfg.textColor="black"] Custom text color for labels of the NavCube.
     * @param {Boolean} [cfg.fitVisible=false] Sets whether the axis, corner and edge-aligned views will fit the
     * view to the entire {@link Scene} or just to visible object-{@link Entity}s. Entitys are visible objects when {@link Entity#isObject} and {@link Entity#visible} are both ````true````.
     * @param {Boolean} [cfg.synchProjection=false] Sets whether the NavCube switches between perspective and orthographic projections in synchrony with the {@link Camera}. When ````false````, the NavCube will always be rendered with perspective projection.
     * @param {Boolean} [cfg.isProjectNorth] sets whether the NavCube switches between true north and project north - using the project north offset angle.
     * @param {number} [cfg.projectNorthOffsetAngle] sets the NavCube project north offset angle - when the {@link isProjectNorth} is true.
     */function NavCubePlugin(viewer){var _this124;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,NavCubePlugin);_this124=_super149.call(this,"NavCube",viewer,cfg);viewer.navCube=_assertThisInitialized(_this124);var visible=true;try{_this124._navCubeScene=new Scene(viewer,{canvasId:cfg.canvasId,canvasElement:cfg.canvasElement,transparent:true});_this124._navCubeCanvas=_this124._navCubeScene.canvas.canvas;_this124._navCubeScene.input.keyboardEnabled=false;// Don't want keyboard input in the NavCube
}catch(error){_this124.error(error);return _possibleConstructorReturn(_this124);}var navCubeScene=_this124._navCubeScene;navCubeScene.clearLights();new DirLight(navCubeScene,{dir:[0.4,-0.4,0.8],color:[0.8,1.0,1.0],intensity:1.0,space:"view"});new DirLight(navCubeScene,{dir:[-0.8,-0.3,-0.4],color:[0.8,0.8,0.8],intensity:1.0,space:"view"});new DirLight(navCubeScene,{dir:[0.8,-0.6,-0.8],color:[1.0,1.0,1.0],intensity:1.0,space:"view"});_this124._navCubeCamera=navCubeScene.camera;_this124._navCubeCamera.ortho.scale=7.0;_this124._navCubeCamera.ortho.near=0.1;_this124._navCubeCamera.ortho.far=2000;navCubeScene.edgeMaterial.edgeColor=[0.2,0.2,0.2];navCubeScene.edgeMaterial.edgeAlpha=0.6;_this124._zUp=Boolean(viewer.camera.zUp);var self=_assertThisInitialized(_this124);_this124.setIsProjectNorth(cfg.isProjectNorth);_this124.setProjectNorthOffsetAngle(cfg.projectNorthOffsetAngle);var rotateTrueNorth=function(){var trueNorthMatrix=math.mat4();return function(dir,vec,dest){math.identityMat4(trueNorthMatrix);math.rotationMat4v(dir*self._projectNorthOffsetAngle*math.DEGTORAD,[0,1,0],trueNorthMatrix);return math.transformVec3(trueNorthMatrix,vec,dest);};}();_this124._synchCamera=function(){var matrix=math.rotationMat4c(-90*math.DEGTORAD,1,0,0);var eyeLookVec=math.vec3();var eyeLookVecCube=math.vec3();var upCube=math.vec3();return function(){var eye=viewer.camera.eye;var look=viewer.camera.look;var up=viewer.camera.up;eyeLookVec=math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye,look,eyeLookVec)),5);if(self._isProjectNorth&&self._projectNorthOffsetAngle){eyeLookVec=rotateTrueNorth(-1,eyeLookVec,tempVec3a$4);up=rotateTrueNorth(-1,up,tempVec3b$1);}if(self._zUp){// +Z up
math.transformVec3(matrix,eyeLookVec,eyeLookVecCube);math.transformVec3(matrix,up,upCube);self._navCubeCamera.look=[0,0,0];self._navCubeCamera.eye=math.transformVec3(matrix,eyeLookVec,eyeLookVecCube);self._navCubeCamera.up=math.transformPoint3(matrix,up,upCube);}else{// +Y up
self._navCubeCamera.look=[0,0,0];self._navCubeCamera.eye=eyeLookVec;self._navCubeCamera.up=up;}};}();_this124._cubeTextureCanvas=new CubeTextureCanvas(viewer,navCubeScene,cfg);_this124._cubeSampler=new Texture(navCubeScene,{image:_this124._cubeTextureCanvas.getImage(),flipY:true,wrapS:ClampToEdgeWrapping,wrapT:ClampToEdgeWrapping});_this124._cubeMesh=new Mesh(navCubeScene,{geometry:new ReadableGeometry(navCubeScene,{primitive:"triangles",normals:[0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1],positions:[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1],uv:[0.5,0.6666,0.25,0.6666,0.25,0.3333,0.5,0.3333,0.5,0.6666,0.5,0.3333,0.75,0.3333,0.75,0.6666,0.5,0.6666,0.5,1,0.25,1,0.25,0.6666,0.25,0.6666,0.0,0.6666,0.0,0.3333,0.25,0.3333,0.25,0,0.50,0,0.50,0.3333,0.25,0.3333,0.75,0.3333,1.0,0.3333,1.0,0.6666,0.75,0.6666],indices:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]}),material:new PhongMaterial(navCubeScene,{diffuse:[0.4,0.4,0.4],specular:[0.4,0.4,0.4],emissive:[.6,.6,.6],diffuseMap:_this124._cubeSampler,emissiveMap:_this124._cubeSampler}),visible:!!visible,edges:true});_this124._shadow=cfg.shadowVisible===false?null:new Mesh(navCubeScene,{geometry:new ReadableGeometry(navCubeScene,buildCylinderGeometry({center:[0,0,0],radiusTop:0.001,radiusBottom:1.4,height:0.01,radialSegments:20,heightSegments:1,openEnded:true})),material:new PhongMaterial(navCubeScene,{diffuse:[0.0,0.0,0.0],specular:[0,0,0],emissive:[0.0,0.0,0.0],alpha:0.5}),position:[0,-1.5,0],visible:!!visible,pickable:false,backfaces:false});_this124._onCameraMatrix=viewer.camera.on("matrix",_this124._synchCamera);_this124._onCameraWorldAxis=viewer.camera.on("worldAxis",function(){if(viewer.camera.zUp){_this124._zUp=true;_this124._cubeTextureCanvas.setZUp();_this124._repaint();_this124._synchCamera();}else if(viewer.camera.yUp){_this124._zUp=false;_this124._cubeTextureCanvas.setYUp();_this124._repaint();_this124._synchCamera();}});_this124._onCameraFOV=viewer.camera.perspective.on("fov",function(fov){if(_this124._synchProjection){_this124._navCubeCamera.perspective.fov=fov;}});_this124._onCameraProjection=viewer.camera.on("projection",function(projection){if(_this124._synchProjection){_this124._navCubeCamera.projection=projection==="ortho"||projection==="perspective"?projection:"perspective";}});var lastAreaId=-1;function actionMove(posX,posY){var yawInc=(posX-lastX)*-sensitivity;var pitchInc=(posY-lastY)*-sensitivity;viewer.camera.orbitYaw(yawInc);viewer.camera.orbitPitch(-pitchInc);lastX=posX;lastY=posY;}function getCoordsWithinElement(event){var coords=[0,0];if(!event){event=window.event;coords[0]=event.x;coords[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent;}coords[0]=event.pageX-totalOffsetLeft;coords[1]=event.pageY-totalOffsetTop;}return coords;}{var downX=null;var downY=null;var down=false;var over=false;var sensitivity=0.5;var lastX;var lastY;self._navCubeCanvas.addEventListener("mouseenter",self._onMouseEnter=function(e){over=true;});self._navCubeCanvas.addEventListener("mouseleave",self._onMouseLeave=function(e){over=false;});self._navCubeCanvas.addEventListener("mousedown",self._onMouseDown=function(e){if(e.which!==1){return;}downX=e.x;downY=e.y;lastX=e.clientX;lastY=e.clientY;var canvasPos=getCoordsWithinElement(e);var hit=navCubeScene.pick({canvasPos:canvasPos});if(hit){down=true;}else{down=false;}});document.addEventListener("mouseup",self._onMouseUp=function(e){if(e.which!==1){// Left button
return;}down=false;if(downX===null){return;}var canvasPos=getCoordsWithinElement(e);var hit=navCubeScene.pick({canvasPos:canvasPos,pickSurface:true});if(hit){if(hit.uv){var areaId=self._cubeTextureCanvas.getArea(hit.uv);if(areaId>=0){document.body.style.cursor="pointer";if(lastAreaId>=0){self._cubeTextureCanvas.setAreaHighlighted(lastAreaId,false);self._repaint();lastAreaId=-1;}if(areaId>=0){self._cubeTextureCanvas.setAreaHighlighted(areaId,true);lastAreaId=areaId;self._repaint();if(e.x<downX-3||e.x>downX+3||e.y<downY-3||e.y>downY+3){return;}var dir=self._cubeTextureCanvas.getAreaDir(areaId);if(dir){var up=self._cubeTextureCanvas.getAreaUp(areaId);if(self._isProjectNorth&&self._projectNorthOffsetAngle){dir=rotateTrueNorth(+1,dir,tempVec3a$4);up=rotateTrueNorth(+1,up,tempVec3b$1);}flyTo(dir,up,function(){if(lastAreaId>=0){self._cubeTextureCanvas.setAreaHighlighted(lastAreaId,false);self._repaint();lastAreaId=-1;}document.body.style.cursor="pointer";if(lastAreaId>=0){self._cubeTextureCanvas.setAreaHighlighted(lastAreaId,false);self._repaint();lastAreaId=-1;}if(areaId>=0){self._cubeTextureCanvas.setAreaHighlighted(areaId,false);lastAreaId=-1;self._repaint();}});}}}}}});document.addEventListener("mousemove",self._onMouseMove=function(e){if(lastAreaId>=0){self._cubeTextureCanvas.setAreaHighlighted(lastAreaId,false);self._repaint();lastAreaId=-1;}if(e.buttons===1&&!down){return;}if(down){var posX=e.clientX;var posY=e.clientY;document.body.style.cursor="move";actionMove(posX,posY);return;}if(!over){return;}var canvasPos=getCoordsWithinElement(e);var hit=navCubeScene.pick({canvasPos:canvasPos,pickSurface:true});if(hit){if(hit.uv){document.body.style.cursor="pointer";var areaId=self._cubeTextureCanvas.getArea(hit.uv);if(areaId===lastAreaId){return;}if(lastAreaId>=0){self._cubeTextureCanvas.setAreaHighlighted(lastAreaId,false);}if(areaId>=0){self._cubeTextureCanvas.setAreaHighlighted(areaId,true);self._repaint();lastAreaId=areaId;}}}else{document.body.style.cursor="default";if(lastAreaId>=0){self._cubeTextureCanvas.setAreaHighlighted(lastAreaId,false);self._repaint();lastAreaId=-1;}}});var flyTo=function(){var center=math.vec3();return function(dir,up,ok){var aabb=self._fitVisible?viewer.scene.getAABB(viewer.scene.visibleObjectIds):viewer.scene.aabb;var diag=math.getAABB3Diag(aabb);math.getAABB3Center(aabb,center);var dist=Math.abs(diag/Math.tan(self._cameraFitFOV*math.DEGTORAD));viewer.cameraControl.pivotPos=center;if(self._cameraFly){viewer.cameraFlight.flyTo({look:center,eye:[center[0]-dist*dir[0],center[1]-dist*dir[1],center[2]-dist*dir[2]],up:up||[0,1,0],orthoScale:diag*1.1,fitFOV:self._cameraFitFOV,duration:self._cameraFlyDuration},ok);}else{viewer.cameraFlight.jumpTo({look:center,eye:[center[0]-dist*dir[0],center[1]-dist*dir[1],center[2]-dist*dir[2]],up:up||[0,1,0],orthoScale:diag*1.1,fitFOV:self._cameraFitFOV},ok);}};}();}_this124._onUpdated=viewer.localeService.on("updated",function(){_this124._cubeTextureCanvas.clear();_this124._repaint();});_this124.setVisible(cfg.visible);_this124.setCameraFitFOV(cfg.cameraFitFOV);_this124.setCameraFly(cfg.cameraFly);_this124.setCameraFlyDuration(cfg.cameraFlyDuration);_this124.setFitVisible(cfg.fitVisible);_this124.setSynchProjection(cfg.synchProjection);return _this124;}_createClass(NavCubePlugin,[{key:"send",value:function send(name,value){switch(name){case"language":this._cubeTextureCanvas.clear();this._repaint();// CubeTextureCanvas gets language from Viewer
break;}}},{key:"_repaint",value:function _repaint(){var image=this._cubeTextureCanvas.getImage();this._cubeMesh.material.diffuseMap.image=image;this._cubeMesh.material.emissiveMap.image=image;}/**
     * Sets if the NavCube is visible.
     *
     * @param {Boolean} visible Whether or not the NavCube is visible.
     */},{key:"setVisible",value:function setVisible(){var visible=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;if(!this._navCubeCanvas){return;}this._cubeMesh.visible=visible;if(this._shadow){this._shadow.visible=visible;}this._navCubeCanvas.style.visibility=visible?"visible":"hidden";}/**
     * Gets if the NavCube is visible.
     *
     * @return {Boolean} True when the NavCube is visible.
     */},{key:"getVisible",value:function getVisible(){if(!this._navCubeCanvas){return false;}return this._cubeMesh.visible;}/**
     * Sets whether the axis, corner and edge-aligned views will fit the
     * view to the entire {@link Scene} or just to visible object-{@link Entity}s.
     *
     * Entitys are visible objects when {@link Entity#isObject} and {@link Entity#visible} are both ````true````.
     *
     * @param {Boolean} fitVisible Set ````true```` to fit only visible object-Entitys.
     */},{key:"setFitVisible",value:function setFitVisible(){var fitVisible=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this._fitVisible=fitVisible;}/**
     * Gets whether the axis, corner and edge-aligned views will fit the
     * view to the entire {@link Scene} or just to visible object-{@link Entity}s.
     *
     * Entitys are visible objects when {@link Entity#isObject} and {@link Entity#visible} are both ````true````.
     *
     * @return {Boolean} True when fitting only visible object-Entitys.
     */},{key:"getFitVisible",value:function getFitVisible(){return this._fitVisible;}/**
     * Sets whether the {@link Camera} flies or jumps to each selected axis or diagonal.
     *
     * Default is ````true````, to fly.
     *
     * @param {Boolean} cameraFly Set ````true```` to fly, else ````false```` to jump.
     */},{key:"setCameraFly",value:function setCameraFly(){var cameraFly=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this._cameraFly=cameraFly;}/**
     * Gets whether the {@link Camera} flies or jumps to each selected axis or diagonal.
     *
     * Default is ````true````, to fly.
     *
     * @returns {Boolean} Returns ````true```` to fly, else ````false```` to jump.
     */},{key:"getCameraFly",value:function getCameraFly(){return this._cameraFly;}/**
     * Sets how much of the field-of-view, in degrees, that the {@link Scene} should
     * fill the canvas when flying or jumping the {@link Camera} to each selected axis or diagonal.
     *
     * Default value is ````45````.
     *
     * @param {Number} cameraFitFOV New FOV value.
     */},{key:"setCameraFitFOV",value:function setCameraFitFOV(){var cameraFitFOV=arguments.length>0&&arguments[0]!==undefined?arguments[0]:45;this._cameraFitFOV=cameraFitFOV;}/**
     * Gets how much of the field-of-view, in degrees, that the {@link Scene} should
     * fill the canvas when flying or jumping the {@link Camera} to each selected axis or diagonal.
     *
     * Default value is ````45````.
     *
     * @returns {Number} Current FOV value.
     */},{key:"getCameraFitFOV",value:function getCameraFitFOV(){return this._cameraFitFOV;}/**
     * When flying the {@link Camera} to each new axis or diagonal, sets how long, in seconds, that the Camera takes to get there.
     *
     * Default is ````0.5````.
     *
     * @param {Boolean} cameraFlyDuration Camera flight duration in seconds.
     */},{key:"setCameraFlyDuration",value:function setCameraFlyDuration(){var cameraFlyDuration=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0.5;this._cameraFlyDuration=cameraFlyDuration;}/**
     * When flying the {@link Camera} to each new axis or diagonal, gets how long, in seconds, that the Camera takes to get there.
     *
     * Default is ````0.5````.
     *
     * @returns {Boolean} Camera flight duration in seconds.
     */},{key:"getCameraFlyDuration",value:function getCameraFlyDuration(){return this._cameraFlyDuration;}/**
     * Sets whether the NavCube switches between perspective and orthographic projections in synchrony with
     * the {@link Camera}. When ````false````, the NavCube will always be rendered with perspective projection.
     *
     * @param {Boolean} synchProjection Set ````true```` to keep NavCube projection synchronized with {@link Camera#projection}.
     */},{key:"setSynchProjection",value:function setSynchProjection(){var synchProjection=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this._synchProjection=synchProjection;}/**
     * Gets whether the NavCube switches between perspective and orthographic projections in synchrony with
     * the {@link Camera}. When ````false````, the NavCube will always be rendered with perspective projection.
     *
     * @return {Boolean} True when NavCube projection is synchronized with {@link Camera#projection}.
     */},{key:"getSynchProjection",value:function getSynchProjection(){return this._synchProjection;}/**
     * Sets whether the NavCube switches between project north and true north
     *
     * @param {Boolean} isProjectNorth Set ````true```` to use project north offset
     */},{key:"setIsProjectNorth",value:function setIsProjectNorth(){var isProjectNorth=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this._isProjectNorth=isProjectNorth;}/**
     * Gets whether the NavCube switches between project north and true north
     *
     * @return {Boolean} isProjectNorth when ````true```` - use project north offset
     */},{key:"getIsProjectNorth",value:function getIsProjectNorth(){return this._isProjectNorth;}/**
     * Sets the NavCube project north offset angle (used when {@link isProjectNorth} is ````true````
     *
     * @param {number} projectNorthOffsetAngle Set the vector offset for project north
     */},{key:"setProjectNorthOffsetAngle",value:function setProjectNorthOffsetAngle(projectNorthOffsetAngle){this._projectNorthOffsetAngle=projectNorthOffsetAngle;}/**
     * Gets the offset angle between project north and true north
     *
     * @return {number} projectNorthOffsetAngle
     */},{key:"getProjectNorthOffsetAngle",value:function getProjectNorthOffsetAngle(){return this._projectNorthOffsetAngle;}/**
     * Destroys this NavCubePlugin.
     *
     * Does not destroy the canvas the NavCubePlugin was configured with.
     */},{key:"destroy",value:function destroy(){if(this._navCubeCanvas){this.viewer.localeService.off(this._onUpdated);this.viewer.camera.off(this._onCameraMatrix);this.viewer.camera.off(this._onCameraWorldAxis);this.viewer.camera.perspective.off(this._onCameraFOV);this.viewer.camera.off(this._onCameraProjection);this._navCubeCanvas.removeEventListener("mouseenter",this._onMouseEnter);this._navCubeCanvas.removeEventListener("mouseleave",this._onMouseLeave);this._navCubeCanvas.removeEventListener("mousedown",this._onMouseDown);document.removeEventListener("mousemove",this._onMouseMove);document.removeEventListener("mouseup",this._onMouseUp);this._navCubeCanvas=null;this._cubeTextureCanvas.destroy();this._cubeTextureCanvas=null;this._onMouseEnter=null;this._onMouseLeave=null;this._onMouseDown=null;this._onMouseMove=null;this._onMouseUp=null;}this._navCubeScene.destroy();this._navCubeScene=null;this._cubeMesh=null;this._shadow=null;_get(_getPrototypeOf(NavCubePlugin.prototype),"destroy",this).call(this);}}]);return NavCubePlugin;}(Plugin);var tempVec3a$3=math.vec3();/**
 * @private
 */var OBJSceneGraphLoader=/*#__PURE__*/function(){function OBJSceneGraphLoader(){_classCallCheck(this,OBJSceneGraphLoader);}_createClass(OBJSceneGraphLoader,[{key:"load",value:/**
     * Loads OBJ and MTL from file(s) into a {@link Node}.
     *
     * @static
     * @param {Node} modelNode Node to load into.
     * @param {String} src Path to OBJ file.
     * @param {Object} params Loading options.
     */function load(modelNode,src){var params=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var spinner=modelNode.scene.canvas.spinner;spinner.processes++;loadOBJ(modelNode,src,function(state){loadMTLs(modelNode,state,function(){createMeshes(modelNode,state);spinner.processes--;core.scheduleTask(function(){modelNode.fire("loaded",true,false);});});});}/**
     * Parses OBJ and MTL text strings into a {@link Node}.
     *
     * @static
     * @param {Node} modelNode Node to load into.
     * @param {String} objText OBJ text string.
     * @param {String} [mtlText] MTL text string.
     * @param {String} [basePath] Base path for external resources.
     */},{key:"parse",value:function parse(modelNode,objText,mtlText,basePath){if(!objText){this.warn("load() param expected: objText");return;}var state=parseOBJ(modelNode,objText,null);if(mtlText){parseMTL(modelNode,mtlText,basePath);}createMeshes(modelNode,state);modelNode.src=null;modelNode.fire("loaded",true,false);}}]);return OBJSceneGraphLoader;}();//--------------------------------------------------------------------------------------------
// Loads OBJ
//
// Parses OBJ into an intermediate state object. The object will contain geometry data
// and material IDs from which meshes can be created later. The object will also
// contain a list of filenames of the MTL files referenced by the OBJ, is any.
//
// Originally based on the THREE.js OBJ and MTL loaders:
//
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/MTLLoader.js
//--------------------------------------------------------------------------------------------
var loadOBJ=function loadOBJ(modelNode,url,ok){loadFile(url,function(text){var state=parseOBJ(modelNode,text,url);ok(state);},function(error){modelNode.error(error);});};var parseOBJ=function(){var regexp={// v float float float
vertex_pattern:/^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,// vn float float float
normal_pattern:/^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,// vt float float
uv_pattern:/^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,// f vertex vertex vertex
face_vertex:/^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,// f vertex/uv vertex/uv vertex/uv
face_vertex_uv:/^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
face_vertex_uv_normal:/^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,// f vertex//normal vertex//normal vertex//normal
face_vertex_normal:/^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,// o object_name | g group_name
object_pattern:/^[og]\s*(.+)?/,// s boolean
smoothing_pattern:/^s\s+(\d+|on|off)/,// mtllib file_reference
material_library_pattern:/^mtllib /,// usemtl material_name
material_use_pattern:/^usemtl /};return function(modelNode,text,url){url=url||"";var state={src:url,basePath:getBasePath(url),objects:[],object:{},positions:[],normals:[],uv:[],materialLibraries:{}};startObject(state,"",false);// Parts of this parser logic are derived from the THREE.js OBJ loader:
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js
if(text.indexOf('\r\n')!==-1){// This is faster than String.split with regex that splits on both
text=text.replace('\r\n','\n');}var lines=text.split('\n');var line='',lineFirstChar='',lineSecondChar='';var lineLength=0;var result=[];// Faster to just trim left side of the line. Use if available.
var trimLeft=typeof''.trimLeft==='function';for(var i=0,l=lines.length;i<l;i++){line=lines[i];line=trimLeft?line.trimLeft():line.trim();lineLength=line.length;if(lineLength===0){continue;}lineFirstChar=line.charAt(0);if(lineFirstChar==='#'){continue;}if(lineFirstChar==='v'){lineSecondChar=line.charAt(1);if(lineSecondChar===' '&&(result=regexp.vertex_pattern.exec(line))!==null){// 0                  1      2      3
// ['v 1.0 2.0 3.0', '1.0', '2.0', '3.0']
state.positions.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3]));}else if(lineSecondChar==='n'&&(result=regexp.normal_pattern.exec(line))!==null){// 0                   1      2      3
// ['vn 1.0 2.0 3.0', '1.0', '2.0', '3.0']
state.normals.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3]));}else if(lineSecondChar==='t'&&(result=regexp.uv_pattern.exec(line))!==null){// 0               1      2
// ['vt 0.1 0.2', '0.1', '0.2']
state.uv.push(parseFloat(result[1]),parseFloat(result[2]));}else{modelNode.error('Unexpected vertex/normal/uv line: \''+line+'\'');return;}}else if(lineFirstChar==='f'){if((result=regexp.face_vertex_uv_normal.exec(line))!==null){// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
// 0                        1    2    3    4    5    6    7    8    9   10         11         12
// ['f 1/1/1 2/2/2 3/3/3', '1', '1', '1', '2', '2', '2', '3', '3', '3', undefined, undefined, undefined]
addFace(state,result[1],result[4],result[7],result[10],result[2],result[5],result[8],result[11],result[3],result[6],result[9],result[12]);}else if((result=regexp.face_vertex_uv.exec(line))!==null){// f vertex/uv vertex/uv vertex/uv
// 0                  1    2    3    4    5    6   7          8
// ['f 1/1 2/2 3/3', '1', '1', '2', '2', '3', '3', undefined, undefined]
addFace(state,result[1],result[3],result[5],result[7],result[2],result[4],result[6],result[8]);}else if((result=regexp.face_vertex_normal.exec(line))!==null){// f vertex//normal vertex//normal vertex//normal
// 0                     1    2    3    4    5    6   7          8
// ['f 1//1 2//2 3//3', '1', '1', '2', '2', '3', '3', undefined, undefined]
addFace(state,result[1],result[3],result[5],result[7],undefined,undefined,undefined,undefined,result[2],result[4],result[6],result[8]);}else if((result=regexp.face_vertex.exec(line))!==null){// f vertex vertex vertex
// 0            1    2    3   4
// ['f 1 2 3', '1', '2', '3', undefined]
addFace(state,result[1],result[2],result[3],result[4]);}else{modelNode.error('Unexpected face line: \''+line+'\'');return;}}else if(lineFirstChar==='l'){var lineParts=line.substring(1).trim().split(' ');var lineVertices=[],lineUVs=[];if(line.indexOf('/')===-1){lineVertices=lineParts;}else{for(var li=0,llen=lineParts.length;li<llen;li++){var parts=lineParts[li].split('/');if(parts[0]!==''){lineVertices.push(parts[0]);}if(parts[1]!==''){lineUVs.push(parts[1]);}}}addLineGeometry(state,lineVertices,lineUVs);}else if((result=regexp.object_pattern.exec(line))!==null){// o object_name
// or
// g group_name
var id=result[0].substr(1).trim();startObject(state,id,true);}else if(regexp.material_use_pattern.test(line)){// material
var id=line.substring(7).trim();state.object.material.id=id;}else if(regexp.material_library_pattern.test(line)){// mtl file
state.materialLibraries[line.substring(7).trim()]=true;}else if((result=regexp.smoothing_pattern.exec(line))!==null){// smooth shading
var value=result[1].trim().toLowerCase();state.object.material.smooth=value==='1'||value==='on';}else{// Handle null terminated files without exception
if(line==='\0'){continue;}modelNode.error('Unexpected line: \''+line+'\'');return;}}return state;};function getBasePath(src){var n=src.lastIndexOf('/');return n===-1?src:src.substring(0,n+1);}function startObject(state,id,fromDeclaration){if(state.object&&state.object.fromDeclaration===false){state.object.id=id;state.object.fromDeclaration=fromDeclaration!==false;return;}state.object={id:id||'',geometry:{positions:[],normals:[],uv:[]},material:{id:'',smooth:true},fromDeclaration:fromDeclaration!==false};state.objects.push(state.object);}function parseVertexIndex(value,len){var index=parseInt(value,10);return(index>=0?index-1:index+len/3)*3;}function parseNormalIndex(value,len){var index=parseInt(value,10);return(index>=0?index-1:index+len/3)*3;}function parseUVIndex(value,len){var index=parseInt(value,10);return(index>=0?index-1:index+len/2)*2;}function addVertex(state,a,b,c){var src=state.positions;var dst=state.object.geometry.positions;dst.push(src[a+0]);dst.push(src[a+1]);dst.push(src[a+2]);dst.push(src[b+0]);dst.push(src[b+1]);dst.push(src[b+2]);dst.push(src[c+0]);dst.push(src[c+1]);dst.push(src[c+2]);}function addVertexLine(state,a){var src=state.positions;var dst=state.object.geometry.positions;dst.push(src[a+0]);dst.push(src[a+1]);dst.push(src[a+2]);}function addNormal(state,a,b,c){var src=state.normals;var dst=state.object.geometry.normals;dst.push(src[a+0]);dst.push(src[a+1]);dst.push(src[a+2]);dst.push(src[b+0]);dst.push(src[b+1]);dst.push(src[b+2]);dst.push(src[c+0]);dst.push(src[c+1]);dst.push(src[c+2]);}function addUV(state,a,b,c){var src=state.uv;var dst=state.object.geometry.uv;dst.push(src[a+0]);dst.push(src[a+1]);dst.push(src[b+0]);dst.push(src[b+1]);dst.push(src[c+0]);dst.push(src[c+1]);}function addUVLine(state,a){var src=state.uv;var dst=state.object.geometry.uv;dst.push(src[a+0]);dst.push(src[a+1]);}function addFace(state,a,b,c,d,ua,ub,uc,ud,na,nb,nc,nd){var vLen=state.positions.length;var ia=parseVertexIndex(a,vLen);var ib=parseVertexIndex(b,vLen);var ic=parseVertexIndex(c,vLen);var id;if(d===undefined){addVertex(state,ia,ib,ic);}else{id=parseVertexIndex(d,vLen);addVertex(state,ia,ib,id);addVertex(state,ib,ic,id);}if(ua!==undefined){var uvLen=state.uv.length;ia=parseUVIndex(ua,uvLen);ib=parseUVIndex(ub,uvLen);ic=parseUVIndex(uc,uvLen);if(d===undefined){addUV(state,ia,ib,ic);}else{id=parseUVIndex(ud,uvLen);addUV(state,ia,ib,id);addUV(state,ib,ic,id);}}if(na!==undefined){// Normals are many times the same. If so, skip function call and parseInt.
var nLen=state.normals.length;ia=parseNormalIndex(na,nLen);ib=na===nb?ia:parseNormalIndex(nb,nLen);ic=na===nc?ia:parseNormalIndex(nc,nLen);if(d===undefined){addNormal(state,ia,ib,ic);}else{id=parseNormalIndex(nd,nLen);addNormal(state,ia,ib,id);addNormal(state,ib,ic,id);}}}function addLineGeometry(state,positions,uv){state.object.geometry.type='Line';var vLen=state.positions.length;var uvLen=state.uv.length;for(var vi=0,l=positions.length;vi<l;vi++){addVertexLine(state,parseVertexIndex(positions[vi],vLen));}for(var uvi=0,uvl=uv.length;uvi<uvl;uvi++){addUVLine(state,parseUVIndex(uv[uvi],uvLen));}}}();//--------------------------------------------------------------------------------------------
// Loads MTL files listed in parsed state
//--------------------------------------------------------------------------------------------
function loadMTLs(modelNode,state,ok){var basePath=state.basePath;var srcList=Object.keys(state.materialLibraries);var numToLoad=srcList.length;for(var i=0,len=numToLoad;i<len;i++){loadMTL(modelNode,basePath,basePath+srcList[i],function(){if(--numToLoad===0){ok();}});}}//--------------------------------------------------------------------------------------------
// Loads an MTL file
//--------------------------------------------------------------------------------------------
var loadMTL=function loadMTL(modelNode,basePath,src,ok){loadFile(src,function(text){parseMTL(modelNode,text,basePath);ok();},function(error){modelNode.error(error);ok();});};var parseMTL=function(){var delimiter_pattern=/\s+/;return function(modelNode,mtlText,basePath){var lines=mtlText.split('\n');var materialCfg={id:"Default"};var needCreate=false;var line;var pos;var key;var value;var alpha;basePath=basePath||"";for(var i=0;i<lines.length;i++){line=lines[i].trim();if(line.length===0||line.charAt(0)==='#'){// Blank line or comment ignore
continue;}pos=line.indexOf(' ');key=pos>=0?line.substring(0,pos):line;key=key.toLowerCase();value=pos>=0?line.substring(pos+1):'';value=value.trim();switch(key.toLowerCase()){case"newmtl":// New material
//if (needCreate) {
createMaterial(modelNode,materialCfg);//}
materialCfg={id:value};needCreate=true;break;case'ka':materialCfg.ambient=parseRGB(value);break;case'kd':materialCfg.diffuse=parseRGB(value);break;case'ks':materialCfg.specular=parseRGB(value);break;case'map_kd':if(!materialCfg.diffuseMap){materialCfg.diffuseMap=createTexture(modelNode,basePath,value,"sRGB");}break;case'map_ks':if(!materialCfg.specularMap){materialCfg.specularMap=createTexture(modelNode,basePath,value,"linear");}break;case'map_bump':case'bump':if(!materialCfg.normalMap){materialCfg.normalMap=createTexture(modelNode,basePath,value);}break;case'ns':materialCfg.shininess=parseFloat(value);break;case'd':alpha=parseFloat(value);if(alpha<1){materialCfg.alpha=alpha;materialCfg.alphaMode="blend";}break;case'tr':alpha=parseFloat(value);if(alpha>0){materialCfg.alpha=1-alpha;materialCfg.alphaMode="blend";}break;// modelNode.error("Unrecognized token: " + key);
}}if(needCreate){createMaterial(modelNode,materialCfg);}};function createTexture(modelNode,basePath,value,encoding){var textureCfg={};var items=value.split(/\s+/);var pos=items.indexOf('-bm');if(pos>=0){//matParams.bumpScale = parseFloat(items[pos + 1]);
items.splice(pos,2);}pos=items.indexOf('-s');if(pos>=0){textureCfg.scale=[parseFloat(items[pos+1]),parseFloat(items[pos+2])];items.splice(pos,4);// we expect 3 parameters here!
}pos=items.indexOf('-o');if(pos>=0){textureCfg.translate=[parseFloat(items[pos+1]),parseFloat(items[pos+2])];items.splice(pos,4);// we expect 3 parameters here!
}textureCfg.src=basePath+items.join(' ').trim();textureCfg.flipY=true;textureCfg.encoding=encoding||"linear";//textureCfg.wrapS = self.wrap;
//textureCfg.wrapT = self.wrap;
var texture=new Texture(modelNode,textureCfg);return texture.id;}function createMaterial(modelNode,materialCfg){new PhongMaterial(modelNode,materialCfg);}function parseRGB(value){var ss=value.split(delimiter_pattern,3);return[parseFloat(ss[0]),parseFloat(ss[1]),parseFloat(ss[2])];}}();//--------------------------------------------------------------------------------------------
// Creates meshes from parsed state
//--------------------------------------------------------------------------------------------
function createMeshes(modelNode,state){for(var j=0,k=state.objects.length;j<k;j++){var object=state.objects[j];var geometry=object.geometry;geometry.type==='Line';if(geometry.positions.length===0){// Skip o/g line declarations that did not follow with any faces
continue;}var geometryCfg={primitive:"triangles",compressGeometry:false};geometryCfg.positions=geometry.positions;if(geometry.normals.length>0){geometryCfg.normals=geometry.normals;}if(geometry.uv.length>0){geometryCfg.uv=geometry.uv;}var indices=new Array(geometryCfg.positions.length/3);// Triangle soup
for(var idx=0;idx<indices.length;idx++){indices[idx]=idx;}geometryCfg.indices=indices;var origin=tempVec3a$3;worldToRTCPositions(geometry.positions,geometry.positions,origin);var readableGeometry=new ReadableGeometry(modelNode,geometryCfg);var materialId=object.material.id;var material;if(materialId&&materialId!==""){material=modelNode.scene.components[materialId];if(!material){modelNode.error("Material not found: "+materialId);}}else{material=new PhongMaterial(modelNode,{//emissive: [0.6, 0.6, 0.0],
diffuse:[0.6,0.6,0.6],backfaces:true});}// material.emissive = [Math.random(), Math.random(), Math.random()];
var mesh=new Mesh(modelNode,{id:modelNode.id+"#"+object.id,origin:origin[0]!==0||origin[1]!==0||origin[2]!==0?origin:null,isObject:true,geometry:readableGeometry,material:material,pickable:true});modelNode.addChild(mesh);}}function loadFile(url,ok,err){var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=event.target.response;if(this.status===200){if(ok){ok(response);}}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
console.warn('loadFile: HTTP Status 0 received.');if(ok){ok(response);}}else{if(err){err(event);}}},false);request.addEventListener('error',function(event){if(err){err(event);}},false);request.send(null);}/**
 * {@link Viewer} plugin that loads models from [OBJ](https://en.wikipedia.org/wiki/Wavefront_.obj_file) files.
 *
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 *
 * ## Metadata
 *
 * OBJLoaderPlugin can also load an accompanying JSON metadata file with each model, which creates a {@link MetaModel} corresponding
 * to the model {@link Entity} and a {@link MetaObject} corresponding to each object {@link Entity}.
 *
 * Each {@link MetaObject} has a {@link MetaObject#type}, which indicates the classification of its corresponding {@link Entity}. When loading
 * metadata, we can also provide GLTFModelLoaderPlugin with a custom lookup table of initial values to set on the properties of each type of {@link Entity}. By default, OBJLoaderPlugin
 * uses its own map of standard default colors, visibilities and opacities for IFC element types.

 *
 * ## Usage
 *
 * [[Run this example](/examples/#loading_OBJ_SportsCar)]
 *
 * ````javascript
 * import {Viewer, OBJLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a xeokit Viewer and arrange the camera
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.camera.orbitPitch(20);
 *
 * // Add an OBJLoaderPlugin to the Viewer
 * const objLoader = new OBJLoaderPlugin(viewer);
 *
 * // Load an OBJ model
 * var model = objLoader.load({ // Model is an Entity
 *      id: "myModel",
 *      src: "./models/obj/sportsCar/sportsCar.obj",
 *      edges: true
 * });
 *
 * // When the model has loaded, fit it to view
 * model.on("loaded", () => {
 *      viewer.cameraFlight.flyTo(model);
 * })
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Update properties of the model Entity
 * model.highlight = [1,0,0];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 * @class OBJLoaderPlugin
 */var OBJLoaderPlugin=/*#__PURE__*/function(_Plugin9){_inherits(OBJLoaderPlugin,_Plugin9);var _super150=_createSuper(OBJLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg Plugin configuration.
     * @param {String} [cfg.id="OBJLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     */function OBJLoaderPlugin(viewer,cfg){var _this125;_classCallCheck(this,OBJLoaderPlugin);_this125=_super150.call(this,"OBJLoader",viewer,cfg);/**
         * @private
         */_this125._sceneGraphLoader=new OBJSceneGraphLoader();return _this125;}/**
     * Loads an OBJ model from a file into this OBJLoader's {@link Viewer}.
     *
     * @param {*} params  Loading parameters.
     * @param {String} params.id ID to assign to the model's root {@link Entity}, unique among all components in the Viewer's {@link Scene}.
     * @param {String} params.src Path to an OBJ file.
     * @param {String} [params.metaModelSrc] Path to an optional metadata file.
     * @param {Number[]} [params.position=[0,0,0]] The model World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Number} [params.edgeThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */_createClass(OBJLoaderPlugin,[{key:"load",value:function load(){var _this126=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var modelNode=new Node$2(this.viewer.scene,utils.apply(params,{isModel:true}));var modelId=modelNode.id;// In case ID was auto-generated
var src=params.src;if(!src){this.error("load() param expected: src");return modelNode;}if(params.metaModelSrc){var metaModelSrc=params.metaModelSrc;utils.loadJSON(metaModelSrc,function(modelMetadata){_this126.viewer.metaScene.createMetaModel(modelId,modelMetadata);_this126._sceneGraphLoader.load(modelNode,src,params);},function(errMsg){_this126.error("load(): Failed to load model modelMetadata for model '".concat(modelId," from  '").concat(metaModelSrc,"' - ").concat(errMsg));});}else{this._sceneGraphLoader.load(modelNode,src,params);}modelNode.once("destroyed",function(){_this126.viewer.metaScene.destroyMetaModel(modelId);});return modelNode;}/**
     * Destroys this OBJLoaderPlugin.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(OBJLoaderPlugin.prototype),"destroy",this).call(this);}}]);return OBJLoaderPlugin;}(Plugin);var zeroVec$1=new Float64Array([0,0,1]);var quat$1=new Float64Array(4);/**
 * Controls a {@link SectionPlane} with mouse and touch input.
 *
 * @private
 */var Control=/*#__PURE__*/function(){/** @private */function Control(plugin){_classCallCheck(this,Control);/**
         * ID of this Control.
         *
         * SectionPlaneControls are mapped by this ID in {@link SectionPlanesPlugin#sectionPlaneControls}.
         *
         * @property id
         * @type {String|Number}
         */this.id=null;this._viewer=plugin.viewer;this._visible=false;this._pos=math.vec3();// Full-precision position of the center of the Control
this._origin=math.vec3();this._rtcPos=math.vec3();this._baseDir=math.vec3();// Saves direction of clip plane when we start dragging an arrow or ring.
this._rootNode=null;// Root of Node graph that represents this control in the 3D scene
this._displayMeshes=null;// Meshes that are always visible
this._affordanceMeshes=null;// Meshes displayed momentarily for affordance
this._ignoreNextSectionPlaneDirUpdate=false;this._createNodes();this._bindEvents();}/**
     * Called by SectionPlanesPlugin to assign this Control to a SectionPlane.
     * SectionPlanesPlugin keeps SectionPlaneControls in a reuse pool.
     * Call with a null or undefined value to disconnect the Control ffrom whatever SectionPlane it was assigned to.
     * @private
     */_createClass(Control,[{key:"_setSectionPlane",value:function _setSectionPlane(sectionPlane){var _this127=this;if(this._sectionPlane){this._sectionPlane.off(this._onSectionPlanePos);this._sectionPlane.off(this._onSectionPlaneDir);this._onSectionPlanePos=null;this._onSectionPlaneDir=null;this._sectionPlane=null;}if(sectionPlane){this.id=sectionPlane.id;this._setPos(sectionPlane.pos);this._setDir(sectionPlane.dir);this._sectionPlane=sectionPlane;this._onSectionPlanePos=sectionPlane.on("pos",function(){_this127._setPos(_this127._sectionPlane.pos);});this._onSectionPlaneDir=sectionPlane.on("dir",function(){if(!_this127._ignoreNextSectionPlaneDirUpdate){_this127._setDir(_this127._sectionPlane.dir);}else{_this127._ignoreNextSectionPlaneDirUpdate=false;}});}}/**
     * Gets the {@link SectionPlane} controlled by this Control.
     * @returns {SectionPlane} The SectionPlane.
     */},{key:"sectionPlane",get:function get(){return this._sectionPlane;}/** @private */},{key:"_setPos",value:function _setPos(xyz){this._pos.set(xyz);worldToRTCPos(this._pos,this._origin,this._rtcPos);this._rootNode.origin=this._origin;this._rootNode.position=this._rtcPos;}/** @private */},{key:"_setDir",value:function _setDir(xyz){this._baseDir.set(xyz);this._rootNode.quaternion=math.vec3PairToQuaternion(zeroVec$1,xyz,quat$1);}},{key:"_setSectionPlaneDir",value:function _setSectionPlaneDir(dir){if(this._sectionPlane){this._ignoreNextSectionPlaneDirUpdate=true;this._sectionPlane.dir=dir;}}/**
     * Sets if this Control is visible.
     *
     * @type {Boolean}
     */},{key:"setVisible",value:function setVisible(){var visible=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;if(this._visible===visible){return;}this._visible=visible;var id;for(id in this._displayMeshes){if(this._displayMeshes.hasOwnProperty(id)){this._displayMeshes[id].visible=visible;}}if(!visible){for(id in this._affordanceMeshes){if(this._affordanceMeshes.hasOwnProperty(id)){this._affordanceMeshes[id].visible=visible;}}}}/**
     * Gets if this Control is visible.
     *
     * @type {Boolean}
     */},{key:"getVisible",value:function getVisible(){return this._visible;}/**
     * Sets if this Control is culled. This is called by SectionPlanesPlugin to
     * temporarily hide the Control while a snapshot is being taken by Viewer#getSnapshot().
     * @param culled
     */},{key:"setCulled",value:function setCulled(culled){var id;for(id in this._displayMeshes){if(this._displayMeshes.hasOwnProperty(id)){this._displayMeshes[id].culled=culled;}}if(!culled){for(id in this._affordanceMeshes){if(this._affordanceMeshes.hasOwnProperty(id)){this._affordanceMeshes[id].culled=culled;}}}}/**
     * Builds the Entities that represent this Control.
     * @private
     */},{key:"_createNodes",value:function _createNodes(){var NO_STATE_INHERIT=false;var scene=this._viewer.scene;var radius=1.0;var handleTubeRadius=0.06;var hoopRadius=radius-0.2;var tubeRadius=0.01;var arrowRadius=0.07;this._rootNode=new Node$2(scene,{position:[0,0,0],scale:[5,5,5]});var rootNode=this._rootNode;var shapes={// Reusable geometries
arrowHead:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:0.001,radiusBottom:arrowRadius,radialSegments:32,heightSegments:1,height:0.2,openEnded:false})),arrowHeadBig:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:0.001,radiusBottom:0.09,radialSegments:32,heightSegments:1,height:0.25,openEnded:false})),arrowHeadHandle:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:0.09,radiusBottom:0.09,radialSegments:8,heightSegments:1,height:0.37,openEnded:false})),curve:new ReadableGeometry(rootNode,buildTorusGeometry({radius:hoopRadius,tube:tubeRadius,radialSegments:64,tubeSegments:14,arc:Math.PI*2.0/4.0})),curveHandle:new ReadableGeometry(rootNode,buildTorusGeometry({radius:hoopRadius,tube:handleTubeRadius,radialSegments:64,tubeSegments:14,arc:Math.PI*2.0/4.0})),hoop:new ReadableGeometry(rootNode,buildTorusGeometry({radius:hoopRadius,tube:tubeRadius,radialSegments:64,tubeSegments:8,arc:Math.PI*2.0})),axis:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:tubeRadius,radiusBottom:tubeRadius,radialSegments:20,heightSegments:1,height:radius,openEnded:false})),axisHandle:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:0.08,radiusBottom:0.08,radialSegments:20,heightSegments:1,height:radius,openEnded:false}))};var materials={// Reusable materials
pickable:new PhongMaterial(rootNode,{// Invisible material for pickable handles, which define a pickable 3D area
diffuse:[1,1,0],alpha:0,// Invisible
alphaMode:"blend"}),red:new PhongMaterial(rootNode,{diffuse:[1,0.0,0.0],emissive:[1,0.0,0.0],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2}),highlightRed:new EmphasisMaterial(rootNode,{// Emphasis for red rotation affordance hoop
edges:false,fill:true,fillColor:[1,0,0],fillAlpha:0.6}),green:new PhongMaterial(rootNode,{diffuse:[0.0,1,0.0],emissive:[0.0,1,0.0],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2}),highlightGreen:new EmphasisMaterial(rootNode,{// Emphasis for green rotation affordance hoop
edges:false,fill:true,fillColor:[0,1,0],fillAlpha:0.6}),blue:new PhongMaterial(rootNode,{diffuse:[0.0,0.0,1],emissive:[0.0,0.0,1],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2}),highlightBlue:new EmphasisMaterial(rootNode,{// Emphasis for blue rotation affordance hoop
edges:false,fill:true,fillColor:[0,0,1],fillAlpha:0.2}),center:new PhongMaterial(rootNode,{diffuse:[0.0,0.0,0.0],emissive:[0,0,0],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80}),highlightBall:new EmphasisMaterial(rootNode,{edges:false,fill:true,fillColor:[0.5,0.5,0.5],fillAlpha:0.5,vertices:false}),highlightPlane:new EmphasisMaterial(rootNode,{edges:true,edgeWidth:3,fill:false,fillColor:[0.5,0.5,.5],fillAlpha:0.5,vertices:false})};this._displayMeshes={plane:rootNode.addChild(new Mesh(rootNode,{geometry:new ReadableGeometry(rootNode,{primitive:"triangles",positions:[0.5,0.5,0.0,0.5,-0.5,0.0,// 0
-0.5,-0.5,0.0,-0.5,0.5,0.0,// 1
0.5,0.5,-0.0,0.5,-0.5,-0.0,// 2
-0.5,-0.5,-0.0,-0.5,0.5,-0.0// 3
],indices:[0,1,2,2,3,0]}),material:new PhongMaterial(rootNode,{emissive:[0,0.0,0],diffuse:[0,0,0],backfaces:true}),opacity:0.6,ghosted:true,ghostMaterial:new EmphasisMaterial(rootNode,{edges:false,filled:true,fillColor:[1,1,0],edgeColor:[0,0,0],fillAlpha:0.1,backfaces:true}),pickable:false,collidable:true,clippable:false,visible:false,scale:[2.4,2.4,1]}),NO_STATE_INHERIT),planeFrame:rootNode.addChild(new Mesh(rootNode,{// Visible frame
geometry:new ReadableGeometry(rootNode,buildTorusGeometry({center:[0,0,0],radius:1.7,tube:tubeRadius*2,radialSegments:4,tubeSegments:4,arc:Math.PI*2.0})),material:new PhongMaterial(rootNode,{emissive:[0,0,0],diffuse:[0,0,0],specular:[0,0,0],shininess:0}),//highlighted: true,
highlightMaterial:new EmphasisMaterial(rootNode,{edges:false,edgeColor:[0.0,0.0,0.0],filled:true,fillColor:[0.8,0.8,0.8],fillAlpha:1.0}),pickable:false,collidable:false,clippable:false,visible:false,scale:[1,1,.1],rotation:[0,0,45]}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
xCurve:rootNode.addChild(new Mesh(rootNode,{// Red hoop about Y-axis
geometry:shapes.curve,material:materials.red,matrix:function(){var rotate2=math.rotationMat4v(90*math.DEGTORAD,[0,1,0],math.identityMat4());var rotate1=math.rotationMat4v(270*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate1,rotate2,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,backfaces:true,visible:false}),NO_STATE_INHERIT),xCurveHandle:rootNode.addChild(new Mesh(rootNode,{// Red hoop about Y-axis
geometry:shapes.curveHandle,material:materials.pickable,matrix:function(){var rotate2=math.rotationMat4v(90*math.DEGTORAD,[0,1,0],math.identityMat4());var rotate1=math.rotationMat4v(270*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate1,rotate2,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,backfaces:true,visible:false}),NO_STATE_INHERIT),xCurveArrow1:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.red,matrix:function(){var translate=math.translateMat4c(0.,-0.07,-0.8,math.identityMat4());var scale=math.scaleMat4v([0.6,0.6,0.6],math.identityMat4());var rotate=math.rotationMat4v(0*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(math.mulMat4(translate,scale,math.identityMat4()),rotate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),xCurveArrow2:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.red,matrix:function(){var translate=math.translateMat4c(0.0,-0.8,-0.07,math.identityMat4());var scale=math.scaleMat4v([0.6,0.6,0.6],math.identityMat4());var rotate=math.rotationMat4v(90*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(math.mulMat4(translate,scale,math.identityMat4()),rotate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
yCurve:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.curve,material:materials.green,rotation:[-90,0,0],pickable:false,collidable:true,clippable:false,backfaces:true,visible:false}),NO_STATE_INHERIT),yCurveHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.curveHandle,material:materials.pickable,rotation:[-90,0,0],pickable:true,collidable:true,clippable:false,backfaces:true,visible:false}),NO_STATE_INHERIT),yCurveArrow1:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.green,matrix:function(){var translate=math.translateMat4c(0.07,0,-0.8,math.identityMat4());var scale=math.scaleMat4v([0.6,0.6,0.6],math.identityMat4());var rotate=math.rotationMat4v(90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(math.mulMat4(translate,scale,math.identityMat4()),rotate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),yCurveArrow2:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.green,matrix:function(){var translate=math.translateMat4c(0.8,0.0,-0.07,math.identityMat4());var scale=math.scaleMat4v([0.6,0.6,0.6],math.identityMat4());var rotate=math.rotationMat4v(90*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(math.mulMat4(translate,scale,math.identityMat4()),rotate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
zCurve:rootNode.addChild(new Mesh(rootNode,{// Blue hoop about Z-axis
geometry:shapes.curve,material:materials.blue,matrix:math.rotationMat4v(180*math.DEGTORAD,[1,0,0],math.identityMat4()),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zCurveHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.curveHandle,material:materials.pickable,matrix:math.rotationMat4v(180*math.DEGTORAD,[1,0,0],math.identityMat4()),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zCurveCurveArrow1:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.blue,matrix:function(){var translate=math.translateMat4c(.8,-0.07,0,math.identityMat4());var scale=math.scaleMat4v([0.6,0.6,0.6],math.identityMat4());return math.mulMat4(translate,scale,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zCurveArrow2:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.blue,matrix:function(){var translate=math.translateMat4c(.05,-0.8,0,math.identityMat4());var scale=math.scaleMat4v([0.6,0.6,0.6],math.identityMat4());var rotate=math.rotationMat4v(90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(math.mulMat4(translate,scale,math.identityMat4()),rotate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
center:rootNode.addChild(new Mesh(rootNode,{geometry:new ReadableGeometry(rootNode,buildSphereGeometry({radius:0.05})),material:materials.center,pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
xAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.red,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),xAxisArrowHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadHandle,material:materials.pickable,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),xAxis:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axis,material:materials.red,matrix:function(){var translate=math.translateMat4c(0,radius/2,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),xAxisHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axisHandle,material:materials.pickable,matrix:function(){var translate=math.translateMat4c(0,radius/2,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
yAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.green,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(180*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),yAxisArrowHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadHandle,material:materials.pickable,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(180*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false,opacity:0.2}),NO_STATE_INHERIT),yShaft:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axis,material:materials.green,position:[0,-radius/2,0],pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),yShaftHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axisHandle,material:materials.pickable,position:[0,-radius/2,0],pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),//----------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------
zAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.blue,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0.8,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zAxisArrowHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadHandle,material:materials.pickable,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0.8,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:true,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zShaft:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axis,material:materials.blue,matrix:function(){var translate=math.translateMat4c(0,radius/2,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),clippable:false,pickable:false,collidable:true,visible:false}),NO_STATE_INHERIT),zAxisHandle:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axisHandle,material:materials.pickable,matrix:function(){var translate=math.translateMat4c(0,radius/2,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),clippable:false,pickable:true,collidable:true,visible:false}),NO_STATE_INHERIT)};this._affordanceMeshes={planeFrame:rootNode.addChild(new Mesh(rootNode,{geometry:new ReadableGeometry(rootNode,buildTorusGeometry({center:[0,0,0],radius:2,tube:tubeRadius,radialSegments:4,tubeSegments:4,arc:Math.PI*2.0})),material:new PhongMaterial(rootNode,{ambient:[1,1,1],diffuse:[0,0,0],emissive:[1,1,0]}),highlighted:true,highlightMaterial:new EmphasisMaterial(rootNode,{edges:false,filled:true,fillColor:[1,1,0],fillAlpha:1.0}),pickable:false,collidable:false,clippable:false,visible:false,scale:[1,1,1],rotation:[0,0,45]}),NO_STATE_INHERIT),xHoop:rootNode.addChild(new Mesh(rootNode,{// Full
geometry:shapes.hoop,material:materials.red,highlighted:true,highlightMaterial:materials.highlightRed,matrix:function(){var rotate2=math.rotationMat4v(90*math.DEGTORAD,[0,1,0],math.identityMat4());var rotate1=math.rotationMat4v(270*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate1,rotate2,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),yHoop:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.hoop,material:materials.green,highlighted:true,highlightMaterial:materials.highlightGreen,rotation:[-90,0,0],pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zHoop:rootNode.addChild(new Mesh(rootNode,{// Blue hoop about Z-axis
geometry:shapes.hoop,material:materials.blue,highlighted:true,highlightMaterial:materials.highlightBlue,matrix:math.rotationMat4v(180*math.DEGTORAD,[1,0,0],math.identityMat4()),pickable:false,collidable:true,clippable:false,backfaces:true,visible:false}),NO_STATE_INHERIT),xAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadBig,material:materials.red,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0,0,1],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),yAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadBig,material:materials.green,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(180*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadBig,material:materials.blue,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0.8,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT)};}},{key:"_bindEvents",value:function _bindEvents(){var _this128=this;var self=this;var grabbed=false;var DRAG_ACTIONS={none:-1,xTranslate:0,yTranslate:1,zTranslate:2,xRotate:3,yRotate:4,zRotate:5};var rootNode=this._rootNode;var nextDragAction=null;// As we hover grabbed an arrow or hoop, self is the action we would do if we then dragged it.
var dragAction=null;// Action we're doing while we drag an arrow or hoop.
var lastCanvasPos=math.vec2();var xBaseAxis=math.vec3([1,0,0]);var yBaseAxis=math.vec3([0,1,0]);var zBaseAxis=math.vec3([0,0,1]);var canvas=this._viewer.scene.canvas.canvas;var camera=this._viewer.camera;var scene=this._viewer.scene;{// Keep gizmo screen size constant
var _tempVec3a=math.vec3([0,0,0]);var lastDist=-1;this._onCameraViewMatrix=scene.camera.on("viewMatrix",function(){});this._onCameraProjMatrix=scene.camera.on("projMatrix",function(){});this._onSceneTick=scene.on("tick",function(){var dist=Math.abs(math.lenVec3(math.subVec3(scene.camera.eye,_this128._pos,_tempVec3a)));if(dist!==lastDist){if(camera.projection==="perspective"){var worldSize=Math.tan(camera.perspective.fov*math.DEGTORAD)*dist;var size=0.07*worldSize;rootNode.scale=[size,size,size];lastDist=dist;}}if(camera.projection==="ortho"){var _worldSize=camera.ortho.scale/10;var _size=_worldSize;rootNode.scale=[_size,_size,_size];lastDist=dist;}});}var getClickCoordsWithinElement=function(){var canvasPos=new Float64Array(2);return function(event){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent;}canvasPos[0]=event.pageX-totalOffsetLeft;canvasPos[1]=event.pageY-totalOffsetTop;}return canvasPos;};}();var localToWorldVec=function(){var mat=math.mat4();return function(localVec,worldVec){math.quaternionToMat4(self._rootNode.quaternion,mat);math.transformVec3(mat,localVec,worldVec);math.normalizeVec3(worldVec);return worldVec;};}();var getTranslationPlane=function(){var planeNormal=math.vec3();return function(worldAxis){var absX=Math.abs(worldAxis[0]);if(absX>Math.abs(worldAxis[1])&&absX>Math.abs(worldAxis[2])){math.cross3Vec3(worldAxis,[0,1,0],planeNormal);}else{math.cross3Vec3(worldAxis,[1,0,0],planeNormal);}math.cross3Vec3(planeNormal,worldAxis,planeNormal);math.normalizeVec3(planeNormal);return planeNormal;};}();var dragTranslateSectionPlane=function(){var p1=math.vec3();var p2=math.vec3();var worldAxis=math.vec4();return function(baseAxis,fromMouse,toMouse){localToWorldVec(baseAxis,worldAxis);var planeNormal=getTranslationPlane(worldAxis,fromMouse,toMouse);getPointerPlaneIntersect(fromMouse,planeNormal,p1);getPointerPlaneIntersect(toMouse,planeNormal,p2);math.subVec3(p2,p1);var dot=math.dotVec3(p2,worldAxis);self._pos[0]+=worldAxis[0]*dot;self._pos[1]+=worldAxis[1]*dot;self._pos[2]+=worldAxis[2]*dot;self._rootNode.position=self._pos;if(self._sectionPlane){self._sectionPlane.pos=self._pos;}};}();var dragRotateSectionPlane=function(){var p1=math.vec4();var p2=math.vec4();var c=math.vec4();var worldAxis=math.vec4();return function(baseAxis,fromMouse,toMouse){localToWorldVec(baseAxis,worldAxis);var hasData=getPointerPlaneIntersect(fromMouse,worldAxis,p1)&&getPointerPlaneIntersect(toMouse,worldAxis,p2);if(!hasData){// Find intersections with view plane and project down to origin
var planeNormal=getTranslationPlane(worldAxis,fromMouse,toMouse);getPointerPlaneIntersect(fromMouse,planeNormal,p1,1);// Ensure plane moves closer to camera so angles become workable
getPointerPlaneIntersect(toMouse,planeNormal,p2,1);var dot=math.dotVec3(p1,worldAxis);p1[0]-=dot*worldAxis[0];p1[1]-=dot*worldAxis[1];p1[2]-=dot*worldAxis[2];dot=math.dotVec3(p2,worldAxis);p2[0]-=dot*worldAxis[0];p2[1]-=dot*worldAxis[1];p2[2]-=dot*worldAxis[2];}math.normalizeVec3(p1);math.normalizeVec3(p2);dot=math.dotVec3(p1,p2);dot=math.clamp(dot,-1.0,1.0);// Rounding errors cause dot to exceed allowed range
var incDegrees=Math.acos(dot)*math.RADTODEG;math.cross3Vec3(p1,p2,c);if(math.dotVec3(c,worldAxis)<0.0){incDegrees=-incDegrees;}self._rootNode.rotate(baseAxis,incDegrees);rotateSectionPlane();};}();var getPointerPlaneIntersect=function(){var dir=math.vec4([0,0,0,1]);var matrix=math.mat4();return function(mouse,axis,dest,offset){offset=offset||0;dir[0]=mouse[0]/canvas.width*2.0-1.0;dir[1]=-(mouse[1]/canvas.height*2.0-1.0);dir[2]=0.0;dir[3]=1.0;math.mulMat4(camera.projMatrix,camera.viewMatrix,matrix);// Unproject norm device coords to view coords
math.inverseMat4(matrix);math.transformVec4(matrix,dir,dir);math.mulVec4Scalar(dir,1.0/dir[3]);// This is now point A on the ray in world space
var rayO=camera.eye;// The direction
math.subVec4(dir,rayO,dir);var origin=self._sectionPlane.pos;// Plane origin:
var d=-math.dotVec3(origin,axis)-offset;var dot=math.dotVec3(axis,dir);if(Math.abs(dot)>0.005){var t=-(math.dotVec3(axis,rayO)+d)/dot;math.mulVec3Scalar(dir,t,dest);math.addVec3(dest,rayO);math.subVec3(dest,origin,dest);return true;}return false;};}();var rotateSectionPlane=function(){var dir=math.vec3();var mat=math.mat4();return function(){if(self.sectionPlane){math.quaternionToMat4(rootNode.quaternion,mat);// << ---
math.transformVec3(mat,[0,0,1],dir);self._setSectionPlaneDir(dir);}};}();{var down=false;var lastAffordanceMesh;this._onCameraControlHover=this._viewer.cameraControl.on("hoverEnter",function(hit){if(!_this128._visible){return;}if(down){return;}grabbed=false;if(lastAffordanceMesh){lastAffordanceMesh.visible=false;}var affordanceMesh;var meshId=hit.entity.id;switch(meshId){case _this128._displayMeshes.xAxisArrowHandle.id:affordanceMesh=_this128._affordanceMeshes.xAxisArrow;nextDragAction=DRAG_ACTIONS.xTranslate;break;case _this128._displayMeshes.xAxisHandle.id:affordanceMesh=_this128._affordanceMeshes.xAxisArrow;nextDragAction=DRAG_ACTIONS.xTranslate;break;case _this128._displayMeshes.yAxisArrowHandle.id:affordanceMesh=_this128._affordanceMeshes.yAxisArrow;nextDragAction=DRAG_ACTIONS.yTranslate;break;case _this128._displayMeshes.yShaftHandle.id:affordanceMesh=_this128._affordanceMeshes.yAxisArrow;nextDragAction=DRAG_ACTIONS.yTranslate;break;case _this128._displayMeshes.zAxisArrowHandle.id:affordanceMesh=_this128._affordanceMeshes.zAxisArrow;nextDragAction=DRAG_ACTIONS.zTranslate;break;case _this128._displayMeshes.zAxisHandle.id:affordanceMesh=_this128._affordanceMeshes.zAxisArrow;nextDragAction=DRAG_ACTIONS.zTranslate;break;case _this128._displayMeshes.xCurveHandle.id:affordanceMesh=_this128._affordanceMeshes.xHoop;nextDragAction=DRAG_ACTIONS.xRotate;break;case _this128._displayMeshes.yCurveHandle.id:affordanceMesh=_this128._affordanceMeshes.yHoop;nextDragAction=DRAG_ACTIONS.yRotate;break;case _this128._displayMeshes.zCurveHandle.id:affordanceMesh=_this128._affordanceMeshes.zHoop;nextDragAction=DRAG_ACTIONS.zRotate;break;default:nextDragAction=DRAG_ACTIONS.none;return;// Not clicked an arrow or hoop
}if(affordanceMesh){affordanceMesh.visible=true;}lastAffordanceMesh=affordanceMesh;grabbed=true;});this._onCameraControlHoverLeave=this._viewer.cameraControl.on("hoverOutEntity",function(hit){if(!_this128._visible){return;}if(lastAffordanceMesh){lastAffordanceMesh.visible=false;}lastAffordanceMesh=null;nextDragAction=DRAG_ACTIONS.none;});canvas.addEventListener("mousedown",this._canvasMouseDownListener=function(e){e.preventDefault();if(!_this128._visible){return;}if(!grabbed){return;}_this128._viewer.cameraControl.pointerEnabled=false;switch(e.which){case 1:// Left button
down=true;var canvasPos=getClickCoordsWithinElement(e);dragAction=nextDragAction;lastCanvasPos[0]=canvasPos[0];lastCanvasPos[1]=canvasPos[1];break;}});canvas.addEventListener("mousemove",this._canvasMouseMoveListener=function(e){if(!_this128._visible){return;}if(!down){return;}var canvasPos=getClickCoordsWithinElement(e);var x=canvasPos[0];var y=canvasPos[1];switch(dragAction){case DRAG_ACTIONS.xTranslate:dragTranslateSectionPlane(xBaseAxis,lastCanvasPos,canvasPos);break;case DRAG_ACTIONS.yTranslate:dragTranslateSectionPlane(yBaseAxis,lastCanvasPos,canvasPos);break;case DRAG_ACTIONS.zTranslate:dragTranslateSectionPlane(zBaseAxis,lastCanvasPos,canvasPos);break;case DRAG_ACTIONS.xRotate:dragRotateSectionPlane(xBaseAxis,lastCanvasPos,canvasPos);break;case DRAG_ACTIONS.yRotate:dragRotateSectionPlane(yBaseAxis,lastCanvasPos,canvasPos);break;case DRAG_ACTIONS.zRotate:dragRotateSectionPlane(zBaseAxis,lastCanvasPos,canvasPos);break;}lastCanvasPos[0]=x;lastCanvasPos[1]=y;});canvas.addEventListener("mouseup",this._canvasMouseUpListener=function(e){if(!_this128._visible){return;}_this128._viewer.cameraControl.pointerEnabled=true;if(!down){return;}switch(e.which){}down=false;grabbed=false;});canvas.addEventListener("wheel",this._canvasWheelListener=function(e){if(!_this128._visible){return;}var delta=Math.max(-1,Math.min(1,-e.deltaY*40));if(delta===0){return;}});}}},{key:"_destroy",value:function _destroy(){this._unbindEvents();this._destroyNodes();}},{key:"_unbindEvents",value:function _unbindEvents(){var viewer=this._viewer;var scene=viewer.scene;var canvas=scene.canvas.canvas;var camera=viewer.camera;var cameraControl=viewer.cameraControl;scene.off(this._onSceneTick);canvas.removeEventListener("mousedown",this._canvasMouseDownListener);canvas.removeEventListener("mousemove",this._canvasMouseMoveListener);canvas.removeEventListener("mouseup",this._canvasMouseUpListener);canvas.removeEventListener("wheel",this._canvasWheelListener);camera.off(this._onCameraViewMatrix);camera.off(this._onCameraProjMatrix);cameraControl.off(this._onCameraControlHover);cameraControl.off(this._onCameraControlHoverLeave);}},{key:"_destroyNodes",value:function _destroyNodes(){this._setSectionPlane(null);this._rootNode.destroy();this._displayMeshes={};this._affordanceMeshes={};}}]);return Control;}();/**
 * Renders a 3D plane within an {@link Overview} to indicate its {@link SectionPlane}'s current position and orientation.
 *
 * @private
 */var Plane$1=/*#__PURE__*/function(){/** @private */function Plane$1(overview,overviewScene,sectionPlane){var _this129=this;_classCallCheck(this,Plane$1);/**
         * The ID of this SectionPlanesOverviewPlane.
         *
         * @type {String}
         */this.id=sectionPlane.id;/**
         * The {@link SectionPlane} represented by this SectionPlanesOverviewPlane.
         *
         * @type {SectionPlane}
         */this._sectionPlane=sectionPlane;this._mesh=new Mesh(overviewScene,{id:sectionPlane.id,geometry:new ReadableGeometry(overviewScene,buildBoxGeometry({xSize:.5,ySize:.5,zSize:.001})),material:new PhongMaterial(overviewScene,{emissive:[1,1,1],diffuse:[0,0,0],backfaces:false}),edgeMaterial:new EdgeMaterial(overviewScene,{edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1}),highlightMaterial:new EmphasisMaterial(overviewScene,{fill:true,fillColor:[0.5,1,0.5],fillAlpha:0.7,edges:true,edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1}),selectedMaterial:new EmphasisMaterial(overviewScene,{fill:true,fillColor:[0,0,1],fillAlpha:0.7,edges:true,edgeColor:[1.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1}),highlighted:true,scale:[3,3,3],position:[0,0,0],rotation:[0,0,0],opacity:0.3,edges:true});{var vec=math.vec3([0,0,0]);var pos2=math.vec3();var _zeroVec=math.vec3([0,0,1]);var _quat=math.vec4(4);var pos3=math.vec3();var update=function update(){var origin=_this129._sectionPlane.scene.center;var negDir=[-_this129._sectionPlane.dir[0],-_this129._sectionPlane.dir[1],-_this129._sectionPlane.dir[2]];math.subVec3(origin,_this129._sectionPlane.pos,vec);var dist=-math.dotVec3(negDir,vec);math.normalizeVec3(negDir);math.mulVec3Scalar(negDir,dist,pos2);var quaternion=math.vec3PairToQuaternion(_zeroVec,_this129._sectionPlane.dir,_quat);pos3[0]=pos2[0]*0.1;pos3[1]=pos2[1]*0.1;pos3[2]=pos2[2]*0.1;_this129._mesh.quaternion=quaternion;_this129._mesh.position=pos3;};this._onSectionPlanePos=this._sectionPlane.on("pos",update);this._onSectionPlaneDir=this._sectionPlane.on("dir",update);// update();
}this._highlighted=false;this._selected=false;}/**
     * Sets if this SectionPlanesOverviewPlane is highlighted.
     *
     * @type {Boolean}
     * @private
     */_createClass(Plane$1,[{key:"setHighlighted",value:function setHighlighted(highlighted){this._highlighted=!!highlighted;this._mesh.highlighted=this._highlighted;this._mesh.highlightMaterial.fillColor=highlighted?[0,0.7,0]:[0,0,0];// this._selectedMesh.highlighted = true;
}/**
     * Gets if this SectionPlanesOverviewPlane is highlighted.
     *
     * @type {Boolean}
     * @private
     */},{key:"getHighlighted",value:function getHighlighted(){return this._highlighted;}/**
     * Sets if this SectionPlanesOverviewPlane is selected.
     *
     * @type {Boolean}
     * @private
     */},{key:"setSelected",value:function setSelected(selected){this._selected=!!selected;this._mesh.edgeMaterial.edgeWidth=selected?3:1;this._mesh.highlightMaterial.edgeWidth=selected?3:1;}/**
     * Gets if this SectionPlanesOverviewPlane is selected.
     *
     * @type {Boolean}
     * @private
     */},{key:"getSelected",value:function getSelected(){return this._selected;}/** @private */},{key:"destroy",value:function destroy(){this._sectionPlane.off(this._onSectionPlanePos);this._sectionPlane.off(this._onSectionPlaneDir);this._mesh.destroy();}}]);return Plane$1;}();/**
 * @desc An interactive 3D overview for navigating the {@link SectionPlane}s created by its {@link SectionPlanesPlugin}.
 *
 * * Located at {@link SectionPlanesPlugin#overview}.
 * * Renders the overview on a separate canvas at a corner of the {@link Viewer}'s {@link Scene} {@link Canvas}.
 * * The overview shows a 3D plane object for each {@link SectionPlane} in the {@link Scene}.
 * * Click a plane object in the overview to toggle the visibility of a 3D gizmo to edit the position and orientation of its {@link SectionPlane}.
 *
 * @private
 */var Overview$1=/*#__PURE__*/function(){/**
     * @private
     */function Overview$1(plugin,cfg){var _this130=this;_classCallCheck(this,Overview$1);if(!cfg.onHoverEnterPlane||!cfg.onHoverLeavePlane||!cfg.onClickedNothing||!cfg.onClickedPlane){throw"Missing config(s): onHoverEnterPlane, onHoverLeavePlane, onClickedNothing || onClickedPlane";}/**
         * The {@link SectionPlanesPlugin} that owns this SectionPlanesOverview.
         *
         * @type {SectionPlanesPlugin}
         */this.plugin=plugin;this._viewer=plugin.viewer;this._onHoverEnterPlane=cfg.onHoverEnterPlane;this._onHoverLeavePlane=cfg.onHoverLeavePlane;this._onClickedNothing=cfg.onClickedNothing;this._onClickedPlane=cfg.onClickedPlane;this._visible=true;this._planes={};//--------------------------------------------------------------------------------------------------------------
// Init canvas
//--------------------------------------------------------------------------------------------------------------
this._canvas=cfg.overviewCanvas;//--------------------------------------------------------------------------------------------------------------
// Init scene
//--------------------------------------------------------------------------------------------------------------
this._scene=new Scene(this._viewer,{canvasId:this._canvas.id,transparent:true});this._scene.clearLights();new DirLight(this._scene,{dir:[0.4,-0.4,0.8],color:[0.8,1.0,1.0],intensity:1.0,space:"view"});new DirLight(this._scene,{dir:[-0.8,-0.3,-0.4],color:[0.8,0.8,0.8],intensity:1.0,space:"view"});new DirLight(this._scene,{dir:[0.8,-0.6,-0.8],color:[1.0,1.0,1.0],intensity:1.0,space:"view"});this._scene.camera;this._scene.camera.perspective.fov=70;this._zUp=false;//--------------------------------------------------------------------------------------------------------------
// Synchronize overview scene camera with viewer camera
//--------------------------------------------------------------------------------------------------------------
{var camera=this._scene.camera;var _matrix2=math.rotationMat4c(-90*math.DEGTORAD,1,0,0);var _eyeLookVec3=math.vec3();var eyeLookVecOverview=math.vec3();var upOverview=math.vec3();this._synchCamera=function(){var eye=_this130._viewer.camera.eye;var look=_this130._viewer.camera.look;var up=_this130._viewer.camera.up;math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye,look,_eyeLookVec3)),7);if(_this130._zUp){// +Z up
math.transformVec3(_matrix2,_eyeLookVec3,eyeLookVecOverview);math.transformVec3(_matrix2,up,upOverview);camera.look=[0,0,0];camera.eye=math.transformVec3(_matrix2,_eyeLookVec3,eyeLookVecOverview);camera.up=math.transformPoint3(_matrix2,up,upOverview);}else{// +Y up
camera.look=[0,0,0];camera.eye=_eyeLookVec3;camera.up=up;}};}this._onViewerCameraMatrix=this._viewer.camera.on("matrix",this._synchCamera);this._onViewerCameraWorldAxis=this._viewer.camera.on("worldAxis",this._synchCamera);this._onViewerCameraFOV=this._viewer.camera.perspective.on("fov",function(fov){_this130._scene.camera.perspective.fov=fov;});//--------------------------------------------------------------------------------------------------------------
// Bind overview canvas events
//--------------------------------------------------------------------------------------------------------------
{var hoveredEntity=null;this._onInputMouseMove=this._scene.input.on("mousemove",function(coords){var hit=_this130._scene.pick({canvasPos:coords});if(hit){if(!hoveredEntity||hit.entity.id!==hoveredEntity.id){if(hoveredEntity){var _plane=_this130._planes[hoveredEntity.id];if(_plane){_this130._onHoverLeavePlane(hoveredEntity.id);}}hoveredEntity=hit.entity;var plane=_this130._planes[hoveredEntity.id];if(plane){_this130._onHoverEnterPlane(hoveredEntity.id);}}}else{if(hoveredEntity){_this130._onHoverLeavePlane(hoveredEntity.id);hoveredEntity=null;}}});this._scene.canvas.canvas.addEventListener("mouseup",this._onCanvasMouseUp=function(){if(hoveredEntity){var plane=_this130._planes[hoveredEntity.id];if(plane){_this130._onClickedPlane(hoveredEntity.id);}}else{_this130._onClickedNothing();}});this._scene.canvas.canvas.addEventListener("mouseout",this._onCanvasMouseOut=function(){if(hoveredEntity){_this130._onHoverLeavePlane(hoveredEntity.id);hoveredEntity=null;}});}//--------------------------------------------------------------------------------------------------------------
// Configure overview
//--------------------------------------------------------------------------------------------------------------
this.setVisible(cfg.overviewVisible);}/** Called by SectionPlanesPlugin#createSectionPlane()
     * @private
     */_createClass(Overview$1,[{key:"addSectionPlane",value:function addSectionPlane(sectionPlane){this._planes[sectionPlane.id]=new Plane$1(this,this._scene,sectionPlane);}/**  @private
     */},{key:"setPlaneHighlighted",value:function setPlaneHighlighted(id,highlighted){var plane=this._planes[id];if(plane){plane.setHighlighted(highlighted);}}/**  @private
     */},{key:"setPlaneSelected",value:function setPlaneSelected(id,selected){var plane=this._planes[id];if(plane){plane.setSelected(selected);}}/** @private
     */},{key:"removeSectionPlane",value:function removeSectionPlane(sectionPlane){var plane=this._planes[sectionPlane.id];if(plane){plane.destroy();delete this._planes[sectionPlane.id];}}/**
     * Sets if this SectionPlanesOverview is visible.
     *
     * @param {Boolean} visible Whether or not this SectionPlanesOverview is visible.
     */},{key:"setVisible",value:function setVisible(){var visible=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this._visible=visible;this._canvas.style.visibility=visible?"visible":"hidden";}/**
     * Gets if this SectionPlanesOverview is visible.
     *
     * @return {Boolean} True when this SectionPlanesOverview is visible.
     */},{key:"getVisible",value:function getVisible(){return this._visible;}/**  @private
     */},{key:"destroy",value:function destroy(){this._viewer.camera.off(this._onViewerCameraMatrix);this._viewer.camera.off(this._onViewerCameraWorldAxis);this._viewer.camera.perspective.off(this._onViewerCameraFOV);this._scene.input.off(this._onInputMouseMove);this._scene.canvas.canvas.removeEventListener("mouseup",this._onCanvasMouseUp);this._scene.canvas.canvas.removeEventListener("mouseout",this._onCanvasMouseOut);this._scene.destroy();}}]);return Overview$1;}();var tempAABB$1=math.AABB3();var tempVec3$1=math.vec3();/**
 * SectionPlanesPlugin is a {@link Viewer} plugin that manages {@link SectionPlane}s.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/57724962-406e9a00-768c-11e9-9f1f-3d178a3ec11f.gif">](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_SectionPlanesPlugin)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_SectionPlanesPlugin)]
 *
 * ## Overview
 *
 * * Use the SectionPlanesPlugin to
 * create and edit {@link SectionPlane}s to slice portions off your models and reveal internal structures.
 * * As shown in the screen capture above, SectionPlanesPlugin shows an overview of all your SectionPlanes (on the right, in
 * this example).
 * * Click a plane in the overview to activate a 3D control with which you can interactively
 * reposition its SectionPlane in the main canvas.
 * * Use {@lin BCFViewpointsPlugin} to save and load SectionPlanes in BCF viewpoints.
 *
 * ## Usage
 *
 * In the example below, we'll use a {@link GLTFLoaderPlugin} to load a model, and a SectionPlanesPlugin
 * to slice it open with two {@link SectionPlane}s. We'll show the overview in the bottom right of the Viewer
 * canvas. Finally, we'll programmatically activate the 3D editing control, so that we can use it to interactively
 * reposition our second SectionPlane.
 *
 * ````JavaScript
 * import {Viewer, GLTFLoaderPlugin, SectionPlanesPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange its Camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-5.02, 2.22, 15.09];
 * viewer.camera.look = [4.97, 2.79, 9.89];
 * viewer.camera.up = [-0.05, 0.99, 0.02];
 *
 *
 * // Add a GLTFLoaderPlugin
 *
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * // Add a SectionPlanesPlugin, with overview visible
 *
 * const sectionPlanes = new SectionPlanesPlugin(viewer, {
 *     overviewCanvasID: "myOverviewCanvas",
 *     overviewVisible: true
 * });
 *
 * // Load a model
 *
 * const model = gltfLoader.load({
 *     id: "myModel",
 *     src: "./models/gltf/schependomlaan/scene.gltf"
 * });
 *
 * // Create a couple of section planes
 * // These will be shown in the overview
 *
 * sectionPlanes.createSectionPlane({
 *     id: "mySectionPlane",
 *     pos: [1.04, 1.95, 9.74],
 *     dir: [1.0, 0.0, 0.0]
 * });
 *
 * sectionPlanes.createSectionPlane({
 *     id: "mySectionPlane2",
 *     pos: [2.30, 4.46, 14.93],
 *     dir: [0.0, -0.09, -0.79]
 * });
 *
 * // Show the SectionPlanePlugin's 3D editing gizmo,
 * // to interactively reposition one of our SectionPlanes
 *
 * sectionPlanes.showControl("mySectionPlane2");
 *
 * const mySectionPlane2 = sectionPlanes.sectionPlanes["mySectionPlane2"];
 *
 * // Programmatically reposition one of our SectionPlanes
 * // This also updates its position as shown in the overview gizmo
 *
 * mySectionPlane2.pos = [11.0, 6.0, -12];
 * mySectionPlane2.dir = [0.4, 0.0, 0.5];
 * ````
 */var SectionPlanesPlugin=/*#__PURE__*/function(_Plugin10){_inherits(SectionPlanesPlugin,_Plugin10);var _super151=_createSuper(SectionPlanesPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg Plugin configuration.
     * @param {String} [cfg.id="SectionPlanes"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} [cfg.overviewCanvasId] ID of a canvas element to display the overview.
     * @param {String} [cfg.overviewVisible=true] Initial visibility of the overview canvas.
     */function SectionPlanesPlugin(viewer){var _this131;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,SectionPlanesPlugin);_this131=_super151.call(this,"SectionPlanes",viewer);_this131._freeControls=[];_this131._sectionPlanes=viewer.scene.sectionPlanes;_this131._controls={};_this131._shownControlId=null;if(cfg.overviewCanvasId!==null&&cfg.overviewCanvasId!==undefined){var overviewCanvas=document.getElementById(cfg.overviewCanvasId);if(!overviewCanvas){_this131.warn("Can't find overview canvas: '"+cfg.overviewCanvasId+"' - will create plugin without overview");}else{_this131._overview=new Overview$1(_assertThisInitialized(_this131),{overviewCanvas:overviewCanvas,visible:cfg.overviewVisible,onHoverEnterPlane:function onHoverEnterPlane(id){_this131._overview.setPlaneHighlighted(id,true);},onHoverLeavePlane:function onHoverLeavePlane(id){_this131._overview.setPlaneHighlighted(id,false);},onClickedPlane:function onClickedPlane(id){if(_this131.getShownControl()===id){_this131.hideControl();return;}_this131.showControl(id);var sectionPlane=_this131.sectionPlanes[id];var sectionPlanePos=sectionPlane.pos;tempAABB$1.set(_this131.viewer.scene.aabb);math.getAABB3Center(tempAABB$1,tempVec3$1);tempAABB$1[0]+=sectionPlanePos[0]-tempVec3$1[0];tempAABB$1[1]+=sectionPlanePos[1]-tempVec3$1[1];tempAABB$1[2]+=sectionPlanePos[2]-tempVec3$1[2];tempAABB$1[3]+=sectionPlanePos[0]-tempVec3$1[0];tempAABB$1[4]+=sectionPlanePos[1]-tempVec3$1[1];tempAABB$1[5]+=sectionPlanePos[2]-tempVec3$1[2];_this131.viewer.cameraFlight.flyTo({aabb:tempAABB$1,fitFOV:65});},onClickedNothing:function onClickedNothing(){_this131.hideControl();}});}}_this131._onSceneSectionPlaneCreated=viewer.scene.on("sectionPlaneCreated",function(sectionPlane){// SectionPlane created, either via SectionPlanesPlugin#createSectionPlane(), or by directly
// instantiating a SectionPlane independently of SectionPlanesPlugin, which can be done
// by BCFViewpointsPlugin#loadViewpoint().
_this131._sectionPlaneCreated(sectionPlane);});return _this131;}/**
     * Sets if the overview canvas is visible.
     *
     * @param {Boolean} visible Whether or not the overview canvas is visible.
     */_createClass(SectionPlanesPlugin,[{key:"setOverviewVisible",value:function setOverviewVisible(visible){if(this._overview){this._overview.setVisible(visible);}}/**
     * Gets if the overview canvas is visible.
     *
     * @return {Boolean} True when the overview canvas is visible.
     */},{key:"getOverviewVisible",value:function getOverviewVisible(){if(this._overview){return this._overview.getVisible();}}/**
     * Returns a map of the {@link SectionPlane}s created by this SectionPlanesPlugin.
     *
     * @returns {{String:SectionPlane}} A map containing the {@link SectionPlane}s, each mapped to its {@link SectionPlane#id}.
     */},{key:"sectionPlanes",get:function get(){return this._sectionPlanes;}/**
     * Creates a {@link SectionPlane}.
     *
     * The {@link SectionPlane} will be registered by {@link SectionPlane#id} in {@link SectionPlanesPlugin#sectionPlanes}.
     *
     * @param {Object} params {@link SectionPlane} configuration.
     * @param {String} [params.id] Unique ID to assign to the {@link SectionPlane}. Must be unique among all components in the {@link Viewer}'s {@link Scene}. Auto-generated when omitted.
     * @param {Number[]} [params.pos=[0,0,0]] World-space position of the {@link SectionPlane}.
     * @param {Number[]} [params.dir=[0,0,-1]] World-space vector indicating the orientation of the {@link SectionPlane}.
     * @param {Boolean} [params.active=true] Whether the {@link SectionPlane} is initially active. Only clips while this is true.
     * @returns {SectionPlane} The new {@link SectionPlane}.
     */},{key:"createSectionPlane",value:function createSectionPlane(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id!==undefined&&params.id!==null&&this.viewer.scene.components[params.id]){this.error("Viewer component with this ID already exists: "+params.id);delete params.id;}// Note that SectionPlane constructor fires "sectionPlaneCreated" on the Scene,
// which SectionPlanesPlugin handles and calls #_sectionPlaneCreated to create gizmo and add to overview canvas.
var sectionPlane=new SectionPlane(this.viewer.scene,{id:params.id,pos:params.pos,dir:params.dir,active:true});return sectionPlane;}},{key:"_sectionPlaneCreated",value:function _sectionPlaneCreated(sectionPlane){var _this132=this;var control=this._freeControls.length>0?this._freeControls.pop():new Control(this);control._setSectionPlane(sectionPlane);control.setVisible(false);this._controls[sectionPlane.id]=control;if(this._overview){this._overview.addSectionPlane(sectionPlane);}sectionPlane.once("destroyed",function(){_this132._sectionPlaneDestroyed(sectionPlane);});}/**
     * Inverts the direction of {@link SectionPlane#dir} on every existing SectionPlane.
     *
     * Inverts all SectionPlanes, including those that were not created with SectionPlanesPlugin.
     */},{key:"flipSectionPlanes",value:function flipSectionPlanes(){var sectionPlanes=this.viewer.scene.sectionPlanes;for(var id in sectionPlanes){var sectionPlane=sectionPlanes[id];sectionPlane.flipDir();}}/**
     * Shows the 3D editing gizmo for a {@link SectionPlane}.
     *
     * @param {String} id ID of the {@link SectionPlane}.
     */},{key:"showControl",value:function showControl(id){var control=this._controls[id];if(!control){this.error("Control not found: "+id);return;}this.hideControl();control.setVisible(true);if(this._overview){this._overview.setPlaneSelected(id,true);}this._shownControlId=id;}/**
     * Gets the ID of the {@link SectionPlane} that the 3D editing gizmo is shown for.
     *
     * Returns ````null```` when the editing gizmo is not shown.
     *
     * @returns {String} ID of the the {@link SectionPlane} that the 3D editing gizmo is shown for, if shown, else ````null````.
     */},{key:"getShownControl",value:function getShownControl(){return this._shownControlId;}/**
     * Hides the 3D {@link SectionPlane} editing gizmo if shown.
     */},{key:"hideControl",value:function hideControl(){for(var id in this._controls){if(this._controls.hasOwnProperty(id)){this._controls[id].setVisible(false);if(this._overview){this._overview.setPlaneSelected(id,false);}}}this._shownControlId=null;}/**
     * Destroys a {@link SectionPlane} created by this SectionPlanesPlugin.
     *
     * @param {String} id ID of the {@link SectionPlane}.
     */},{key:"destroySectionPlane",value:function destroySectionPlane(id){var sectionPlane=this.viewer.scene.sectionPlanes[id];if(!sectionPlane){this.error("SectionPlane not found: "+id);return;}this._sectionPlaneDestroyed(sectionPlane);sectionPlane.destroy();if(id===this._shownControlId){this._shownControlId=null;}}},{key:"_sectionPlaneDestroyed",value:function _sectionPlaneDestroyed(sectionPlane){if(this._overview){this._overview.removeSectionPlane(sectionPlane);}var control=this._controls[sectionPlane.id];if(!control){return;}control.setVisible(false);control._setSectionPlane(null);delete this._controls[sectionPlane.id];this._freeControls.push(control);}/**
     * Destroys all {@link SectionPlane}s created by this SectionPlanesPlugin.
     */},{key:"clear",value:function clear(){var ids=Object.keys(this._sectionPlanes);for(var i=0,len=ids.length;i<len;i++){this.destroySectionPlane(ids[i]);}}/**
     * @private
     */},{key:"send",value:function send(name,value){switch(name){case"snapshotStarting":// Viewer#getSnapshot() about to take snapshot - hide controls
for(var id in this._controls){if(this._controls.hasOwnProperty(id)){this._controls[id].setCulled(true);}}break;case"snapshotFinished":// Viewer#getSnapshot() finished taking snapshot - show controls again
for(var _id4 in this._controls){if(this._controls.hasOwnProperty(_id4)){this._controls[_id4].setCulled(false);}}break;case"clearSectionPlanes":this.clear();break;}}/**
     * Destroys this SectionPlanesPlugin.
     *
     * Also destroys each {@link SectionPlane} created by this SectionPlanesPlugin.
     *
     * Does not destroy the canvas the SectionPlanesPlugin was configured with.
     */},{key:"destroy",value:function destroy(){this.clear();if(this._overview){this._overview.destroy();}this._destroyFreeControls();_get(_getPrototypeOf(SectionPlanesPlugin.prototype),"destroy",this).call(this);}},{key:"_destroyFreeControls",value:function _destroyFreeControls(){var control=this._freeControls.pop();while(control){control._destroy();control=this._freeControls.pop();}this.viewer.scene.off(this._onSceneSectionPlaneCreated);}}]);return SectionPlanesPlugin;}(Plugin);/**
 * @desc Information about an ````IfcBuildingStorey````.
 *
 * These are provided by a {@link StoreyViewsPlugin}.
 */var Storey=/*#__PURE__*/_createClass(/**
     * @private
     */function Storey(plugin,modelAABB,storeyAABB,modelId,storeyId,numObjects){_classCallCheck(this,Storey);/**
         * The {@link StoreyViewsPlugin} this Storey belongs to.
         *
         * @property plugin
         * @type {StoreyViewsPlugin}
         */this.plugin=plugin;/**
         * ID of the IfcBuildingStorey.
         *
         * This matches IDs of the IfcBuildingStorey's {@link MetaObject} and {@link Entity}.
         *
         * @property storeyId
         * @type {String}
         */this.storeyId=storeyId;/**
         * ID of the model.
         *
         * This matches the ID of the {@link MetaModel} that contains the IfcBuildingStorey's {@link MetaObject}.
         *
         * @property modelId
         * @type {String|Number}
         */this.modelId=modelId;/**
         * Axis-aligned World-space boundary of the {@link Entity}s that represent the IfcBuildingStorey.
         *
         * The boundary is a six-element Float32Array containing the min/max extents of the
         * axis-aligned boundary, ie. ````[xmin, ymin, zmin, xmax, ymax, zmax]````
         *
         * @property storeyAABB
         * @type {Number[]}
         */this.storeyAABB=storeyAABB.slice();/**
         * Axis-aligned World-space boundary of the {@link Entity}s that represent the IfcBuildingStorey.
         *
         * The boundary is a six-element Float32Array containing the min/max extents of the
         * axis-aligned boundary, ie. ````[xmin, ymin, zmin, xmax, ymax, zmax]````
         *
         * @deprecated
         * @property storeyAABB
         * @type {Number[]}
         */this.aabb=this.storeyAABB;/**
         * Axis-aligned World-space boundary of the {@link Entity}s that represent the model.
         *
         * The boundary is a six-element Float32Array containing the min/max extents of the
         * axis-aligned boundary, ie. ````[xmin, ymin, zmin, xmax, ymax, zmax]````
         *
         * @property modelAABB
         * @type {Number[]}
         */this.modelAABB=modelAABB.slice();/** Number of {@link Entity}s within the IfcBuildingStorey.
         *
         * @property numObjects
         * @type {Number}
         */this.numObjects=numObjects;});/**
 * @desc A 2D plan view image of an ````IfcBuildingStorey````.
 *
 * These are created by a {@link StoreyViewsPlugin}.
 */var StoreyMap=/*#__PURE__*/_createClass(/**
     * @private
     */function StoreyMap(storeyId,imageData,format,width,height,padding){_classCallCheck(this,StoreyMap);/**
         * ID of the IfcBuildingStorey.
         *
         * This matches IDs of the IfcBuildingStorey's {@link MetaObject} and {@link Entity}.
         *
         * @property storeyId
         * @type {String}
         */this.storeyId=storeyId;/**
         * Base64-encoded plan view image.
         *
         * @property imageData
         * @type {String}
         */this.imageData=imageData;/**
         * The image format - "png" or "jpeg".
         *
         * @property format
         * @type {String}
         */this.format=format;/**
         * Width of the image, in pixels.
         *
         * @property width
         * @type {Number}
         */this.width=width;/**
         * Height of the image, in pixels.
         *
         * @property height
         * @type {Number}
         */this.height=height;});var tempVec3a$2=math.vec3();var tempMat4=math.mat4();var EMPTY_IMAGE="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==";/**
 * @desc A {@link Viewer} plugin that provides methods for visualizing IfcBuildingStoreys.
 *
 *  <a href="https://xeokit.github.io/xeokit-sdk/examples/navigation/#StoreyViewsPlugin_recipe3"><img src="http://xeokit.io/img/docs/StoreyViewsPlugin/minimap.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/navigation/#StoreyViewsPlugin_recipe3)]
 *
 * ## Overview
 *
 * StoreyViewsPlugin provides a flexible set of methods for visualizing building storeys in 3D and 2D.
 *
 * Use the first two methods to set up 3D views of storeys:
 *
 * * [showStoreyObjects](#instance-method-showStoreyObjects) - shows the {@link Entity}s within a storey, and
 * * [gotoStoreyCamera](#instance-method-gotoStoreyCamera) - positions the {@link Camera} for a plan view of the Entitys within a storey.
 * <br> <br>
 *
 * Use the second two methods to create 2D plan view mini-map images:
 *
 * * [createStoreyMap](#instance-method-createStoreyMap) - creates a 2D plan view image of a storey, and
 * * [pickStoreyMap](#instance-method-pickStoreyMap) - picks the {@link Entity} at the given 2D pixel coordinates within a plan view image.
 *
 * ## Usage
 *
 * Let's start by creating a {@link Viewer} with a StoreyViewsPlugin and an {@link XKTLoaderPlugin}.
 *
 * Then we'll load a BIM building model from an  ```.xkt``` file.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, StoreyViewsPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer, arrange the camera
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas",
 *        transparent: true
 *    });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * // Add an XKTLoaderPlugin
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * // Add a StoreyViewsPlugin
 *
 * const storeyViewsPlugin = new StoreyViewsPlugin(viewer);
 *
 * // Load a BIM model from .xkt format
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true
 * });
 * ````
 *
 * ## Finding Storeys
 *
 * Getting information on a storey in our model:
 *
 * ````javascript
 * const storey = storeyViewsPlugin.storeys["2SWZMQPyD9pfT9q87pgXa1"]; // ID of the IfcBuildingStorey
 *
 * const modelId  = storey.modelId;  // "myModel"
 * const storeyId = storey.storeyId; // "2SWZMQPyD9pfT9q87pgXa1"
 * const aabb     = storey.aabb;     // Axis-aligned 3D World-space boundary of the IfcBuildingStorey
 * ````
 *
 * We can also get a "storeys" event every time the set of storeys changes, ie. every time a storey is created or destroyed:
 *
 * ````javascript
 * storeyViewsPlugin.on("storeys", ()=> {
 *      const storey = storeyViewsPlugin.storeys["2SWZMQPyD9pfT9q87pgXa1"];
 *      //...
 * });
 * ````
 *
 * ## Showing Entitys within Storeys
 *
 * Showing the {@link Entity}s within a storey:
 *
 * ````javascript
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1");
 * ````
 *
 * Showing **only** the Entitys in a storey, hiding all others:
 *
 * ````javascript
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1", {
 *     hideOthers: true
 * });
 * ````
 * Showing only the storey Entitys:
 *
 * ````javascript
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1", {
 *     hideOthers: true
 * });
 * ````
 *
 * When using this option, at some point later you'll probably want to restore all Entitys to their original visibilities and
 * appearances.
 *
 * To do that, save their visibility and appearance states in an {@link ObjectsMemento} beforehand, from
 * which you can restore them later:
 *
 * ````javascript
 * const objectsMemento = new ObjectsMemento();
 *
 * // Save all Entity visibility and appearance states
 *
 * objectsMemento.saveObjects(viewer.scene);
 *
 * // Show storey view Entitys
 *
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1");
 *
 * //...
 *
 * // Later, restore all Entitys to their saved visibility and appearance states
 * objectsMemento.restoreObjects(viewer.scene);
 * ````
 *
 * ## Arranging the Camera for Storey Plan Views
 *
 * The {@link StoreyViewsPlugin#gotoStoreyCamera} method positions the {@link Camera} for a plan view of
 * the {@link Entity}s within the given storey.
 *
 * Let's fly the {@link Camera} to a downward-looking orthographic view of the Entitys within our storey.
 *
 * ````javascript
 * storeyViewsPlugin.gotoStoreyCamera("2SWZMQPyD9pfT9q87pgXa1", {
 *     projection: "ortho", // Orthographic projection
 *     duration: 2.5,       // 2.5 second transition
 *     done: () => {
 *         viewer.cameraControl.planView = true; // Disable rotation
 *     }
 * });
 * ````
 *
 * Note that we also set {@link CameraControl#planView} ````true````, which prevents the CameraControl from rotating
 * or orbiting. In orthographic mode, this effectively makes the {@link Viewer} behave as if it were a 2D viewer, with
 * picking, panning and zooming still enabled.
 *
 * If you need to be able to restore the Camera to its previous state, you can save it to a {@link CameraMemento}
 * beforehand, from which you can restore it later:
 *
 * ````javascript
 * const cameraMemento = new CameraMemento();
 *
 * // Save camera state
 *
 * cameraMemento.saveCamera(viewer.scene);
 *
 * // Position camera for a downward-looking orthographic view of our storey
 *
 * storeyViewsPlugin.gotoStoreyCamera("2SWZMQPyD9pfT9q87pgXa1", {
 *     projection: "ortho",
 *     duration: 2.5,
 *     done: () => {
 *         viewer.cameraControl.planView = true; // Disable rotation
 *     }
 * });
 *
 * //...
 *
 * // Later, restore the Camera to its saved state
 * cameraMemento.restoreCamera(viewer.scene);
 * ````
 *
 * ## Creating StoreyMaps
 *
 * The {@link StoreyViewsPlugin#createStoreyMap} method creates a 2D orthographic plan image of the given storey.
 *
 * This method creates a {@link StoreyMap}, which provides the plan image as a Base64-encoded string.
 *
 * Let's create a 2D plan image of our building storey:
 *
 * ````javascript
 * const storeyMap = storeyViewsPlugin.createStoreyMap("2SWZMQPyD9pfT9q87pgXa1", {
 *     width: 300,
 *     format: "png"
 * });
 *
 * const imageData = storeyMap.imageData; // Base64-encoded image data string
 * const width     = storeyMap.width; // 300
 * const height    = storeyMap.height; // Automatically derived from width
 * const format    = storeyMap.format; // "png"
 * ````
 *
 * We can also specify a ````height```` for the plan image, as an alternative to ````width````:
 *
 *  ````javascript
 *  const storeyMap = storeyViewsPlugin.createStoreyMap("2SWZMQPyD9pfT9q87pgXa1", {
 *      height: 200,
 *      format: "png"
 * });
 * ````
 *
 * ## Picking Entities in StoreyMaps
 *
 * We can use {@link StoreyViewsPlugin#pickStoreyMap} to pick Entities in our building storey, using 2D coordinates from mouse or touch events on our {@link StoreyMap}'s 2D plan image.
 *
 * Let's programmatically pick the Entity at the given 2D pixel coordinates within our image:
 *
 * ````javascript
 * const mouseCoords = [65, 120]; // Mouse coords within the image extents
 *
 * const pickResult = storeyViewsPlugin.pickStoreyMap(storeyMap, mouseCoords);
 *
 * if (pickResult && pickResult.entity) {
 *     pickResult.entity.highlighted = true;
 * }
 * ````
 */var StoreyViewsPlugin=/*#__PURE__*/function(_Plugin11){_inherits(StoreyViewsPlugin,_Plugin11);var _super152=_createSuper(StoreyViewsPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="StoreyViews"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Boolean} [cfg.fitStoreyMaps=false] If enabled, the elements of each floor map image will be proportionally resized to encompass the entire image. This leads to varying scales among different floor map images. If disabled, each floor map image will display the model's extents, ensuring a consistent scale across all images.
     */function StoreyViewsPlugin(viewer){var _this133;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,StoreyViewsPlugin);_this133=_super152.call(this,"StoreyViews",viewer);_this133._objectsMemento=new ObjectsMemento();_this133._cameraMemento=new CameraMemento();/**
         * A {@link Storey} for each ````IfcBuildingStorey```.
         *
         * There will be a {@link Storey} for every existing {@link MetaObject} whose {@link MetaObject#type} equals "IfcBuildingStorey".
         *
         * These are created and destroyed automatically as models are loaded and destroyed.
         *
         * @type {{String:Storey}}
         */_this133.storeys={};/**
         * A set of {@link Storey}s for each {@link MetaModel}.
         *
         * These are created and destroyed automatically as models are loaded and destroyed.
         *
         * @type {{String: {String:Storey}}}
         */_this133.modelStoreys={};_this133._fitStoreyMaps=!!cfg.fitStoreyMaps;_this133._onModelLoaded=_this133.viewer.scene.on("modelLoaded",function(modelId){_this133._registerModelStoreys(modelId);_this133.fire("storeys",_this133.storeys);});return _this133;}_createClass(StoreyViewsPlugin,[{key:"_registerModelStoreys",value:function _registerModelStoreys(modelId){var _this134=this;var viewer=this.viewer;var scene=viewer.scene;var metaScene=viewer.metaScene;var metaModel=metaScene.metaModels[modelId];var model=scene.models[modelId];if(!metaModel||!metaModel.rootMetaObjects){return;}var rootMetaObjects=metaModel.rootMetaObjects;for(var j=0,lenj=rootMetaObjects.length;j<lenj;j++){var storeyIds=rootMetaObjects[j].getObjectIDsInSubtreeByType(["IfcBuildingStorey"]);for(var _i523=0,len=storeyIds.length;_i523<len;_i523++){var storeyId=storeyIds[_i523];var metaObject=metaScene.metaObjects[storeyId];var childObjectIds=metaObject.getObjectIDsInSubtree();var storeyAABB=scene.getAABB(childObjectIds);var numObjects=Math.random()>0.5?childObjectIds.length:0;var storey=new Storey(this,model.aabb,storeyAABB,modelId,storeyId,numObjects);storey._onModelDestroyed=model.once("destroyed",function(){_this134._deregisterModelStoreys(modelId);_this134.fire("storeys",_this134.storeys);});this.storeys[storeyId]=storey;if(!this.modelStoreys[modelId]){this.modelStoreys[modelId]={};}this.modelStoreys[modelId][storeyId]=storey;}}}},{key:"_deregisterModelStoreys",value:function _deregisterModelStoreys(modelId){var storeys=this.modelStoreys[modelId];if(storeys){var scene=this.viewer.scene;for(var storyObjectId in storeys){if(storeys.hasOwnProperty(storyObjectId)){var storey=storeys[storyObjectId];var model=scene.models[storey.modelId];if(model){model.off(storey._onModelDestroyed);}delete this.storeys[storyObjectId];}}delete this.modelStoreys[modelId];}}/**
     * When true, the elements of each floor map image will be proportionally resized to encompass the entire image. This leads to varying scales among different
     * floor map images. If false, each floor map image will display the model's extents, ensuring a consistent scale across all images.
     * @returns {*|boolean}
     */},{key:"fitStoreyMaps",get:function get(){return this._fitStoreyMaps;}/**
     * Arranges the {@link Camera} for a 3D orthographic view of the {@link Entity}s within the given storey.
     *
     * See also: {@link CameraMemento}, which saves and restores the state of the {@link Scene}'s {@link Camera}
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {*} [options] Options for arranging the Camera.
     * @param {String} [options.projection] Projection type to transition the Camera to. Accepted values are "perspective" and "ortho".
     * @param {Function} [options.done] Callback to fire when the Camera has arrived. When provided, causes an animated flight to the saved state. Otherwise jumps to the saved state.
     */},{key:"gotoStoreyCamera",value:function gotoStoreyCamera(storeyId){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var storey=this.storeys[storeyId];if(!storey){this.error("IfcBuildingStorey not found with this ID: "+storeyId);if(options.done){options.done();}return;}var viewer=this.viewer;var scene=viewer.scene;var camera=scene.camera;var storeyAABB=storey.storeyAABB;if(storeyAABB[3]<storeyAABB[0]||storeyAABB[4]<storeyAABB[1]||storeyAABB[5]<storeyAABB[2]){// Don't fly to an inverted boundary
if(options.done){options.done();}return;}if(storeyAABB[3]===storeyAABB[0]&&storeyAABB[4]===storeyAABB[1]&&storeyAABB[5]===storeyAABB[2]){// Don't fly to an empty boundary
if(options.done){options.done();}return;}var look2=math.getAABB3Center(storeyAABB);var diag=math.getAABB3Diag(storeyAABB);var fitFOV=45;// fitFOV;
var sca=Math.abs(diag/Math.tan(fitFOV*math.DEGTORAD));var orthoScale2=diag*1.3;var eye2=tempVec3a$2;eye2[0]=look2[0]+camera.worldUp[0]*sca;eye2[1]=look2[1]+camera.worldUp[1]*sca;eye2[2]=look2[2]+camera.worldUp[2]*sca;var up2=camera.worldForward;if(options.done){viewer.cameraFlight.flyTo(utils.apply(options,{eye:eye2,look:look2,up:up2,orthoScale:orthoScale2}),function(){options.done();});}else{viewer.cameraFlight.jumpTo(utils.apply(options,{eye:eye2,look:look2,up:up2,orthoScale:orthoScale2}));viewer.camera.ortho.scale=orthoScale2;}}/**
     * Shows the {@link Entity}s within the given storey.
     *
     * Optionally hides all other Entitys.
     *
     * See also: {@link ObjectsMemento}, which saves and restores a memento of the visual state
     * of the {@link Entity}'s that represent objects within a {@link Scene}.
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {*} [options] Options for showing the Entitys within the storey.
     * @param {Boolean} [options.hideOthers=false] When ````true````, hide all other {@link Entity}s.
    */},{key:"showStoreyObjects",value:function showStoreyObjects(storeyId){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var storey=this.storeys[storeyId];if(!storey){this.error("IfcBuildingStorey not found with this ID: "+storeyId);return;}var viewer=this.viewer;var scene=viewer.scene;var metaScene=viewer.metaScene;var storeyMetaObject=metaScene.metaObjects[storeyId];if(!storeyMetaObject){return;}if(options.hideOthers){scene.setObjectsVisible(viewer.scene.visibleObjectIds,false);}this.withStoreyObjects(storeyId,function(entity,metaObject){if(entity){entity.visible=true;}});}/**
     * Executes a callback on each of the objects within the given storey.
     *
     * ## Usage
     *
     * In the example below, we'll show all the {@link Entity}s, within the given ````IfcBuildingStorey````,
     * that have {@link MetaObject}s with type ````IfcSpace````. Note that the callback will only be given
     * an {@link Entity} when one exists for the given {@link MetaObject}.
     *
     * ````JavaScript
     * myStoreyViewsPlugin.withStoreyObjects(storeyId, (entity, metaObject) => {
     *      if (entity && metaObject && metaObject.type === "IfcSpace") {
     *          entity.visible = true;
     *      }
     * });
     * ````
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {Function} callback The callback.
     */},{key:"withStoreyObjects",value:function withStoreyObjects(storeyId,callback){var viewer=this.viewer;var scene=viewer.scene;var metaScene=viewer.metaScene;var rootMetaObject=metaScene.metaObjects[storeyId];if(!rootMetaObject){return;}var storeySubObjects=rootMetaObject.getObjectIDsInSubtree();for(var i=0,len=storeySubObjects.length;i<len;i++){var objectId=storeySubObjects[i];var metaObject=metaScene.metaObjects[objectId];var entity=scene.objects[objectId];if(entity){callback(entity,metaObject);}}}/**
     * Creates a 2D map of the given storey.
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {*} [options] Options for creating the image.
     * @param {Number} [options.width=300] Image width in pixels. Height will be automatically determined from this, if not given.
     * @param {Number} [options.height=300] Image height in pixels, as an alternative to width. Width will be automatically determined from this, if not given.
     * @param {String} [options.format="png"] Image format. Accepted values are "png" and "jpeg".
     * @returns {StoreyMap} The StoreyMap.
     */},{key:"createStoreyMap",value:function createStoreyMap(storeyId){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var storey=this.storeys[storeyId];if(!storey){this.error("IfcBuildingStorey not found with this ID: "+storeyId);return EMPTY_IMAGE;}var viewer=this.viewer;var scene=viewer.scene;var format=options.format||"png";var aabb=this._fitStoreyMaps?storey.storeyAABB:storey.modelAABB;var aspect=Math.abs((aabb[5]-aabb[2])/(aabb[3]-aabb[0]));var padding=options.padding||0;var width;var height;if(options.width&&options.height){width=options.width;height=options.height;}else if(options.height){height=options.height;width=Math.round(height/aspect);}else if(options.width){width=options.width;height=Math.round(width*aspect);}else{width=300;height=Math.round(width*aspect);}this._objectsMemento.saveObjects(scene);this._cameraMemento.saveCamera(scene);this.showStoreyObjects(storeyId,utils.apply(options,{hideOthers:true}));this._arrangeStoreyMapCamera(storey);var src=viewer.getSnapshot({width:width,height:height,format:format});this._objectsMemento.restoreObjects(scene);this._cameraMemento.restoreCamera(scene);return new StoreyMap(storeyId,src,format,width,height,padding);}},{key:"_arrangeStoreyMapCamera",value:function _arrangeStoreyMapCamera(storey){var viewer=this.viewer;var scene=viewer.scene;var camera=scene.camera;var aabb=this._fitStoreyMaps?storey.storeyAABB:storey.modelAABB;var look=math.getAABB3Center(aabb);var sca=0.5;var eye=tempVec3a$2;eye[0]=look[0]+camera.worldUp[0]*sca;eye[1]=look[1]+camera.worldUp[1]*sca;eye[2]=look[2]+camera.worldUp[2]*sca;var up=camera.worldForward;viewer.cameraFlight.jumpTo({eye:eye,look:look,up:up});var xHalfSize=(aabb[3]-aabb[0])/2;var yHalfSize=(aabb[4]-aabb[1])/2;var zHalfSize=(aabb[5]-aabb[2])/2;var xmin=-xHalfSize;var xmax=+xHalfSize;var ymin=-yHalfSize;var ymax=+yHalfSize;var zmin=-zHalfSize;var zmax=+zHalfSize;viewer.camera.customProjection.matrix=math.orthoMat4c(xmin,xmax,zmin,zmax,ymin,ymax,tempMat4);viewer.camera.projection="customProjection";}/**
     * Attempts to pick an {@link Entity} at the given pixel coordinates within a StoreyMap image.
     *
     * @param {StoreyMap} storeyMap The StoreyMap.
     * @param {Number[]} imagePos 2D pixel coordinates within the bounds of {@link StoreyMap#imageData}.
     * @param {*} [options] Picking options.
     * @param {Boolean} [options.pickSurface=false] Whether to return the picked position on the surface of the Entity.
     * @returns {PickResult} The pick result, if an Entity was successfully picked, else null.
     */},{key:"pickStoreyMap",value:function pickStoreyMap(storeyMap,imagePos){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var storeyId=storeyMap.storeyId;var storey=this.storeys[storeyId];if(!storey){this.error("IfcBuildingStorey not found with this ID: "+storeyId);return null;}var normX=1.0-imagePos[0]/storeyMap.width;var normZ=1.0-imagePos[1]/storeyMap.height;var aabb=this._fitStoreyMaps?storey.storeyAABB:storey.modelAABB;var xmin=aabb[0];var ymin=aabb[1];var zmin=aabb[2];var xmax=aabb[3];var ymax=aabb[4];var zmax=aabb[5];var xWorldSize=xmax-xmin;var yWorldSize=ymax-ymin;var zWorldSize=zmax-zmin;var origin=math.vec3([xmin+xWorldSize*normX,ymin+yWorldSize*0.5,zmin+zWorldSize*normZ]);var direction=math.vec3([0,-1,0]);var look=math.addVec3(origin,direction,tempVec3a$2);var worldForward=this.viewer.camera.worldForward;var matrix=math.lookAtMat4v(origin,look,worldForward,tempMat4);var pickResult=this.viewer.scene.pick({// Picking with arbitrarily-positioned ray
pickSurface:options.pickSurface,pickInvisible:true,matrix:matrix});return pickResult;}},{key:"storeyMapToWorldPos",value:function storeyMapToWorldPos(storeyMap,imagePos){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var storeyId=storeyMap.storeyId;var storey=this.storeys[storeyId];if(!storey){this.error("IfcBuildingStorey not found with this ID: "+storeyId);return null;}var normX=1.0-imagePos[0]/storeyMap.width;var normZ=1.0-imagePos[1]/storeyMap.height;var aabb=this._fitStoreyMaps?storey.storeyAABB:storey.modelAABB;var xmin=aabb[0];var ymin=aabb[1];var zmin=aabb[2];var xmax=aabb[3];var ymax=aabb[4];var zmax=aabb[5];var xWorldSize=xmax-xmin;var yWorldSize=ymax-ymin;var zWorldSize=zmax-zmin;var origin=math.vec3([xmin+xWorldSize*normX,ymin+yWorldSize*0.5,zmin+zWorldSize*normZ]);return origin;}/**
     * Gets the ID of the storey that contains the given 3D World-space position.
     *.
     * @param {Number[]} worldPos 3D World-space position.
     * @returns {String} ID of the storey containing the position, or null if the position falls outside all the storeys.
     */},{key:"getStoreyContainingWorldPos",value:function getStoreyContainingWorldPos(worldPos){for(var storeyId in this.storeys){var storey=this.storeys[storeyId];if(math.point3AABB3Intersect(storey.storeyAABB,worldPos)){return storeyId;}}return null;}/**
     * Converts a 3D World-space position to a 2D position within a StoreyMap image.
     *
     * Use {@link StoreyViewsPlugin#pickStoreyMap} to convert 2D image positions to 3D world-space.
     *
     * @param {StoreyMap} storeyMap The StoreyMap.
     * @param {Number[]} worldPos 3D World-space position within the storey.
     * @param {Number[]} imagePos 2D pixel position within the {@link StoreyMap#imageData}.
     * @returns {Boolean} True if ````imagePos```` is within the bounds of the {@link StoreyMap#imageData}, else ````false```` if it falls outside.
     */},{key:"worldPosToStoreyMap",value:function worldPosToStoreyMap(storeyMap,worldPos,imagePos){var storeyId=storeyMap.storeyId;var storey=this.storeys[storeyId];if(!storey){this.error("IfcBuildingStorey not found with this ID: "+storeyId);return false;}var aabb=this._fitStoreyMaps?storey.storeyAABB:storey.modelAABB;var xmin=aabb[0];var ymin=aabb[1];var zmin=aabb[2];var xmax=aabb[3];var ymax=aabb[4];var zmax=aabb[5];var xWorldSize=xmax-xmin;var yWorldSize=ymax-ymin;var zWorldSize=zmax-zmin;var camera=this.viewer.camera;var worldUp=camera.worldUp;var xUp=worldUp[0]>worldUp[1]&&worldUp[0]>worldUp[2];var yUp=!xUp&&worldUp[1]>worldUp[0]&&worldUp[1]>worldUp[2];!xUp&&!yUp&&worldUp[2]>worldUp[0]&&worldUp[2]>worldUp[1];var ratioX=storeyMap.width/xWorldSize;var ratioY=yUp?storeyMap.height/zWorldSize:storeyMap.height/yWorldSize;// Assuming either Y or Z is "up", but never X
imagePos[0]=Math.floor(storeyMap.width-(worldPos[0]-xmin)*ratioX);imagePos[1]=Math.floor(storeyMap.height-(worldPos[2]-zmin)*ratioY);return imagePos[0]>=0&&imagePos[0]<storeyMap.width&&imagePos[1]>=0&&imagePos[1]<=storeyMap.height;}/**
     * Converts a 3D World-space direction vector to a 2D vector within a StoreyMap image.
     *
     * @param {StoreyMap} storeyMap The StoreyMap.
     * @param {Number[]} worldDir 3D World-space direction vector.
     * @param {Number[]} imageDir Normalized 2D direction vector.
     */},{key:"worldDirToStoreyMap",value:function worldDirToStoreyMap(storeyMap,worldDir,imageDir){var camera=this.viewer.camera;var eye=camera.eye;var look=camera.look;var eyeLookDir=math.subVec3(look,eye,tempVec3a$2);var worldUp=camera.worldUp;var xUp=worldUp[0]>worldUp[1]&&worldUp[0]>worldUp[2];var yUp=!xUp&&worldUp[1]>worldUp[0]&&worldUp[1]>worldUp[2];!xUp&&!yUp&&worldUp[2]>worldUp[0]&&worldUp[2]>worldUp[1];if(xUp){imageDir[0]=eyeLookDir[1];imageDir[1]=eyeLookDir[2];}else if(yUp){imageDir[0]=eyeLookDir[0];imageDir[1]=eyeLookDir[2];}else{imageDir[0]=eyeLookDir[0];imageDir[1]=eyeLookDir[1];}math.normalizeVec2(imageDir);}/**
     * Destroys this StoreyViewsPlugin.
     */},{key:"destroy",value:function destroy(){this.viewer.scene.off(this._onModelLoaded);_get(_getPrototypeOf(StoreyViewsPlugin.prototype),"destroy",this).call(this);}}]);return StoreyViewsPlugin;}(Plugin);var zeroVec=new Float64Array([0,0,1]);var quat=new Float64Array(4);/**
 * Controls a {@link SectionPlane} with mouse and touch input.
 */var FaceAlignedSectionPlanesControl=/*#__PURE__*/function(){/** @private */function FaceAlignedSectionPlanesControl(plugin){_classCallCheck(this,FaceAlignedSectionPlanesControl);/**
         * ID of this FaceAlignedSectionPlanesControl.
         *
         * FaceAlignedSectionPlanesControl are mapped by this ID in {@link FaceAlignedSectionPlanesPlugin#controls}.
         *
         * @property id
         * @type {String|Number}
         */this.id=null;this._viewer=plugin.viewer;this._plugin=plugin;this._visible=false;this._pos=math.vec3();// Full-precision position of the center of the FaceAlignedSectionPlanesControl
this._origin=math.vec3();this._rtcPos=math.vec3();this._baseDir=math.vec3();// Saves direction of clip plane when we start dragging an arrow or ring.
this._rootNode=null;// Root of Node graph that represents this control in the 3D scene
this._displayMeshes=null;// Meshes that are always visible
this._affordanceMeshes=null;// Meshes displayed momentarily for affordance
this._ignoreNextSectionPlaneDirUpdate=false;this._createNodes();this._bindEvents();}/**
     * Called by FaceAlignedSectionPlanesPlugin to assign this FaceAlignedSectionPlanesControl to a SectionPlane.
     * FaceAlignedSectionPlanesPlugin keeps FaceAlignedSectionPlanesControls in a reuse pool.
     * Call with a null or undefined value to disconnect the FaceAlignedSectionPlanesControl ffrom whatever SectionPlane it was assigned to.
     * @private
     */_createClass(FaceAlignedSectionPlanesControl,[{key:"_setSectionPlane",value:function _setSectionPlane(sectionPlane){var _this135=this;if(this._sectionPlane){this._sectionPlane.off(this._onSectionPlanePos);this._sectionPlane.off(this._onSectionPlaneDir);this._onSectionPlanePos=null;this._onSectionPlaneDir=null;this._sectionPlane=null;}if(sectionPlane){this.id=sectionPlane.id;this._setPos(sectionPlane.pos);this._setDir(sectionPlane.dir);this._sectionPlane=sectionPlane;this._onSectionPlanePos=sectionPlane.on("pos",function(){_this135._setPos(_this135._sectionPlane.pos);});this._onSectionPlaneDir=sectionPlane.on("dir",function(){if(!_this135._ignoreNextSectionPlaneDirUpdate){_this135._setDir(_this135._sectionPlane.dir);}else{_this135._ignoreNextSectionPlaneDirUpdate=false;}});}}/**
     * Gets the {@link SectionPlane} controlled by this FaceAlignedSectionPlanesControl.
     * @returns {SectionPlane} The SectionPlane.
     */},{key:"sectionPlane",get:function get(){return this._sectionPlane;}/** @private */},{key:"_setPos",value:function _setPos(xyz){this._pos.set(xyz);worldToRTCPos(this._pos,this._origin,this._rtcPos);this._rootNode.origin=this._origin;this._rootNode.position=this._rtcPos;}/** @private */},{key:"_setDir",value:function _setDir(xyz){this._baseDir.set(xyz);this._rootNode.quaternion=math.vec3PairToQuaternion(zeroVec,xyz,quat);}},{key:"_setSectionPlaneDir",value:function _setSectionPlaneDir(dir){if(this._sectionPlane){this._ignoreNextSectionPlaneDirUpdate=true;this._sectionPlane.dir=dir;}}/**
     * Sets if this FaceAlignedSectionPlanesControl is visible.
     *
     * @type {Boolean}
     */},{key:"setVisible",value:function setVisible(){var visible=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;if(this._visible===visible){return;}this._visible=visible;var id;for(id in this._displayMeshes){if(this._displayMeshes.hasOwnProperty(id)){this._displayMeshes[id].visible=visible;}}if(!visible){for(id in this._affordanceMeshes){if(this._affordanceMeshes.hasOwnProperty(id)){this._affordanceMeshes[id].visible=visible;}}}}/**
     * Gets if this FaceAlignedSectionPlanesControl is visible.
     *
     * @type {Boolean}
     */},{key:"getVisible",value:function getVisible(){return this._visible;}/**
     * Sets if this FaceAlignedSectionPlanesControl is culled. This is called by FaceAlignedSectionPlanesPlugin to
     * temporarily hide the FaceAlignedSectionPlanesControl while a snapshot is being taken by Viewer#getSnapshot().
     * @param culled
     */},{key:"setCulled",value:function setCulled(culled){var id;for(id in this._displayMeshes){if(this._displayMeshes.hasOwnProperty(id)){this._displayMeshes[id].culled=culled;}}if(!culled){for(id in this._affordanceMeshes){if(this._affordanceMeshes.hasOwnProperty(id)){this._affordanceMeshes[id].culled=culled;}}}}/**
     * Builds the Entities that represent this FaceAlignedSectionPlanesControl.
     * @private
     */},{key:"_createNodes",value:function _createNodes(){var NO_STATE_INHERIT=false;var scene=this._viewer.scene;var radius=1.0;var tubeRadius=0.01;var arrowRadius=0.07;this._rootNode=new Node$2(scene,{position:[0,0,0],scale:[5,5,5]});var rootNode=this._rootNode;var shapes={// Reusable geometries
arrowHead:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:0.001,radiusBottom:arrowRadius,radialSegments:32,heightSegments:1,height:0.2,openEnded:false})),arrowHeadBig:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:0.001,radiusBottom:0.09,radialSegments:32,heightSegments:1,height:0.25,openEnded:false})),axis:new ReadableGeometry(rootNode,buildCylinderGeometry({radiusTop:tubeRadius,radiusBottom:tubeRadius,radialSegments:20,heightSegments:1,height:radius,openEnded:false}))};var materials={// Reusable materials
red:new PhongMaterial(rootNode,{diffuse:[1,0.0,0.0],emissive:[1,0.0,0.0],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2}),green:new PhongMaterial(rootNode,{diffuse:[0,1.0,0.0],emissive:[1,0.0,0.0],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2}),blue:new PhongMaterial(rootNode,{diffuse:[0,0.0,1.0],emissive:[1,0.0,0.0],ambient:[0.0,0.0,0.0],specular:[.6,.6,.3],shininess:80,lineWidth:2}),highlightRed:new EmphasisMaterial(rootNode,{// Emphasis for red rotation affordance hoop
edges:false,fill:true,fillColor:[1,0,0],fillAlpha:0.6})};this._displayMeshes={plane:rootNode.addChild(new Mesh(rootNode,{geometry:new ReadableGeometry(rootNode,{primitive:"triangles",positions:[0.5,0.5,0.0,0.5,-0.5,0.0,// 0
-0.5,-0.5,0.0,-0.5,0.5,0.0,// 1
0.5,0.5,-0.0,0.5,-0.5,-0.0,// 2
-0.5,-0.5,-0.0,-0.5,0.5,-0.0// 3
],indices:[0,1,2,2,3,0]}),material:new PhongMaterial(rootNode,{emissive:[0,0.0,0],diffuse:[0,0,0],backfaces:true}),opacity:0.6,ghosted:true,pickable:false,collidable:true,clippable:false,visible:false,scale:[2.4,2.4,1]}),NO_STATE_INHERIT),planeFrame:rootNode.addChild(new Mesh(rootNode,{// Visible frame
geometry:new ReadableGeometry(rootNode,buildTorusGeometry({center:[0,0,0],radius:1.7,tube:tubeRadius*2,radialSegments:4,tubeSegments:4,arc:Math.PI*2.0})),material:new PhongMaterial(rootNode,{emissive:[0,0,0],diffuse:[0,0,0],specular:[0,0,0],shininess:0}),pickable:false,collidable:false,clippable:false,visible:false,scale:[1,1,.1],rotation:[0,0,45]}),NO_STATE_INHERIT),center:rootNode.addChild(new Mesh(rootNode,{geometry:new ReadableGeometry(rootNode,buildSphereGeometry({radius:0.05})),material:materials.center,pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHead,material:materials.blue,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0.8,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT),zShaft:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.axis,material:materials.blue,matrix:function(){var translate=math.translateMat4c(0,radius/2,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[1,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),clippable:false,pickable:false,collidable:true,visible:false}),NO_STATE_INHERIT)};this._affordanceMeshes={planeFrame:rootNode.addChild(new Mesh(rootNode,{geometry:new ReadableGeometry(rootNode,buildTorusGeometry({center:[0,0,0],radius:2,tube:tubeRadius,radialSegments:4,tubeSegments:4,arc:Math.PI*2.0})),material:new PhongMaterial(rootNode,{ambient:[1,1,1],diffuse:[0,0,0],emissive:[1,1,0]}),highlighted:true,highlightMaterial:new EmphasisMaterial(rootNode,{edges:false,filled:true,fillColor:[1,1,0],fillAlpha:1.0}),pickable:false,collidable:false,clippable:false,visible:false,scale:[1,1,1],rotation:[0,0,45]}),NO_STATE_INHERIT),zAxisArrow:rootNode.addChild(new Mesh(rootNode,{geometry:shapes.arrowHeadBig,material:materials.blue,matrix:function(){var translate=math.translateMat4c(0,radius+.1,0,math.identityMat4());var rotate=math.rotationMat4v(-90*math.DEGTORAD,[0.8,0,0],math.identityMat4());return math.mulMat4(rotate,translate,math.identityMat4());}(),pickable:false,collidable:true,clippable:false,visible:false}),NO_STATE_INHERIT)};}},{key:"_bindEvents",value:function _bindEvents(){var _this136=this;var rootNode=this._rootNode;var lastCanvasPos=math.vec2();var camera=this._viewer.camera;var scene=this._viewer.scene;var deltaUpdate=0;var waitForTick=false;{// Keep gizmo screen size constant
var _tempVec3a2=math.vec3([0,0,0]);var lastDist=-1;this._onCameraViewMatrix=scene.camera.on("viewMatrix",function(){});this._onCameraProjMatrix=scene.camera.on("projMatrix",function(){});this._onSceneTick=scene.on("tick",function(){waitForTick=false;var dist=Math.abs(math.lenVec3(math.subVec3(scene.camera.eye,_this136._pos,_tempVec3a2)));if(dist!==lastDist){if(camera.projection==="perspective"){var worldSize=Math.tan(camera.perspective.fov*math.DEGTORAD)*dist;var size=0.07*worldSize;rootNode.scale=[size,size,size];lastDist=dist;}}if(camera.projection==="ortho"){var _worldSize2=camera.ortho.scale/10;var _size2=_worldSize2;rootNode.scale=[_size2,_size2,_size2];lastDist=dist;}if(deltaUpdate!==0){moveSectionPlane(deltaUpdate);deltaUpdate=0;}});}var getClickCoordsWithinElement=function(){var canvasPos=new Float64Array(2);return function(event){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y;}else{var element=event.target;var totalOffsetLeft=0;var totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent;}canvasPos[0]=event.pageX-totalOffsetLeft;canvasPos[1]=event.pageY-totalOffsetTop;}return canvasPos;};}();var moveSectionPlane=function moveSectionPlane(delta){var pos=_this136._sectionPlane.pos;var dir=_this136._sectionPlane.dir;math.addVec3(pos,math.mulVec3Scalar(dir,0.1*delta*_this136._plugin.getDragSensitivity(),math.vec3()));_this136._sectionPlane.pos=pos;};{var down=false;this._plugin._controlElement.addEventListener("mousedown",this._canvasMouseDownListener=function(e){e.preventDefault();if(!_this136._visible){return;}_this136._viewer.cameraControl.pointerEnabled=false;switch(e.which){case 1:// Left button
down=true;var canvasPos=getClickCoordsWithinElement(e);lastCanvasPos[0]=canvasPos[0];lastCanvasPos[1]=canvasPos[1];break;}});this._plugin._controlElement.addEventListener("mousemove",this._canvasMouseMoveListener=function(e){if(!_this136._visible){return;}if(!down){return;}if(waitForTick){// Limit changes detection to one per frame
return;}var canvasPos=getClickCoordsWithinElement(e);var x=canvasPos[0];var y=canvasPos[1];moveSectionPlane(y-lastCanvasPos[1]);lastCanvasPos[0]=x;lastCanvasPos[1]=y;});this._plugin._controlElement.addEventListener("mouseup",this._canvasMouseUpListener=function(e){if(!_this136._visible){return;}_this136._viewer.cameraControl.pointerEnabled=true;if(!down){return;}switch(e.which){}down=false;});this._plugin._controlElement.addEventListener("wheel",this._canvasWheelListener=function(e){if(!_this136._visible){return;}deltaUpdate+=Math.max(-1,Math.min(1,-e.deltaY*40));});}{var touchStartY,touchEndY;var lastTouchY=null;this._plugin._controlElement.addEventListener("touchstart",this._handleTouchStart=function(e){e.stopPropagation();e.preventDefault();if(!_this136._visible){return;}touchStartY=e.touches[0].clientY;lastTouchY=touchStartY;deltaUpdate=0;});this._plugin._controlElement.addEventListener("touchmove",this._handleTouchMove=function(e){e.stopPropagation();e.preventDefault();if(!_this136._visible){return;}if(waitForTick){// Limit changes detection to one per frame
return;}waitForTick=true;touchEndY=e.touches[0].clientY;if(lastTouchY!==null){deltaUpdate+=touchEndY-lastTouchY;}lastTouchY=touchEndY;});this._plugin._controlElement.addEventListener("touchend",this._handleTouchEnd=function(e){e.stopPropagation();e.preventDefault();if(!_this136._visible){return;}touchStartY=null;touchEndY=null;deltaUpdate=0;});}}},{key:"_destroy",value:function _destroy(){this._unbindEvents();this._destroyNodes();}},{key:"_unbindEvents",value:function _unbindEvents(){var viewer=this._viewer;var scene=viewer.scene;var canvas=scene.canvas.canvas;var camera=viewer.camera;var controlElement=this._plugin._controlElement;scene.off(this._onSceneTick);canvas.removeEventListener("mousedown",this._canvasMouseDownListener);canvas.removeEventListener("mousemove",this._canvasMouseMoveListener);canvas.removeEventListener("mouseup",this._canvasMouseUpListener);canvas.removeEventListener("wheel",this._canvasWheelListener);controlElement.removeEventListener("touchstart",this._handleTouchStart);controlElement.removeEventListener("touchmove",this._handleTouchMove);controlElement.removeEventListener("touchend",this._handleTouchEnd);camera.off(this._onCameraViewMatrix);camera.off(this._onCameraProjMatrix);}},{key:"_destroyNodes",value:function _destroyNodes(){this._setSectionPlane(null);this._rootNode.destroy();this._displayMeshes={};this._affordanceMeshes={};}}]);return FaceAlignedSectionPlanesControl;}();/**
 * Renders a 3D plane within an {@link Overview} to indicate its {@link SectionPlane}'s current position and orientation.
 *
 * @private
 */var Plane=/*#__PURE__*/function(){/** @private */function Plane(overview,overviewScene,sectionPlane){var _this137=this;_classCallCheck(this,Plane);/**
         * The ID of this SectionPlanesOverviewPlane.
         *
         * @type {String}
         */this.id=sectionPlane.id;/**
         * The {@link SectionPlane} represented by this SectionPlanesOverviewPlane.
         *
         * @type {SectionPlane}
         */this._sectionPlane=sectionPlane;this._mesh=new Mesh(overviewScene,{id:sectionPlane.id,geometry:new ReadableGeometry(overviewScene,buildBoxGeometry({xSize:.5,ySize:.5,zSize:.001})),material:new PhongMaterial(overviewScene,{emissive:[1,1,1],diffuse:[0,0,0],backfaces:false}),edgeMaterial:new EdgeMaterial(overviewScene,{edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1}),highlightMaterial:new EmphasisMaterial(overviewScene,{fill:true,fillColor:[0.5,1,0.5],fillAlpha:0.7,edges:true,edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1}),selectedMaterial:new EmphasisMaterial(overviewScene,{fill:true,fillColor:[0,0,1],fillAlpha:0.7,edges:true,edgeColor:[1.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1}),highlighted:true,scale:[3,3,3],position:[0,0,0],rotation:[0,0,0],opacity:0.3,edges:true});{var vec=math.vec3([0,0,0]);var pos2=math.vec3();var _zeroVec2=math.vec3([0,0,1]);var _quat2=math.vec4(4);var pos3=math.vec3();var update=function update(){var origin=_this137._sectionPlane.scene.center;var negDir=[-_this137._sectionPlane.dir[0],-_this137._sectionPlane.dir[1],-_this137._sectionPlane.dir[2]];math.subVec3(origin,_this137._sectionPlane.pos,vec);var dist=-math.dotVec3(negDir,vec);math.normalizeVec3(negDir);math.mulVec3Scalar(negDir,dist,pos2);var quaternion=math.vec3PairToQuaternion(_zeroVec2,_this137._sectionPlane.dir,_quat2);pos3[0]=pos2[0]*0.1;pos3[1]=pos2[1]*0.1;pos3[2]=pos2[2]*0.1;_this137._mesh.quaternion=quaternion;_this137._mesh.position=pos3;};this._onSectionPlanePos=this._sectionPlane.on("pos",update);this._onSectionPlaneDir=this._sectionPlane.on("dir",update);// update();
}this._highlighted=false;this._selected=false;}/**
     * Sets if this SectionPlanesOverviewPlane is highlighted.
     *
     * @type {Boolean}
     * @private
     */_createClass(Plane,[{key:"setHighlighted",value:function setHighlighted(highlighted){this._highlighted=!!highlighted;this._mesh.highlighted=this._highlighted;this._mesh.highlightMaterial.fillColor=highlighted?[0,0.7,0]:[0,0,0];// this._selectedMesh.highlighted = true;
}/**
     * Gets if this SectionPlanesOverviewPlane is highlighted.
     *
     * @type {Boolean}
     * @private
     */},{key:"getHighlighted",value:function getHighlighted(){return this._highlighted;}/**
     * Sets if this SectionPlanesOverviewPlane is selected.
     *
     * @type {Boolean}
     * @private
     */},{key:"setSelected",value:function setSelected(selected){this._selected=!!selected;this._mesh.edgeMaterial.edgeWidth=selected?3:1;this._mesh.highlightMaterial.edgeWidth=selected?3:1;}/**
     * Gets if this SectionPlanesOverviewPlane is selected.
     *
     * @type {Boolean}
     * @private
     */},{key:"getSelected",value:function getSelected(){return this._selected;}/** @private */},{key:"destroy",value:function destroy(){this._sectionPlane.off(this._onSectionPlanePos);this._sectionPlane.off(this._onSectionPlaneDir);this._mesh.destroy();}}]);return Plane;}();/**
 * @desc An interactive 3D overview for navigating the {@link SectionPlane}s created by its {@link FaceAlignedSectionPlanesPlugin}.
 *
 * * Located at {@link FaceAlignedSectionPlanesPlugin#overview}.
 * * Renders the overview on a separate canvas at a corner of the {@link Viewer}'s {@link Scene} {@link Canvas}.
 * * The overview shows a 3D plane object for each {@link SectionPlane} in the {@link Scene}.
 * * Click a plane object in the overview to toggle the visibility of a 3D gizmo to edit the position and orientation of its {@link SectionPlane}.
 *
 * @private
 */var Overview=/*#__PURE__*/function(){/**
     * @private
     */function Overview(plugin,cfg){var _this138=this;_classCallCheck(this,Overview);if(!cfg.onHoverEnterPlane||!cfg.onHoverLeavePlane||!cfg.onClickedNothing||!cfg.onClickedPlane){throw"Missing config(s): onHoverEnterPlane, onHoverLeavePlane, onClickedNothing || onClickedPlane";}/**
         * The {@link FaceAlignedSectionPlanesPlugin} that owns this SectionPlanesOverview.
         *
         * @type {FaceAlignedSectionPlanesPlugin}
         */this.plugin=plugin;this._viewer=plugin.viewer;this._onHoverEnterPlane=cfg.onHoverEnterPlane;this._onHoverLeavePlane=cfg.onHoverLeavePlane;this._onClickedNothing=cfg.onClickedNothing;this._onClickedPlane=cfg.onClickedPlane;this._visible=true;this._planes={};//--------------------------------------------------------------------------------------------------------------
// Init canvas
//--------------------------------------------------------------------------------------------------------------
this._canvas=cfg.overviewCanvas;//--------------------------------------------------------------------------------------------------------------
// Init scene
//--------------------------------------------------------------------------------------------------------------
this._scene=new Scene(this._viewer,{canvasId:this._canvas.id,transparent:true});this._scene.clearLights();new DirLight(this._scene,{dir:[0.4,-0.4,0.8],color:[0.8,1.0,1.0],intensity:1.0,space:"view"});new DirLight(this._scene,{dir:[-0.8,-0.3,-0.4],color:[0.8,0.8,0.8],intensity:1.0,space:"view"});new DirLight(this._scene,{dir:[0.8,-0.6,-0.8],color:[1.0,1.0,1.0],intensity:1.0,space:"view"});this._scene.camera;this._scene.camera.perspective.fov=70;this._zUp=false;//--------------------------------------------------------------------------------------------------------------
// Synchronize overview scene camera with viewer camera
//--------------------------------------------------------------------------------------------------------------
{var camera=this._scene.camera;var _matrix3=math.rotationMat4c(-90*math.DEGTORAD,1,0,0);var _eyeLookVec4=math.vec3();var eyeLookVecOverview=math.vec3();var upOverview=math.vec3();this._synchCamera=function(){var eye=_this138._viewer.camera.eye;var look=_this138._viewer.camera.look;var up=_this138._viewer.camera.up;math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye,look,_eyeLookVec4)),7);if(_this138._zUp){// +Z up
math.transformVec3(_matrix3,_eyeLookVec4,eyeLookVecOverview);math.transformVec3(_matrix3,up,upOverview);camera.look=[0,0,0];camera.eye=math.transformVec3(_matrix3,_eyeLookVec4,eyeLookVecOverview);camera.up=math.transformPoint3(_matrix3,up,upOverview);}else{// +Y up
camera.look=[0,0,0];camera.eye=_eyeLookVec4;camera.up=up;}};}this._onViewerCameraMatrix=this._viewer.camera.on("matrix",this._synchCamera);this._onViewerCameraWorldAxis=this._viewer.camera.on("worldAxis",this._synchCamera);this._onViewerCameraFOV=this._viewer.camera.perspective.on("fov",function(fov){_this138._scene.camera.perspective.fov=fov;});//--------------------------------------------------------------------------------------------------------------
// Bind overview canvas events
//--------------------------------------------------------------------------------------------------------------
{var hoveredEntity=null;this._onInputMouseMove=this._scene.input.on("mousemove",function(coords){var hit=_this138._scene.pick({canvasPos:coords});if(hit){if(!hoveredEntity||hit.entity.id!==hoveredEntity.id){if(hoveredEntity){var _plane2=_this138._planes[hoveredEntity.id];if(_plane2){_this138._onHoverLeavePlane(hoveredEntity.id);}}hoveredEntity=hit.entity;var plane=_this138._planes[hoveredEntity.id];if(plane){_this138._onHoverEnterPlane(hoveredEntity.id);}}}else{if(hoveredEntity){_this138._onHoverLeavePlane(hoveredEntity.id);hoveredEntity=null;}}});this._scene.canvas.canvas.addEventListener("mouseup",this._onCanvasMouseUp=function(){if(hoveredEntity){var plane=_this138._planes[hoveredEntity.id];if(plane){_this138._onClickedPlane(hoveredEntity.id);}}else{_this138._onClickedNothing();}});this._scene.canvas.canvas.addEventListener("mouseout",this._onCanvasMouseOut=function(){if(hoveredEntity){_this138._onHoverLeavePlane(hoveredEntity.id);hoveredEntity=null;}});}//--------------------------------------------------------------------------------------------------------------
// Configure overview
//--------------------------------------------------------------------------------------------------------------
this.setVisible(cfg.overviewVisible);}/** Called by SectionPlanesPlugin#createSectionPlane()
     * @private
     */_createClass(Overview,[{key:"addSectionPlane",value:function addSectionPlane(sectionPlane){this._planes[sectionPlane.id]=new Plane(this,this._scene,sectionPlane);}/**  @private
     */},{key:"setPlaneHighlighted",value:function setPlaneHighlighted(id,highlighted){var plane=this._planes[id];if(plane){plane.setHighlighted(highlighted);}}/**  @private
     */},{key:"setPlaneSelected",value:function setPlaneSelected(id,selected){var plane=this._planes[id];if(plane){plane.setSelected(selected);}}/** @private
     */},{key:"removeSectionPlane",value:function removeSectionPlane(sectionPlane){var plane=this._planes[sectionPlane.id];if(plane){plane.destroy();delete this._planes[sectionPlane.id];}}/**
     * Sets if this SectionPlanesOverview is visible.
     *
     * @param {Boolean} visible Whether or not this SectionPlanesOverview is visible.
     */},{key:"setVisible",value:function setVisible(){var visible=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this._visible=visible;this._canvas.style.visibility=visible?"visible":"hidden";}/**
     * Gets if this SectionPlanesOverview is visible.
     *
     * @return {Boolean} True when this SectionPlanesOverview is visible.
     */},{key:"getVisible",value:function getVisible(){return this._visible;}/**  @private
     */},{key:"destroy",value:function destroy(){this._viewer.camera.off(this._onViewerCameraMatrix);this._viewer.camera.off(this._onViewerCameraWorldAxis);this._viewer.camera.perspective.off(this._onViewerCameraFOV);this._scene.input.off(this._onInputMouseMove);this._scene.canvas.canvas.removeEventListener("mouseup",this._onCanvasMouseUp);this._scene.canvas.canvas.removeEventListener("mouseout",this._onCanvasMouseOut);this._scene.destroy();}}]);return Overview;}();var tempAABB=math.AABB3();var tempVec3=math.vec3();/**
 * FaceAlignedSectionPlanesPlugin is a {@link Viewer} plugin that creates and edits face-aligned {@link SectionPlane}s.
 *
 * [<img src="https://xeokit.github.io/xeokit-sdk/assets/images/FaceAlignedSectionPlanesPlugin.gif">](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_FaceAlignedSectionPlanesPlugin)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_FaceAlignedSectionPlanesPlugin)]
 *
 * ## Overview
 *
 * * Use the FaceAlignedSectionPlanesPlugin to
 * create and edit {@link SectionPlane}s to slice portions off your models and reveal internal structures.
 *
 * * As shown in the screen capture above, FaceAlignedSectionPlanesPlugin shows an overview of all your SectionPlanes (on the right, in
 * this example).
 * * Click a plane in the overview to activate a 3D control with which you can interactively
 * reposition its SectionPlane in the main canvas.
 * * Configure the plugin with an HTML element that the user can click-and-drag on to reposition the SectionPlane for which the control is active.
 * * Use {@link BCFViewpointsPlugin} to save and load SectionPlanes in BCF viewpoints.
 *
 * ## Usage
 *
 * In the example below, we'll use a {@link GLTFLoaderPlugin} to load a model, and a FaceAlignedSectionPlanesPlugin
 * to slice it open with two {@link SectionPlane}s. We'll show the overview in the bottom right of the Viewer
 * canvas. Finally, we'll programmatically activate the 3D editing control, so that we can use it to interactively
 * reposition our second SectionPlane.
 *
 * ````JavaScript
 * import {Viewer, GLTFLoaderPlugin, FaceAlignedSectionPlanesPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange its Camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-5.02, 2.22, 15.09];
 * viewer.camera.look = [4.97, 2.79, 9.89];
 * viewer.camera.up = [-0.05, 0.99, 0.02];
 *
 * // Add a GLTFLoaderPlugin
 *
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * // Add a FaceAlignedSectionPlanesPlugin, with overview visible
 *
 * const faceAlignedSectionPlanes = new FaceAlignedSectionPlanesPlugin(viewer, {
 *     overviewCanvasID: "myOverviewCanvas",
 *     overviewVisible: true,
 *     controlElementId: "myControlElement", // ID of element to capture drag events that move the SectionPlane
 *     dragSensitivity: 1  // Sensitivity factor that governs the rate at which dragging moves the SectionPlane
 * });
 *
 * // Load a model
 *
 * const model = gltfLoader.load({
 *     id: "myModel",
 *     src: "./models/gltf/schependomlaan/scene.glb"
 * });
 *
 * // Create a couple of section planes
 * // These will be shown in the overview
 *
 * faceAlignedSectionPlanes.createSectionPlane({
 *     id: "mySectionPlane",
 *     pos: [1.04, 1.95, 9.74],
 *     dir: [1.0, 0.0, 0.0]
 * });
 *
 * faceAlignedSectionPlanes.createSectionPlane({
 *     id: "mySectionPlane2",
 *     pos: [2.30, 4.46, 14.93],
 *     dir: [0.0, -0.09, -0.79]
 * });
 *
 * // Show the FaceAlignedSectionPlanesPlugin's 3D editing gizmo,
 * // to interactively reposition one of our SectionPlanes
 *
 * faceAlignedSectionPlanes.showControl("mySectionPlane2");
 *
 * const mySectionPlane2 = faceAlignedSectionPlanes.sectionPlanes["mySectionPlane2"];
 *
 * // Programmatically reposition one of our SectionPlanes
 * // This also updates its position as shown in the overview gizmo
 *
 * mySectionPlane2.pos = [11.0, 6.0, -12];
 * mySectionPlane2.dir = [0.4, 0.0, 0.5];
 * ````
 */var FaceAlignedSectionPlanesPlugin=/*#__PURE__*/function(_Plugin12){_inherits(FaceAlignedSectionPlanesPlugin,_Plugin12);var _super153=_createSuper(FaceAlignedSectionPlanesPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg Plugin configuration.
     * @param {String} [cfg.id="SectionPlanes"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} [cfg.overviewCanvasId] ID of a canvas element to display the overview.
     * @param {String} [cfg.overviewVisible=true] Initial visibility of the overview canvas.
     * @param {String} cfg.controlElementId ID of an HTML element that catches drag events to move the active SectionPlane.
     * @param {Number} [cfg.dragSensitivity=1] Sensitivity factor that governs the rate at which dragging on the control element moves SectionPlane.
     */function FaceAlignedSectionPlanesPlugin(viewer){var _this139;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,FaceAlignedSectionPlanesPlugin);_this139=_super153.call(this,"FaceAlignedSectionPlanesPlugin",viewer);_this139._freeControls=[];_this139._sectionPlanes=viewer.scene.sectionPlanes;_this139._controls={};_this139._shownControlId=null;_this139._dragSensitivity=cfg.dragSensitivity||1;if(cfg.overviewCanvasId!==null&&cfg.overviewCanvasId!==undefined){var overviewCanvas=document.getElementById(cfg.overviewCanvasId);if(!overviewCanvas){_this139.warn("Can't find overview canvas: '"+cfg.overviewCanvasId+"' - will create plugin without overview");}else{_this139._overview=new Overview(_assertThisInitialized(_this139),{overviewCanvas:overviewCanvas,visible:cfg.overviewVisible,onHoverEnterPlane:function onHoverEnterPlane(id){_this139._overview.setPlaneHighlighted(id,true);},onHoverLeavePlane:function onHoverLeavePlane(id){_this139._overview.setPlaneHighlighted(id,false);},onClickedPlane:function onClickedPlane(id){if(_this139.getShownControl()===id){_this139.hideControl();return;}_this139.showControl(id);var sectionPlane=_this139.sectionPlanes[id];var sectionPlanePos=sectionPlane.pos;tempAABB.set(_this139.viewer.scene.aabb);math.getAABB3Center(tempAABB,tempVec3);tempAABB[0]+=sectionPlanePos[0]-tempVec3[0];tempAABB[1]+=sectionPlanePos[1]-tempVec3[1];tempAABB[2]+=sectionPlanePos[2]-tempVec3[2];tempAABB[3]+=sectionPlanePos[0]-tempVec3[0];tempAABB[4]+=sectionPlanePos[1]-tempVec3[1];tempAABB[5]+=sectionPlanePos[2]-tempVec3[2];_this139.viewer.cameraFlight.flyTo({aabb:tempAABB,fitFOV:65});},onClickedNothing:function onClickedNothing(){_this139.hideControl();}});}}if(cfg.controlElementId===null||cfg.controlElementId===undefined){_this139.error("Parameter expected: controlElementId");}else{_this139._controlElement=document.getElementById(cfg.controlElementId);if(!_this139._controlElement){_this139.warn("Can't find control element: '"+cfg.controlElementId+"' - will create plugin without control element");}}_this139._onSceneSectionPlaneCreated=viewer.scene.on("sectionPlaneCreated",function(sectionPlane){// SectionPlane created, either via FaceAlignedSectionPlanesPlugin#createSectionPlane(), or by directly
// instantiating a SectionPlane independently of FaceAlignedSectionPlanesPlugin, which can be done
// by BCFViewpointsPlugin#loadViewpoint().
_this139._sectionPlaneCreated(sectionPlane);});return _this139;}/**
     * Sets the factor that governs how fast a SectionPlane moves as we drag on the control element.
     *
     * @param {Number} dragSensitivity  The dragging sensitivity factor.
     */_createClass(FaceAlignedSectionPlanesPlugin,[{key:"setDragSensitivity",value:function setDragSensitivity(dragSensitivity){this._dragSensitivity=dragSensitivity||1;}/**
     * Gets the factor that governs how fast a SectionPlane moves as we drag on the control element.
     *
     * @return {Number} The dragging sensitivity factor.
     */},{key:"getDragSensitivity",value:function getDragSensitivity(){return this._dragSensitivity;}/**
     * Sets if the overview canvas is visible.
     *
     * @param {Boolean} visible Whether or not the overview canvas is visible.
     */},{key:"setOverviewVisible",value:function setOverviewVisible(visible){if(this._overview){this._overview.setVisible(visible);}}/**
     * Gets if the overview canvas is visible.
     *
     * @return {Boolean} True when the overview canvas is visible.
     */},{key:"getOverviewVisible",value:function getOverviewVisible(){if(this._overview){return this._overview.getVisible();}}/**
     * Returns a map of the {@link SectionPlane}s created by this FaceAlignedSectionPlanesPlugin.
     *
     * @returns {{String:SectionPlane}} A map containing the {@link SectionPlane}s, each mapped to its {@link SectionPlane#id}.
     */},{key:"sectionPlanes",get:function get(){return this._sectionPlanes;}/**
     * Creates a {@link SectionPlane}.
     *
     * The {@link SectionPlane} will be registered by {@link SectionPlane#id} in {@link FaceAlignedSectionPlanesPlugin#sectionPlanes}.
     *
     * @param {Object} params {@link SectionPlane} configuration.
     * @param {String} [params.id] Unique ID to assign to the {@link SectionPlane}. Must be unique among all components in the {@link Viewer}'s {@link Scene}. Auto-generated when omitted.
     * @param {Number[]} [params.pos=[0,0,0]] World-space position of the {@link SectionPlane}.
     * @param {Number[]} [params.dir=[0,0,-1]] World-space vector indicating the orientation of the {@link SectionPlane}.
     * @param {Boolean} [params.active=true] Whether the {@link SectionPlane} is initially active. Only clips while this is true.
     * @returns {SectionPlane} The new {@link SectionPlane}.
     */},{key:"createSectionPlane",value:function createSectionPlane(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id!==undefined&&params.id!==null&&this.viewer.scene.components[params.id]){this.error("Viewer component with this ID already exists: "+params.id);delete params.id;}// Note that SectionPlane constructor fires "sectionPlaneCreated" on the Scene,
// which FaceAlignedSectionPlanesPlugin handles and calls #_sectionPlaneCreated to create gizmo and add to overview canvas.
var sectionPlane=new SectionPlane(this.viewer.scene,{id:params.id,pos:params.pos,dir:params.dir,active:true});return sectionPlane;}},{key:"_sectionPlaneCreated",value:function _sectionPlaneCreated(sectionPlane){var _this140=this;var control=this._freeControls.length>0?this._freeControls.pop():new FaceAlignedSectionPlanesControl(this);control._setSectionPlane(sectionPlane);control.setVisible(false);this._controls[sectionPlane.id]=control;if(this._overview){this._overview.addSectionPlane(sectionPlane);}sectionPlane.once("destroyed",function(){_this140._sectionPlaneDestroyed(sectionPlane);});}/**
     * Inverts the direction of {@link SectionPlane#dir} on every existing SectionPlane.
     *
     * Inverts all SectionPlanes, including those that were not created with FaceAlignedSectionPlanesPlugin.
     */},{key:"flipSectionPlanes",value:function flipSectionPlanes(){var sectionPlanes=this.viewer.scene.sectionPlanes;for(var id in sectionPlanes){var sectionPlane=sectionPlanes[id];sectionPlane.flipDir();}}/**
     * Shows the 3D editing gizmo for a {@link SectionPlane}.
     *
     * @param {String} id ID of the {@link SectionPlane}.
     */},{key:"showControl",value:function showControl(id){var control=this._controls[id];if(!control){this.error("Control not found: "+id);return;}this.hideControl();control.setVisible(true);if(this._overview){this._overview.setPlaneSelected(id,true);}this._shownControlId=id;}/**
     * Gets the ID of the {@link SectionPlane} that the 3D editing gizmo is shown for.
     *
     * Returns ````null```` when the editing gizmo is not shown.
     *
     * @returns {String} ID of the the {@link SectionPlane} that the 3D editing gizmo is shown for, if shown, else ````null````.
     */},{key:"getShownControl",value:function getShownControl(){return this._shownControlId;}/**
     * Hides the 3D {@link SectionPlane} editing gizmo if shown.
     */},{key:"hideControl",value:function hideControl(){for(var id in this._controls){if(this._controls.hasOwnProperty(id)){this._controls[id].setVisible(false);if(this._overview){this._overview.setPlaneSelected(id,false);}}}this._shownControlId=null;}/**
     * Destroys a {@link SectionPlane} created by this FaceAlignedSectionPlanesPlugin.
     *
     * @param {String} id ID of the {@link SectionPlane}.
     */},{key:"destroySectionPlane",value:function destroySectionPlane(id){var sectionPlane=this.viewer.scene.sectionPlanes[id];if(!sectionPlane){this.error("SectionPlane not found: "+id);return;}this._sectionPlaneDestroyed(sectionPlane);sectionPlane.destroy();if(id===this._shownControlId){this._shownControlId=null;}}},{key:"_sectionPlaneDestroyed",value:function _sectionPlaneDestroyed(sectionPlane){if(this._overview){this._overview.removeSectionPlane(sectionPlane);}var control=this._controls[sectionPlane.id];if(!control){return;}control.setVisible(false);control._setSectionPlane(null);delete this._controls[sectionPlane.id];this._freeControls.push(control);}/**
     * Destroys all {@link SectionPlane}s created by this FaceAlignedSectionPlanesPlugin.
     */},{key:"clear",value:function clear(){var ids=Object.keys(this._sectionPlanes);for(var _i524=0,len=ids.length;_i524<len;_i524++){this.destroySectionPlane(ids[_i524]);}}/**
     * @private
     */},{key:"send",value:function send(name,value){switch(name){case"snapshotStarting":// Viewer#getSnapshot() about to take snapshot - hide controls
for(var id in this._controls){if(this._controls.hasOwnProperty(id)){this._controls[id].setCulled(true);}}break;case"snapshotFinished":// Viewer#getSnapshot() finished taking snapshot - show controls again
for(var _id5 in this._controls){if(this._controls.hasOwnProperty(_id5)){this._controls[_id5].setCulled(false);}}break;case"clearSectionPlanes":this.clear();break;}}/**
     * Destroys this FaceAlignedSectionPlanesPlugin.
     *
     * Also destroys each {@link SectionPlane} created by this FaceAlignedSectionPlanesPlugin.
     *
     * Does not destroy the canvas the FaceAlignedSectionPlanesPlugin was configured with.
     */},{key:"destroy",value:function destroy(){this.clear();if(this._overview){this._overview.destroy();}this._destroyFreeControls();_get(_getPrototypeOf(FaceAlignedSectionPlanesPlugin.prototype),"destroy",this).call(this);}},{key:"_destroyFreeControls",value:function _destroyFreeControls(){var control=this._freeControls.pop();while(control){control._destroy();control=this._freeControls.pop();}this.viewer.scene.off(this._onSceneSectionPlaneCreated);}}]);return FaceAlignedSectionPlanesPlugin;}(Plugin);/**
 * {@link Viewer} plugin that manages skyboxes
 *
 * @example
 *
 * // Create a Viewer
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Add a GLTFModelsPlugin
 * var gltfLoaderPlugin = new GLTFModelsPlugin(viewer, {
 *     id: "GLTFModels"  // Default value
 * });
 *
 * // Add a SkyboxesPlugin
 * var skyboxesPlugin = new SkyboxesPlugin(viewer, {
 *     id: "Skyboxes" // Default value
 * });
 *
 * // Load a glTF model
 * const model = gltfLoaderPlugin.load({
 *     id: "myModel",
 *     src: "./models/gltf/mygltfmodel.gltf"
 * });
 *
 * // Create three directional World-space lights. "World" means that they will appear as if part
 * // of the world, instead of "View", where they move with the user's head.
 *
 * skyboxesPlugin.createLight({
 *     id: "keyLight",
 *     dir: [0.8, -0.6, -0.8],
 *     color: [1.0, 0.3, 0.3],
 *     intensity: 1.0,
 *     space: "world"
 * });
 *
 * skyboxesPlugin.createLight({
 *     id: "fillLight",
 *     dir: [-0.8, -0.4, -0.4],
 *     color: [0.3, 1.0, 0.3],
 *     intensity: 1.0,
 *     space: "world"
 * });
 *
 * skyboxesPlugin.createDirLight({
 *     id: "rimLight",
 *     dir: [0.2, -0.8, 0.8],
 *     color: [0.6, 0.6, 0.6],
 *     intensity: 1.0,
 *     space: "world"
 * });
 *
 * @class SkyboxesPlugin
 */var SkyboxesPlugin=/*#__PURE__*/function(_Plugin13){_inherits(SkyboxesPlugin,_Plugin13);var _super154=_createSuper(SkyboxesPlugin);function SkyboxesPlugin(viewer){var _this141;_classCallCheck(this,SkyboxesPlugin);_this141=_super154.call(this,"skyboxes",viewer);_this141.skyboxes={};return _this141;}/**
     * @private
     */_createClass(SkyboxesPlugin,[{key:"send",value:function send(name,value){switch(name){case"clear":this.clear();break;}}/**
     Creates a skybox.

     @param {String} id Unique ID to assign to the skybox.
     @param {Object} params Skybox configuration.
     @param {Boolean} [params.active=true] Whether the skybox plane is initially active. Only skyboxes while this is true.
     @returns {Skybox} The new skybox.
     */},{key:"createSkybox",value:function createSkybox(id,params){if(this.viewer.scene.components[id]){this.error("Component with this ID already exists: "+id);return this;}var skybox=new Skybox(this.viewer.scene,{id:id,pos:params.pos,dir:params.dir,active:true});this.skyboxes[id]=skybox;return skybox;}/**
     Destroys a skybox.
     @param id
     */},{key:"destroySkybox",value:function destroySkybox(id){var skybox=this.skyboxes[id];if(!skybox){this.error("Skybox not found: "+id);return;}skybox.destroy();}/**
     Destroys all skyboxes.
     */},{key:"clear",value:function clear(){var ids=Object.keys(this.viewer.scene.skyboxes);for(var i=0,len=ids.length;i<len;i++){this.destroySkybox(ids[i]);}}/**
     * Destroys this plugin.
     *
     * Clears skyboxes from the Viewer first.
     */},{key:"destroy",value:function destroy(){this.clear();_get(_getPrototypeOf(SkyboxesPlugin.prototype),"clear",this).call(this);}}]);return SkyboxesPlugin;}(Plugin);/**
 * Default data access strategy for {@link STLLoaderPlugin}.
 *
 * This implementation simply loads STL files using XMLHttpRequest.
 */var STLDefaultDataSource=/*#__PURE__*/function(){function STLDefaultDataSource(){_classCallCheck(this,STLDefaultDataSource);}_createClass(STLDefaultDataSource,[{key:"getSTL",value:/**
     * Gets STL data.
     *
     * @param {String|Number} src Identifies the STL file.
     * @param {Function} ok Fired on successful loading of the STL file.
     * @param {Function} error Fired on error while loading the STL file.
     */function getSTL(src,ok,error){var request=new XMLHttpRequest();request.overrideMimeType("application/json");request.open('GET',src,true);request.responseType='arraybuffer';request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){ok(request.response);}else{error(request.statusText);}}};request.send(null);}}]);return STLDefaultDataSource;}();var tempVec3a$1=math.vec3();/**
 * @private
 */var STLSceneGraphLoader=/*#__PURE__*/function(){function STLSceneGraphLoader(){_classCallCheck(this,STLSceneGraphLoader);}_createClass(STLSceneGraphLoader,[{key:"load",value:function load(plugin,modelNode,src,options,ok,error){options=options||{};var spinner=plugin.viewer.scene.canvas.spinner;spinner.processes++;plugin.dataSource.getSTL(src,function(data){// OK
parse(plugin,modelNode,data,options);try{var binData=ensureBinary(data);if(isBinary(binData)){parseBinary(plugin,binData,modelNode,options);}else{parseASCII(plugin,ensureString(data),modelNode,options);}spinner.processes--;core.scheduleTask(function(){modelNode.fire("loaded",true,false);});if(ok){ok();}}catch(e){spinner.processes--;plugin.error(e);if(error){error(e);}modelNode.fire("error",e);}},function(msg){spinner.processes--;plugin.error(msg);if(error){error(msg);}modelNode.fire("error",msg);});}},{key:"parse",value:function parse(plugin,modelNode,data,options){var spinner=plugin.viewer.scene.canvas.spinner;spinner.processes++;try{var binData=ensureBinary(data);if(isBinary(binData)){parseBinary(plugin,binData,modelNode,options);}else{parseASCII(plugin,ensureString(data),modelNode,options);}spinner.processes--;core.scheduleTask(function(){modelNode.fire("loaded",true,false);});}catch(e){spinner.processes--;modelNode.fire("error",e);}}}]);return STLSceneGraphLoader;}();function parse(plugin,modelNode,data,options){try{var binData=ensureBinary(data);if(isBinary(binData)){parseBinary(plugin,binData,modelNode,options);}else{parseASCII(plugin,ensureString(data),modelNode,options);}}catch(e){modelNode.fire("error",e);}}function isBinary(data){var reader=new DataView(data);var numFaces=reader.getUint32(80,true);var faceSize=32/8*3+32/8*3*3+16/8;var numExpectedBytes=80+32/8+numFaces*faceSize;if(numExpectedBytes===reader.byteLength){return true;}var solid=[115,111,108,105,100];for(var i=0;i<5;i++){if(solid[i]!==reader.getUint8(i,false)){return true;}}return false;}function parseBinary(plugin,data,modelNode,options){var reader=new DataView(data);var faces=reader.getUint32(80,true);var r;var g;var b;var hasColors=false;var colors;var defaultR;var defaultG;var defaultB;var lastR=null;var lastG=null;var lastB=null;var newMesh=false;for(var index=0;index<80-10;index++){if(reader.getUint32(index,false)===0x434F4C4F/*COLO*/&&reader.getUint8(index+4)===0x52/*'R'*/&&reader.getUint8(index+5)===0x3D/*'='*/){hasColors=true;colors=[];defaultR=reader.getUint8(index+6)/255;defaultG=reader.getUint8(index+7)/255;defaultB=reader.getUint8(index+8)/255;reader.getUint8(index+9)/255;}}var material=new MetallicMaterial(modelNode,{// Share material with all meshes
roughness:0.5});// var material = new PhongMaterial(modelNode, { // Share material with all meshes
//     diffuse: [0.4, 0.4, 0.4],
//     reflectivity: 1,
//     specular: [0.5, 0.5, 1.0]
// });
var dataOffset=84;var faceLength=12*4+2;var positions=[];var normals=[];var splitMeshes=options.splitMeshes;for(var face=0;face<faces;face++){var start=dataOffset+face*faceLength;var normalX=reader.getFloat32(start,true);var normalY=reader.getFloat32(start+4,true);var normalZ=reader.getFloat32(start+8,true);if(hasColors){var packedColor=reader.getUint16(start+48,true);if((packedColor&0x8000)===0){r=(packedColor&0x1F)/31;g=(packedColor>>5&0x1F)/31;b=(packedColor>>10&0x1F)/31;}else{r=defaultR;g=defaultG;b=defaultB;}if(splitMeshes&&r!==lastR||g!==lastG||b!==lastB){if(lastR!==null){newMesh=true;}lastR=r;lastG=g;lastB=b;}}for(var _i525=1;_i525<=3;_i525++){var vertexstart=start+_i525*12;positions.push(reader.getFloat32(vertexstart,true));positions.push(reader.getFloat32(vertexstart+4,true));positions.push(reader.getFloat32(vertexstart+8,true));normals.push(normalX,normalY,normalZ);if(hasColors){colors.push(r,g,b,1);// TODO: handle alpha
}}if(splitMeshes&&newMesh){addMesh(modelNode,positions,normals,colors,material,options);positions=[];normals=[];colors=colors?[]:null;newMesh=false;}}if(positions.length>0){addMesh(modelNode,positions,normals,colors,material,options);}}function parseASCII(plugin,data,modelNode,options){var faceRegex=/facet([\s\S]*?)endfacet/g;var faceCounter=0;var floatRegex=/[\s]+([+-]?(?:\d+.\d+|\d+.|\d+|.\d+)(?:[eE][+-]?\d+)?)/.source;var vertexRegex=new RegExp('vertex'+floatRegex+floatRegex+floatRegex,'g');var normalRegex=new RegExp('normal'+floatRegex+floatRegex+floatRegex,'g');var positions=[];var normals=[];var colors=null;var normalx;var normaly;var normalz;var result;var verticesPerFace;var normalsPerFace;var text;while((result=faceRegex.exec(data))!==null){verticesPerFace=0;normalsPerFace=0;text=result[0];while((result=normalRegex.exec(text))!==null){normalx=parseFloat(result[1]);normaly=parseFloat(result[2]);normalz=parseFloat(result[3]);normalsPerFace++;}while((result=vertexRegex.exec(text))!==null){positions.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3]));normals.push(normalx,normaly,normalz);verticesPerFace++;}if(normalsPerFace!==1){plugin.error("Error in normal of face "+faceCounter);}if(verticesPerFace!==3){plugin.error("Error in positions of face "+faceCounter);}faceCounter++;}var material=new MetallicMaterial(modelNode,{roughness:0.5});// var material = new PhongMaterial(modelNode, {
//     diffuse: [0.4, 0.4, 0.4],
//     reflectivity: 1,
//     specular: [0.5, 0.5, 1.0]
// });
addMesh(modelNode,positions,normals,colors,material,options);}function addMesh(modelNode,positions,normals,colors,material,options){var indices=new Int32Array(positions.length/3);for(var ni=0,len=indices.length;ni<len;ni++){indices[ni]=ni;}normals=normals&&normals.length>0?normals:null;colors=colors&&colors.length>0?colors:null;if(options.smoothNormals){math.faceToVertexNormals(positions,normals,options);}var origin=tempVec3a$1;worldToRTCPositions(positions,positions,origin);var geometry=new ReadableGeometry(modelNode,{primitive:"triangles",positions:positions,normals:normals,colors:colors,indices:indices});var mesh=new Mesh(modelNode,{origin:origin[0]!==0||origin[1]!==0||origin[2]!==0?origin:null,geometry:geometry,material:material,edges:options.edges});modelNode.addChild(mesh);}function ensureString(buffer){if(typeof buffer!=='string'){return decodeText(new Uint8Array(buffer));}return buffer;}function ensureBinary(buffer){if(typeof buffer==='string'){var arrayBuffer=new Uint8Array(buffer.length);for(var _i526=0;_i526<buffer.length;_i526++){arrayBuffer[_i526]=buffer.charCodeAt(_i526)&0xff;// implicitly assumes little-endian
}return arrayBuffer.buffer||arrayBuffer;}else{return buffer;}}function decodeText(array){if(typeof TextDecoder!=='undefined'){return new TextDecoder().decode(array);}var s='';for(var _i527=0,il=array.length;_i527<il;_i527++){s+=String.fromCharCode(array[_i527]);// Implicitly assumes little-endian.
}return decodeURIComponent(escape(s));}/**
 * {@link Viewer} plugin that loads models from <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files.
 *
 * ## Overview
 *
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 * * Supports both binary and ASCII formats.
 * * Supports double-precision vertex positions.
 * * Supports custom data source configuration.
 *
 * ## Smoothing STL Normals
 *
 * STL models are normally flat-shaded, however providing a ````smoothNormals```` parameter when loading gives a smooth
 * appearance. Triangles in STL are disjoint, where each triangle has its own separate vertex positions, normals and
 * (optionally) colors. This means that you can have gaps between triangles in an STL model. Normals for each triangle
 * are perpendicular to the triangle's surface, which gives the model a faceted appearance by default.
 *
 * The ```smoothNormals``` parameter causes the plugin to recalculate the STL normals, so that each normal's direction is
 * the average of the orientations of the triangles adjacent to its vertex. When smoothing, each vertex normal is set to
 * the average of the orientations of all other triangles that have a vertex at the same position, excluding those triangles
 * whose direction deviates from the direction of the vertice's triangle by a threshold given in
 * the ````smoothNormalsAngleThreshold```` loading parameter. This makes smoothing robust for hard edges.
 *
 * ## Creating Entities for Objects
 *
 * An STL model is normally a single mesh, however providing a ````splitMeshes```` parameter when loading
 * will create a separate object {@link Entity} for each group of faces that share the same vertex colors. This option
 * only works with binary STL files.
 *
 * See the {@link STLLoaderPlugin#load} method for more info on loading options.
 *
 * ## Usage
 *
 * In the example below, we'll use an STLLoaderPlugin to load an STL model of a spur gear. When the model has loaded,
 * we'll use the {@link CameraFlightAnimation} to fly the {@link Camera} to look at boundary of the model. We'll
 * then get the model's {@link Entity} from the {@link Scene} and highlight the whole model.
 *
 *  * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_STL_SpurGear)]
 *
 * ````javascript
 * // Create a xeokit Viewer
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * // Add an STLLoaderPlugin to the Viewer
 * var plugin = new STLLoaderPlugin(viewer);
 *
 * // Load the STL model
 * var model = plugin.load({ // Model is an Entity
 *      id: "myModel",
 *      src: "./models/stl/binary/spurGear.stl",
 *      scale: [0.1, 0.1, 0.1],
 *      rotate: [90, 0, 0],
 *      translate: [100,0,0],
 *      edges: true,
 *      smoothNormals: true,                // Default
 *      smoothNormalsAngleThreshold: 20,    // Default
 *      splitMeshes: true                   // Default
 * });
 *
 * // When the model has loaded, fit it to view
 * model.on("loaded", function() { // Model is an Entity
 *      viewer.cameraFlight.flyTo(model);
 * });
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Update properties of the model Entity
 * model.highlight = [1,0,0];
 *
 * // Destroy the model Entity
 * model.destroy();
 * ````
 *
 * ## Loading from a Pre-Loaded STL File
 *
 * If we already have our STL file in memory (perhaps pre-loaded, or even generated in-client), then we can just pass that
 * file data straight into the {@link STLLoaderPlugin#load} method. In the example below, to show how it's done, we'll pre-load
 * our STL file data, then pass it straight into that method.
 *
 *  * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_STL_dataAsParam)]
 *
 * ````javascript
 * loadSTL("./models/stl/binary/spurGear.stl", (stlData) =>{
 *
 *      const model = stlLoader.load({
 *          id: "myModel",
 *          stl: stlData,
 *          smoothNormals: true
 *      });
 *
 *      model.on("loaded", () => {
 *          viewer.cameraFlight.jumpTo(model);
 *          viewer.scene.on("tick", () => {
 *              viewer.camera.orbitYaw(0.4);
 *          })
 *      });
 *  })
 *
 * function loadSTL(src, ok, error) {
 *     const request = new XMLHttpRequest();
 *     request.overrideMimeType("application/json");
 *     request.open('GET', src, true);
 *     request.responseType = 'arraybuffer';
 *     request.onreadystatechange = function () {
 *         if (request.readyState === 4) {
 *             if (request.status === 200) {
 *                 ok(request.response);
 *             } else if (error) {
 *                     error(request.statusText);
 *             }
 *         }
 *     };
 *     request.send(null);
 * }
 *````
 *
 * ## Configuring a Custom Data Source
 *
 * In the example below, we'll create the STLLoaderPlugin again, this time configuring it with a
 * custom data source object, through which it can load STL files. For this example, our data source just loads
 * them via HTTP, for simplicity. Once we've created the STLLoaderPlugin, we'll load our STL file as before.
 *
 *  * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_STL_dataSource)]
 *
 * ````javascript
 * // Our custom STL data access strategy - implementation happens to be the same as STLDefaultDataSource
 *
 * class MyDataSource {
 *      getSTL(src, ok, error) {
 *          const request = new XMLHttpRequest();
 *          request.overrideMimeType("application/json");
 *          request.open('GET', src, true);
 *          request.responseType = 'arraybuffer';
 *          request.onreadystatechange = function () {
 *              if (request.readyState === 4) {
 *                  if (request.status === 200) {
 *                      ok(request.response);
 *                  } else {
 *                      error(request.statusText);
 *                  }
 *              }
 *          };
 *          request.send(null);
 *      }
 *  }
 *
 * const stlLoader = new STLLoaderPlugin(viewer, {
 *      dataSource: new MyDataSource()
 *  });
 *
 * // Load the STL model as before
 * var model = plugin.load({
 *      id: "myModel",
 *      src: "./models/stl/binary/spurGear.stl",
 *      scale: [0.1, 0.1, 0.1],
 *      rotate: [90, 0, 0],
 *      translate: [100,0,0],
 *      edges: true,
 *      smoothNormals: true,                // Default
 *      smoothNormalsAngleThreshold: 20,    // Default
 *      splitMeshes: true                   // Default
 * });
 *
 * //...
 *````
 *
 * @class STLLoaderPlugin
 */var STLLoaderPlugin=/*#__PURE__*/function(_Plugin14){_inherits(STLLoaderPlugin,_Plugin14);var _super155=_createSuper(STLLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} [cfg]  Plugin configuration.
     * @param {String} [cfg.id="STLLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Object} [cfg.dataSource] A custom data source through which the STLLoaderPlugin can load STL files. Defaults to an instance of {@link STLDefaultDataSource}, which loads over HTTP.
     */function STLLoaderPlugin(viewer){var _this142;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,STLLoaderPlugin);_this142=_super155.call(this,"STLLoader",viewer,cfg);/**
         * @private
         */_this142._sceneGraphLoader=new STLSceneGraphLoader();_this142.dataSource=cfg.dataSource;return _this142;}/**
     * Sets a custom data source through which the STLLoaderPlugin can load STL files.
     *
     * Default value is {@link STLDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */_createClass(STLLoaderPlugin,[{key:"dataSource",get:/**
     * Gets the custom data source through which the STLLoaderPlugin can load STL files.
     *
     * Default value is {@link STLDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */function get(){return this._dataSource;}/**
     * Loads an STL model from a file into this STLLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} params.id ID to assign to the model's root {@link Entity}, unique among all components in the Viewer's {@link Scene}.
     * @param {String} [params.src] Path to an STL file. Overrides the ````stl```` parameter.
     * @param {String} [params.stl] Contents of an STL file, either binary of ASCII. Overridden by the ````src```` parameter.
     * @param {Boolean} [params.edges=false] Whether or not to renders the model with edges emphasized.
     * @param {Number[]} [params.origin=[0,0,0]] The model's World-space double-precision 3D origin. Use this to position the model within xeokit's World coordinate system, using double-precision coordinates.
     * @param {Number[]} [params.position=[0,0,0]] The model single-precision 3D position, relative to the ````origin```` parameter.
     * @param {Number[]} [params.scale=[1,1,1]] The model's scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's orientation, given as Euler angles in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters. Relative to ````origin````.
     * @param {Boolean} [params.backfaces=false] When true, allows visible backfaces, wherever specified in the STL.  When false, ignores backfaces.
     * @param {Boolean} [params.smoothNormals=true] When true, automatically converts face-oriented normals to vertex normals for a smooth appearance.
     * @param {Number} [params.smoothNormalsAngleThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Number} [params.edgeThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Boolean} [params.splitMeshes=true] When true, creates a separate {@link Mesh} for each group of faces that share the same vertex colors. Only works with binary STL.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */,set:function set(value){this._dataSource=value||new STLDefaultDataSource();}},{key:"load",value:function load(params){if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var modelNode=new Node$2(this.viewer.scene,utils.apply(params,{isModel:true}));var src=params.src;var stl=params.stl;if(!src&&!stl){this.error("load() param expected: either 'src' or 'stl'");return modelNode;}if(src){this._sceneGraphLoader.load(this,modelNode,src,params);}else{this._sceneGraphLoader.parse(this,modelNode,stl,params);}return modelNode;}}]);return STLLoaderPlugin;}(Plugin);/**
 * @desc A {@link TreeViewPlugin} render class.
 * 
 */var RenderService=/*#__PURE__*/function(){function RenderService(){_classCallCheck(this,RenderService);}_createClass(RenderService,[{key:"createRootNode",value:/*
  * Creates the root node of the tree.
  * @return {HTMLElement} The root node of the tree.
  */function createRootNode(){return document.createElement('ul');}/*
  * Creates node of the tree.
  * @param {Object} node The node to create.

  * @return {HTMLElement} The html element for the node.
  */},{key:"createNodeElement",value:function createNodeElement(node,expandHandler,checkHandler,contextmenuHandler,titleClickHandler){var nodeElement=document.createElement('li');nodeElement.id=node.nodeId;if(node.xrayed){nodeElement.classList.add('xrayed-node');}if(node.children.length>0){var switchElement=document.createElement('a');switchElement.href='#';switchElement.id="switch-".concat(node.nodeId);switchElement.textContent='+';switchElement.classList.add('plus');if(expandHandler)switchElement.addEventListener('click',expandHandler);nodeElement.appendChild(switchElement);}var checkbox=document.createElement('input');checkbox.id="checkbox-".concat(node.nodeId);checkbox.type="checkbox";checkbox.checked=node.checked;checkbox.style["pointer-events"]="all";if(checkHandler)checkbox.addEventListener("change",checkHandler);nodeElement.appendChild(checkbox);var span=document.createElement('span');span.textContent=node.title;nodeElement.appendChild(span);if(contextmenuHandler){span.oncontextmenu=contextmenuHandler;}if(titleClickHandler){span.onclick=titleClickHandler;}return nodeElement;}},{key:"createDisabledNodeElement",value:function createDisabledNodeElement(rootName){var li=document.createElement('li');var switchElement=document.createElement('a');switchElement.href='#';switchElement.textContent='!';switchElement.classList.add('warn');switchElement.classList.add('warning');li.appendChild(switchElement);var span=document.createElement('span');span.textContent=rootName;li.appendChild(span);return li;}},{key:"addChildren",value:function addChildren(element,nodes){var ul=document.createElement('ul');nodes.forEach(function(nodeElement){ul.appendChild(nodeElement);});element.parentElement.appendChild(ul);}},{key:"expand",value:function expand(element,expandHandler,collapseHandler){element.classList.remove('plus');element.classList.add('minus');element.textContent='-';element.removeEventListener('click',expandHandler);element.addEventListener('click',collapseHandler);}},{key:"collapse",value:function collapse(element,expandHandler,collapseHandler){if(!element){return;}var parent=element.parentElement;if(!parent){return;}var ul=parent.querySelector('ul');if(!ul){return;}parent.removeChild(ul);element.classList.remove('minus');element.classList.add('plus');element.textContent='+';element.removeEventListener('click',collapseHandler);element.addEventListener('click',expandHandler);}},{key:"isExpanded",value:function isExpanded(element){var parentElement=element.parentElement;return parentElement.getElementsByTagName('li')[0]!==undefined;}},{key:"getId",value:function getId(element){var parentElement=element.parentElement;return parentElement.id;}},{key:"getIdFromCheckbox",value:function getIdFromCheckbox(element){return element.id.replace('checkbox-','');}},{key:"getSwitchElement",value:function getSwitchElement(nodeId){return document.getElementById("switch-".concat(nodeId));}},{key:"isChecked",value:function isChecked(element){return element.checked;}},{key:"setCheckbox",value:function setCheckbox(nodeId,checked){var checkbox=document.getElementById("checkbox-".concat(nodeId));if(checkbox){if(checked!==checkbox.checked){checkbox.checked=checked;}}}},{key:"setXRayed",value:function setXRayed(nodeId,xrayed){var treeNode=document.getElementById(nodeId);if(treeNode){if(xrayed){treeNode.classList.add('xrayed-node');}else{treeNode.classList.remove('xrayed-node');}}}},{key:"setHighlighted",value:function setHighlighted(nodeId,highlighted){var treeNode=document.getElementById(nodeId);if(treeNode){if(highlighted){treeNode.scrollIntoView({block:"center"});treeNode.classList.add('highlighted-node');}else{treeNode.classList.remove('highlighted-node');}}}}]);return RenderService;}();var treeViews=[];/**
 * @desc A {@link Viewer} plugin that provides an HTML tree view to navigate the IFC elements in models.
 * <br>
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_WestRiverSideHospital" style="border: 1px solid black;"><img src="http://xeokit.io/img/docs/TreeViewPlugin/TreeViewPlugin.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_WestRiverSideHospital)]
 *
 * ## Overview
 *
 * * A fast HTML tree view, with zero external dependencies, that works with huge numbers of objects.
 * * Each tree node has a checkbox to control the visibility of its object.
 * * Has three hierarchy modes: "containment", "types" and "storeys".
 * * Automatically contains all models (that have metadata) that are currently in the {@link Scene}.
 * * Sorts tree nodes by default - spatially, from top-to-bottom for ````IfcBuildingStorey```` nodes, and alphanumerically for other nodes.
 * * Allows custom CSS styling.
 * * Use {@link ContextMenu} to create a context menu for the tree nodes.
 *
 * ## Credits
 *
 * TreeViewPlugin is based on techniques described in [*Super Fast Tree View in JavaScript*](https://chrissmith.xyz/super-fast-tree-view-in-javascript/) by [Chris Smith](https://twitter.com/chris22smith).
 *
 * ## Usage
 *
 * In the example below, we'll add a TreeViewPlugin which, by default, will automatically show the structural
 * hierarchy of the IFC elements in each model we load.
 *
 * Then we'll use an {@link XKTLoaderPlugin} to load the Schependomlaan model from an
 * [.xkt file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/models/xkt/schependomlaan).
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_Schependomlaan)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, TreeViewPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const treeView = new TreeViewPlugin(viewer, {
 *     containerElement: document.getElementById("myTreeViewContainer")
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 * ````
 *
 * ## Manually Adding Models
 *
 * Instead of adding models automatically, we can control which models appear in our TreeViewPlugin by adding them manually.
 *
 * In the next example, we'll configure the TreeViewPlugin to not add models automatically. Then, once the model
 * has loaded, we'll add it manually using {@link TreeViewPlugin#addModel}.
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      autoAddModels: false  // <<---------------- Don't auto-add models
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 *
 * model.on("loaded", () => {
 *      treeView.addModel(model.id);
 * });
 * ````
 *
 * Adding models manually also allows us to set some options for the model. For example, the ````rootName```` option allows us to provide a custom name for
 * the root node, which is sometimes desirable when the model's "IfcProject" element's name is not suitable:
 *
 * ````javascript
 * model.on("loaded", () => {
 *      treeView.addModel(model.id, {
 *          rootName: "Schependomlaan Model"
 *      });
 * });
 * ````
 *
 * ## Initially Expanding the Hierarchy
 *
 * We can also configure TreeViewPlugin to initially expand each model's nodes to a given depth.
 *
 * Let's automatically expand the first three nodes from the root, for every model added:
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      autoExpandDepth: 3
 * });
 * ````
 *
 * ## Showing a Node by ID
 *
 * We can show a given node using its ID. This causes the TreeViewPlugin to collapse, then expand and scroll the node into view, then highlight the node.
 *
 * See the documentation for the {@link TreeViewPlugin#showNode} method for more information, including how to define a custom highlighted appearance for the node using CSS.
 *
 * Let's make the TreeViewPlugin show the node corresponding to whatever object {@link Entity} that we pick:
 *
 * ````javascript
 * viewer.cameraControl.on("picked", function (e) {
 *     var objectId = e.entity.id;
 *     treeView.showNode(objectId);
 * });
 * ````
 *
 * This will de-highlight any node that was previously shown by this method.
 *
 * Note that this method only works if the picked {@link Entity} is an object that belongs to a model that's represented in the TreeViewPlugin.
 *
 * ## Customizing Appearance
 *
 * We can customize the appearance of our TreeViewPlugin by defining custom CSS for its HTML
 * elements. See our example's [source code](https://github.com/xeokit/xeokit-sdk/blob/master/examples/BIMOffline_XKT_Schependomlaan.html)
 * for an example of custom CSS rules.
 *
 * ## Model Hierarchies
 *
 * TreeViewPlugin has three hierarchies for organizing its nodes:
 *
 * * "containment" - organizes the tree nodes to indicate the containment hierarchy of the {@link MetaObject}s.
 * * "types" - groups nodes by their IFC types.
 * * "storeys" - groups nodes within their ````IfcBuildingStoreys````, and sub-groups them by their IFC types.
 *
 * <br>
 * The table below shows what the hierarchies look like:
 * <br>
 *
 * | 1. Containment Hierarchy | 2. Types Hierarchy | 3. Storeys Hierarchy |
 * |---|---|---|
 * | <img src="http://xeokit.io/img/docs/TreeViewPlugin/structureMode.png"> | <img src="http://xeokit.io/img/docs/TreeViewPlugin/typesMode.png"> | <img src="http://xeokit.io/img/docs/TreeViewPlugin/storeysMode.png"> |
 * <br>
 *
 * Let's create a TreeViewPlugin that groups nodes by their building stories and IFC types:
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      hierarchy: "stories"
 * });
 * ````
 *
 * ## Sorting Nodes
 *
 * TreeViewPlugin sorts its tree nodes by default. For a "storeys" hierarchy, it orders ````IfcBuildingStorey```` nodes
 * spatially, with the node for the highest story at the top, down to the lowest at the bottom.
 *
 * For all the hierarchy types ("containment", "classes" and "storeys"), TreeViewPlugin sorts the other node types
 * alphanumerically on their titles.
 *
 * If for some reason you need to prevent sorting, create your TreeViewPlugin with the option disabled, like so:
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      hierarchy: "stories",
 *      sortNodes: false // <<------ Disable node sorting
 * });
 * ````
 *
 * Note that, for all hierarchy modes, node sorting is only done for each model at the time that it is added to the TreeViewPlugin, and will not
 * update dynamically if we later transform the {@link Entity}s corresponding to the nodes.
 *
 * ## Pruning empty nodes
 *
 * Sometimes a model contains subtrees of objects that don't have any geometry. These are models whose
 * {@link MetaModel} contains trees of {@link MetaObject}s that don't have any {@link Entity}s in the {@link Scene}.
 *
 * For these models, the tree view would contain nodes that don't do anything in the Scene when we interact with them,
 * which is undesirable.
 *
 * By default, TreeViewPlugin will not create nodes for those objects. However, we can override that behaviour if we want
 * to have nodes for those objects (perhaps for debugging the model):
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      hierarchy: "stories",
 *      pruneEmptyNodes: false // <<------ Create nodes for object subtrees without geometry
 * });
 * ````
 *
 * ## Context Menu
 *
 * TreeViewPlugin fires a "contextmenu" event whenever we right-click on a tree node.
 *
 * The event contains:
 *
 * * ````event```` - the original [contextmenu](https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event) [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)
 * * ````viewer```` - the {@link Viewer}
 * * ````treeViewPlugin```` - the TreeViewPlugin
 * * ````treeViewNode```` - the {@link TreeViewNode} representing the tree node
 *<br><br>
 *
 * Let's use {@link ContextMenu} to show a simple context menu for the node we clicked.
 *
 * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]
 *
 * ````javascript
 * import {ContextMenu} from "../src/extras/ContextMenu/ContextMenu.js";
 *
 * const treeViewContextMenu = new ContextMenu({
 *     items: [
 *         [
 *             [
 *                 {
 *                     title: "Hide",
 *                     doAction: function (context) {
 *                         context.treeViewPlugin.withNodeTree(context.treeViewNode, (treeViewNode) => {
 *                             if (treeViewNode.objectId) {
 *                                 const entity = context.viewer.scene.objects[treeViewNode.objectId];
 *                                 if (entity) {
 *                                     entity.visible = false;
 *                                 }
 *                             }
 *                         });
 *                     }
 *                 },
 *                 {
 *                     title: "Hide all",
 *                     doAction: function (context) {
 *                         context.viewer.scene.setObjectsVisible(context.viewer.scene.visibleObjectIds, false);
 *                     }
 *                 }
 *             ],
 *             [
 *                 {
 *                     title: "Show",
 *                     doAction: function (context) {
 *                         context.treeViewPlugin.withNodeTree(context.treeViewNode, (treeViewNode) => {
 *                             if (treeViewNode.objectId) {
 *                                 const entity = context.viewer.scene.objects[treeViewNode.objectId];
 *                                 if (entity) {
 *                                     entity.visible = true;
 *                                     entity.xrayed = false;
 *                                     entity.selected = false;
 *                                 }
 *                             }
 *                         });
 *                     }
 *                 },
 *                 {
 *                     title: "Show all",
 *                     doAction: function (context) {
 *                         const scene = context.viewer.scene;
 *                         scene.setObjectsVisible(scene.objectIds, true);
 *                         scene.setObjectsXRayed(scene.xrayedObjectIds, false);
 *                         scene.setObjectsSelected(scene.selectedObjectIds, false);
 *                     }
 *                 }
 *             ]
 *         ]
 *     ]
 * });
 *
 * treeView.on("contextmenu", (e) => {
 *
 *     const event = e.event;                           // MouseEvent
 *     const viewer = e.viewer;                         // Viewer
 *     const treeViewPlugin = e.treeViewPlugin;         // TreeViewPlugin
 *     const treeViewNode = e.treeViewNode;             // TreeViewNode
 *
 *     treeViewContextMenu.show(e.event.pageX, e.event.pageY);
 *
 *     treeViewContextMenu.context = {
 *         viewer: e.viewer,
 *         treeViewPlugin: e.treeViewPlugin,
 *         treeViewNode: e.treeViewNode
 *     };
 * });
 * ````
 *
 * ## Clicking Node Titles
 *
 * TreeViewPlugin fires a "nodeTitleClicked" event whenever we left-click on a tree node.
 *
 * Like the "contextmenu" event, this event contains:
 *
 * * ````event```` - the original [click](https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event) [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)
 * * ````viewer```` - the {@link Viewer}
 * * ````treeViewPlugin```` - the TreeViewPlugin
 * * ````treeViewNode```` - the {@link TreeViewNode} representing the tree node
 *<br><br>
 *
 * Let's register a callback to isolate and fit-to-view the {@link Entity}(s) represented by the node. This callback is
 * going to X-ray all the other Entitys, fly the camera to fit the Entity(s) for the clicked node, then hide the other Entitys.
 *
 * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]
 *
 * ````javascript
 * treeView.on("nodeTitleClicked", (e) => {
 *     const scene = viewer.scene;
 *     const objectIds = [];
 *     e.treeViewPlugin.withNodeTree(e.treeViewNode, (treeViewNode) => {
 *         if (treeViewNode.objectId) {
 *             objectIds.push(treeViewNode.objectId);
 *         }
 *     });
 *     scene.setObjectsXRayed(scene.objectIds, true);
 *     scene.setObjectsVisible(scene.objectIds, true);
 *     scene.setObjectsXRayed(objectIds, false);
 *     viewer.cameraFlight.flyTo({
 *         aabb: scene.getAABB(objectIds),
 *         duration: 0.5
 *     }, () => {
 *         setTimeout(function () {
 *             scene.setObjectsVisible(scene.xrayedObjectIds, false);
 *             scene.setObjectsXRayed(scene.xrayedObjectIds, false);
 *         }, 500);
 *     });
 * });
 * ````
 *
 * To make the cursor change to a pointer when we hover over the node titles, and also to make the titles change to blue, we'll also define this CSS for the ````<span>```` elements
 * that represent the titles of our TreeViewPlugin nodes:
 *
 * ````css
 * #treeViewContainer ul li span:hover {
 *      color: blue;
 *      cursor: pointer;
 * }
 * ````
 *
 * @class TreeViewPlugin
 */var TreeViewPlugin=/*#__PURE__*/function(_Plugin15){_inherits(TreeViewPlugin,_Plugin15);var _super156=_createSuper(TreeViewPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {*} cfg Plugin configuration.
     * @param {String} [cfg.containerElementId]  ID of an existing HTML element to contain the TreeViewPlugin - either this or containerElement is mandatory. When both values are given, the element reference is always preferred to the ID.
     * @param {HTMLElement} cfg.containerElement DOM element to contain the TreeViewPlugin.
     * @param {Boolean} [cfg.autoAddModels=true] When ````true```` (default), will automatically add each model as it's created. Set this ````false```` if you want to manually add models using {@link TreeViewPlugin#addModel} instead.
     * @param {Number} [cfg.autoExpandDepth] Optional depth to which to initially expand the tree.
     * @param {String} [cfg.hierarchy="containment"] How to organize the tree nodes: "containment", "storeys" or "types". See the class documentation for details.
     * @param {Boolean} [cfg.sortNodes=true] When true, will sort the children of each node. For a "storeys" hierarchy, the
     * ````IfcBuildingStorey```` nodes will be ordered spatially, from the highest storey down to the lowest, on the
     * vertical World axis. For all hierarchy types, other node types will be ordered in the ascending alphanumeric order of their titles.
     * @param {Boolean} [cfg.pruneEmptyNodes=true] When true, will not contain nodes that don't have content in the {@link Scene}. These are nodes whose {@link MetaObject}s don't have {@link Entity}s.
     * @param {RenderService} [cfg.renderService] Optional {@link RenderService} to use. Defaults to the {@link TreeViewPlugin}'s default {@link RenderService}.
     */function TreeViewPlugin(viewer){var _this143;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,TreeViewPlugin);_this143=_super156.call(this,"TreeViewPlugin",viewer);/**
         * Contains messages for any errors found while last rebuilding this TreeView.
         * @type {String[]}
         */_this143.errors=[];/**
         * True if errors were found generating this TreeView.
         * @type {boolean}
         */_this143.valid=true;var containerElement=cfg.containerElement||document.getElementById(cfg.containerElementId);if(!(containerElement instanceof HTMLElement)){_this143.error("Mandatory config expected: valid containerElementId or containerElement");return _possibleConstructorReturn(_this143);}for(var _i528=0;;_i528++){if(!treeViews[_i528]){treeViews[_i528]=_assertThisInitialized(_this143);_this143._index=_i528;_this143._id="tree-".concat(_i528);break;}}_this143._containerElement=containerElement;_this143._metaModels={};_this143._autoAddModels=cfg.autoAddModels!==false;_this143._autoExpandDepth=cfg.autoExpandDepth||0;_this143._sortNodes=cfg.sortNodes!==false;_this143._viewer=viewer;_this143._rootElement=null;_this143._muteSceneEvents=false;_this143._muteTreeEvents=false;_this143._rootNodes=[];_this143._objectNodes={};// Object ID -> Node
_this143._nodeNodes={};// Node ID -> Node
_this143._rootNames={};// Node ID -> Root name
_this143._sortNodes=cfg.sortNodes;_this143._pruneEmptyNodes=cfg.pruneEmptyNodes;_this143._showListItemElementId=null;_this143._renderService=cfg.renderService||new RenderService();if(!_this143._renderService){throw new Error('TreeViewPlugin: no render service set');}_this143._containerElement.oncontextmenu=function(e){e.preventDefault();};_this143._onObjectVisibility=_this143._viewer.scene.on("objectVisibility",function(entity){if(_this143._muteSceneEvents){return;}var objectId=entity.id;var node=_this143._objectNodes[objectId];if(!node){return;// Not in this tree
}var visible=entity.visible;var updated=visible!==node.checked;if(!updated){return;}_this143._muteTreeEvents=true;node.checked=visible;if(visible){node.numVisibleEntities++;}else{node.numVisibleEntities--;}_this143._renderService.setCheckbox(node.nodeId,visible);var parent=node.parent;while(parent){parent.checked=visible;if(visible){parent.numVisibleEntities++;}else{parent.numVisibleEntities--;}_this143._renderService.setCheckbox(parent.nodeId,parent.numVisibleEntities>0);parent=parent.parent;}_this143._muteTreeEvents=false;});_this143._onObjectXrayed=_this143._viewer.scene.on('objectXRayed',function(entity){if(_this143._muteSceneEvents){return;}var objectId=entity.id;var node=_this143._objectNodes[objectId];if(!node){return;// Not in this tree
}_this143._muteTreeEvents=true;var xrayed=entity.xrayed;var updated=xrayed!==node.xrayed;if(!updated){return;}node.xrayed=xrayed;_this143._renderService.setXRayed(node.nodeId,xrayed);_this143._muteTreeEvents=false;});_this143._switchExpandHandler=function(event){event.preventDefault();event.stopPropagation();var switchElement=event.target;_this143._expandSwitchElement(switchElement);};_this143._switchCollapseHandler=function(event){event.preventDefault();event.stopPropagation();var switchElement=event.target;_this143._collapseSwitchElement(switchElement);};_this143._checkboxChangeHandler=function(event){if(_this143._muteTreeEvents){return;}_this143._muteSceneEvents=true;var checkbox=event.target;var visible=_this143._renderService.isChecked(checkbox);var nodeId=_this143._renderService.getIdFromCheckbox(checkbox);var checkedNode=_this143._nodeNodes[nodeId];var objects=_this143._viewer.scene.objects;var numUpdated=0;_this143._withNodeTree(checkedNode,function(node){var objectId=node.objectId;var entity=objects[objectId];var isLeaf=node.children.length===0;node.numVisibleEntities=visible?node.numEntities:0;if(isLeaf&&visible!==node.checked){numUpdated++;}node.checked=visible;_this143._renderService.setCheckbox(node.nodeId,visible);if(entity){entity.visible=visible;}});var parent=checkedNode.parent;while(parent){parent.checked=visible;if(visible){parent.numVisibleEntities+=numUpdated;}else{parent.numVisibleEntities-=numUpdated;}_this143._renderService.setCheckbox(parent.nodeId,parent.numVisibleEntities>0);parent=parent.parent;}_this143._muteSceneEvents=false;};_this143._hierarchy=cfg.hierarchy||"containment";_this143._autoExpandDepth=cfg.autoExpandDepth||0;if(_this143._autoAddModels){var modelIds=Object.keys(_this143.viewer.metaScene.metaModels);for(var _i529=0,len=modelIds.length;_i529<len;_i529++){var modelId=modelIds[_i529];var metaModel=_this143.viewer.metaScene.metaModels[modelId];if(metaModel.finalized){_this143.addModel(modelId);}}_this143.viewer.scene.on("modelLoaded",function(modelId){if(_this143.viewer.metaScene.metaModels[modelId]){_this143.addModel(modelId);}});}_this143.hierarchy=cfg.hierarchy;return _this143;}/**
     * Sets how the nodes are organized within this tree view.
     *
     * Accepted values are:
     *
     * * "containment" - organizes the nodes to indicate the containment hierarchy of the IFC objects.
     * * "types" - groups the nodes within their IFC types.
     * * "storeys" - groups the nodes within ````IfcBuildingStoreys```` and sub-groups them by their IFC types.
     *
     * <br>
     * This can be updated dynamically.
     *
     * Default value is "containment".
     *
     * @type {String}
     */_createClass(TreeViewPlugin,[{key:"hierarchy",get:/**
     * Gets how the nodes are organized within this tree view.
     *
     * @type {String}
     */function get(){return this._hierarchy;}/**
     * Adds a model to this tree view.
     *
     * The model will be automatically removed when destroyed.
     *
     * To automatically add each model as it's created, instead of manually calling this method each time,
     * provide a ````autoAddModels: true```` to the TreeViewPlugin constructor.
     *
     * @param {String} modelId ID of a model {@link Entity} in {@link Scene#models}.
     * @param {Object} [options] Options for model in the tree view.
     * @param {String} [options.rootName] Optional display name for the root node. Ordinary, for "containment"
     * and "storeys" hierarchy types, the tree would derive the root node name from the model's "IfcProject" element
     * name. This option allows to override that name when it is not suitable as a display name.
     */,set:function set(hierarchy){hierarchy=hierarchy||"containment";if(hierarchy!=="containment"&&hierarchy!=="storeys"&&hierarchy!=="types"){this.error("Unsupported value for `hierarchy' - defaulting to 'containment'");hierarchy="containment";}if(this._hierarchy===hierarchy){return;}this._hierarchy=hierarchy;this._createNodes();}},{key:"addModel",value:function addModel(modelId){var _this144=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!this._containerElement){return;}var model=this.viewer.scene.models[modelId];if(!model){throw"Model not found: "+modelId;}var metaModel=this.viewer.metaScene.metaModels[modelId];if(!metaModel){this.error("MetaModel not found: "+modelId);return;}if(this._metaModels[modelId]){this.warn("Model already added: "+modelId);return;}this._metaModels[modelId]=metaModel;if(options&&options.rootName){this._rootNames[modelId]=options.rootName;}model.on("destroyed",function(){_this144.removeModel(model.id);});this._createNodes();}/**
     * Removes a model from this tree view.
     *
     * Does nothing if model not currently in tree view.
     *
     * @param {String} modelId ID of a model {@link Entity} in {@link Scene#models}.
     */},{key:"removeModel",value:function removeModel(modelId){if(!this._containerElement){return;}var metaModel=this._metaModels[modelId];if(!metaModel){return;}if(this._rootNames[modelId]){delete this._rootNames[modelId];}delete this._metaModels[modelId];this._createNodes();}/**
     * Highlights the tree view node that represents the given object {@link Entity}.
     *
     * This causes the tree view to collapse, then expand to reveal the node, then highlight the node.
     *
     * If a node is previously highlighted, de-highlights that node and collapses the tree first.
     *
     * Note that if the TreeViewPlugin was configured with ````pruneEmptyNodes: true```` (default configuration), then the
     * node won't exist in the tree if it has no Entitys in the {@link Scene}. in that case, nothing will happen.
     *
     * Within the DOM, the node is represented by an ````<li>```` element. This method will add a ````.highlighted-node```` class to
     * the element to make it appear highlighted, removing that class when de-highlighting it again. See the CSS rules
     * in the TreeViewPlugin examples for an example of that class.
     *
     * @param {String} objectId ID of the {@link Entity}.
     */},{key:"showNode",value:function showNode(objectId){this.unShowNode();var node=this._objectNodes[objectId];if(!node){return;// Node may not exist for the given object if (this._pruneEmptyNodes == true)
}var nodeId=node.nodeId;var switchElement=this._renderService.getSwitchElement(nodeId);if(switchElement){this._expandSwitchElement(switchElement);switchElement.scrollIntoView();return true;}var path=[];path.unshift(node);var parent=node.parent;while(parent){path.unshift(parent);parent=parent.parent;}for(var _i530=0,len=path.length;_i530<len;_i530++){var _switchElement=this._renderService.getSwitchElement(path[_i530].nodeId);if(_switchElement){this._expandSwitchElement(_switchElement);}}this._renderService.setHighlighted(nodeId,true);this._showListItemElementId=nodeId;}/**
     * De-highlights the node previously shown with {@link TreeViewPlugin#showNode}.
     *
     * Does nothing if no node is currently shown.
     *
     * If the node is currently scrolled into view, keeps the node in view.
     */},{key:"unShowNode",value:function unShowNode(){if(!this._showListItemElementId){return;}this._renderService.setHighlighted(this._showListItemElementId,false);this._showListItemElementId=null;}/**
     * Expands the tree to the given depth.
     *
     * Collapses the tree first.
     *
     * @param {Number} depth Depth to expand to.
     */},{key:"expandToDepth",value:function expandToDepth(depth){var _this145=this;this.collapse();var expand=function expand(node,countDepth){if(countDepth===depth){return;}var switchElement=_this145._renderService.getSwitchElement(node.nodeId);if(switchElement){_this145._expandSwitchElement(switchElement);var childNodes=node.children;for(var i=0,len=childNodes.length;i<len;i++){var childNode=childNodes[i];expand(childNode,countDepth+1);}}};for(var _i531=0,len=this._rootNodes.length;_i531<len;_i531++){var rootNode=this._rootNodes[_i531];expand(rootNode,0);}}/**
     * Closes all the nodes in the tree.
     */},{key:"collapse",value:function collapse(){for(var _i532=0,len=this._rootNodes.length;_i532<len;_i532++){var rootNode=this._rootNodes[_i532];var objectId=rootNode.objectId;this._collapseNode(objectId);}}/**
     * Iterates over a subtree of the tree view's {@link TreeViewNode}s, calling the given callback for each
     * node in depth-first pre-order.
     *
     * @param {TreeViewNode} node Root of the subtree.
     * @param {Function} callback Callback called at each {@link TreeViewNode}, with the TreeViewNode given as the argument.
     */},{key:"withNodeTree",value:function withNodeTree(node,callback){callback(node);var children=node.children;if(!children){return;}for(var _i533=0,len=children.length;_i533<len;_i533++){this.withNodeTree(children[_i533],callback);}}/**
     * Destroys this TreeViewPlugin.
     */},{key:"destroy",value:function destroy(){if(!this._containerElement){return;}this._metaModels={};if(this._rootElement&&!this._destroyed){this._rootElement.parentNode.removeChild(this._rootElement);this._viewer.scene.off(this._onObjectVisibility);this._destroyed=true;}delete treeViews[this._index];_get(_getPrototypeOf(TreeViewPlugin.prototype),"destroy",this).call(this);}},{key:"_createNodes",value:function _createNodes(){if(this._rootElement){this._rootElement.parentNode.removeChild(this._rootElement);this._rootElement=null;}this._rootNodes=[];this._objectNodes={};this._nodeNodes={};this._validate();if(this.valid||this._hierarchy!=="storeys"){this._createEnabledNodes();}else{this._createDisabledNodes();}}},{key:"_validate",value:function _validate(){this.errors=[];switch(this._hierarchy){case"storeys":this.valid=this._validateMetaModelForStoreysHierarchy();break;case"types":this.valid=this._rootNodes.length>0;break;case"containment":default:this.valid=this._rootNodes.length>0;break;}return this.valid;}},{key:"_validateMetaModelForStoreysHierarchy",value:function _validateMetaModelForStoreysHierarchy(){var level=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var ctx=arguments.length>1?arguments[1]:undefined;var buildingNode=arguments.length>2?arguments[2]:undefined;// ctx = ctx || {
//     foundIFCBuildingStoreys: false
// };
// const metaObjectType = metaObject.type;
// const children = metaObject.children;
// if (metaObjectType === "IfcBuilding") {
//     buildingNode = true;
// } else if (metaObjectType === "IfcBuildingStorey") {
//     if (!buildingNode) {
//         errors.push("Can't build storeys hierarchy: IfcBuildingStorey found without parent IfcBuilding");
//         return false;
//     }
//     ctx.foundIFCBuildingStoreys = true;
// }
// if (children) {
//     for (let i = 0, len = children.length; i < len; i++) {
//         const childMetaObject = children[i];
//         if (!this._validateMetaModelForStoreysHierarchy(childMetaObject, errors, level + 1, ctx, buildingNode)) {
//             return false;
//         }
//     }
// }
// if (level === 0) {
//     if (!ctx.foundIFCBuildingStoreys) {
//         // errors.push("Can't build storeys hierarchy: no IfcBuildingStoreys found");
//     }
// }
return true;}},{key:"_createEnabledNodes",value:function _createEnabledNodes(){if(this._pruneEmptyNodes){this._findEmptyNodes();}switch(this._hierarchy){case"storeys":this._createStoreysNodes();if(this._rootNodes.length===0){this.error("Failed to build storeys hierarchy");}break;case"types":this._createTypesNodes();break;case"containment":default:this._createContainmentNodes();}if(this._sortNodes){this._doSortNodes();}this._synchNodesToEntities();this._createTrees();this.expandToDepth(this._autoExpandDepth);}},{key:"_createDisabledNodes",value:function _createDisabledNodes(){var rootNode=this._renderService.createRootNode();this._rootElement=rootNode;this._containerElement.appendChild(rootNode);var rootMetaObjects=this._viewer.metaScene.rootMetaObjects;for(var objectId in rootMetaObjects){var rootMetaObject=rootMetaObjects[objectId];var metaObjectType=rootMetaObject.type;var metaObjectName=rootMetaObject.name;var rootName=metaObjectName&&metaObjectName!==""&&metaObjectName!=="Undefined"&&metaObjectName!=="Default"?metaObjectName:metaObjectType;var childNode=this._renderService.createDisabledNodeElement(rootName);rootNode.appendChild(childNode);}}},{key:"_findEmptyNodes",value:function _findEmptyNodes(){var rootMetaObjects=this._viewer.metaScene.rootMetaObjects;for(var objectId in rootMetaObjects){this._findEmptyNodes2(rootMetaObjects[objectId]);}}},{key:"_findEmptyNodes2",value:function _findEmptyNodes2(metaObject){var countEntities=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var viewer=this.viewer;var scene=viewer.scene;var children=metaObject.children;var objectId=metaObject.id;var entity=scene.objects[objectId];metaObject._countEntities=0;if(entity){metaObject._countEntities++;}if(children){for(var _i534=0,len=children.length;_i534<len;_i534++){var childMetaObject=children[_i534];childMetaObject._countEntities=this._findEmptyNodes2(childMetaObject);metaObject._countEntities+=childMetaObject._countEntities;}}return metaObject._countEntities;}},{key:"_createStoreysNodes",value:function _createStoreysNodes(){var rootMetaObjects=this._viewer.metaScene.rootMetaObjects;for(var id in rootMetaObjects){this._createStoreysNodes2(rootMetaObjects[id],null,null,null);}}},{key:"_createStoreysNodes2",value:function _createStoreysNodes2(metaObject,buildingNode,storeyNode,typeNodes){if(this._pruneEmptyNodes&&metaObject._countEntities===0){return;}var metaObjectType=metaObject.type;var metaObjectName=metaObject.name;var children=metaObject.children;var objectId=metaObject.id;if(metaObjectType==="IfcBuilding"){buildingNode={nodeId:"".concat(this._id,"-").concat(objectId),objectId:objectId,title:metaObject.metaModels.length===0?"na":this._rootNames[metaObject.metaModels[0].id]||(metaObjectName&&metaObjectName!==""&&metaObjectName!=="Undefined"&&metaObjectName!=="Default"?metaObjectName:metaObjectType),type:metaObjectType,parent:null,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};this._rootNodes.push(buildingNode);this._objectNodes[buildingNode.objectId]=buildingNode;this._nodeNodes[buildingNode.nodeId]=buildingNode;}else if(metaObjectType==="IfcBuildingStorey"){if(!buildingNode){this.error("Failed to build storeys hierarchy for model '"+this.metaModel.id+"' - model does not have an IfcBuilding object, or is not an IFC model");return;}storeyNode={nodeId:"".concat(this._id,"-").concat(objectId),objectId:objectId,title:metaObjectName&&metaObjectName!==""&&metaObjectName!=="Undefined"&&metaObjectName!=="Default"?metaObjectName:metaObjectType,type:metaObjectType,parent:buildingNode,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};buildingNode.children.push(storeyNode);this._objectNodes[storeyNode.objectId]=storeyNode;this._nodeNodes[storeyNode.nodeId]=storeyNode;typeNodes={};}else{if(storeyNode){var objects=this._viewer.scene.objects;var object=objects[objectId];if(object){typeNodes=typeNodes||{};var typeNode=typeNodes[metaObjectType];if(!typeNode){typeNode={nodeId:"".concat(this._id,"-").concat(storeyNode.objectId,"-").concat(metaObjectType),objectId:"".concat(storeyNode.objectId,"-").concat(metaObjectType),title:metaObjectType,type:metaObjectType,parent:storeyNode,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};storeyNode.children.push(typeNode);this._objectNodes[typeNode.objectId]=typeNode;this._nodeNodes[typeNode.nodeId]=typeNode;typeNodes[metaObjectType]=typeNode;}var _node8={nodeId:"".concat(this._id,"-").concat(objectId),objectId:objectId,title:metaObjectName&&metaObjectName!==""&&metaObjectName!=="Undefined"&&metaObjectName!=="Default"?metaObjectName:metaObjectType,type:metaObjectType,parent:typeNode,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};typeNode.children.push(_node8);this._objectNodes[_node8.objectId]=_node8;this._nodeNodes[_node8.nodeId]=_node8;}}}if(children){for(var _i535=0,len=children.length;_i535<len;_i535++){var childMetaObject=children[_i535];this._createStoreysNodes2(childMetaObject,buildingNode,storeyNode,typeNodes);}}}},{key:"_createTypesNodes",value:function _createTypesNodes(){var rootMetaObjects=this._viewer.metaScene.rootMetaObjects;for(var id in rootMetaObjects){this._createTypesNodes2(rootMetaObjects[id],null,null);}}},{key:"_createTypesNodes2",value:function _createTypesNodes2(metaObject,rootNode,typeNodes){if(this._pruneEmptyNodes&&metaObject._countEntities===0){return;}var metaObjectType=metaObject.type;var metaObjectName=metaObject.name;var children=metaObject.children;var objectId=metaObject.id;if(!metaObject.parent){rootNode={nodeId:"".concat(this._id,"-").concat(objectId),objectId:objectId,title:metaObject.metaModels.length===0?"na":this._rootNames[metaObject.metaModels[0].id]||(metaObjectName&&metaObjectName!==""&&metaObjectName!=="Undefined"&&metaObjectName!=="Default"?metaObjectName:metaObjectType),type:metaObjectType,parent:null,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};this._rootNodes.push(rootNode);this._objectNodes[rootNode.objectId]=rootNode;this._nodeNodes[rootNode.nodeId]=rootNode;typeNodes={};}else{if(rootNode){var objects=this._viewer.scene.objects;var object=objects[objectId];if(object){var typeNode=typeNodes[metaObjectType];if(!typeNode){typeNode={nodeId:"".concat(this._id,"-").concat(rootNode.objectId,"-").concat(metaObjectType),objectId:"".concat(rootNode.objectId,"-").concat(metaObjectType),title:metaObjectType,type:metaObjectType,parent:rootNode,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};rootNode.children.push(typeNode);this._objectNodes[typeNode.objectId]=typeNode;this._nodeNodes[typeNode.nodeId]=typeNode;typeNodes[metaObjectType]=typeNode;}var _node9={nodeId:"".concat(this._id,"-").concat(objectId),objectId:objectId,title:metaObjectName&&metaObjectName!==""&&metaObjectName!=="Default"?metaObjectName:metaObjectType,type:metaObjectType,parent:typeNode,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};typeNode.children.push(_node9);this._objectNodes[_node9.objectId]=_node9;this._nodeNodes[_node9.nodeId]=_node9;}}}if(children){for(var _i536=0,len=children.length;_i536<len;_i536++){var childMetaObject=children[_i536];this._createTypesNodes2(childMetaObject,rootNode,typeNodes);}}}},{key:"_createContainmentNodes",value:function _createContainmentNodes(){var rootMetaObjects=this._viewer.metaScene.rootMetaObjects;for(var id in rootMetaObjects){this._createContainmentNodes2(rootMetaObjects[id],null);}}},{key:"_createContainmentNodes2",value:function _createContainmentNodes2(metaObject,parent){if(this._pruneEmptyNodes&&metaObject._countEntities===0){return;}var metaObjectType=metaObject.type;var metaObjectName=metaObject.name||metaObjectType;var children=metaObject.children;var objectId=metaObject.id;var node={nodeId:"".concat(this._id,"-").concat(objectId),objectId:objectId,title:!parent?metaObject.metaModels.length===0?"na":this._rootNames[metaObject.metaModels[0].id]||metaObjectName:metaObjectName&&metaObjectName!==""&&metaObjectName!=="Undefined"&&metaObjectName!=="Default"?metaObjectName:metaObjectType,type:metaObjectType,parent:parent,numEntities:0,numVisibleEntities:0,checked:false,xrayed:false,children:[]};if(parent){parent.children.push(node);}else{this._rootNodes.push(node);}this._objectNodes[node.objectId]=node;this._nodeNodes[node.nodeId]=node;if(children){for(var _i537=0,len=children.length;_i537<len;_i537++){var childMetaObject=children[_i537];this._createContainmentNodes2(childMetaObject,node);}}}},{key:"_doSortNodes",value:function _doSortNodes(){for(var _i538=0,len=this._rootNodes.length;_i538<len;_i538++){var rootNode=this._rootNodes[_i538];this._sortChildren(rootNode);}}},{key:"_sortChildren",value:function _sortChildren(node){var children=node.children;if(!children||children.length===0){return;}if(this._hierarchy==="storeys"&&node.type==="IfcBuilding"){// Assumes that children of an IfcBuilding will always be IfcBuildingStoreys
children.sort(this._getSpatialSortFunc());}else{children.sort(this._alphaSortFunc);}for(var _i539=0,len=children.length;_i539<len;_i539++){var _node10=children[_i539];this._sortChildren(_node10);}}},{key:"_getSpatialSortFunc",value:function _getSpatialSortFunc(){// Creates cached sort func with Viewer in scope
var viewer=this.viewer;var scene=viewer.scene;var camera=scene.camera;var metaScene=viewer.metaScene;return this._spatialSortFunc||(this._spatialSortFunc=function(node1,node2){if(!node1.aabb||!node2.aabb){// Sorting on lowest point of the AABB is likely more more robust when objects could overlap storeys
if(!node1.aabb){node1.aabb=scene.getAABB(metaScene.getObjectIDsInSubtree(node1.objectId));}if(!node2.aabb){node2.aabb=scene.getAABB(metaScene.getObjectIDsInSubtree(node2.objectId));}}var idx=0;if(camera.xUp){idx=0;}else if(camera.yUp){idx=1;}else{idx=2;}if(node1.aabb[idx]>node2.aabb[idx]){return-1;}if(node1.aabb[idx]<node2.aabb[idx]){return 1;}return 0;});}},{key:"_alphaSortFunc",value:function _alphaSortFunc(node1,node2){var title1=node1.title.toUpperCase();// FIXME: Should be case sensitive?
var title2=node2.title.toUpperCase();if(title1<title2){return-1;}if(title1>title2){return 1;}return 0;}},{key:"_synchNodesToEntities",value:function _synchNodesToEntities(){var objectIds=Object.keys(this.viewer.metaScene.metaObjects);var metaObjects=this._viewer.metaScene.metaObjects;var objects=this._viewer.scene.objects;for(var _i540=0,len=objectIds.length;_i540<len;_i540++){var objectId=objectIds[_i540];var metaObject=metaObjects[objectId];if(metaObject){var _node11=this._objectNodes[objectId];if(_node11){var entity=objects[objectId];if(entity){var visible=entity.visible;_node11.numEntities=1;_node11.xrayed=entity.xrayed;if(visible){_node11.numVisibleEntities=1;_node11.checked=true;}else{_node11.numVisibleEntities=0;_node11.checked=false;}var parent=_node11.parent;// Synch parents
while(parent){parent.numEntities++;if(visible){parent.numVisibleEntities++;parent.checked=true;}parent=parent.parent;}}}}}}},{key:"_withNodeTree",value:function _withNodeTree(node,callback){callback(node);var children=node.children;if(!children){return;}for(var _i541=0,len=children.length;_i541<len;_i541++){this._withNodeTree(children[_i541],callback);}}},{key:"_createTrees",value:function _createTrees(){var _this146=this;if(this._rootNodes.length===0){return;}var rootNodeElements=this._rootNodes.map(function(rootNode){return _this146._createNodeElement(rootNode);});var rootNode=this._renderService.createRootNode();rootNodeElements.forEach(function(nodeElement){rootNode.appendChild(nodeElement);});this._containerElement.appendChild(rootNode);this._rootElement=rootNode;}},{key:"_createNodeElement",value:function _createNodeElement(node){var _this147=this;var contextmenuHandler=function contextmenuHandler(event){_this147.fire("contextmenu",{event:event,viewer:_this147._viewer,treeViewPlugin:_this147,treeViewNode:node});event.preventDefault();};var onclickHandler=function onclickHandler(event){_this147.fire("nodeTitleClicked",{event:event,viewer:_this147._viewer,treeViewPlugin:_this147,treeViewNode:node});event.preventDefault();};return this._renderService.createNodeElement(node,this._switchExpandHandler,this._checkboxChangeHandler,contextmenuHandler,onclickHandler);}},{key:"_expandSwitchElement",value:function _expandSwitchElement(switchElement){var _this148=this;var expanded=this._renderService.isExpanded(switchElement);if(expanded){return;}var nodeId=this._renderService.getId(switchElement);var nodeElements=this._nodeNodes[nodeId].children.map(function(node){return _this148._createNodeElement(node);});this._renderService.addChildren(switchElement,nodeElements);this._renderService.expand(switchElement,this._switchExpandHandler,this._switchCollapseHandler);}},{key:"_collapseNode",value:function _collapseNode(nodeId){var switchElement=this._renderService.getSwitchElement(nodeId);this._collapseSwitchElement(switchElement);}},{key:"_collapseSwitchElement",value:function _collapseSwitchElement(switchElement){this._renderService.collapse(switchElement,this._switchExpandHandler,this._switchCollapseHandler);}}]);return TreeViewPlugin;}(Plugin);/**
 * For each Entity in its Scene, efficiently combines updates from multiple culling systems into a single "culled" state.
 *
 * Two culling systems are supported:
 *
 * * View culling - culls Entities when they fall outside the current view frustum, and
 * * Detail culling - momentarily culls less visually-significant Entities while we are moving the camera.
 *
 * @private
 */var ObjectCullStates=/*#__PURE__*/function(){/**
     * @private
     * @param scene
     */function ObjectCullStates(scene){var _this149=this;_classCallCheck(this,ObjectCullStates);this._scene=scene;this._objects=[];// Array of all Entity instances that represent objects
this._objectsViewCulled=[];// A flag for each object to indicate its view-cull status
this._objectsDetailCulled=[];// A flag for each object to indicate its detail-cull status
this._objectsChanged=[];// A flag for each object, set whenever its cull status has changed since last _applyChanges()
this._objectsChangedList=[];// A list of objects whose cull status has changed, applied and cleared by _applyChanges()
this._modelInfos={};this._numObjects=0;this._lenObjectsChangedList=0;this._dirty=true;this._onModelLoaded=scene.on("modelLoaded",function(modelId){var model=scene.models[modelId];if(model){_this149._addModel(model);}});this._onTick=scene.on("tick",function(){if(_this149._dirty){_this149._build();}_this149._applyChanges();});}_createClass(ObjectCullStates,[{key:"_addModel",value:function _addModel(model){var _this150=this;var modelInfo={model:model,onDestroyed:model.on("destroyed",function(){_this150._removeModel(model);})};this._modelInfos[model.id]=modelInfo;this._dirty=true;}},{key:"_removeModel",value:function _removeModel(model){var modelInfo=this._modelInfos[model.id];if(modelInfo){modelInfo.model.off(modelInfo.onDestroyed);delete this._modelInfos[model.id];this._dirty=true;}}},{key:"_build",value:function _build(){if(!this._dirty){return;}this._applyChanges();var objects=this._scene.objects;for(var _i542=0;_i542<this._numObjects;_i542++){this._objects[_i542]=null;}this._numObjects=0;for(var objectId in objects){var entity=objects[objectId];this._objects[this._numObjects++]=entity;}this._lenObjectsChangedList=0;this._dirty=false;}},{key:"_applyChanges",value:function _applyChanges(){if(this._lenObjectsChangedList>0){for(var _i543=0;_i543<this._lenObjectsChangedList;_i543++){var objectIdx=this._objectsChangedList[_i543];var object=this._objects[objectIdx];var viewCulled=this._objectsViewCulled[objectIdx];var detailCulled=this._objectsDetailCulled[objectIdx];var culled=viewCulled||detailCulled;object.culled=culled;this._objectsChanged[objectIdx]=false;}this._lenObjectsChangedList=0;}}/**
     * Array of {@link Entity} instances that represent objects in the {@link Scene}.
     *
     * ObjectCullStates rebuilds this from {@link Scene#objects} whenever ````Scene```` fires a ````modelLoaded```` event.
     *
     * @returns {Entity[]}
     */},{key:"objects",get:function get(){if(this._dirty){this._build();}return this._objects;}/**
     * Number of objects in {@link ObjectCullStates#objects},
     *
     * Updated whenever ````Scene```` fires a ````modelLoaded```` event.
     *
     * @returns {Number}
     */},{key:"numObjects",get:function get(){if(this._dirty){this._build();}return this._numObjects;}/**
     * Updates an object's view-cull status.
     *
     * @param {Number} objectIdx Index of the object in {@link ObjectCullStates#objects}
     * @param {boolean} culled Whether to view-cull or not.
     */},{key:"setObjectViewCulled",value:function setObjectViewCulled(objectIdx,culled){if(this._dirty){this._build();}if(this._objectsViewCulled[objectIdx]===culled){return;}this._objectsViewCulled[objectIdx]=culled;if(!this._objectsChanged[objectIdx]){this._objectsChanged[objectIdx]=true;this._objectsChangedList[this._lenObjectsChangedList++]=objectIdx;}}/**
     * Updates an object's detail-cull status.
     *
     * @param {Number} objectIdx Index of the object in {@link ObjectCullStates#objects}
     * @param {boolean} culled Whether to detail-cull or not.
     */},{key:"setObjectDetailCulled",value:function setObjectDetailCulled(objectIdx,culled){if(this._dirty){this._build();}if(this._objectsDetailCulled[objectIdx]===culled){return;}this._objectsDetailCulled[objectIdx]=culled;if(!this._objectsChanged[objectIdx]){this._objectsChanged[objectIdx]=true;this._objectsChangedList[this._lenObjectsChangedList++]=objectIdx;}}/**
     * Destroys this ObjectCullStAtes.
     */},{key:"_destroy",value:function _destroy(){this._clear();this._scene.off(this._onModelLoaded);this._scene.off(this._onTick);}},{key:"_clear",value:function _clear(){for(var modelId in this._modelInfos){var modelInfo=this._modelInfos[modelId];modelInfo.model.off(modelInfo.onDestroyed);}this._modelInfos={};this._dirty=true;}}]);return ObjectCullStates;}();var sceneObjectCullStates={};/**
 * @private
 */function getObjectCullStates(scene){var sceneId=scene.id;var objectCullStates=sceneObjectCullStates[sceneId];if(!objectCullStates){objectCullStates=new ObjectCullStates(scene);sceneObjectCullStates[sceneId]=objectCullStates;scene.on("destroyed",function(){delete sceneObjectCullStates[sceneId];objectCullStates._destroy();});}return objectCullStates;}var MAX_KD_TREE_DEPTH=8;// Increase if greater precision needed
var kdTreeDimLength=new Float32Array(3);/**
 * {@link Viewer} plugin that performs view frustum culling to accelerate rendering performance.
 *
 * For each {@link Entity} that represents an object, ````ViewCullPlugin```` will automatically
 * set {@link Entity#culled}````false```` whenever it falls outside our field of view.
 *
 * When culled, an ````Entity```` is not processed by xeokit's renderer.
 *
 * Internally, ````ViewCullPlugin```` organizes {@link Entity}s in
 * a [bounding volume hierarchy](https://en.wikipedia.org/wiki/Bounding_volume_hierarchy), implemented as
 * a [kd-tree](https://en.wikipedia.org/wiki/K-d_tree).
 *
 * On each {@link Scene} "tick" event, ````ViewCullPlugin```` searches the kd-tree using a frustum generated from
 * the {@link Camera}, marking each ````Entity```` **culled** if it falls outside the frustum.
 *
 * Use ````ViewCullPlugin```` by simply adding it to your ````Viewer````:
 *
 * ````javascript
 * const viewer = new Viewer({
 *    canvasId: "myCanvas",
 *    transparent: true
 * });
 *
 * const viewCullPlugin = new ViewCullPlugin(viewer, {
 *    maxTreeDepth: 20
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/OTCConferenceCenter.xkt"
 * });
 * ````
 */var ViewCullPlugin=/*#__PURE__*/function(_Plugin16){_inherits(ViewCullPlugin,_Plugin16);var _super157=_createSuper(ViewCullPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="ViewCull"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Number} [cfg.maxTreeDepth=8] Maximum depth of the kd-tree.
     */function ViewCullPlugin(viewer){var _this151;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ViewCullPlugin);_this151=_super157.call(this,"ViewCull",viewer);_this151._objectCullStates=getObjectCullStates(viewer.scene);// Combines updates from multiple culling systems for its Scene's Entities
_this151._maxTreeDepth=cfg.maxTreeDepth||MAX_KD_TREE_DEPTH;_this151._modelInfos={};_this151._frustum=new Frustum$1();_this151._kdRoot=null;_this151._frustumDirty=false;_this151._kdTreeDirty=false;_this151._onViewMatrix=viewer.scene.camera.on("viewMatrix",function(){_this151._frustumDirty=true;});_this151._onProjMatrix=viewer.scene.camera.on("projMatMatrix",function(){_this151._frustumDirty=true;});_this151._onModelLoaded=viewer.scene.on("modelLoaded",function(modelId){var model=_this151.viewer.scene.models[modelId];if(model){_this151._addModel(model);}});_this151._onSceneTick=viewer.scene.on("tick",function(){_this151._doCull();});return _this151;}/**
     * Sets whether view culling is enabled.
     *
     * @param {Boolean} enabled Whether to enable view culling.
     */_createClass(ViewCullPlugin,[{key:"enabled",get:/**
     * Gets whether view culling is enabled.
     *
     * @retutns {Boolean} Whether view culling is enabled.
     */function get(){return this._enabled;},set:function set(enabled){this._enabled=enabled;}},{key:"_addModel",value:function _addModel(model){var _this152=this;var modelInfo={model:model,onDestroyed:model.on("destroyed",function(){_this152._removeModel(model);})};this._modelInfos[model.id]=modelInfo;this._kdTreeDirty=true;}},{key:"_removeModel",value:function _removeModel(model){var modelInfo=this._modelInfos[model.id];if(modelInfo){modelInfo.model.off(modelInfo.onDestroyed);delete this._modelInfos[model.id];this._kdTreeDirty=true;}}},{key:"_doCull",value:function _doCull(){var cullDirty=this._frustumDirty||this._kdTreeDirty;if(this._frustumDirty){this._buildFrustum();}if(this._kdTreeDirty){this._buildKDTree();}if(cullDirty){var kdNode=this._kdRoot;if(kdNode){this._visitKDNode(kdNode);}}}},{key:"_buildFrustum",value:function _buildFrustum(){var camera=this.viewer.scene.camera;setFrustum(this._frustum,camera.viewMatrix,camera.projMatrix);this._frustumDirty=false;}},{key:"_buildKDTree",value:function _buildKDTree(){var viewer=this.viewer;var scene=viewer.scene;var depth=0;if(this._kdRoot);this._kdRoot={aabb:scene.getAABB(),intersection:Frustum$1.INTERSECT};for(var objectIdx=0,len=this._objectCullStates.numObjects;objectIdx<len;objectIdx++){var entity=this._objectCullStates.objects[objectIdx];this._insertEntityIntoKDTree(this._kdRoot,entity,objectIdx,depth+1);}this._kdTreeDirty=false;}},{key:"_insertEntityIntoKDTree",value:function _insertEntityIntoKDTree(kdNode,entity,objectIdx,depth){var entityAABB=entity.aabb;if(depth>=this._maxTreeDepth){kdNode.objects=kdNode.objects||[];kdNode.objects.push(objectIdx);math.expandAABB3(kdNode.aabb,entityAABB);return;}if(kdNode.left){if(math.containsAABB3(kdNode.left.aabb,entityAABB)){this._insertEntityIntoKDTree(kdNode.left,entity,objectIdx,depth+1);return;}}if(kdNode.right){if(math.containsAABB3(kdNode.right.aabb,entityAABB)){this._insertEntityIntoKDTree(kdNode.right,entity,objectIdx,depth+1);return;}}var nodeAABB=kdNode.aabb;kdTreeDimLength[0]=nodeAABB[3]-nodeAABB[0];kdTreeDimLength[1]=nodeAABB[4]-nodeAABB[1];kdTreeDimLength[2]=nodeAABB[5]-nodeAABB[2];var dim=0;if(kdTreeDimLength[1]>kdTreeDimLength[dim]){dim=1;}if(kdTreeDimLength[2]>kdTreeDimLength[dim]){dim=2;}if(!kdNode.left){var aabbLeft=nodeAABB.slice();aabbLeft[dim+3]=(nodeAABB[dim]+nodeAABB[dim+3])/2.0;kdNode.left={aabb:aabbLeft,intersection:Frustum$1.INTERSECT};if(math.containsAABB3(aabbLeft,entityAABB)){this._insertEntityIntoKDTree(kdNode.left,entity,objectIdx,depth+1);return;}}if(!kdNode.right){var aabbRight=nodeAABB.slice();aabbRight[dim]=(nodeAABB[dim]+nodeAABB[dim+3])/2.0;kdNode.right={aabb:aabbRight,intersection:Frustum$1.INTERSECT};if(math.containsAABB3(aabbRight,entityAABB)){this._insertEntityIntoKDTree(kdNode.right,entity,objectIdx,depth+1);return;}}kdNode.objects=kdNode.objects||[];kdNode.objects.push(objectIdx);math.expandAABB3(kdNode.aabb,entityAABB);}},{key:"_visitKDNode",value:function _visitKDNode(kdNode){var intersects=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Frustum$1.INTERSECT;if(intersects!==Frustum$1.INTERSECT&&kdNode.intersects===intersects){return;}if(intersects===Frustum$1.INTERSECT){intersects=frustumIntersectsAABB3(this._frustum,kdNode.aabb);kdNode.intersects=intersects;}var culled=intersects===Frustum$1.OUTSIDE;var objects=kdNode.objects;if(objects&&objects.length>0){for(var _i544=0,len=objects.length;_i544<len;_i544++){var objectIdx=objects[_i544];this._objectCullStates.setObjectViewCulled(objectIdx,culled);}}if(kdNode.left){this._visitKDNode(kdNode.left,intersects);}if(kdNode.right){this._visitKDNode(kdNode.right,intersects);}}/**
     * @private
     */},{key:"send",value:function send(name,value){}/**
     * Destroys this ViewCullPlugin.
     */},{key:"destroy",value:function destroy(){_get(_getPrototypeOf(ViewCullPlugin.prototype),"destroy",this).call(this);this._clear();var scene=this.viewer.scene;var camera=scene.camera;scene.off(this._onModelLoaded);scene.off(this._onSceneTick);camera.off(this._onViewMatrix);camera.off(this._onProjMatrix);}},{key:"_clear",value:function _clear(){for(var modelId in this._modelInfos){var modelInfo=this._modelInfos[modelId];modelInfo.model.off(modelInfo.onDestroyed);}this._modelInfos={};this._kdRoot=null;this._kdTreeDirty=true;}}]);return ViewCullPlugin;}(Plugin);/**
 * Default data access strategy for {@link XKTLoaderPlugin}.
 */var XKTDefaultDataSource=/*#__PURE__*/function(){function XKTDefaultDataSource(){_classCallCheck(this,XKTDefaultDataSource);}/**
     * Gets manifest JSON.
     *
     * @param {String|Number} manifestSrc Identifies the manifest JSON asset.
     * @param {Function} ok Fired on successful loading of the manifest JSON asset.
     * @param {Function} error Fired on error while loading the manifest JSON asset.
     */_createClass(XKTDefaultDataSource,[{key:"getManifest",value:function getManifest(manifestSrc,ok,error){utils.loadJSON(manifestSrc,function(json){ok(json);},function(errMsg){error(errMsg);});}/**
     * Gets metamodel JSON.
     *
     * @param {String|Number} metaModelSrc Identifies the metamodel JSON asset.
     * @param {Function} ok Fired on successful loading of the metamodel JSON asset.
     * @param {Function} error Fired on error while loading the metamodel JSON asset.
     */},{key:"getMetaModel",value:function getMetaModel(metaModelSrc,ok,error){utils.loadJSON(metaModelSrc,function(json){ok(json);},function(errMsg){error(errMsg);});}/**
     * Gets the contents of the given ````.xkt```` file in an arraybuffer.
     *
     * @param {String|Number} src Path or ID of an ````.xkt```` file.
     * @param {Function} ok Callback fired on success, argument is the ````.xkt```` file in an arraybuffer.
     * @param {Function} error Callback fired on error.
     */},{key:"getXKT",value:function getXKT(src,ok,error){var defaultCallback=function defaultCallback(){};ok=ok||defaultCallback;error=error||defaultCallback;var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=src.match(dataUriRegex);if(dataUriRegexResult){// Safari can't handle data URIs through XMLHttpRequest
var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64){data=window.atob(data);}try{var buffer=new ArrayBuffer(data.length);var view=new Uint8Array(buffer);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}ok(buffer);}catch(errMsg){error(errMsg);}}else{var request=new XMLHttpRequest();request.open('GET',src,true);request.responseType='arraybuffer';request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){ok(request.response);}else{error('getXKT error : '+request.response);}}};request.send(null);}}}]);return XKTDefaultDataSource;}();/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */!function(t,e){"object"==(typeof exports==="undefined"?"undefined":_typeof(exports))&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).pako={});}(undefined,function(t){function e(t){var e=t.length;for(;--e>=0;){t[e]=0;}}var a=256,i=286,n=30,s=15,r=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),o=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),l=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),h=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),d=new Array(576);e(d);var _=new Array(60);e(_);var f=new Array(512);e(f);var c=new Array(256);e(c);var u=new Array(29);e(u);var w=new Array(n);function m(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length;}var b,g,p;function k(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e;}e(w);var v=function v(t){return t<256?f[t]:f[256+(t>>>7)];},y=function y(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255;},x=function x(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,y(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a);},z=function z(t,e,a){x(t,a[2*e],a[2*e+1]);},A=function A(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1;}while(--e>0);return a>>>1;},E=function E(t,e,a){var i=new Array(16);var n,r,o=0;for(n=1;n<=s;n++){o=o+a[n-1]<<1,i[n]=o;}for(r=0;r<=e;r++){var _e2=t[2*r+1];0!==_e2&&(t[2*r]=A(i[_e2]++,_e2));}},R=function R(t){var e;for(e=0;e<i;e++){t.dyn_ltree[2*e]=0;}for(e=0;e<n;e++){t.dyn_dtree[2*e]=0;}for(e=0;e<19;e++){t.bl_tree[2*e]=0;}t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0;},Z=function Z(t){t.bi_valid>8?y(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0;},U=function U(t,e,a,i){var n=2*e,s=2*a;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[a];},S=function S(t,e,a){var i=t.heap[a];var n=a<<1;for(;n<=t.heap_len&&(n<t.heap_len&&U(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!U(e,i,t.heap[n],t.depth));){t.heap[a]=t.heap[n],a=n,n<<=1;}t.heap[a]=i;},D=function D(t,e,i){var n,s,l,h,d=0;if(0!==t.sym_next)do{n=255&t.pending_buf[t.sym_buf+d++],n+=(255&t.pending_buf[t.sym_buf+d++])<<8,s=t.pending_buf[t.sym_buf+d++],0===n?z(t,s,e):(l=c[s],z(t,l+a+1,e),h=r[l],0!==h&&(s-=u[l],x(t,s,h)),n--,l=v(n),z(t,l,i),h=o[l],0!==h&&(n-=w[l],x(t,n,h)));}while(d<t.sym_next);z(t,256,e);},T=function T(t,e){var a=e.dyn_tree,i=e.stat_desc.static_tree,n=e.stat_desc.has_stree,r=e.stat_desc.elems;var o,l,h,d=-1;for(t.heap_len=0,t.heap_max=573,o=0;o<r;o++){0!==a[2*o]?(t.heap[++t.heap_len]=d=o,t.depth[o]=0):a[2*o+1]=0;}for(;t.heap_len<2;){h=t.heap[++t.heap_len]=d<2?++d:0,a[2*h]=1,t.depth[h]=0,t.opt_len--,n&&(t.static_len-=i[2*h+1]);}for(e.max_code=d,o=t.heap_len>>1;o>=1;o--){S(t,a,o);}h=r;do{o=t.heap[1],t.heap[1]=t.heap[t.heap_len--],S(t,a,1),l=t.heap[1],t.heap[--t.heap_max]=o,t.heap[--t.heap_max]=l,a[2*h]=a[2*o]+a[2*l],t.depth[h]=(t.depth[o]>=t.depth[l]?t.depth[o]:t.depth[l])+1,a[2*o+1]=a[2*l+1]=h,t.heap[1]=h++,S(t,a,1);}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a=e.dyn_tree,i=e.max_code,n=e.stat_desc.static_tree,r=e.stat_desc.has_stree,o=e.stat_desc.extra_bits,l=e.stat_desc.extra_base,h=e.stat_desc.max_length;var d,_,f,c,u,w,m=0;for(c=0;c<=s;c++){t.bl_count[c]=0;}for(a[2*t.heap[t.heap_max]+1]=0,d=t.heap_max+1;d<573;d++){_=t.heap[d],c=a[2*a[2*_+1]+1]+1,c>h&&(c=h,m++),a[2*_+1]=c,_>i||(t.bl_count[c]++,u=0,_>=l&&(u=o[_-l]),w=a[2*_],t.opt_len+=w*(c+u),r&&(t.static_len+=w*(n[2*_+1]+u)));}if(0!==m){do{for(c=h-1;0===t.bl_count[c];){c--;}t.bl_count[c]--,t.bl_count[c+1]+=2,t.bl_count[h]--,m-=2;}while(m>0);for(c=h;0!==c;c--){for(_=t.bl_count[c];0!==_;){f=t.heap[--d],f>i||(a[2*f+1]!==c&&(t.opt_len+=(c-a[2*f+1])*a[2*f],a[2*f+1]=c),_--);}}}}(t,e),E(a,d,t.bl_count);},O=function O(t,e,a){var i,n,s=-1,r=e[1],o=0,l=7,h=4;for(0===r&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++){n=r,r=e[2*(i+1)+1],++o<l&&n===r||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[32]++):o<=10?t.bl_tree[34]++:t.bl_tree[36]++,o=0,s=n,0===r?(l=138,h=3):n===r?(l=6,h=3):(l=7,h=4));}},I=function I(t,e,a){var i,n,s=-1,r=e[1],o=0,l=7,h=4;for(0===r&&(l=138,h=3),i=0;i<=a;i++){if(n=r,r=e[2*(i+1)+1],!(++o<l&&n===r)){if(o<h)do{z(t,n,t.bl_tree);}while(0!=--o);else 0!==n?(n!==s&&(z(t,n,t.bl_tree),o--),z(t,16,t.bl_tree),x(t,o-3,2)):o<=10?(z(t,17,t.bl_tree),x(t,o-3,3)):(z(t,18,t.bl_tree),x(t,o-11,7));o=0,s=n,0===r?(l=138,h=3):n===r?(l=6,h=3):(l=7,h=4);}}};var F=!1;var L=function L(t,e,a,i){x(t,0+(i?1:0),3),Z(t),y(t,a),y(t,~a),a&&t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a;};var N=function N(t,e,i,n){var s,r,o=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,i=4093624447;for(e=0;e<=31;e++,i>>>=1){if(1&i&&0!==t.dyn_ltree[2*e])return 0;}if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<a;e++){if(0!==t.dyn_ltree[2*e])return 1;}return 0;}(t)),T(t,t.l_desc),T(t,t.d_desc),o=function(t){var e;for(O(t,t.dyn_ltree,t.l_desc.max_code),O(t,t.dyn_dtree,t.d_desc.max_code),T(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*h[e]+1];e--){;}return t.opt_len+=3*(e+1)+5+5+4,e;}(t),s=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=s&&(s=r)):s=r=i+5,i+4<=s&&-1!==e?L(t,e,i,n):4===t.strategy||r===s?(x(t,2+(n?1:0),3),D(t,d,_)):(x(t,4+(n?1:0),3),function(t,e,a,i){var n;for(x(t,e-257,5),x(t,a-1,5),x(t,i-4,4),n=0;n<i;n++){x(t,t.bl_tree[2*h[n]+1],3);}I(t,t.dyn_ltree,e-1),I(t,t.dyn_dtree,a-1);}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,o+1),D(t,t.dyn_ltree,t.dyn_dtree)),R(t),n&&Z(t);},B={_tr_init:function _tr_init(t){F||(function(){var t,e,a,h,k;var v=new Array(16);for(a=0,h=0;h<28;h++){for(u[h]=a,t=0;t<1<<r[h];t++){c[a++]=h;}}for(c[a-1]=h,k=0,h=0;h<16;h++){for(w[h]=k,t=0;t<1<<o[h];t++){f[k++]=h;}}for(k>>=7;h<n;h++){for(w[h]=k<<7,t=0;t<1<<o[h]-7;t++){f[256+k++]=h;}}for(e=0;e<=s;e++){v[e]=0;}for(t=0;t<=143;){d[2*t+1]=8,t++,v[8]++;}for(;t<=255;){d[2*t+1]=9,t++,v[9]++;}for(;t<=279;){d[2*t+1]=7,t++,v[7]++;}for(;t<=287;){d[2*t+1]=8,t++,v[8]++;}for(E(d,287,v),t=0;t<n;t++){_[2*t+1]=5,_[2*t]=A(t,5);}b=new m(d,r,257,i,s),g=new m(_,o,0,n,s),p=new m(new Array(0),l,0,19,7);}(),F=!0),t.l_desc=new k(t.dyn_ltree,b),t.d_desc=new k(t.dyn_dtree,g),t.bl_desc=new k(t.bl_tree,p),t.bi_buf=0,t.bi_valid=0,R(t);},_tr_stored_block:L,_tr_flush_block:N,_tr_tally:function _tr_tally(t,e,i){return t.pending_buf[t.sym_buf+t.sym_next++]=e,t.pending_buf[t.sym_buf+t.sym_next++]=e>>8,t.pending_buf[t.sym_buf+t.sym_next++]=i,0===e?t.dyn_ltree[2*i]++:(t.matches++,e--,t.dyn_ltree[2*(c[i]+a+1)]++,t.dyn_dtree[2*v(e)]++),t.sym_next===t.sym_end;},_tr_align:function _tr_align(t){x(t,2,3),z(t,256,d),function(t){16===t.bi_valid?(y(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8);}(t);}};var C=function C(t,e,a,i){var n=65535&t|0,s=t>>>16&65535|0,r=0;for(;0!==a;){r=a>2e3?2e3:a,a-=r;do{n=n+e[i++]|0,s=s+n|0;}while(--r);n%=65521,s%=65521;}return n|s<<16|0;};var M=new Uint32Array(function(){var t,e=[];for(var a=0;a<256;a++){t=a;for(var i=0;i<8;i++){t=1&t?3988292384^t>>>1:t>>>1;}e[a]=t;}return e;}());var H=function H(t,e,a,i){var n=M,s=i+a;t^=-1;for(var _a6=i;_a6<s;_a6++){t=t>>>8^n[255&(t^e[_a6])];}return-1^t;},j={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},K={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};var P=B._tr_init,Y=B._tr_stored_block,G=B._tr_flush_block,X=B._tr_tally,W=B._tr_align,q=K.Z_NO_FLUSH,J=K.Z_PARTIAL_FLUSH,Q=K.Z_FULL_FLUSH,V=K.Z_FINISH,$=K.Z_BLOCK,tt=K.Z_OK,et=K.Z_STREAM_END,at=K.Z_STREAM_ERROR,it=K.Z_DATA_ERROR,nt=K.Z_BUF_ERROR,st=K.Z_DEFAULT_COMPRESSION,rt=K.Z_FILTERED,ot=K.Z_HUFFMAN_ONLY,lt=K.Z_RLE,ht=K.Z_FIXED,dt=K.Z_DEFAULT_STRATEGY,_t=K.Z_UNKNOWN,ft=K.Z_DEFLATED,ct=258,ut=262,wt=42,mt=113,bt=666,gt=function gt(t,e){return t.msg=j[e],e;},pt=function pt(t){return 2*t-(t>4?9:0);},kt=function kt(t){var e=t.length;for(;--e>=0;){t[e]=0;}},vt=function vt(t){var e,a,i,n=t.w_size;e=t.hash_size,i=e;do{a=t.head[--i],t.head[i]=a>=n?a-n:0;}while(--e);e=n,i=e;do{a=t.prev[--i],t.prev[i]=a>=n?a-n:0;}while(--e);};var yt=function yt(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask;};var xt=function xt(t){var e=t.state;var a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0));},zt=function zt(t,e){G(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,xt(t.strm);},At=function At(t,e){t.pending_buf[t.pending++]=e;},Et=function Et(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e;},Rt=function Rt(t,e,a,i){var n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,e.set(t.input.subarray(t.next_in,t.next_in+n),a),1===t.state.wrap?t.adler=C(t.adler,e,n,a):2===t.state.wrap&&(t.adler=H(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n);},Zt=function Zt(t,e){var a,i,n=t.max_chain_length,s=t.strstart,r=t.prev_length,o=t.nice_match;var l=t.strstart>t.w_size-ut?t.strstart-(t.w_size-ut):0,h=t.window,d=t.w_mask,_=t.prev,f=t.strstart+ct;var c=h[s+r-1],u=h[s+r];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(a=e,h[a+r]===u&&h[a+r-1]===c&&h[a]===h[s]&&h[++a]===h[s+1]){s+=2,a++;do{}while(h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&s<f);if(i=ct-(f-s),s=f-ct,i>r){if(t.match_start=e,r=i,i>=o)break;c=h[s+r-1],u=h[s+r];}}}while((e=_[e&d])>l&&0!=--n);return r<=t.lookahead?r:t.lookahead;},Ut=function Ut(t){var e=t.w_size;var a,i,n;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-ut)&&(t.window.set(t.window.subarray(e,e+e-i),0),t.match_start-=e,t.strstart-=e,t.block_start-=e,t.insert>t.strstart&&(t.insert=t.strstart),vt(t),i+=e),0===t.strm.avail_in)break;if(a=Rt(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=a,t.lookahead+t.insert>=3)for(n=t.strstart-t.insert,t.ins_h=t.window[n],t.ins_h=yt(t,t.ins_h,t.window[n+1]);t.insert&&(t.ins_h=yt(t,t.ins_h,t.window[n+3-1]),t.prev[n&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=n,n++,t.insert--,!(t.lookahead+t.insert<3));){;}}while(t.lookahead<ut&&0!==t.strm.avail_in);},St=function St(t,e){var a,i,n,s=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,r=0,o=t.strm.avail_in;do{if(a=65535,n=t.bi_valid+42>>3,t.strm.avail_out<n)break;if(n=t.strm.avail_out-n,i=t.strstart-t.block_start,a>i+t.strm.avail_in&&(a=i+t.strm.avail_in),a>n&&(a=n),a<s&&(0===a&&e!==V||e===q||a!==i+t.strm.avail_in))break;r=e===V&&a===i+t.strm.avail_in?1:0,Y(t,0,0,r),t.pending_buf[t.pending-4]=a,t.pending_buf[t.pending-3]=a>>8,t.pending_buf[t.pending-2]=~a,t.pending_buf[t.pending-1]=~a>>8,xt(t.strm),i&&(i>a&&(i=a),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+i),t.strm.next_out),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i,t.block_start+=i,a-=i),a&&(Rt(t.strm,t.strm.output,t.strm.next_out,a),t.strm.next_out+=a,t.strm.avail_out-=a,t.strm.total_out+=a);}while(0===r);return o-=t.strm.avail_in,o&&(o>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=o&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-o,t.strm.next_in),t.strstart),t.strstart+=o,t.insert+=o>t.w_size-t.insert?t.w_size-t.insert:o),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),r?4:e!==q&&e!==V&&0===t.strm.avail_in&&t.strstart===t.block_start?2:(n=t.window_size-t.strstart,t.strm.avail_in>n&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,n+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),n>t.strm.avail_in&&(n=t.strm.avail_in),n&&(Rt(t.strm,t.window,t.strstart,n),t.strstart+=n,t.insert+=n>t.w_size-t.insert?t.w_size-t.insert:n),t.high_water<t.strstart&&(t.high_water=t.strstart),n=t.bi_valid+42>>3,n=t.pending_buf_size-n>65535?65535:t.pending_buf_size-n,s=n>t.w_size?t.w_size:n,i=t.strstart-t.block_start,(i>=s||(i||e===V)&&e!==q&&0===t.strm.avail_in&&i<=n)&&(a=i>n?n:i,r=e===V&&0===t.strm.avail_in&&a===i?1:0,Y(t,t.block_start,a,r),t.block_start+=a,xt(t.strm)),r?3:1);},Dt=function Dt(t,e){var a,i;for(;;){if(t.lookahead<ut){if(Ut(t),t.lookahead<ut&&e===q)return 1;if(0===t.lookahead)break;}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ut&&(t.match_length=Zt(t,a)),t.match_length>=3){if(i=X(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;}while(0!=--t.match_length);t.strstart++;}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=yt(t,t.ins_h,t.window[t.strstart+1]);}else i=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(zt(t,!1),0===t.strm.avail_out))return 1;}return t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(zt(t,!1),0===t.strm.avail_out)?1:2;},Tt=function Tt(t,e){var a,i,n;for(;;){if(t.lookahead<ut){if(Ut(t),t.lookahead<ut&&e===q)return 1;if(0===t.lookahead)break;}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ut&&(t.match_length=Zt(t,a),t.match_length<=5&&(t.strategy===rt||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-3,i=X(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,i&&(zt(t,!1),0===t.strm.avail_out))return 1;}else if(t.match_available){if(i=X(t,0,t.window[t.strstart-1]),i&&zt(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1;}else t.match_available=1,t.strstart++,t.lookahead--;}return t.match_available&&(i=X(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(zt(t,!1),0===t.strm.avail_out)?1:2;};function Ot(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n;}var It=[new Ot(0,0,0,0,St),new Ot(4,4,8,4,Dt),new Ot(4,5,16,8,Dt),new Ot(4,6,32,32,Dt),new Ot(4,4,16,16,Tt),new Ot(8,16,32,32,Tt),new Ot(8,16,128,128,Tt),new Ot(8,32,128,256,Tt),new Ot(32,128,258,1024,Tt),new Ot(32,258,258,4096,Tt)];function Ft(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ft,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),kt(this.dyn_ltree),kt(this.dyn_dtree),kt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),kt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),kt(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}var Lt=function Lt(t){if(!t)return 1;var e=t.state;return!e||e.strm!==t||e.status!==wt&&57!==e.status&&69!==e.status&&73!==e.status&&91!==e.status&&103!==e.status&&e.status!==mt&&e.status!==bt?1:0;},Nt=function Nt(t){if(Lt(t))return gt(t,at);t.total_in=t.total_out=0,t.data_type=_t;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=2===e.wrap?57:e.wrap?wt:mt,t.adler=2===e.wrap?0:1,e.last_flush=-2,P(e),tt;},Bt=function Bt(t){var e=Nt(t);var a;return e===tt&&((a=t.state).window_size=2*a.w_size,kt(a.head),a.max_lazy_match=It[a.level].max_lazy,a.good_match=It[a.level].good_length,a.nice_match=It[a.level].nice_length,a.max_chain_length=It[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=2,a.match_available=0,a.ins_h=0),e;},Ct=function Ct(t,e,a,i,n,s){if(!t)return at;var r=1;if(e===st&&(e=6),i<0?(r=0,i=-i):i>15&&(r=2,i-=16),n<1||n>9||a!==ft||i<8||i>15||e<0||e>9||s<0||s>ht||8===i&&1!==r)return gt(t,at);8===i&&(i=9);var o=new Ft();return t.state=o,o.strm=t,o.status=wt,o.wrap=r,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=e,o.strategy=s,o.method=a,Bt(t);};var Mt={deflateInit:function deflateInit(t,e){return Ct(t,e,ft,15,8,dt);},deflateInit2:Ct,deflateReset:Bt,deflateResetKeep:Nt,deflateSetHeader:function deflateSetHeader(t,e){return Lt(t)||2!==t.state.wrap?at:(t.state.gzhead=e,tt);},deflate:function deflate(t,e){if(Lt(t)||e>$||e<0)return t?gt(t,at):at;var a=t.state;if(!t.output||0!==t.avail_in&&!t.input||a.status===bt&&e!==V)return gt(t,0===t.avail_out?nt:at);var i=a.last_flush;if(a.last_flush=e,0!==a.pending){if(xt(t),0===t.avail_out)return a.last_flush=-1,tt;}else if(0===t.avail_in&&pt(e)<=pt(i)&&e!==V)return gt(t,nt);if(a.status===bt&&0!==t.avail_in)return gt(t,nt);if(a.status===wt&&0===a.wrap&&(a.status=mt),a.status===wt){var _e3=ft+(a.w_bits-8<<4)<<8,_i545=-1;if(_i545=a.strategy>=ot||a.level<2?0:a.level<6?1:6===a.level?2:3,_e3|=_i545<<6,0!==a.strstart&&(_e3|=32),_e3+=31-_e3%31,Et(a,_e3),0!==a.strstart&&(Et(a,t.adler>>>16),Et(a,65535&t.adler)),t.adler=1,a.status=mt,xt(t),0!==a.pending)return a.last_flush=-1,tt;}if(57===a.status)if(t.adler=0,At(a,31),At(a,139),At(a,8),a.gzhead)At(a,(a.gzhead.text?1:0)+(a.gzhead.hcrc?2:0)+(a.gzhead.extra?4:0)+(a.gzhead.name?8:0)+(a.gzhead.comment?16:0)),At(a,255&a.gzhead.time),At(a,a.gzhead.time>>8&255),At(a,a.gzhead.time>>16&255),At(a,a.gzhead.time>>24&255),At(a,9===a.level?2:a.strategy>=ot||a.level<2?4:0),At(a,255&a.gzhead.os),a.gzhead.extra&&a.gzhead.extra.length&&(At(a,255&a.gzhead.extra.length),At(a,a.gzhead.extra.length>>8&255)),a.gzhead.hcrc&&(t.adler=H(t.adler,a.pending_buf,a.pending,0)),a.gzindex=0,a.status=69;else if(At(a,0),At(a,0),At(a,0),At(a,0),At(a,0),At(a,9===a.level?2:a.strategy>=ot||a.level<2?4:0),At(a,3),a.status=mt,xt(t),0!==a.pending)return a.last_flush=-1,tt;if(69===a.status){if(a.gzhead.extra){var _e4=a.pending,_i546=(65535&a.gzhead.extra.length)-a.gzindex;for(;a.pending+_i546>a.pending_buf_size;){var _n3=a.pending_buf_size-a.pending;if(a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex,a.gzindex+_n3),a.pending),a.pending=a.pending_buf_size,a.gzhead.hcrc&&a.pending>_e4&&(t.adler=H(t.adler,a.pending_buf,a.pending-_e4,_e4)),a.gzindex+=_n3,xt(t),0!==a.pending)return a.last_flush=-1,tt;_e4=0,_i546-=_n3;}var _n2=new Uint8Array(a.gzhead.extra);a.pending_buf.set(_n2.subarray(a.gzindex,a.gzindex+_i546),a.pending),a.pending+=_i546,a.gzhead.hcrc&&a.pending>_e4&&(t.adler=H(t.adler,a.pending_buf,a.pending-_e4,_e4)),a.gzindex=0;}a.status=73;}if(73===a.status){if(a.gzhead.name){var _e5,_i547=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>_i547&&(t.adler=H(t.adler,a.pending_buf,a.pending-_i547,_i547)),xt(t),0!==a.pending)return a.last_flush=-1,tt;_i547=0;}_e5=a.gzindex<a.gzhead.name.length?255&a.gzhead.name.charCodeAt(a.gzindex++):0,At(a,_e5);}while(0!==_e5);a.gzhead.hcrc&&a.pending>_i547&&(t.adler=H(t.adler,a.pending_buf,a.pending-_i547,_i547)),a.gzindex=0;}a.status=91;}if(91===a.status){if(a.gzhead.comment){var _e6,_i548=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>_i548&&(t.adler=H(t.adler,a.pending_buf,a.pending-_i548,_i548)),xt(t),0!==a.pending)return a.last_flush=-1,tt;_i548=0;}_e6=a.gzindex<a.gzhead.comment.length?255&a.gzhead.comment.charCodeAt(a.gzindex++):0,At(a,_e6);}while(0!==_e6);a.gzhead.hcrc&&a.pending>_i548&&(t.adler=H(t.adler,a.pending_buf,a.pending-_i548,_i548));}a.status=103;}if(103===a.status){if(a.gzhead.hcrc){if(a.pending+2>a.pending_buf_size&&(xt(t),0!==a.pending))return a.last_flush=-1,tt;At(a,255&t.adler),At(a,t.adler>>8&255),t.adler=0;}if(a.status=mt,xt(t),0!==a.pending)return a.last_flush=-1,tt;}if(0!==t.avail_in||0!==a.lookahead||e!==q&&a.status!==bt){var _i549=0===a.level?St(a,e):a.strategy===ot?function(t,e){var a;for(;;){if(0===t.lookahead&&(Ut(t),0===t.lookahead)){if(e===q)return 1;break;}if(t.match_length=0,a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(zt(t,!1),0===t.strm.avail_out))return 1;}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(zt(t,!1),0===t.strm.avail_out)?1:2;}(a,e):a.strategy===lt?function(t,e){var a,i,n,s;var r=t.window;for(;;){if(t.lookahead<=ct){if(Ut(t),t.lookahead<=ct&&e===q)return 1;if(0===t.lookahead)break;}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=t.strstart-1,i=r[n],i===r[++n]&&i===r[++n]&&i===r[++n])){s=t.strstart+ct;do{}while(i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&n<s);t.match_length=ct-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead);}if(t.match_length>=3?(a=X(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(zt(t,!1),0===t.strm.avail_out))return 1;}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(zt(t,!1),0===t.strm.avail_out)?1:2;}(a,e):It[a.level].func(a,e);if(3!==_i549&&4!==_i549||(a.status=bt),1===_i549||3===_i549)return 0===t.avail_out&&(a.last_flush=-1),tt;if(2===_i549&&(e===J?W(a):e!==$&&(Y(a,0,0,!1),e===Q&&(kt(a.head),0===a.lookahead&&(a.strstart=0,a.block_start=0,a.insert=0))),xt(t),0===t.avail_out))return a.last_flush=-1,tt;}return e!==V?tt:a.wrap<=0?et:(2===a.wrap?(At(a,255&t.adler),At(a,t.adler>>8&255),At(a,t.adler>>16&255),At(a,t.adler>>24&255),At(a,255&t.total_in),At(a,t.total_in>>8&255),At(a,t.total_in>>16&255),At(a,t.total_in>>24&255)):(Et(a,t.adler>>>16),Et(a,65535&t.adler)),xt(t),a.wrap>0&&(a.wrap=-a.wrap),0!==a.pending?tt:et);},deflateEnd:function deflateEnd(t){if(Lt(t))return at;var e=t.state.status;return t.state=null,e===mt?gt(t,it):tt;},deflateSetDictionary:function deflateSetDictionary(t,e){var a=e.length;if(Lt(t))return at;var i=t.state,n=i.wrap;if(2===n||1===n&&i.status!==wt||i.lookahead)return at;if(1===n&&(t.adler=C(t.adler,e,a,0)),i.wrap=0,a>=i.w_size){0===n&&(kt(i.head),i.strstart=0,i.block_start=0,i.insert=0);var _t2=new Uint8Array(i.w_size);_t2.set(e.subarray(a-i.w_size,a),0),e=_t2,a=i.w_size;}var s=t.avail_in,r=t.next_in,o=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,Ut(i);i.lookahead>=3;){var _t3=i.strstart,_e7=i.lookahead-2;do{i.ins_h=yt(i,i.ins_h,i.window[_t3+3-1]),i.prev[_t3&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=_t3,_t3++;}while(--_e7);i.strstart=_t3,i.lookahead=2,Ut(i);}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,t.next_in=r,t.input=o,t.avail_in=s,i.wrap=n,tt;},deflateInfo:"pako deflate (from Nodeca project)"};var Ht=function Ht(t,e){return Object.prototype.hasOwnProperty.call(t,e);};var jt=function jt(t){var e=Array.prototype.slice.call(arguments,1);for(;e.length;){var _a7=e.shift();if(_a7){if("object"!=_typeof(_a7))throw new TypeError(_a7+"must be non-object");for(var _e8 in _a7){Ht(_a7,_e8)&&(t[_e8]=_a7[_e8]);}}}return t;},Kt=function Kt(t){var e=0;for(var _a8=0,_i550=t.length;_a8<_i550;_a8++){e+=t[_a8].length;}var a=new Uint8Array(e);for(var _e9=0,_i551=0,_n4=t.length;_e9<_n4;_e9++){var _n5=t[_e9];a.set(_n5,_i551),_i551+=_n5.length;}return a;};var Pt=!0;try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(t){Pt=!1;}var Yt=new Uint8Array(256);for(var _t4=0;_t4<256;_t4++){Yt[_t4]=_t4>=252?6:_t4>=248?5:_t4>=240?4:_t4>=224?3:_t4>=192?2:1;}Yt[254]=Yt[254]=1;var Gt=function Gt(t){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return new TextEncoder().encode(t);var e,a,i,n,s,r=t.length,o=0;for(n=0;n<r;n++){a=t.charCodeAt(n),55296==(64512&a)&&n+1<r&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),n++)),o+=a<128?1:a<2048?2:a<65536?3:4;}for(e=new Uint8Array(o),s=0,n=0;s<o;n++){a=t.charCodeAt(n),55296==(64512&a)&&n+1<r&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),n++)),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);}return e;},Xt=function Xt(t,e){var a=e||t.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return new TextDecoder().decode(t.subarray(0,e));var i,n;var s=new Array(2*a);for(n=0,i=0;i<a;){var _e10=t[i++];if(_e10<128){s[n++]=_e10;continue;}var _r6=Yt[_e10];if(_r6>4)s[n++]=65533,i+=_r6-1;else{for(_e10&=2===_r6?31:3===_r6?15:7;_r6>1&&i<a;){_e10=_e10<<6|63&t[i++],_r6--;}_r6>1?s[n++]=65533:_e10<65536?s[n++]=_e10:(_e10-=65536,s[n++]=55296|_e10>>10&1023,s[n++]=56320|1023&_e10);}}return function(t,e){if(e<65534&&t.subarray&&Pt)return String.fromCharCode.apply(null,t.length===e?t:t.subarray(0,e));var a="";for(var _i552=0;_i552<e;_i552++){a+=String.fromCharCode(t[_i552]);}return a;}(s,n);},Wt=function Wt(t,e){(e=e||t.length)>t.length&&(e=t.length);var a=e-1;for(;a>=0&&128==(192&t[a]);){a--;}return a<0||0===a?e:a+Yt[t[a]]>e?a:e;};var qt=function qt(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;};var Jt=Object.prototype.toString,Qt=K.Z_NO_FLUSH,Vt=K.Z_SYNC_FLUSH,$t=K.Z_FULL_FLUSH,te=K.Z_FINISH,ee=K.Z_OK,ae=K.Z_STREAM_END,ie=K.Z_DEFAULT_COMPRESSION,ne=K.Z_DEFAULT_STRATEGY,se=K.Z_DEFLATED;function re(t){this.options=jt({level:ie,method:se,chunkSize:16384,windowBits:15,memLevel:8,strategy:ne},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new qt(),this.strm.avail_out=0;var a=Mt.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==ee)throw new Error(j[a]);if(e.header&&Mt.deflateSetHeader(this.strm,e.header),e.dictionary){var _t5;if(_t5="string"==typeof e.dictionary?Gt(e.dictionary):"[object ArrayBuffer]"===Jt.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,a=Mt.deflateSetDictionary(this.strm,_t5),a!==ee)throw new Error(j[a]);this._dict_set=!0;}}function oe(t,e){var a=new re(e);if(a.push(t,!0),a.err)throw a.msg||j[a.err];return a.result;}re.prototype.push=function(t,e){var a=this.strm,i=this.options.chunkSize;var n,s;if(this.ended)return!1;for(s=e===~~e?e:!0===e?te:Qt,"string"==typeof t?a.input=Gt(t):"[object ArrayBuffer]"===Jt.call(t)?a.input=new Uint8Array(t):a.input=t,a.next_in=0,a.avail_in=a.input.length;;){if(0===a.avail_out&&(a.output=new Uint8Array(i),a.next_out=0,a.avail_out=i),(s===Vt||s===$t)&&a.avail_out<=6)this.onData(a.output.subarray(0,a.next_out)),a.avail_out=0;else{if(n=Mt.deflate(a,s),n===ae)return a.next_out>0&&this.onData(a.output.subarray(0,a.next_out)),n=Mt.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===ee;if(0!==a.avail_out){if(s>0&&a.next_out>0)this.onData(a.output.subarray(0,a.next_out)),a.avail_out=0;else if(0===a.avail_in)break;}else this.onData(a.output);}}return!0;},re.prototype.onData=function(t){this.chunks.push(t);},re.prototype.onEnd=function(t){t===ee&&(this.result=Kt(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg;};var le={Deflate:re,deflate:oe,deflateRaw:function deflateRaw(t,e){return(e=e||{}).raw=!0,oe(t,e);},gzip:function gzip(t,e){return(e=e||{}).gzip=!0,oe(t,e);},constants:K};var he=16209;var de=function de(t,e){var a,i,n,s,r,o,l,h,d,_,f,c,u,w,m,b,g,p,k,v,y,x,z,A;var E=t.state;a=t.next_in,z=t.input,i=a+(t.avail_in-5),n=t.next_out,A=t.output,s=n-(e-t.avail_out),r=n+(t.avail_out-257),o=E.dmax,l=E.wsize,h=E.whave,d=E.wnext,_=E.window,f=E.hold,c=E.bits,u=E.lencode,w=E.distcode,m=(1<<E.lenbits)-1,b=(1<<E.distbits)-1;t:do{c<15&&(f+=z[a++]<<c,c+=8,f+=z[a++]<<c,c+=8),g=u[f&m];e:for(;;){if(p=g>>>24,f>>>=p,c-=p,p=g>>>16&255,0===p)A[n++]=65535&g;else{if(!(16&p)){if(0==(64&p)){g=u[(65535&g)+(f&(1<<p)-1)];continue e;}if(32&p){E.mode=16191;break t;}t.msg="invalid literal/length code",E.mode=he;break t;}k=65535&g,p&=15,p&&(c<p&&(f+=z[a++]<<c,c+=8),k+=f&(1<<p)-1,f>>>=p,c-=p),c<15&&(f+=z[a++]<<c,c+=8,f+=z[a++]<<c,c+=8),g=w[f&b];a:for(;;){if(p=g>>>24,f>>>=p,c-=p,p=g>>>16&255,!(16&p)){if(0==(64&p)){g=w[(65535&g)+(f&(1<<p)-1)];continue a;}t.msg="invalid distance code",E.mode=he;break t;}if(v=65535&g,p&=15,c<p&&(f+=z[a++]<<c,c+=8,c<p&&(f+=z[a++]<<c,c+=8)),v+=f&(1<<p)-1,v>o){t.msg="invalid distance too far back",E.mode=he;break t;}if(f>>>=p,c-=p,p=n-s,v>p){if(p=v-p,p>h&&E.sane){t.msg="invalid distance too far back",E.mode=he;break t;}if(y=0,x=_,0===d){if(y+=l-p,p<k){k-=p;do{A[n++]=_[y++];}while(--p);y=n-v,x=A;}}else if(d<p){if(y+=l+d-p,p-=d,p<k){k-=p;do{A[n++]=_[y++];}while(--p);if(y=0,d<k){p=d,k-=p;do{A[n++]=_[y++];}while(--p);y=n-v,x=A;}}}else if(y+=d-p,p<k){k-=p;do{A[n++]=_[y++];}while(--p);y=n-v,x=A;}for(;k>2;){A[n++]=x[y++],A[n++]=x[y++],A[n++]=x[y++],k-=3;}k&&(A[n++]=x[y++],k>1&&(A[n++]=x[y++]));}else{y=n-v;do{A[n++]=A[y++],A[n++]=A[y++],A[n++]=A[y++],k-=3;}while(k>2);k&&(A[n++]=A[y++],k>1&&(A[n++]=A[y++]));}break;}}break;}}while(a<i&&n<r);k=c>>3,a-=k,c-=k<<3,f&=(1<<c)-1,t.next_in=a,t.next_out=n,t.avail_in=a<i?i-a+5:5-(a-i),t.avail_out=n<r?r-n+257:257-(n-r),E.hold=f,E.bits=c;};var _e=15,fe=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),ce=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ue=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),we=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var me=function me(t,e,a,i,n,s,r,o){var l=o.bits;var h,d,_,f,c,u,w=0,m=0,b=0,g=0,p=0,k=0,v=0,y=0,x=0,z=0,A=null;var E=new Uint16Array(16),R=new Uint16Array(16);var Z,U,S,D=null;for(w=0;w<=_e;w++){E[w]=0;}for(m=0;m<i;m++){E[e[a+m]]++;}for(p=l,g=_e;g>=1&&0===E[g];g--){;}if(p>g&&(p=g),0===g)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(b=1;b<g&&0===E[b];b++){;}for(p<b&&(p=b),y=1,w=1;w<=_e;w++){if(y<<=1,y-=E[w],y<0)return-1;}if(y>0&&(0===t||1!==g))return-1;for(R[1]=0,w=1;w<_e;w++){R[w+1]=R[w]+E[w];}for(m=0;m<i;m++){0!==e[a+m]&&(r[R[e[a+m]]++]=m);}if(0===t?(A=D=r,u=20):1===t?(A=fe,D=ce,u=257):(A=ue,D=we,u=0),z=0,m=0,w=b,c=s,k=p,v=0,_=-1,x=1<<p,f=x-1,1===t&&x>852||2===t&&x>592)return 1;for(;;){Z=w-v,r[m]+1<u?(U=0,S=r[m]):r[m]>=u?(U=D[r[m]-u],S=A[r[m]-u]):(U=96,S=0),h=1<<w-v,d=1<<k,b=d;do{d-=h,n[c+(z>>v)+d]=Z<<24|U<<16|S|0;}while(0!==d);for(h=1<<w-1;z&h;){h>>=1;}if(0!==h?(z&=h-1,z+=h):z=0,m++,0==--E[w]){if(w===g)break;w=e[a+r[m]];}if(w>p&&(z&f)!==_){for(0===v&&(v=p),c+=b,k=w-v,y=1<<k;k+v<g&&(y-=E[k+v],!(y<=0));){k++,y<<=1;}if(x+=1<<k,1===t&&x>852||2===t&&x>592)return 1;_=z&f,n[_]=p<<24|k<<16|c-s|0;}}return 0!==z&&(n[c+z]=w-v<<24|64<<16|0),o.bits=p,0;};var be=K.Z_FINISH,ge=K.Z_BLOCK,pe=K.Z_TREES,ke=K.Z_OK,ve=K.Z_STREAM_END,ye=K.Z_NEED_DICT,xe=K.Z_STREAM_ERROR,ze=K.Z_DATA_ERROR,Ae=K.Z_MEM_ERROR,Ee=K.Z_BUF_ERROR,Re=K.Z_DEFLATED,Ze=16180,Ue=16190,Se=16191,De=16192,Te=16194,Oe=16199,Ie=16200,Fe=16206,Le=16209,Ne=function Ne(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);};function Be(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}var Ce=function Ce(t){if(!t)return 1;var e=t.state;return!e||e.strm!==t||e.mode<Ze||e.mode>16211?1:0;},Me=function Me(t){if(Ce(t))return xe;var e=t.state;return t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=Ze,e.last=0,e.havedict=0,e.flags=-1,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,ke;},He=function He(t){if(Ce(t))return xe;var e=t.state;return e.wsize=0,e.whave=0,e.wnext=0,Me(t);},je=function je(t,e){var a;if(Ce(t))return xe;var i=t.state;return e<0?(a=0,e=-e):(a=5+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?xe:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,He(t));},Ke=function Ke(t,e){if(!t)return xe;var a=new Be();t.state=a,a.strm=t,a.window=null,a.mode=Ze;var i=je(t,e);return i!==ke&&(t.state=null),i;};var Pe,Ye,Ge=!0;var Xe=function Xe(t){if(Ge){Pe=new Int32Array(512),Ye=new Int32Array(32);var _e11=0;for(;_e11<144;){t.lens[_e11++]=8;}for(;_e11<256;){t.lens[_e11++]=9;}for(;_e11<280;){t.lens[_e11++]=7;}for(;_e11<288;){t.lens[_e11++]=8;}for(me(1,t.lens,0,288,Pe,0,t.work,{bits:9}),_e11=0;_e11<32;){t.lens[_e11++]=5;}me(2,t.lens,0,32,Ye,0,t.work,{bits:5}),Ge=!1;}t.lencode=Pe,t.lenbits=9,t.distcode=Ye,t.distbits=5;},We=function We(t,e,a,i){var n;var s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new Uint8Array(s.wsize)),i>=s.wsize?(s.window.set(e.subarray(a-s.wsize,a),0),s.wnext=0,s.whave=s.wsize):(n=s.wsize-s.wnext,n>i&&(n=i),s.window.set(e.subarray(a-i,a-i+n),s.wnext),(i-=n)?(s.window.set(e.subarray(a-i,a),0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0;};var qe={inflateReset:He,inflateReset2:je,inflateResetKeep:Me,inflateInit:function inflateInit(t){return Ke(t,15);},inflateInit2:Ke,inflate:function inflate(t,e){var a,i,n,s,r,o,l,h,d,_,f,c,u,w,m,b,g,p,k,v,y,x,z=0;var A=new Uint8Array(4);var E,R;var Z=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Ce(t)||!t.output||!t.input&&0!==t.avail_in)return xe;a=t.state,a.mode===Se&&(a.mode=De),r=t.next_out,n=t.output,l=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,h=a.hold,d=a.bits,_=o,f=l,x=ke;t:for(;;){switch(a.mode){case Ze:if(0===a.wrap){a.mode=De;break;}for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(2&a.wrap&&35615===h){0===a.wbits&&(a.wbits=15),a.check=0,A[0]=255&h,A[1]=h>>>8&255,a.check=H(a.check,A,2,0),h=0,d=0,a.mode=16181;break;}if(a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&h)<<8)+(h>>8))%31){t.msg="incorrect header check",a.mode=Le;break;}if((15&h)!==Re){t.msg="unknown compression method",a.mode=Le;break;}if(h>>>=4,d-=4,y=8+(15&h),0===a.wbits&&(a.wbits=y),y>15||y>a.wbits){t.msg="invalid window size",a.mode=Le;break;}a.dmax=1<<a.wbits,a.flags=0,t.adler=a.check=1,a.mode=512&h?16189:Se,h=0,d=0;break;case 16181:for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(a.flags=h,(255&a.flags)!==Re){t.msg="unknown compression method",a.mode=Le;break;}if(57344&a.flags){t.msg="unknown header flags set",a.mode=Le;break;}a.head&&(a.head.text=h>>8&1),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=H(a.check,A,2,0)),h=0,d=0,a.mode=16182;case 16182:for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}a.head&&(a.head.time=h),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,A[2]=h>>>16&255,A[3]=h>>>24&255,a.check=H(a.check,A,4,0)),h=0,d=0,a.mode=16183;case 16183:for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}a.head&&(a.head.xflags=255&h,a.head.os=h>>8),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=H(a.check,A,2,0)),h=0,d=0,a.mode=16184;case 16184:if(1024&a.flags){for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}a.length=h,a.head&&(a.head.extra_len=h),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=H(a.check,A,2,0)),h=0,d=0;}else a.head&&(a.head.extra=null);a.mode=16185;case 16185:if(1024&a.flags&&(c=a.length,c>o&&(c=o),c&&(a.head&&(y=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Uint8Array(a.head.extra_len)),a.head.extra.set(i.subarray(s,s+c),y)),512&a.flags&&4&a.wrap&&(a.check=H(a.check,i,c,s)),o-=c,s+=c,a.length-=c),a.length))break t;a.length=0,a.mode=16186;case 16186:if(2048&a.flags){if(0===o)break t;c=0;do{y=i[s+c++],a.head&&y&&a.length<65536&&(a.head.name+=String.fromCharCode(y));}while(y&&c<o);if(512&a.flags&&4&a.wrap&&(a.check=H(a.check,i,c,s)),o-=c,s+=c,y)break t;}else a.head&&(a.head.name=null);a.length=0,a.mode=16187;case 16187:if(4096&a.flags){if(0===o)break t;c=0;do{y=i[s+c++],a.head&&y&&a.length<65536&&(a.head.comment+=String.fromCharCode(y));}while(y&&c<o);if(512&a.flags&&4&a.wrap&&(a.check=H(a.check,i,c,s)),o-=c,s+=c,y)break t;}else a.head&&(a.head.comment=null);a.mode=16188;case 16188:if(512&a.flags){for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(4&a.wrap&&h!==(65535&a.check)){t.msg="header crc mismatch",a.mode=Le;break;}h=0,d=0;}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=Se;break;case 16189:for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}t.adler=a.check=Ne(h),h=0,d=0,a.mode=Ue;case Ue:if(0===a.havedict)return t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,ye;t.adler=a.check=1,a.mode=Se;case Se:if(e===ge||e===pe)break t;case De:if(a.last){h>>>=7&d,d-=7&d,a.mode=Fe;break;}for(;d<3;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}switch(a.last=1&h,h>>>=1,d-=1,3&h){case 0:a.mode=16193;break;case 1:if(Xe(a),a.mode=Oe,e===pe){h>>>=2,d-=2;break t;}break;case 2:a.mode=16196;break;case 3:t.msg="invalid block type",a.mode=Le;}h>>>=2,d-=2;break;case 16193:for(h>>>=7&d,d-=7&d;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if((65535&h)!=(h>>>16^65535)){t.msg="invalid stored block lengths",a.mode=Le;break;}if(a.length=65535&h,h=0,d=0,a.mode=Te,e===pe)break t;case Te:a.mode=16195;case 16195:if(c=a.length,c){if(c>o&&(c=o),c>l&&(c=l),0===c)break t;n.set(i.subarray(s,s+c),r),o-=c,s+=c,l-=c,r+=c,a.length-=c;break;}a.mode=Se;break;case 16196:for(;d<14;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(a.nlen=257+(31&h),h>>>=5,d-=5,a.ndist=1+(31&h),h>>>=5,d-=5,a.ncode=4+(15&h),h>>>=4,d-=4,a.nlen>286||a.ndist>30){t.msg="too many length or distance symbols",a.mode=Le;break;}a.have=0,a.mode=16197;case 16197:for(;a.have<a.ncode;){for(;d<3;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}a.lens[Z[a.have++]]=7&h,h>>>=3,d-=3;}for(;a.have<19;){a.lens[Z[a.have++]]=0;}if(a.lencode=a.lendyn,a.lenbits=7,E={bits:a.lenbits},x=me(0,a.lens,0,19,a.lencode,0,a.work,E),a.lenbits=E.bits,x){t.msg="invalid code lengths set",a.mode=Le;break;}a.have=0,a.mode=16198;case 16198:for(;a.have<a.nlen+a.ndist;){for(;z=a.lencode[h&(1<<a.lenbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(g<16)h>>>=m,d-=m,a.lens[a.have++]=g;else{if(16===g){for(R=m+2;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(h>>>=m,d-=m,0===a.have){t.msg="invalid bit length repeat",a.mode=Le;break;}y=a.lens[a.have-1],c=3+(3&h),h>>>=2,d-=2;}else if(17===g){for(R=m+3;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}h>>>=m,d-=m,y=0,c=3+(7&h),h>>>=3,d-=3;}else{for(R=m+7;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}h>>>=m,d-=m,y=0,c=11+(127&h),h>>>=7,d-=7;}if(a.have+c>a.nlen+a.ndist){t.msg="invalid bit length repeat",a.mode=Le;break;}for(;c--;){a.lens[a.have++]=y;}}}if(a.mode===Le)break;if(0===a.lens[256]){t.msg="invalid code -- missing end-of-block",a.mode=Le;break;}if(a.lenbits=9,E={bits:a.lenbits},x=me(1,a.lens,0,a.nlen,a.lencode,0,a.work,E),a.lenbits=E.bits,x){t.msg="invalid literal/lengths set",a.mode=Le;break;}if(a.distbits=6,a.distcode=a.distdyn,E={bits:a.distbits},x=me(2,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,E),a.distbits=E.bits,x){t.msg="invalid distances set",a.mode=Le;break;}if(a.mode=Oe,e===pe)break t;case Oe:a.mode=Ie;case Ie:if(o>=6&&l>=258){t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,de(t,f),r=t.next_out,n=t.output,l=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,h=a.hold,d=a.bits,a.mode===Se&&(a.back=-1);break;}for(a.back=0;z=a.lencode[h&(1<<a.lenbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(b&&0==(240&b)){for(p=m,k=b,v=g;z=a.lencode[v+((h&(1<<p+k)-1)>>p)],m=z>>>24,b=z>>>16&255,g=65535&z,!(p+m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}h>>>=p,d-=p,a.back+=p;}if(h>>>=m,d-=m,a.back+=m,a.length=g,0===b){a.mode=16205;break;}if(32&b){a.back=-1,a.mode=Se;break;}if(64&b){t.msg="invalid literal/length code",a.mode=Le;break;}a.extra=15&b,a.mode=16201;case 16201:if(a.extra){for(R=a.extra;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}a.length+=h&(1<<a.extra)-1,h>>>=a.extra,d-=a.extra,a.back+=a.extra;}a.was=a.length,a.mode=16202;case 16202:for(;z=a.distcode[h&(1<<a.distbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(0==(240&b)){for(p=m,k=b,v=g;z=a.distcode[v+((h&(1<<p+k)-1)>>p)],m=z>>>24,b=z>>>16&255,g=65535&z,!(p+m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}h>>>=p,d-=p,a.back+=p;}if(h>>>=m,d-=m,a.back+=m,64&b){t.msg="invalid distance code",a.mode=Le;break;}a.offset=g,a.extra=15&b,a.mode=16203;case 16203:if(a.extra){for(R=a.extra;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}a.offset+=h&(1<<a.extra)-1,h>>>=a.extra,d-=a.extra,a.back+=a.extra;}if(a.offset>a.dmax){t.msg="invalid distance too far back",a.mode=Le;break;}a.mode=16204;case 16204:if(0===l)break t;if(c=f-l,a.offset>c){if(c=a.offset-c,c>a.whave&&a.sane){t.msg="invalid distance too far back",a.mode=Le;break;}c>a.wnext?(c-=a.wnext,u=a.wsize-c):u=a.wnext-c,c>a.length&&(c=a.length),w=a.window;}else w=n,u=r-a.offset,c=a.length;c>l&&(c=l),l-=c,a.length-=c;do{n[r++]=w[u++];}while(--c);0===a.length&&(a.mode=Ie);break;case 16205:if(0===l)break t;n[r++]=a.length,l--,a.mode=Ie;break;case Fe:if(a.wrap){for(;d<32;){if(0===o)break t;o--,h|=i[s++]<<d,d+=8;}if(f-=l,t.total_out+=f,a.total+=f,4&a.wrap&&f&&(t.adler=a.check=a.flags?H(a.check,n,f,r-f):C(a.check,n,f,r-f)),f=l,4&a.wrap&&(a.flags?h:Ne(h))!==a.check){t.msg="incorrect data check",a.mode=Le;break;}h=0,d=0;}a.mode=16207;case 16207:if(a.wrap&&a.flags){for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8;}if(4&a.wrap&&h!==(4294967295&a.total)){t.msg="incorrect length check",a.mode=Le;break;}h=0,d=0;}a.mode=16208;case 16208:x=ve;break t;case Le:x=ze;break t;case 16210:return Ae;default:return xe;}}return t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,(a.wsize||f!==t.avail_out&&a.mode<Le&&(a.mode<Fe||e!==be))&&We(t,t.output,t.next_out,f-t.avail_out),_-=t.avail_in,f-=t.avail_out,t.total_in+=_,t.total_out+=f,a.total+=f,4&a.wrap&&f&&(t.adler=a.check=a.flags?H(a.check,n,f,t.next_out-f):C(a.check,n,f,t.next_out-f)),t.data_type=a.bits+(a.last?64:0)+(a.mode===Se?128:0)+(a.mode===Oe||a.mode===Te?256:0),(0===_&&0===f||e===be)&&x===ke&&(x=Ee),x;},inflateEnd:function inflateEnd(t){if(Ce(t))return xe;var e=t.state;return e.window&&(e.window=null),t.state=null,ke;},inflateGetHeader:function inflateGetHeader(t,e){if(Ce(t))return xe;var a=t.state;return 0==(2&a.wrap)?xe:(a.head=e,e.done=!1,ke);},inflateSetDictionary:function inflateSetDictionary(t,e){var a=e.length;var i,n,s;return Ce(t)?xe:(i=t.state,0!==i.wrap&&i.mode!==Ue?xe:i.mode===Ue&&(n=1,n=C(n,e,a,0),n!==i.check)?ze:(s=We(t,e,a,a),s?(i.mode=16210,Ae):(i.havedict=1,ke)));},inflateInfo:"pako inflate (from Nodeca project)"};var Je=function Je(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;};var Qe=Object.prototype.toString,Ve=K.Z_NO_FLUSH,$e=K.Z_FINISH,ta=K.Z_OK,ea=K.Z_STREAM_END,aa=K.Z_NEED_DICT,ia=K.Z_STREAM_ERROR,na=K.Z_DATA_ERROR,sa=K.Z_MEM_ERROR;function ra(t){this.options=jt({chunkSize:65536,windowBits:15,to:""},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new qt(),this.strm.avail_out=0;var a=qe.inflateInit2(this.strm,e.windowBits);if(a!==ta)throw new Error(j[a]);if(this.header=new Je(),qe.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Gt(e.dictionary):"[object ArrayBuffer]"===Qe.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(a=qe.inflateSetDictionary(this.strm,e.dictionary),a!==ta)))throw new Error(j[a]);}function oa(t,e){var a=new ra(e);if(a.push(t),a.err)throw a.msg||j[a.err];return a.result;}ra.prototype.push=function(t,e){var a=this.strm,i=this.options.chunkSize,n=this.options.dictionary;var s,r,o;if(this.ended)return!1;for(r=e===~~e?e:!0===e?$e:Ve,"[object ArrayBuffer]"===Qe.call(t)?a.input=new Uint8Array(t):a.input=t,a.next_in=0,a.avail_in=a.input.length;;){for(0===a.avail_out&&(a.output=new Uint8Array(i),a.next_out=0,a.avail_out=i),s=qe.inflate(a,r),s===aa&&n&&(s=qe.inflateSetDictionary(a,n),s===ta?s=qe.inflate(a,r):s===na&&(s=aa));a.avail_in>0&&s===ea&&a.state.wrap>0&&0!==t[a.next_in];){qe.inflateReset(a),s=qe.inflate(a,r);}switch(s){case ia:case na:case aa:case sa:return this.onEnd(s),this.ended=!0,!1;}if(o=a.avail_out,a.next_out&&(0===a.avail_out||s===ea))if("string"===this.options.to){var _t6=Wt(a.output,a.next_out),_e12=a.next_out-_t6,_n6=Xt(a.output,_t6);a.next_out=_e12,a.avail_out=i-_e12,_e12&&a.output.set(a.output.subarray(_t6,_t6+_e12),0),this.onData(_n6);}else this.onData(a.output.length===a.next_out?a.output:a.output.subarray(0,a.next_out));if(s!==ta||0!==o){if(s===ea)return s=qe.inflateEnd(this.strm),this.onEnd(s),this.ended=!0,!0;if(0===a.avail_in)break;}}return!0;},ra.prototype.onData=function(t){this.chunks.push(t);},ra.prototype.onEnd=function(t){t===ta&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Kt(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg;};var la={Inflate:ra,inflate:oa,inflateRaw:function inflateRaw(t,e){return(e=e||{}).raw=!0,oa(t,e);},ungzip:oa,constants:K};var ha=le.Deflate,da=le.deflate,_a=le.deflateRaw,fa=le.gzip,ca=la.Inflate,ua=la.inflate,wa=la.inflateRaw,ma=la.ungzip;var ba=ha,ga=da,pa=_a,ka=fa,va=ca,ya=ua,xa=wa,za=ma,Aa=K,Ea={Deflate:ba,deflate:ga,deflateRaw:pa,gzip:ka,Inflate:va,inflate:ya,inflateRaw:xa,ungzip:za,constants:Aa};t.Deflate=ba,t.Inflate=va,t.constants=Aa,t["default"]=Ea,t.deflate=ga,t.deflateRaw=pa,t.gzip=ka,t.inflate=ya,t.inflateRaw=xa,t.ungzip=za,Object.defineProperty(t,"__esModule",{value:!0});});var p=/*#__PURE__*/Object.freeze({__proto__:null});/*

 Parser for .XKT Format V1

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 DEPRECATED

 */var pako$9=window.pako||p;if(!pako$9.inflate){// See https://github.com/nodeca/pako/issues/97
pako$9=pako$9["default"];}var decompressColor$9=function(){var color2=new Float32Array(3);return function(color){color2[0]=color[0]/255.0;color2[1]=color[1]/255.0;color2[2]=color[2]/255.0;return color2;};}();function extract$9(elements){return{positions:elements[0],normals:elements[1],indices:elements[2],edgeIndices:elements[3],meshPositions:elements[4],meshIndices:elements[5],meshEdgesIndices:elements[6],meshColors:elements[7],entityIDs:elements[8],entityMeshes:elements[9],entityIsObjects:elements[10],positionsDecodeMatrix:elements[11]};}function inflate$9(deflatedData){return{positions:new Uint16Array(pako$9.inflate(deflatedData.positions).buffer),normals:new Int8Array(pako$9.inflate(deflatedData.normals).buffer),indices:new Uint32Array(pako$9.inflate(deflatedData.indices).buffer),edgeIndices:new Uint32Array(pako$9.inflate(deflatedData.edgeIndices).buffer),meshPositions:new Uint32Array(pako$9.inflate(deflatedData.meshPositions).buffer),meshIndices:new Uint32Array(pako$9.inflate(deflatedData.meshIndices).buffer),meshEdgesIndices:new Uint32Array(pako$9.inflate(deflatedData.meshEdgesIndices).buffer),meshColors:new Uint8Array(pako$9.inflate(deflatedData.meshColors).buffer),entityIDs:pako$9.inflate(deflatedData.entityIDs,{to:'string'}),entityMeshes:new Uint32Array(pako$9.inflate(deflatedData.entityMeshes).buffer),entityIsObjects:new Uint8Array(pako$9.inflate(deflatedData.entityIsObjects).buffer),positionsDecodeMatrix:new Float32Array(pako$9.inflate(deflatedData.positionsDecodeMatrix).buffer)};}function load$9(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){manifestCtx.getNextId();sceneModel.positionsCompression="precompressed";sceneModel.normalsCompression="precompressed";var positions=inflatedData.positions;var normals=inflatedData.normals;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var meshPositions=inflatedData.meshPositions;var meshIndices=inflatedData.meshIndices;var meshEdgesIndices=inflatedData.meshEdgesIndices;var meshColors=inflatedData.meshColors;var entityIDs=JSON.parse(inflatedData.entityIDs);var entityMeshes=inflatedData.entityMeshes;var entityIsObjects=inflatedData.entityIsObjects;var numMeshes=meshPositions.length;var numEntities=entityMeshes.length;for(var _i553=0;_i553<numEntities;_i553++){var xktEntityId=entityIDs[_i553];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};if(metaObject){if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}}}else{if(options.excludeUnclassifiedObjects){continue;}}var lastEntity=_i553===numEntities-1;var meshIds=[];for(var j=entityMeshes[_i553],jlen=lastEntity?entityMeshes.length:entityMeshes[_i553+1];j<jlen;j++){var lastMesh=j===numMeshes-1;var meshId=entityId+".mesh."+j;var _color6=decompressColor$9(meshColors.subarray(j*4,j*4+3));var _opacity=meshColors[j*4+3]/255.0;sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,primitive:"triangles",positionsCompressed:positions.subarray(meshPositions[j],lastMesh?positions.length:meshPositions[j+1]),normalsCompressed:normals.subarray(meshPositions[j],lastMesh?positions.length:meshPositions[j+1]),indices:indices.subarray(meshIndices[j],lastMesh?indices.length:meshIndices[j+1]),edgeIndices:edgeIndices.subarray(meshEdgesIndices[j],lastMesh?edgeIndices.length:meshEdgesIndices[j+1]),positionsDecodeMatrix:inflatedData.positionsDecodeMatrix,color:_color6,opacity:_opacity}));meshIds.push(meshId);}sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:entityIsObjects[_i553]===1,meshIds:meshIds}));}}/** @private */var ParserV1={version:1,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$9(elements);var inflatedData=inflate$9(deflatedData);load$9(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

Parser for .XKT Format V2

DEPRECATED

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */var pako$8=window.pako||p;if(!pako$8.inflate){// See https://github.com/nodeca/pako/issues/97
pako$8=pako$8["default"];}function extract$8(elements){return{positions:elements[0],normals:elements[1],indices:elements[2],edgeIndices:elements[3],meshPositions:elements[4],meshIndices:elements[5],meshEdgesIndices:elements[6],meshColors:elements[7],entityIDs:elements[8],entityMeshes:elements[9],entityIsObjects:elements[10],positionsDecodeMatrix:elements[11],entityMeshIds:elements[12],entityMatrices:elements[13],entityUsesInstancing:elements[14]};}function inflate$8(deflatedData){return{positions:new Uint16Array(pako$8.inflate(deflatedData.positions).buffer),normals:new Int8Array(pako$8.inflate(deflatedData.normals).buffer),indices:new Uint32Array(pako$8.inflate(deflatedData.indices).buffer),edgeIndices:new Uint32Array(pako$8.inflate(deflatedData.edgeIndices).buffer),meshPositions:new Uint32Array(pako$8.inflate(deflatedData.meshPositions).buffer),meshIndices:new Uint32Array(pako$8.inflate(deflatedData.meshIndices).buffer),meshEdgesIndices:new Uint32Array(pako$8.inflate(deflatedData.meshEdgesIndices).buffer),meshColors:new Uint8Array(pako$8.inflate(deflatedData.meshColors).buffer),entityIDs:pako$8.inflate(deflatedData.entityIDs,{to:'string'}),entityMeshes:new Uint32Array(pako$8.inflate(deflatedData.entityMeshes).buffer),entityIsObjects:new Uint8Array(pako$8.inflate(deflatedData.entityIsObjects).buffer),positionsDecodeMatrix:new Float32Array(pako$8.inflate(deflatedData.positionsDecodeMatrix).buffer),entityMeshIds:new Uint32Array(pako$8.inflate(deflatedData.entityMeshIds).buffer),entityMatrices:new Float32Array(pako$8.inflate(deflatedData.entityMatrices).buffer),entityUsesInstancing:new Uint8Array(pako$8.inflate(deflatedData.entityUsesInstancing).buffer)};}var decompressColor$8=function(){var color2=new Float32Array(3);return function(color){color2[0]=color[0]/255.0;color2[1]=color[1]/255.0;color2[2]=color[2]/255.0;return color2;};}();function load$8(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();sceneModel.positionsCompression="precompressed";sceneModel.normalsCompression="precompressed";var positions=inflatedData.positions;var normals=inflatedData.normals;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var meshPositions=inflatedData.meshPositions;var meshIndices=inflatedData.meshIndices;var meshEdgesIndices=inflatedData.meshEdgesIndices;var meshColors=inflatedData.meshColors;var entityIDs=JSON.parse(inflatedData.entityIDs);var entityMeshes=inflatedData.entityMeshes;var entityIsObjects=inflatedData.entityIsObjects;var entityMeshIds=inflatedData.entityMeshIds;var entityMatrices=inflatedData.entityMatrices;var entityUsesInstancing=inflatedData.entityUsesInstancing;var numMeshes=meshPositions.length;var numEntities=entityMeshes.length;var alreadyCreatedGeometries={};for(var _i554=0;_i554<numEntities;_i554++){var xktEntityId=entityIDs[_i554];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};var entityMatrix=entityMatrices.subarray(_i554*16,_i554*16+16);if(metaObject){if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}}}else{if(options.excludeUnclassifiedObjects){continue;}}var lastEntity=_i554===numEntities-1;var meshIds=[];for(var j=entityMeshes[_i554],jlen=lastEntity?entityMeshIds.length:entityMeshes[_i554+1];j<jlen;j++){var jj=entityMeshIds[j];var lastMesh=jj===numMeshes-1;var meshId=manifestCtx.getNextId();var _color7=decompressColor$8(meshColors.subarray(jj*4,jj*4+3));var _opacity2=meshColors[jj*4+3]/255.0;var tmpPositions=positions.subarray(meshPositions[jj],lastMesh?positions.length:meshPositions[jj+1]);var tmpNormals=normals.subarray(meshPositions[jj],lastMesh?positions.length:meshPositions[jj+1]);var tmpIndices=indices.subarray(meshIndices[jj],lastMesh?indices.length:meshIndices[jj+1]);var tmpEdgeIndices=edgeIndices.subarray(meshEdgesIndices[jj],lastMesh?edgeIndices.length:meshEdgesIndices[jj+1]);if(entityUsesInstancing[_i554]===1){var geometryId="".concat(modelPartId,".geometry.").concat(meshId,".").concat(jj);if(!(geometryId in alreadyCreatedGeometries)){sceneModel.createGeometry({id:geometryId,positionsCompressed:tmpPositions,normalsCompressed:tmpNormals,indices:tmpIndices,edgeIndices:tmpEdgeIndices,primitive:"triangles",positionsDecodeMatrix:inflatedData.positionsDecodeMatrix});alreadyCreatedGeometries[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,color:_color7,opacity:_opacity2,matrix:entityMatrix,geometryId:geometryId}));meshIds.push(meshId);}else{sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,primitive:"triangles",positionsCompressed:tmpPositions,normalsCompressed:tmpNormals,indices:tmpIndices,edgeIndices:tmpEdgeIndices,positionsDecodeMatrix:inflatedData.positionsDecodeMatrix,color:_color7,opacity:_opacity2}));meshIds.push(meshId);}}if(meshIds.length){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:entityIsObjects[_i554]===1,meshIds:meshIds}));}}}/** @private */var ParserV2={version:2,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$8(elements);var inflatedData=inflate$8(deflatedData);load$8(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

Parser for .XKT Format V3

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */var pako$7=window.pako||p;if(!pako$7.inflate){// See https://github.com/nodeca/pako/issues/97
pako$7=pako$7["default"];}function extract$7(elements){return{positions:elements[0],normals:elements[1],indices:elements[2],edgeIndices:elements[3],meshPositions:elements[4],meshIndices:elements[5],meshEdgesIndices:elements[6],meshColors:elements[7],entityIDs:elements[8],entityMeshes:elements[9],entityIsObjects:elements[10],instancedPositionsDecodeMatrix:elements[11],batchedPositionsDecodeMatrix:elements[12],entityMeshIds:elements[13],entityMatrices:elements[14],entityUsesInstancing:elements[15]};}function inflate$7(deflatedData){return{positions:new Uint16Array(pako$7.inflate(deflatedData.positions).buffer),normals:new Int8Array(pako$7.inflate(deflatedData.normals).buffer),indices:new Uint32Array(pako$7.inflate(deflatedData.indices).buffer),edgeIndices:new Uint32Array(pako$7.inflate(deflatedData.edgeIndices).buffer),meshPositions:new Uint32Array(pako$7.inflate(deflatedData.meshPositions).buffer),meshIndices:new Uint32Array(pako$7.inflate(deflatedData.meshIndices).buffer),meshEdgesIndices:new Uint32Array(pako$7.inflate(deflatedData.meshEdgesIndices).buffer),meshColors:new Uint8Array(pako$7.inflate(deflatedData.meshColors).buffer),entityIDs:pako$7.inflate(deflatedData.entityIDs,{to:'string'}),entityMeshes:new Uint32Array(pako$7.inflate(deflatedData.entityMeshes).buffer),entityIsObjects:new Uint8Array(pako$7.inflate(deflatedData.entityIsObjects).buffer),instancedPositionsDecodeMatrix:new Float32Array(pako$7.inflate(deflatedData.instancedPositionsDecodeMatrix).buffer),batchedPositionsDecodeMatrix:new Float32Array(pako$7.inflate(deflatedData.batchedPositionsDecodeMatrix).buffer),entityMeshIds:new Uint32Array(pako$7.inflate(deflatedData.entityMeshIds).buffer),entityMatrices:new Float32Array(pako$7.inflate(deflatedData.entityMatrices).buffer),entityUsesInstancing:new Uint8Array(pako$7.inflate(deflatedData.entityUsesInstancing).buffer)};}var decompressColor$7=function(){var color2=new Float32Array(3);return function(color){color2[0]=color[0]/255.0;color2[1]=color[1]/255.0;color2[2]=color[2]/255.0;return color2;};}();function load$7(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();sceneModel.positionsCompression="precompressed";sceneModel.normalsCompression="precompressed";var positions=inflatedData.positions;var normals=inflatedData.normals;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var meshPositions=inflatedData.meshPositions;var meshIndices=inflatedData.meshIndices;var meshEdgesIndices=inflatedData.meshEdgesIndices;var meshColors=inflatedData.meshColors;var entityIDs=JSON.parse(inflatedData.entityIDs);var entityMeshes=inflatedData.entityMeshes;var entityIsObjects=inflatedData.entityIsObjects;var entityMeshIds=inflatedData.entityMeshIds;var entityMatrices=inflatedData.entityMatrices;var entityUsesInstancing=inflatedData.entityUsesInstancing;var numMeshes=meshPositions.length;var numEntities=entityMeshes.length;var _alreadyCreatedGeometries={};for(var _i555=0;_i555<numEntities;_i555++){var xktEntityId=entityIDs[_i555];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};var entityMatrix=entityMatrices.subarray(_i555*16,_i555*16+16);if(metaObject){if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}}}else{if(options.excludeUnclassifiedObjects){continue;}}var lastEntity=_i555===numEntities-1;var meshIds=[];for(var j=entityMeshes[_i555],jlen=lastEntity?entityMeshIds.length:entityMeshes[_i555+1];j<jlen;j++){var jj=entityMeshIds[j];var lastMesh=jj===numMeshes-1;var meshId="".concat(modelPartId,".").concat(entityId,".mesh.").concat(jj);var _color8=decompressColor$7(meshColors.subarray(jj*4,jj*4+3));var _opacity3=meshColors[jj*4+3]/255.0;var tmpPositions=positions.subarray(meshPositions[jj],lastMesh?positions.length:meshPositions[jj+1]);var tmpNormals=normals.subarray(meshPositions[jj],lastMesh?positions.length:meshPositions[jj+1]);var tmpIndices=indices.subarray(meshIndices[jj],lastMesh?indices.length:meshIndices[jj+1]);var tmpEdgeIndices=edgeIndices.subarray(meshEdgesIndices[jj],lastMesh?edgeIndices.length:meshEdgesIndices[jj+1]);if(entityUsesInstancing[_i555]===1){var geometryId="".concat(modelPartId,".geometry.").concat(meshId,".").concat(jj);if(!(geometryId in _alreadyCreatedGeometries)){sceneModel.createGeometry({id:geometryId,positionsCompressed:tmpPositions,normalsCompressed:tmpNormals,indices:tmpIndices,edgeIndices:tmpEdgeIndices,primitive:"triangles",positionsDecodeMatrix:inflatedData.instancedPositionsDecodeMatrix});_alreadyCreatedGeometries[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,color:_color8,opacity:_opacity3,matrix:entityMatrix,geometryId:geometryId}));meshIds.push(meshId);}else{sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,primitive:"triangles",positionsCompressed:tmpPositions,normalsCompressed:tmpNormals,indices:tmpIndices,edgeIndices:tmpEdgeIndices,positionsDecodeMatrix:inflatedData.batchedPositionsDecodeMatrix,color:_color8,opacity:_opacity3}));meshIds.push(meshId);}}if(meshIds.length){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:entityIsObjects[_i555]===1,meshIds:meshIds}));}}}/** @private */var ParserV3={version:3,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$7(elements);var inflatedData=inflate$7(deflatedData);load$7(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

Parser for .XKT Format V4

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */var pako$6=window.pako||p;if(!pako$6.inflate){// See https://github.com/nodeca/pako/issues/97
pako$6=pako$6["default"];}function extract$6(elements){return{positions:elements[0],normals:elements[1],indices:elements[2],edgeIndices:elements[3],decodeMatrices:elements[4],matrices:elements[5],eachPrimitivePositionsAndNormalsPortion:elements[6],eachPrimitiveIndicesPortion:elements[7],eachPrimitiveEdgeIndicesPortion:elements[8],eachPrimitiveDecodeMatricesPortion:elements[9],eachPrimitiveColor:elements[10],primitiveInstances:elements[11],eachEntityId:elements[12],eachEntityPrimitiveInstancesPortion:elements[13],eachEntityMatricesPortion:elements[14],eachEntityMatrix:elements[15]};}function inflate$6(deflatedData){return{positions:new Uint16Array(pako$6.inflate(deflatedData.positions).buffer),normals:new Int8Array(pako$6.inflate(deflatedData.normals).buffer),indices:new Uint32Array(pako$6.inflate(deflatedData.indices).buffer),edgeIndices:new Uint32Array(pako$6.inflate(deflatedData.edgeIndices).buffer),decodeMatrices:new Float32Array(pako$6.inflate(deflatedData.decodeMatrices).buffer),matrices:new Float32Array(pako$6.inflate(deflatedData.matrices).buffer),eachPrimitivePositionsAndNormalsPortion:new Uint32Array(pako$6.inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion).buffer),eachPrimitiveIndicesPortion:new Uint32Array(pako$6.inflate(deflatedData.eachPrimitiveIndicesPortion).buffer),eachPrimitiveEdgeIndicesPortion:new Uint32Array(pako$6.inflate(deflatedData.eachPrimitiveEdgeIndicesPortion).buffer),eachPrimitiveDecodeMatricesPortion:new Uint32Array(pako$6.inflate(deflatedData.eachPrimitiveDecodeMatricesPortion).buffer),eachPrimitiveColor:new Uint8Array(pako$6.inflate(deflatedData.eachPrimitiveColor).buffer),primitiveInstances:new Uint32Array(pako$6.inflate(deflatedData.primitiveInstances).buffer),eachEntityId:pako$6.inflate(deflatedData.eachEntityId,{to:'string'}),eachEntityPrimitiveInstancesPortion:new Uint32Array(pako$6.inflate(deflatedData.eachEntityPrimitiveInstancesPortion).buffer),eachEntityMatricesPortion:new Uint32Array(pako$6.inflate(deflatedData.eachEntityMatricesPortion).buffer)};}var decompressColor$6=function(){var color2=new Float32Array(3);return function(color){color2[0]=color[0]/255.0;color2[1]=color[1]/255.0;color2[2]=color[2]/255.0;return color2;};}();function load$6(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();sceneModel.positionsCompression="precompressed";sceneModel.normalsCompression="precompressed";var positions=inflatedData.positions;var normals=inflatedData.normals;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var decodeMatrices=inflatedData.decodeMatrices;var matrices=inflatedData.matrices;var eachPrimitivePositionsAndNormalsPortion=inflatedData.eachPrimitivePositionsAndNormalsPortion;var eachPrimitiveIndicesPortion=inflatedData.eachPrimitiveIndicesPortion;var eachPrimitiveEdgeIndicesPortion=inflatedData.eachPrimitiveEdgeIndicesPortion;var eachPrimitiveDecodeMatricesPortion=inflatedData.eachPrimitiveDecodeMatricesPortion;var eachPrimitiveColor=inflatedData.eachPrimitiveColor;var primitiveInstances=inflatedData.primitiveInstances;var eachEntityId=JSON.parse(inflatedData.eachEntityId);var eachEntityPrimitiveInstancesPortion=inflatedData.eachEntityPrimitiveInstancesPortion;var eachEntityMatricesPortion=inflatedData.eachEntityMatricesPortion;var numPrimitives=eachPrimitivePositionsAndNormalsPortion.length;var numPrimitiveInstances=primitiveInstances.length;var primitiveInstanceCounts=new Uint8Array(numPrimitives);// For each mesh, how many times it is instanced
var orderedPrimitiveIndexes=new Uint32Array(numPrimitives);// For each mesh, its index sorted into runs that share the same decode matrix
var numEntities=eachEntityId.length;// Get lookup that orders primitives into runs that share the same decode matrices;
// this is used to create meshes in batches that use the same decode matrix
for(var primitiveIndex=0;primitiveIndex<numPrimitives;primitiveIndex++){orderedPrimitiveIndexes[primitiveIndex]=primitiveIndex;}orderedPrimitiveIndexes.sort(function(i1,i2){if(eachPrimitiveDecodeMatricesPortion[i1]<eachPrimitiveDecodeMatricesPortion[i2]){return-1;}if(eachPrimitiveDecodeMatricesPortion[i1]>eachPrimitiveDecodeMatricesPortion[i2]){return 1;}return 0;});// Count instances of each primitive
for(var primitiveInstanceIndex=0;primitiveInstanceIndex<numPrimitiveInstances;primitiveInstanceIndex++){var _primitiveIndex=primitiveInstances[primitiveInstanceIndex];primitiveInstanceCounts[_primitiveIndex]++;}// Map batched primitives to the entities that will use them
var batchedPrimitiveEntityIndexes={};for(var entityIndex=0;entityIndex<numEntities;entityIndex++){var lastEntityIndex=numEntities-1;var atLastEntity=entityIndex===lastEntityIndex;var firstEntityPrimitiveInstanceIndex=eachEntityPrimitiveInstancesPortion[entityIndex];var lastEntityPrimitiveInstanceIndex=atLastEntity?eachEntityPrimitiveInstancesPortion[lastEntityIndex]:eachEntityPrimitiveInstancesPortion[entityIndex+1];for(var primitiveInstancesIndex=firstEntityPrimitiveInstanceIndex;primitiveInstancesIndex<lastEntityPrimitiveInstanceIndex;primitiveInstancesIndex++){var _primitiveIndex2=primitiveInstances[primitiveInstancesIndex];var primitiveInstanceCount=primitiveInstanceCounts[_primitiveIndex2];var isInstancedPrimitive=primitiveInstanceCount>1;if(!isInstancedPrimitive){batchedPrimitiveEntityIndexes[_primitiveIndex2]=entityIndex;}}}// Create 1) geometries for instanced primitives, and 2) meshes for batched primitives.  We create all the
// batched meshes now, before we create entities, because we're creating the batched meshes in runs that share
// the same decode matrices. Each run of meshes with the same decode matrix will end up in the same
// BatchingLayer; the SceneModel#createMesh() method starts a new BatchingLayer each time the decode
// matrix has changed since the last invocation of that method, hence why we need to order batched meshes
// in runs like this.
for(var _primitiveIndex3=0;_primitiveIndex3<numPrimitives;_primitiveIndex3++){var orderedPrimitiveIndex=orderedPrimitiveIndexes[_primitiveIndex3];var atLastPrimitive=orderedPrimitiveIndex===numPrimitives-1;var _primitiveInstanceCount=primitiveInstanceCounts[orderedPrimitiveIndex];var _isInstancedPrimitive=_primitiveInstanceCount>1;var _color9=decompressColor$6(eachPrimitiveColor.subarray(orderedPrimitiveIndex*4,orderedPrimitiveIndex*4+3));var _opacity4=eachPrimitiveColor[orderedPrimitiveIndex*4+3]/255.0;var primitivePositions=positions.subarray(eachPrimitivePositionsAndNormalsPortion[orderedPrimitiveIndex],atLastPrimitive?positions.length:eachPrimitivePositionsAndNormalsPortion[orderedPrimitiveIndex+1]);var primitiveNormals=normals.subarray(eachPrimitivePositionsAndNormalsPortion[orderedPrimitiveIndex],atLastPrimitive?normals.length:eachPrimitivePositionsAndNormalsPortion[orderedPrimitiveIndex+1]);var primitiveIndices=indices.subarray(eachPrimitiveIndicesPortion[orderedPrimitiveIndex],atLastPrimitive?indices.length:eachPrimitiveIndicesPortion[orderedPrimitiveIndex+1]);var primitiveEdgeIndices=edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion[orderedPrimitiveIndex],atLastPrimitive?edgeIndices.length:eachPrimitiveEdgeIndicesPortion[orderedPrimitiveIndex+1]);var primitiveDecodeMatrix=decodeMatrices.subarray(eachPrimitiveDecodeMatricesPortion[orderedPrimitiveIndex],eachPrimitiveDecodeMatricesPortion[orderedPrimitiveIndex]+16);if(_isInstancedPrimitive){// Primitive instanced by more than one entity, and has positions in Model-space
var geometryId="".concat(modelPartId,"-geometry.").concat(orderedPrimitiveIndex);// These IDs are local to the SceneModel
sceneModel.createGeometry({id:geometryId,primitive:"triangles",positionsCompressed:primitivePositions,normalsCompressed:primitiveNormals,indices:primitiveIndices,edgeIndices:primitiveEdgeIndices,positionsDecodeMatrix:primitiveDecodeMatrix});}else{// Primitive is used only by one entity, and has positions pre-transformed into World-space
var meshId="".concat(modelPartId,"-").concat(orderedPrimitiveIndex);var _entityIndex=batchedPrimitiveEntityIndexes[orderedPrimitiveIndex];eachEntityId[_entityIndex];var meshDefaults={};// TODO: get from lookup from entity IDs
sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,primitive:"triangles",positionsCompressed:primitivePositions,normalsCompressed:primitiveNormals,indices:primitiveIndices,edgeIndices:primitiveEdgeIndices,positionsDecodeMatrix:primitiveDecodeMatrix,color:_color9,opacity:_opacity4}));}}var countInstances=0;for(var _entityIndex2=0;_entityIndex2<numEntities;_entityIndex2++){var _lastEntityIndex=numEntities-1;var _atLastEntity=_entityIndex2===_lastEntityIndex;var entityId=eachEntityId[_entityIndex2];var _firstEntityPrimitiveInstanceIndex=eachEntityPrimitiveInstancesPortion[_entityIndex2];var _lastEntityPrimitiveInstanceIndex=_atLastEntity?eachEntityPrimitiveInstancesPortion[_lastEntityIndex]:eachEntityPrimitiveInstancesPortion[_entityIndex2+1];var meshIds=[];for(var _primitiveInstancesIndex=_firstEntityPrimitiveInstanceIndex;_primitiveInstancesIndex<_lastEntityPrimitiveInstanceIndex;_primitiveInstancesIndex++){var _primitiveIndex4=primitiveInstances[_primitiveInstancesIndex];var _primitiveInstanceCount2=primitiveInstanceCounts[_primitiveIndex4];var _isInstancedPrimitive2=_primitiveInstanceCount2>1;if(_isInstancedPrimitive2){var _meshDefaults={};// TODO: get from lookup from entity IDs
var _meshId="".concat(modelPartId,"-instance.").concat(countInstances++);var _geometryId="".concat(modelPartId,"-geometry.").concat(_primitiveIndex4);// These IDs are local to the SceneModel
var matricesIndex=eachEntityMatricesPortion[_entityIndex2]*16;var _matrix4=matrices.subarray(matricesIndex,matricesIndex+16);sceneModel.createMesh(utils.apply(_meshDefaults,{id:_meshId,geometryId:_geometryId,matrix:_matrix4}));meshIds.push(_meshId);}else{meshIds.push(_primitiveIndex4);}}if(meshIds.length>0){var entityDefaults={};// TODO: get from lookup from entity IDs
sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,///////////////// TODO: If metaobject exists
meshIds:meshIds}));}}}/** @private */var ParserV4={version:4,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$6(elements);var inflatedData=inflate$6(deflatedData);load$6(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

 Parser for .XKT Format V5

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */var pako$5=window.pako||p;if(!pako$5.inflate){// See https://github.com/nodeca/pako/issues/97
pako$5=pako$5["default"];}function extract$5(elements){return{positions:elements[0],normals:elements[1],indices:elements[2],edgeIndices:elements[3],matrices:elements[4],eachPrimitivePositionsAndNormalsPortion:elements[5],eachPrimitiveIndicesPortion:elements[6],eachPrimitiveEdgeIndicesPortion:elements[7],eachPrimitiveColor:elements[8],primitiveInstances:elements[9],eachEntityId:elements[10],eachEntityPrimitiveInstancesPortion:elements[11],eachEntityMatricesPortion:elements[12]};}function inflate$5(deflatedData){return{positions:new Float32Array(pako$5.inflate(deflatedData.positions).buffer),normals:new Int8Array(pako$5.inflate(deflatedData.normals).buffer),indices:new Uint32Array(pako$5.inflate(deflatedData.indices).buffer),edgeIndices:new Uint32Array(pako$5.inflate(deflatedData.edgeIndices).buffer),matrices:new Float32Array(pako$5.inflate(deflatedData.matrices).buffer),eachPrimitivePositionsAndNormalsPortion:new Uint32Array(pako$5.inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion).buffer),eachPrimitiveIndicesPortion:new Uint32Array(pako$5.inflate(deflatedData.eachPrimitiveIndicesPortion).buffer),eachPrimitiveEdgeIndicesPortion:new Uint32Array(pako$5.inflate(deflatedData.eachPrimitiveEdgeIndicesPortion).buffer),eachPrimitiveColor:new Uint8Array(pako$5.inflate(deflatedData.eachPrimitiveColor).buffer),primitiveInstances:new Uint32Array(pako$5.inflate(deflatedData.primitiveInstances).buffer),eachEntityId:pako$5.inflate(deflatedData.eachEntityId,{to:'string'}),eachEntityPrimitiveInstancesPortion:new Uint32Array(pako$5.inflate(deflatedData.eachEntityPrimitiveInstancesPortion).buffer),eachEntityMatricesPortion:new Uint32Array(pako$5.inflate(deflatedData.eachEntityMatricesPortion).buffer)};}var decompressColor$5=function(){var color2=new Float32Array(3);return function(color){color2[0]=color[0]/255.0;color2[1]=color[1]/255.0;color2[2]=color[2]/255.0;return color2;};}();function load$5(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();sceneModel.positionsCompression="disabled";// Positions in XKT V4 are floats, which we never quantize, for precision with big models
sceneModel.normalsCompression="precompressed";// Normals are oct-encoded though
var positions=inflatedData.positions;var normals=inflatedData.normals;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var matrices=inflatedData.matrices;var eachPrimitivePositionsAndNormalsPortion=inflatedData.eachPrimitivePositionsAndNormalsPortion;var eachPrimitiveIndicesPortion=inflatedData.eachPrimitiveIndicesPortion;var eachPrimitiveEdgeIndicesPortion=inflatedData.eachPrimitiveEdgeIndicesPortion;var eachPrimitiveColor=inflatedData.eachPrimitiveColor;var primitiveInstances=inflatedData.primitiveInstances;var eachEntityId=JSON.parse(inflatedData.eachEntityId);var eachEntityPrimitiveInstancesPortion=inflatedData.eachEntityPrimitiveInstancesPortion;var eachEntityMatricesPortion=inflatedData.eachEntityMatricesPortion;var numPrimitives=eachPrimitivePositionsAndNormalsPortion.length;var numPrimitiveInstances=primitiveInstances.length;var primitiveInstanceCounts=new Uint8Array(numPrimitives);// For each mesh, how many times it is instanced
var numEntities=eachEntityId.length;// Count instances of each primitive
for(var primitiveInstanceIndex=0;primitiveInstanceIndex<numPrimitiveInstances;primitiveInstanceIndex++){var primitiveIndex=primitiveInstances[primitiveInstanceIndex];primitiveInstanceCounts[primitiveIndex]++;}// Map batched primitives to the entities that will use them
var batchedPrimitiveEntityIndexes={};for(var entityIndex=0;entityIndex<numEntities;entityIndex++){var lastEntityIndex=numEntities-1;var atLastEntity=entityIndex===lastEntityIndex;var firstEntityPrimitiveInstanceIndex=eachEntityPrimitiveInstancesPortion[entityIndex];var lastEntityPrimitiveInstanceIndex=atLastEntity?eachEntityPrimitiveInstancesPortion[lastEntityIndex]:eachEntityPrimitiveInstancesPortion[entityIndex+1];for(var primitiveInstancesIndex=firstEntityPrimitiveInstanceIndex;primitiveInstancesIndex<lastEntityPrimitiveInstanceIndex;primitiveInstancesIndex++){var _primitiveIndex5=primitiveInstances[primitiveInstancesIndex];var primitiveInstanceCount=primitiveInstanceCounts[_primitiveIndex5];var isInstancedPrimitive=primitiveInstanceCount>1;if(!isInstancedPrimitive){batchedPrimitiveEntityIndexes[_primitiveIndex5]=entityIndex;}}}// Create geometries for instanced primitives and meshes for batched primitives.
for(var _primitiveIndex6=0;_primitiveIndex6<numPrimitives;_primitiveIndex6++){var atLastPrimitive=_primitiveIndex6===numPrimitives-1;var _primitiveInstanceCount3=primitiveInstanceCounts[_primitiveIndex6];var _isInstancedPrimitive3=_primitiveInstanceCount3>1;var _color10=decompressColor$5(eachPrimitiveColor.subarray(_primitiveIndex6*4,_primitiveIndex6*4+3));var _opacity5=eachPrimitiveColor[_primitiveIndex6*4+3]/255.0;var primitivePositions=positions.subarray(eachPrimitivePositionsAndNormalsPortion[_primitiveIndex6],atLastPrimitive?positions.length:eachPrimitivePositionsAndNormalsPortion[_primitiveIndex6+1]);var primitiveNormals=normals.subarray(eachPrimitivePositionsAndNormalsPortion[_primitiveIndex6],atLastPrimitive?normals.length:eachPrimitivePositionsAndNormalsPortion[_primitiveIndex6+1]);var primitiveIndices=indices.subarray(eachPrimitiveIndicesPortion[_primitiveIndex6],atLastPrimitive?indices.length:eachPrimitiveIndicesPortion[_primitiveIndex6+1]);var primitiveEdgeIndices=edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion[_primitiveIndex6],atLastPrimitive?edgeIndices.length:eachPrimitiveEdgeIndicesPortion[_primitiveIndex6+1]);if(_isInstancedPrimitive3){// Primitive instanced by more than one entity, and has positions in Model-space
var geometryId="".concat(modelPartId,"-geometry.").concat(_primitiveIndex6);// These IDs are local to the SceneModel
sceneModel.createGeometry({id:geometryId,primitive:"triangles",positionsCompressed:primitivePositions,normalsCompressed:primitiveNormals,indices:primitiveIndices,edgeIndices:primitiveEdgeIndices});}else{// Primitive is used only by one entity, and has positions pre-transformed into World-space
var meshId=_primitiveIndex6;// These IDs are local to the SceneModel
var _entityIndex3=batchedPrimitiveEntityIndexes[_primitiveIndex6];eachEntityId[_entityIndex3];var meshDefaults={};// TODO: get from lookup from entity IDs
sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,primitive:"triangles",positionsCompressed:primitivePositions,normalsCompressed:primitiveNormals,indices:primitiveIndices,edgeIndices:primitiveEdgeIndices,color:_color10,opacity:_opacity5}));}}var countInstances=0;for(var _entityIndex4=0;_entityIndex4<numEntities;_entityIndex4++){var _lastEntityIndex2=numEntities-1;var _atLastEntity2=_entityIndex4===_lastEntityIndex2;var entityId=eachEntityId[_entityIndex4];var _firstEntityPrimitiveInstanceIndex2=eachEntityPrimitiveInstancesPortion[_entityIndex4];var _lastEntityPrimitiveInstanceIndex2=_atLastEntity2?eachEntityPrimitiveInstancesPortion[_lastEntityIndex2]:eachEntityPrimitiveInstancesPortion[_entityIndex4+1];var meshIds=[];for(var _primitiveInstancesIndex2=_firstEntityPrimitiveInstanceIndex2;_primitiveInstancesIndex2<_lastEntityPrimitiveInstanceIndex2;_primitiveInstancesIndex2++){var _primitiveIndex7=primitiveInstances[_primitiveInstancesIndex2];var _primitiveInstanceCount4=primitiveInstanceCounts[_primitiveIndex7];var _isInstancedPrimitive4=_primitiveInstanceCount4>1;if(_isInstancedPrimitive4){var _meshDefaults2={};// TODO: get from lookup from entity IDs
var _meshId2="instance."+countInstances++;var _geometryId2="geometry"+_primitiveIndex7;var matricesIndex=eachEntityMatricesPortion[_entityIndex4]*16;var _matrix5=matrices.subarray(matricesIndex,matricesIndex+16);sceneModel.createMesh(utils.apply(_meshDefaults2,{id:_meshId2,geometryId:_geometryId2,matrix:_matrix5}));meshIds.push(_meshId2);}else{meshIds.push(_primitiveIndex7);}}if(meshIds.length>0){var entityDefaults={};// TODO: get from lookup from entity IDs
sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,///////////////// TODO: If metaobject exists
meshIds:meshIds}));}}}/** @private */var ParserV5={version:5,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$5(elements);var inflatedData=inflate$5(deflatedData);load$5(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

 Parser for .XKT Format V6

 */var pako$4=window.pako||p;if(!pako$4.inflate){// See https://github.com/nodeca/pako/issues/97
pako$4=pako$4["default"];}function extract$4(elements){return{positions:elements[0],normals:elements[1],indices:elements[2],edgeIndices:elements[3],matrices:elements[4],reusedPrimitivesDecodeMatrix:elements[5],eachPrimitivePositionsAndNormalsPortion:elements[6],eachPrimitiveIndicesPortion:elements[7],eachPrimitiveEdgeIndicesPortion:elements[8],eachPrimitiveColorAndOpacity:elements[9],primitiveInstances:elements[10],eachEntityId:elements[11],eachEntityPrimitiveInstancesPortion:elements[12],eachEntityMatricesPortion:elements[13],eachTileAABB:elements[14],eachTileEntitiesPortion:elements[15]};}function inflate$4(deflatedData){function inflate(array,options){return array.length===0?[]:pako$4.inflate(array,options).buffer;}return{positions:new Uint16Array(inflate(deflatedData.positions)),normals:new Int8Array(inflate(deflatedData.normals)),indices:new Uint32Array(inflate(deflatedData.indices)),edgeIndices:new Uint32Array(inflate(deflatedData.edgeIndices)),matrices:new Float32Array(inflate(deflatedData.matrices)),reusedPrimitivesDecodeMatrix:new Float32Array(inflate(deflatedData.reusedPrimitivesDecodeMatrix)),eachPrimitivePositionsAndNormalsPortion:new Uint32Array(inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion)),eachPrimitiveIndicesPortion:new Uint32Array(inflate(deflatedData.eachPrimitiveIndicesPortion)),eachPrimitiveEdgeIndicesPortion:new Uint32Array(inflate(deflatedData.eachPrimitiveEdgeIndicesPortion)),eachPrimitiveColorAndOpacity:new Uint8Array(inflate(deflatedData.eachPrimitiveColorAndOpacity)),primitiveInstances:new Uint32Array(inflate(deflatedData.primitiveInstances)),eachEntityId:pako$4.inflate(deflatedData.eachEntityId,{to:'string'}),eachEntityPrimitiveInstancesPortion:new Uint32Array(inflate(deflatedData.eachEntityPrimitiveInstancesPortion)),eachEntityMatricesPortion:new Uint32Array(inflate(deflatedData.eachEntityMatricesPortion)),eachTileAABB:new Float64Array(inflate(deflatedData.eachTileAABB)),eachTileEntitiesPortion:new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion))};}var decompressColor$4=function(){var floatColor=new Float32Array(3);return function(intColor){floatColor[0]=intColor[0]/255.0;floatColor[1]=intColor[1]/255.0;floatColor[2]=intColor[2]/255.0;return floatColor;};}();function load$4(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();var positions=inflatedData.positions;var normals=inflatedData.normals;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var matrices=inflatedData.matrices;var reusedPrimitivesDecodeMatrix=inflatedData.reusedPrimitivesDecodeMatrix;var eachPrimitivePositionsAndNormalsPortion=inflatedData.eachPrimitivePositionsAndNormalsPortion;var eachPrimitiveIndicesPortion=inflatedData.eachPrimitiveIndicesPortion;var eachPrimitiveEdgeIndicesPortion=inflatedData.eachPrimitiveEdgeIndicesPortion;var eachPrimitiveColorAndOpacity=inflatedData.eachPrimitiveColorAndOpacity;var primitiveInstances=inflatedData.primitiveInstances;var eachEntityId=JSON.parse(inflatedData.eachEntityId);var eachEntityPrimitiveInstancesPortion=inflatedData.eachEntityPrimitiveInstancesPortion;var eachEntityMatricesPortion=inflatedData.eachEntityMatricesPortion;var eachTileAABB=inflatedData.eachTileAABB;var eachTileEntitiesPortion=inflatedData.eachTileEntitiesPortion;var numPrimitives=eachPrimitivePositionsAndNormalsPortion.length;var numPrimitiveInstances=primitiveInstances.length;var numEntities=eachEntityId.length;var numTiles=eachTileEntitiesPortion.length;// Count instances of each primitive
var primitiveReuseCounts=new Uint32Array(numPrimitives);for(var primitiveInstanceIndex=0;primitiveInstanceIndex<numPrimitiveInstances;primitiveInstanceIndex++){var primitiveIndex=primitiveInstances[primitiveInstanceIndex];if(primitiveReuseCounts[primitiveIndex]!==undefined){primitiveReuseCounts[primitiveIndex]++;}else{primitiveReuseCounts[primitiveIndex]=1;}}// Iterate over tiles
var tileCenter=math.vec3();var rtcAABB=math.AABB3();for(var tileIndex=0;tileIndex<numTiles;tileIndex++){var lastTileIndex=numTiles-1;var atLastTile=tileIndex===lastTileIndex;var firstTileEntityIndex=eachTileEntitiesPortion[tileIndex];var lastTileEntityIndex=atLastTile?numEntities:eachTileEntitiesPortion[tileIndex+1];var tileAABBIndex=tileIndex*6;var tileAABB=eachTileAABB.subarray(tileAABBIndex,tileAABBIndex+6);math.getAABB3Center(tileAABB,tileCenter);rtcAABB[0]=tileAABB[0]-tileCenter[0];rtcAABB[1]=tileAABB[1]-tileCenter[1];rtcAABB[2]=tileAABB[2]-tileCenter[2];rtcAABB[3]=tileAABB[3]-tileCenter[0];rtcAABB[4]=tileAABB[4]-tileCenter[1];rtcAABB[5]=tileAABB[5]-tileCenter[2];var tileDecodeMatrix=geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);var geometryCreated={};// Iterate over each tile's entities
for(var tileEntityIndex=firstTileEntityIndex;tileEntityIndex<lastTileEntityIndex;tileEntityIndex++){var xktEntityId=eachEntityId[tileEntityIndex];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var entityMatrixIndex=eachEntityMatricesPortion[tileEntityIndex];var entityMatrix=matrices.slice(entityMatrixIndex,entityMatrixIndex+16);var _lastTileEntityIndex=numEntities-1;var atLastTileEntity=tileEntityIndex===_lastTileEntityIndex;var firstPrimitiveInstanceIndex=eachEntityPrimitiveInstancesPortion[tileEntityIndex];var lastPrimitiveInstanceIndex=atLastTileEntity?primitiveInstances.length:eachEntityPrimitiveInstancesPortion[tileEntityIndex+1];var meshIds=[];var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};if(metaObject){// Mask loading of object types
if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}// Get initial property values for object types
var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}}}else{if(options.excludeUnclassifiedObjects){continue;}}// Iterate each entity's primitive instances
for(var primitiveInstancesIndex=firstPrimitiveInstanceIndex;primitiveInstancesIndex<lastPrimitiveInstanceIndex;primitiveInstancesIndex++){var _primitiveIndex8=primitiveInstances[primitiveInstancesIndex];var primitiveReuseCount=primitiveReuseCounts[_primitiveIndex8];var isReusedPrimitive=primitiveReuseCount>1;var atLastPrimitive=_primitiveIndex8===numPrimitives-1;var primitivePositions=positions.subarray(eachPrimitivePositionsAndNormalsPortion[_primitiveIndex8],atLastPrimitive?positions.length:eachPrimitivePositionsAndNormalsPortion[_primitiveIndex8+1]);var primitiveNormals=normals.subarray(eachPrimitivePositionsAndNormalsPortion[_primitiveIndex8],atLastPrimitive?normals.length:eachPrimitivePositionsAndNormalsPortion[_primitiveIndex8+1]);var primitiveIndices=indices.subarray(eachPrimitiveIndicesPortion[_primitiveIndex8],atLastPrimitive?indices.length:eachPrimitiveIndicesPortion[_primitiveIndex8+1]);var primitiveEdgeIndices=edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion[_primitiveIndex8],atLastPrimitive?edgeIndices.length:eachPrimitiveEdgeIndicesPortion[_primitiveIndex8+1]);var _color11=decompressColor$4(eachPrimitiveColorAndOpacity.subarray(_primitiveIndex8*4,_primitiveIndex8*4+3));var _opacity6=eachPrimitiveColorAndOpacity[_primitiveIndex8*4+3]/255.0;var meshId=manifestCtx.getNextId();if(isReusedPrimitive){// Create mesh for multi-use primitive - create (or reuse) geometry, create mesh using that geometry
var geometryId="".concat(modelPartId,"-geometry.").concat(tileIndex,".").concat(_primitiveIndex8);// These IDs are local to the SceneModel
if(!geometryCreated[geometryId]){sceneModel.createGeometry({id:geometryId,primitive:"triangles",positionsCompressed:primitivePositions,//   normalsCompressed: primitiveNormals,
indices:primitiveIndices,edgeIndices:primitiveEdgeIndices,positionsDecodeMatrix:reusedPrimitivesDecodeMatrix});geometryCreated[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,geometryId:geometryId,origin:tileCenter,matrix:entityMatrix,color:_color11,opacity:_opacity6}));meshIds.push(meshId);}else{sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,origin:tileCenter,primitive:"triangles",positionsCompressed:primitivePositions,normalsCompressed:primitiveNormals,indices:primitiveIndices,edgeIndices:primitiveEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:_color11,opacity:_opacity6}));meshIds.push(meshId);}}if(meshIds.length>0){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,meshIds:meshIds}));}}}}/** @private */var ParserV6={version:6,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$4(elements);var inflatedData=inflate$4(deflatedData);load$4(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

 Parser for .XKT Format V7

 */var pako$3=window.pako||p;if(!pako$3.inflate){// See https://github.com/nodeca/pako/issues/97
pako$3=pako$3["default"];}function extract$3(elements){return{// Vertex attributes
positions:elements[0],normals:elements[1],colors:elements[2],// Indices
indices:elements[3],edgeIndices:elements[4],// Transform matrices
matrices:elements[5],reusedGeometriesDecodeMatrix:elements[6],// Geometries
eachGeometryPrimitiveType:elements[7],eachGeometryPositionsPortion:elements[8],eachGeometryNormalsPortion:elements[9],eachGeometryColorsPortion:elements[10],eachGeometryIndicesPortion:elements[11],eachGeometryEdgeIndicesPortion:elements[12],// Meshes are grouped in runs that are shared by the same entities
eachMeshGeometriesPortion:elements[13],eachMeshMatricesPortion:elements[14],eachMeshMaterial:elements[15],// Entity elements in the following arrays are grouped in runs that are shared by the same tiles
eachEntityId:elements[16],eachEntityMeshesPortion:elements[17],eachTileAABB:elements[18],eachTileEntitiesPortion:elements[19]};}function inflate$3(deflatedData){function inflate(array,options){return array.length===0?[]:pako$3.inflate(array,options).buffer;}return{positions:new Uint16Array(inflate(deflatedData.positions)),normals:new Int8Array(inflate(deflatedData.normals)),colors:new Uint8Array(inflate(deflatedData.colors)),indices:new Uint32Array(inflate(deflatedData.indices)),edgeIndices:new Uint32Array(inflate(deflatedData.edgeIndices)),matrices:new Float32Array(inflate(deflatedData.matrices)),reusedGeometriesDecodeMatrix:new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),eachGeometryPrimitiveType:new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),eachGeometryPositionsPortion:new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),eachGeometryNormalsPortion:new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),eachGeometryColorsPortion:new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),eachGeometryIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),eachGeometryEdgeIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),eachMeshGeometriesPortion:new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),eachMeshMatricesPortion:new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),eachMeshMaterial:new Uint8Array(inflate(deflatedData.eachMeshMaterial)),eachEntityId:pako$3.inflate(deflatedData.eachEntityId,{to:'string'}),eachEntityMeshesPortion:new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),eachTileAABB:new Float64Array(inflate(deflatedData.eachTileAABB)),eachTileEntitiesPortion:new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion))};}var decompressColor$3=function(){var floatColor=new Float32Array(3);return function(intColor){floatColor[0]=intColor[0]/255.0;floatColor[1]=intColor[1]/255.0;floatColor[2]=intColor[2]/255.0;return floatColor;};}();function convertColorsRGBToRGBA$1(colorsRGB){var colorsRGBA=[];for(var _i556=0,len=colorsRGB.length;_i556<len;_i556+=3){colorsRGBA.push(colorsRGB[_i556]);colorsRGBA.push(colorsRGB[_i556+1]);colorsRGBA.push(colorsRGB[_i556+2]);colorsRGBA.push(1.0);}return colorsRGBA;}function load$3(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();var positions=inflatedData.positions;var normals=inflatedData.normals;var colors=inflatedData.colors;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var matrices=inflatedData.matrices;var reusedGeometriesDecodeMatrix=inflatedData.reusedGeometriesDecodeMatrix;var eachGeometryPrimitiveType=inflatedData.eachGeometryPrimitiveType;var eachGeometryPositionsPortion=inflatedData.eachGeometryPositionsPortion;var eachGeometryNormalsPortion=inflatedData.eachGeometryNormalsPortion;var eachGeometryColorsPortion=inflatedData.eachGeometryColorsPortion;var eachGeometryIndicesPortion=inflatedData.eachGeometryIndicesPortion;var eachGeometryEdgeIndicesPortion=inflatedData.eachGeometryEdgeIndicesPortion;var eachMeshGeometriesPortion=inflatedData.eachMeshGeometriesPortion;var eachMeshMatricesPortion=inflatedData.eachMeshMatricesPortion;var eachMeshMaterial=inflatedData.eachMeshMaterial;var eachEntityId=JSON.parse(inflatedData.eachEntityId);var eachEntityMeshesPortion=inflatedData.eachEntityMeshesPortion;var eachTileAABB=inflatedData.eachTileAABB;var eachTileEntitiesPortion=inflatedData.eachTileEntitiesPortion;var numGeometries=eachGeometryPositionsPortion.length;var numMeshes=eachMeshGeometriesPortion.length;var numEntities=eachEntityId.length;var numTiles=eachTileEntitiesPortion.length;// Count instances of each geometry
var geometryReuseCounts=new Uint32Array(numGeometries);for(var meshIndex=0;meshIndex<numMeshes;meshIndex++){var geometryIndex=eachMeshGeometriesPortion[meshIndex];if(geometryReuseCounts[geometryIndex]!==undefined){geometryReuseCounts[geometryIndex]++;}else{geometryReuseCounts[geometryIndex]=1;}}// Iterate over tiles
var tileCenter=math.vec3();var rtcAABB=math.AABB3();for(var tileIndex=0;tileIndex<numTiles;tileIndex++){var lastTileIndex=numTiles-1;var atLastTile=tileIndex===lastTileIndex;var firstTileEntityIndex=eachTileEntitiesPortion[tileIndex];var lastTileEntityIndex=atLastTile?numEntities:eachTileEntitiesPortion[tileIndex+1];var tileAABBIndex=tileIndex*6;var tileAABB=eachTileAABB.subarray(tileAABBIndex,tileAABBIndex+6);math.getAABB3Center(tileAABB,tileCenter);rtcAABB[0]=tileAABB[0]-tileCenter[0];rtcAABB[1]=tileAABB[1]-tileCenter[1];rtcAABB[2]=tileAABB[2]-tileCenter[2];rtcAABB[3]=tileAABB[3]-tileCenter[0];rtcAABB[4]=tileAABB[4]-tileCenter[1];rtcAABB[5]=tileAABB[5]-tileCenter[2];var tileDecodeMatrix=geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);var geometryCreated={};// Iterate over each tile's entities
for(var tileEntityIndex=firstTileEntityIndex;tileEntityIndex<lastTileEntityIndex;tileEntityIndex++){var xktEntityId=eachEntityId[tileEntityIndex];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var _lastTileEntityIndex2=numEntities-1;var atLastTileEntity=tileEntityIndex===_lastTileEntityIndex2;var firstMeshIndex=eachEntityMeshesPortion[tileEntityIndex];var lastMeshIndex=atLastTileEntity?eachMeshGeometriesPortion.length:eachEntityMeshesPortion[tileEntityIndex+1];var meshIds=[];var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};if(metaObject){// Mask loading of object types
if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}// Get initial property values for object types
var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}if(props.metallic!==undefined&&props.metallic!==null){meshDefaults.metallic=props.metallic;}if(props.roughness!==undefined&&props.roughness!==null){meshDefaults.roughness=props.roughness;}}}else{if(options.excludeUnclassifiedObjects){continue;}}// Iterate each entity's meshes
for(var _meshIndex=firstMeshIndex;_meshIndex<lastMeshIndex;_meshIndex++){var _geometryIndex=eachMeshGeometriesPortion[_meshIndex];var geometryReuseCount=geometryReuseCounts[_geometryIndex];var isReusedGeometry=geometryReuseCount>1;var atLastGeometry=_geometryIndex===numGeometries-1;var meshColor=decompressColor$3(eachMeshMaterial.subarray(_meshIndex*6,_meshIndex*6+3));var meshOpacity=eachMeshMaterial[_meshIndex*6+3]/255.0;var meshMetallic=eachMeshMaterial[_meshIndex*6+4]/255.0;var meshRoughness=eachMeshMaterial[_meshIndex*6+5]/255.0;var meshId=manifestCtx.getNextId();if(isReusedGeometry){// Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry
var meshMatrixIndex=eachMeshMatricesPortion[_meshIndex];var meshMatrix=matrices.slice(meshMatrixIndex,meshMatrixIndex+16);var geometryId="".concat(modelPartId,"-geometry.").concat(tileIndex,".").concat(_geometryIndex);// These IDs are local to the SceneModel
if(!geometryCreated[geometryId]){var primitiveType=eachGeometryPrimitiveType[_geometryIndex];var primitiveName=void 0;var geometryPositions=void 0;var geometryNormals=void 0;var geometryColors=void 0;var geometryIndices=void 0;var geometryEdgeIndices=void 0;switch(primitiveType){case 0:primitiveName="solid";geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex+1]);break;case 1:primitiveName="surface";geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex+1]);break;case 2:primitiveName="points";geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);geometryColors=convertColorsRGBToRGBA$1(colors.subarray(eachGeometryColorsPortion[_geometryIndex],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex+1]));break;case 3:primitiveName="lines";geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex+1]);break;default:continue;}sceneModel.createGeometry({id:geometryId,primitive:primitiveName,positionsCompressed:geometryPositions,normalsCompressed:geometryNormals,colors:geometryColors,indices:geometryIndices,edgeIndices:geometryEdgeIndices,positionsDecodeMatrix:reusedGeometriesDecodeMatrix});geometryCreated[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,geometryId:geometryId,origin:tileCenter,matrix:meshMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}else{var _primitiveType=eachGeometryPrimitiveType[_geometryIndex];var _primitiveName=void 0;var _geometryPositions=void 0;var _geometryNormals=void 0;var _geometryColors=void 0;var _geometryIndices=void 0;var _geometryEdgeIndices=void 0;switch(_primitiveType){case 0:_primitiveName="solid";_geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);_geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex+1]);_geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex+1]);_geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex+1]);break;case 1:_primitiveName="surface";_geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);_geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex+1]);_geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex+1]);_geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex+1]);break;case 2:_primitiveName="points";_geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);_geometryColors=convertColorsRGBToRGBA$1(colors.subarray(eachGeometryColorsPortion[_geometryIndex],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex+1]));break;case 3:_primitiveName="lines";_geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex+1]);_geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex+1]);break;default:continue;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,origin:tileCenter,primitive:_primitiveName,positionsCompressed:_geometryPositions,normalsCompressed:_geometryNormals,colors:_geometryColors,indices:_geometryIndices,edgeIndices:_geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}}if(meshIds.length>0){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,meshIds:meshIds}));}}}}/** @private */var ParserV7={version:7,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$3(elements);var inflatedData=inflate$3(deflatedData);load$3(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

 Parser for .XKT Format V8

 */var pako$2=window.pako||p;if(!pako$2.inflate){// See https://github.com/nodeca/pako/issues/97
pako$2=pako$2["default"];}var tempVec4a$2=math.vec4();var tempVec4b$2=math.vec4();function extract$2(elements){return{// Vertex attributes
types:elements[0],eachMetaObjectId:elements[1],eachMetaObjectType:elements[2],eachMetaObjectName:elements[3],eachMetaObjectParent:elements[4],positions:elements[5],normals:elements[6],colors:elements[7],indices:elements[8],edgeIndices:elements[9],// Transform matrices
matrices:elements[10],reusedGeometriesDecodeMatrix:elements[11],// Geometries
eachGeometryPrimitiveType:elements[12],eachGeometryPositionsPortion:elements[13],eachGeometryNormalsPortion:elements[14],eachGeometryColorsPortion:elements[15],eachGeometryIndicesPortion:elements[16],eachGeometryEdgeIndicesPortion:elements[17],// Meshes are grouped in runs that are shared by the same entities
eachMeshGeometriesPortion:elements[18],eachMeshMatricesPortion:elements[19],eachMeshMaterial:elements[20],// Entity elements in the following arrays are grouped in runs that are shared by the same tiles
eachEntityMetaObject:elements[21],eachEntityMeshesPortion:elements[22],eachTileAABB:elements[23],eachTileEntitiesPortion:elements[24]};}function inflate$2(deflatedData){function inflate(array,options){return array.length===0?[]:pako$2.inflate(array,options).buffer;}return{types:pako$2.inflate(deflatedData.types,{to:'string'}),eachMetaObjectId:pako$2.inflate(deflatedData.eachMetaObjectId,{to:'string'}),eachMetaObjectType:new Uint32Array(inflate(deflatedData.eachMetaObjectType)),eachMetaObjectName:pako$2.inflate(deflatedData.eachMetaObjectName,{to:'string'}),eachMetaObjectParent:new Uint32Array(inflate(deflatedData.eachMetaObjectParent)),positions:new Uint16Array(inflate(deflatedData.positions)),normals:new Int8Array(inflate(deflatedData.normals)),colors:new Uint8Array(inflate(deflatedData.colors)),indices:new Uint32Array(inflate(deflatedData.indices)),edgeIndices:new Uint32Array(inflate(deflatedData.edgeIndices)),matrices:new Float32Array(inflate(deflatedData.matrices)),reusedGeometriesDecodeMatrix:new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),eachGeometryPrimitiveType:new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),eachGeometryPositionsPortion:new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),eachGeometryNormalsPortion:new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),eachGeometryColorsPortion:new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),eachGeometryIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),eachGeometryEdgeIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),eachMeshGeometriesPortion:new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),eachMeshMatricesPortion:new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),eachMeshMaterial:new Uint8Array(inflate(deflatedData.eachMeshMaterial)),eachEntityMetaObject:new Uint32Array(inflate(deflatedData.eachEntityMetaObject)),eachEntityMeshesPortion:new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),eachTileAABB:new Float64Array(inflate(deflatedData.eachTileAABB)),eachTileEntitiesPortion:new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion))};}var decompressColor$2=function(){var floatColor=new Float32Array(3);return function(intColor){floatColor[0]=intColor[0]/255.0;floatColor[1]=intColor[1]/255.0;floatColor[2]=intColor[2]/255.0;return floatColor;};}();function convertColorsRGBToRGBA(colorsRGB){var colorsRGBA=[];for(var _i557=0,len=colorsRGB.length;_i557<len;_i557+=3){colorsRGBA.push(colorsRGB[_i557]);colorsRGBA.push(colorsRGB[_i557+1]);colorsRGBA.push(colorsRGB[_i557+2]);colorsRGBA.push(1.0);}return colorsRGBA;}function load$2(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();var types=JSON.parse(inflatedData.types);var eachMetaObjectId=JSON.parse(inflatedData.eachMetaObjectId);var eachMetaObjectType=inflatedData.eachMetaObjectType;var eachMetaObjectName=JSON.parse(inflatedData.eachMetaObjectName);var eachMetaObjectParent=inflatedData.eachMetaObjectParent;var positions=inflatedData.positions;var normals=inflatedData.normals;var colors=inflatedData.colors;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var matrices=inflatedData.matrices;var reusedGeometriesDecodeMatrix=inflatedData.reusedGeometriesDecodeMatrix;var eachGeometryPrimitiveType=inflatedData.eachGeometryPrimitiveType;var eachGeometryPositionsPortion=inflatedData.eachGeometryPositionsPortion;var eachGeometryNormalsPortion=inflatedData.eachGeometryNormalsPortion;var eachGeometryColorsPortion=inflatedData.eachGeometryColorsPortion;var eachGeometryIndicesPortion=inflatedData.eachGeometryIndicesPortion;var eachGeometryEdgeIndicesPortion=inflatedData.eachGeometryEdgeIndicesPortion;var eachMeshGeometriesPortion=inflatedData.eachMeshGeometriesPortion;var eachMeshMatricesPortion=inflatedData.eachMeshMatricesPortion;var eachMeshMaterial=inflatedData.eachMeshMaterial;var eachEntityMetaObject=inflatedData.eachEntityMetaObject;var eachEntityMeshesPortion=inflatedData.eachEntityMeshesPortion;var eachTileAABB=inflatedData.eachTileAABB;var eachTileEntitiesPortion=inflatedData.eachTileEntitiesPortion;var numMetaObjects=eachMetaObjectId.length;var numGeometries=eachGeometryPositionsPortion.length;var numMeshes=eachMeshGeometriesPortion.length;var numEntities=eachEntityMetaObject.length;var numTiles=eachTileEntitiesPortion.length;if(metaModel){var metaModelData={metaObjects:[]};for(var metaObjectIndex=0;metaObjectIndex<numMetaObjects;metaObjectIndex++){var metaObjectId=eachMetaObjectId[metaObjectIndex];var typeIndex=eachMetaObjectType[metaObjectIndex];var metaObjectType=types[typeIndex]||"default";var metaObjectName=eachMetaObjectName[metaObjectIndex];var metaObjectParentIndex=eachMetaObjectParent[metaObjectIndex];var metaObjectParentId=metaObjectParentIndex!==metaObjectIndex?eachMetaObjectId[metaObjectParentIndex]:null;metaModelData.metaObjects.push({id:metaObjectId,type:metaObjectType,name:metaObjectName,parent:metaObjectParentId});}metaModel.loadData(metaModelData,{includeTypes:options.includeTypes,excludeTypes:options.excludeTypes,globalizeObjectIds:options.globalizeObjectIds});}// Count instances of each geometry
var geometryReuseCounts=new Uint32Array(numGeometries);for(var meshIndex=0;meshIndex<numMeshes;meshIndex++){var geometryIndex=eachMeshGeometriesPortion[meshIndex];if(geometryReuseCounts[geometryIndex]!==undefined){geometryReuseCounts[geometryIndex]++;}else{geometryReuseCounts[geometryIndex]=1;}}// Iterate over tiles
var tileCenter=math.vec3();var rtcAABB=math.AABB3();var geometryArraysCache={};for(var tileIndex=0;tileIndex<numTiles;tileIndex++){var lastTileIndex=numTiles-1;var atLastTile=tileIndex===lastTileIndex;var firstTileEntityIndex=eachTileEntitiesPortion[tileIndex];var lastTileEntityIndex=atLastTile?numEntities:eachTileEntitiesPortion[tileIndex+1];var tileAABBIndex=tileIndex*6;var tileAABB=eachTileAABB.subarray(tileAABBIndex,tileAABBIndex+6);math.getAABB3Center(tileAABB,tileCenter);rtcAABB[0]=tileAABB[0]-tileCenter[0];rtcAABB[1]=tileAABB[1]-tileCenter[1];rtcAABB[2]=tileAABB[2]-tileCenter[2];rtcAABB[3]=tileAABB[3]-tileCenter[0];rtcAABB[4]=tileAABB[4]-tileCenter[1];rtcAABB[5]=tileAABB[5]-tileCenter[2];var tileDecodeMatrix=geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);var geometryCreatedInTile={};// Iterate over each tile's entities
for(var tileEntityIndex=firstTileEntityIndex;tileEntityIndex<lastTileEntityIndex;tileEntityIndex++){var xktMetaObjectIndex=eachEntityMetaObject[tileEntityIndex];var xktMetaObjectId=eachMetaObjectId[xktMetaObjectIndex];var xktEntityId=xktMetaObjectId;var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var _lastTileEntityIndex3=numEntities-1;var atLastTileEntity=tileEntityIndex===_lastTileEntityIndex3;var firstMeshIndex=eachEntityMeshesPortion[tileEntityIndex];var lastMeshIndex=atLastTileEntity?eachMeshGeometriesPortion.length:eachEntityMeshesPortion[tileEntityIndex+1];var meshIds=[];var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};if(metaObject){// Mask loading of object types
if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}// Get initial property values for object types
var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}if(props.metallic!==undefined&&props.metallic!==null){meshDefaults.metallic=props.metallic;}if(props.roughness!==undefined&&props.roughness!==null){meshDefaults.roughness=props.roughness;}}}else{if(options.excludeUnclassifiedObjects){continue;}}// Iterate each entity's meshes
for(var _meshIndex2=firstMeshIndex;_meshIndex2<lastMeshIndex;_meshIndex2++){var _geometryIndex2=eachMeshGeometriesPortion[_meshIndex2];var geometryReuseCount=geometryReuseCounts[_geometryIndex2];var isReusedGeometry=geometryReuseCount>1;var atLastGeometry=_geometryIndex2===numGeometries-1;var meshColor=decompressColor$2(eachMeshMaterial.subarray(_meshIndex2*6,_meshIndex2*6+3));var meshOpacity=eachMeshMaterial[_meshIndex2*6+3]/255.0;var meshMetallic=eachMeshMaterial[_meshIndex2*6+4]/255.0;var meshRoughness=eachMeshMaterial[_meshIndex2*6+5]/255.0;var meshId=manifestCtx.getNextId();if(isReusedGeometry){// Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry
var meshMatrixIndex=eachMeshMatricesPortion[_meshIndex2];var meshMatrix=matrices.slice(meshMatrixIndex,meshMatrixIndex+16);var geometryId="".concat(modelPartId,"-geometry.").concat(tileIndex,".").concat(_geometryIndex2);// These IDs are local to the SceneModel
var geometryArrays=geometryArraysCache[geometryId];if(!geometryArrays){geometryArrays={batchThisMesh:!options.reuseGeometries};var primitiveType=eachGeometryPrimitiveType[_geometryIndex2];var geometryValid=false;switch(primitiveType){case 0:geometryArrays.primitiveName="solid";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryArrays.geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex2],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex2+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex2],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex2+1]);geometryArrays.geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex2],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex2+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 1:geometryArrays.primitiveName="surface";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryArrays.geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex2],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex2+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex2],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex2+1]);geometryArrays.geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex2],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex2+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 2:geometryArrays.primitiveName="points";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryArrays.geometryColors=convertColorsRGBToRGBA(colors.subarray(eachGeometryColorsPortion[_geometryIndex2],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex2+1]));geometryValid=geometryArrays.geometryPositions.length>0;break;case 3:geometryArrays.primitiveName="lines";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex2],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex2+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;default:continue;}if(!geometryValid){geometryArrays=null;}if(geometryArrays){if(geometryArrays.geometryPositions.length>1000);if(geometryArrays.batchThisMesh){geometryArrays.decompressedPositions=new Float32Array(geometryArrays.geometryPositions.length);var geometryPositions=geometryArrays.geometryPositions;var decompressedPositions=geometryArrays.decompressedPositions;for(var _i558=0,len=geometryPositions.length;_i558<len;_i558+=3){decompressedPositions[_i558+0]=geometryPositions[_i558+0]*reusedGeometriesDecodeMatrix[0]+reusedGeometriesDecodeMatrix[12];decompressedPositions[_i558+1]=geometryPositions[_i558+1]*reusedGeometriesDecodeMatrix[5]+reusedGeometriesDecodeMatrix[13];decompressedPositions[_i558+2]=geometryPositions[_i558+2]*reusedGeometriesDecodeMatrix[10]+reusedGeometriesDecodeMatrix[14];}geometryArrays.geometryPositions=null;geometryArraysCache[geometryId]=geometryArrays;}}}if(geometryArrays){if(geometryArrays.batchThisMesh){var _decompressedPositions=geometryArrays.decompressedPositions;var _positions4=new Uint16Array(_decompressedPositions.length);for(var _i559=0,_len114=_decompressedPositions.length;_i559<_len114;_i559+=3){tempVec4a$2[0]=_decompressedPositions[_i559+0];tempVec4a$2[1]=_decompressedPositions[_i559+1];tempVec4a$2[2]=_decompressedPositions[_i559+2];tempVec4a$2[3]=1;math.transformVec4(meshMatrix,tempVec4a$2,tempVec4b$2);geometryCompressionUtils.compressPosition(tempVec4b$2,rtcAABB,tempVec4a$2);_positions4[_i559+0]=tempVec4a$2[0];_positions4[_i559+1]=tempVec4a$2[1];_positions4[_i559+2]=tempVec4a$2[2];}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,origin:tileCenter,primitive:geometryArrays.primitiveName,positionsCompressed:_positions4,normalsCompressed:geometryArrays.geometryNormals,colorsCompressed:geometryArrays.geometryColors,indices:geometryArrays.geometryIndices,edgeIndices:geometryArrays.geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}else{if(!geometryCreatedInTile[geometryId]){sceneModel.createGeometry({id:geometryId,primitive:geometryArrays.primitiveName,positionsCompressed:geometryArrays.geometryPositions,normalsCompressed:geometryArrays.geometryNormals,colorsCompressed:geometryArrays.geometryColors,indices:geometryArrays.geometryIndices,edgeIndices:geometryArrays.geometryEdgeIndices,positionsDecodeMatrix:reusedGeometriesDecodeMatrix});geometryCreatedInTile[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,geometryId:geometryId,origin:tileCenter,matrix:meshMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}}}else{var _primitiveType2=eachGeometryPrimitiveType[_geometryIndex2];var primitiveName=void 0;var _geometryPositions2=void 0;var geometryNormals=void 0;var geometryColors=void 0;var geometryIndices=void 0;var geometryEdgeIndices=void 0;var _geometryValid=false;switch(_primitiveType2){case 0:primitiveName="solid";_geometryPositions2=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex2],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex2+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex2],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex2+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex2],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex2+1]);_geometryValid=_geometryPositions2.length>0&&geometryIndices.length>0;break;case 1:primitiveName="surface";_geometryPositions2=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex2],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex2+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex2],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex2+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex2],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex2+1]);_geometryValid=_geometryPositions2.length>0&&geometryIndices.length>0;break;case 2:primitiveName="points";_geometryPositions2=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryColors=convertColorsRGBToRGBA(colors.subarray(eachGeometryColorsPortion[_geometryIndex2],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex2+1]));_geometryValid=_geometryPositions2.length>0;break;case 3:primitiveName="lines";_geometryPositions2=positions.subarray(eachGeometryPositionsPortion[_geometryIndex2],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex2+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex2],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex2+1]);_geometryValid=_geometryPositions2.length>0&&geometryIndices.length>0;break;default:continue;}if(_geometryValid){sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,origin:tileCenter,primitive:primitiveName,positionsCompressed:_geometryPositions2,normalsCompressed:geometryNormals,colorsCompressed:geometryColors,indices:geometryIndices,edgeIndices:geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}}}if(meshIds.length>0){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,meshIds:meshIds}));}}}}/** @private */var ParserV8={version:8,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$2(elements);var inflatedData=inflate$2(deflatedData);load$2(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*

 Parser for .XKT Format V9

 */var pako$1=window.pako||p;if(!pako$1.inflate){// See https://github.com/nodeca/pako/issues/97
pako$1=pako$1["default"];}var tempVec4a$1=math.vec4();var tempVec4b$1=math.vec4();function extract$1(elements){return{// Metadata
metadata:elements[0],positions:elements[1],normals:elements[2],colors:elements[3],indices:elements[4],edgeIndices:elements[5],// Transform matrices
matrices:elements[6],reusedGeometriesDecodeMatrix:elements[7],// Geometries
eachGeometryPrimitiveType:elements[8],eachGeometryPositionsPortion:elements[9],eachGeometryNormalsPortion:elements[10],eachGeometryColorsPortion:elements[11],eachGeometryIndicesPortion:elements[12],eachGeometryEdgeIndicesPortion:elements[13],// Meshes are grouped in runs that are shared by the same entities
eachMeshGeometriesPortion:elements[14],eachMeshMatricesPortion:elements[15],eachMeshMaterial:elements[16],// Entity elements in the following arrays are grouped in runs that are shared by the same tiles
eachEntityId:elements[17],eachEntityMeshesPortion:elements[18],eachTileAABB:elements[19],eachTileEntitiesPortion:elements[20]};}function inflate$1(deflatedData){function inflate(array,options){return array.length===0?[]:pako$1.inflate(array,options).buffer;}return{metadata:JSON.parse(pako$1.inflate(deflatedData.metadata,{to:'string'})),positions:new Uint16Array(inflate(deflatedData.positions)),normals:new Int8Array(inflate(deflatedData.normals)),colors:new Uint8Array(inflate(deflatedData.colors)),indices:new Uint32Array(inflate(deflatedData.indices)),edgeIndices:new Uint32Array(inflate(deflatedData.edgeIndices)),matrices:new Float32Array(inflate(deflatedData.matrices)),reusedGeometriesDecodeMatrix:new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),eachGeometryPrimitiveType:new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),eachGeometryPositionsPortion:new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),eachGeometryNormalsPortion:new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),eachGeometryColorsPortion:new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),eachGeometryIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),eachGeometryEdgeIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),eachMeshGeometriesPortion:new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),eachMeshMatricesPortion:new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),eachMeshMaterial:new Uint8Array(inflate(deflatedData.eachMeshMaterial)),eachEntityId:JSON.parse(pako$1.inflate(deflatedData.eachEntityId,{to:'string'})),eachEntityMeshesPortion:new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),eachTileAABB:new Float64Array(inflate(deflatedData.eachTileAABB)),eachTileEntitiesPortion:new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion))};}var decompressColor$1=function(){var floatColor=new Float32Array(3);return function(intColor){floatColor[0]=intColor[0]/255.0;floatColor[1]=intColor[1]/255.0;floatColor[2]=intColor[2]/255.0;return floatColor;};}();function load$1(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();var metadata=inflatedData.metadata;var positions=inflatedData.positions;var normals=inflatedData.normals;var colors=inflatedData.colors;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var matrices=inflatedData.matrices;var reusedGeometriesDecodeMatrix=inflatedData.reusedGeometriesDecodeMatrix;var eachGeometryPrimitiveType=inflatedData.eachGeometryPrimitiveType;var eachGeometryPositionsPortion=inflatedData.eachGeometryPositionsPortion;var eachGeometryNormalsPortion=inflatedData.eachGeometryNormalsPortion;var eachGeometryColorsPortion=inflatedData.eachGeometryColorsPortion;var eachGeometryIndicesPortion=inflatedData.eachGeometryIndicesPortion;var eachGeometryEdgeIndicesPortion=inflatedData.eachGeometryEdgeIndicesPortion;var eachMeshGeometriesPortion=inflatedData.eachMeshGeometriesPortion;var eachMeshMatricesPortion=inflatedData.eachMeshMatricesPortion;var eachMeshMaterial=inflatedData.eachMeshMaterial;var eachEntityId=inflatedData.eachEntityId;var eachEntityMeshesPortion=inflatedData.eachEntityMeshesPortion;var eachTileAABB=inflatedData.eachTileAABB;var eachTileEntitiesPortion=inflatedData.eachTileEntitiesPortion;var numGeometries=eachGeometryPositionsPortion.length;var numMeshes=eachMeshGeometriesPortion.length;var numEntities=eachEntityMeshesPortion.length;var numTiles=eachTileEntitiesPortion.length;if(metaModel){metaModel.loadData(metadata,{includeTypes:options.includeTypes,excludeTypes:options.excludeTypes,globalizeObjectIds:options.globalizeObjectIds});// Can be empty
}// Count instances of each geometry
var geometryReuseCounts=new Uint32Array(numGeometries);for(var meshIndex=0;meshIndex<numMeshes;meshIndex++){var geometryIndex=eachMeshGeometriesPortion[meshIndex];if(geometryReuseCounts[geometryIndex]!==undefined){geometryReuseCounts[geometryIndex]++;}else{geometryReuseCounts[geometryIndex]=1;}}// Iterate over tiles
var tileCenter=math.vec3();var rtcAABB=math.AABB3();var geometryArraysCache={};for(var tileIndex=0;tileIndex<numTiles;tileIndex++){var lastTileIndex=numTiles-1;var atLastTile=tileIndex===lastTileIndex;var firstTileEntityIndex=eachTileEntitiesPortion[tileIndex];var lastTileEntityIndex=atLastTile?numEntities-1:eachTileEntitiesPortion[tileIndex+1]-1;var tileAABBIndex=tileIndex*6;var tileAABB=eachTileAABB.subarray(tileAABBIndex,tileAABBIndex+6);math.getAABB3Center(tileAABB,tileCenter);rtcAABB[0]=tileAABB[0]-tileCenter[0];rtcAABB[1]=tileAABB[1]-tileCenter[1];rtcAABB[2]=tileAABB[2]-tileCenter[2];rtcAABB[3]=tileAABB[3]-tileCenter[0];rtcAABB[4]=tileAABB[4]-tileCenter[1];rtcAABB[5]=tileAABB[5]-tileCenter[2];var tileDecodeMatrix=geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);var geometryCreatedInTile={};// Iterate over each tile's entities
for(var tileEntityIndex=firstTileEntityIndex;tileEntityIndex<=lastTileEntityIndex;tileEntityIndex++){var xktEntityId=eachEntityId[tileEntityIndex];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var finalTileEntityIndex=numEntities-1;var atLastTileEntity=tileEntityIndex===finalTileEntityIndex;var firstMeshIndex=eachEntityMeshesPortion[tileEntityIndex];var lastMeshIndex=atLastTileEntity?eachMeshGeometriesPortion.length-1:eachEntityMeshesPortion[tileEntityIndex+1]-1;var meshIds=[];var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};if(metaObject){// Mask loading of object types
if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}// Get initial property values for object types
var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}if(props.metallic!==undefined&&props.metallic!==null){meshDefaults.metallic=props.metallic;}if(props.roughness!==undefined&&props.roughness!==null){meshDefaults.roughness=props.roughness;}}}else{if(options.excludeUnclassifiedObjects){continue;}}// Iterate each entity's meshes
for(var _meshIndex3=firstMeshIndex;_meshIndex3<=lastMeshIndex;_meshIndex3++){var _geometryIndex3=eachMeshGeometriesPortion[_meshIndex3];var geometryReuseCount=geometryReuseCounts[_geometryIndex3];var isReusedGeometry=geometryReuseCount>1;var atLastGeometry=_geometryIndex3===numGeometries-1;var meshColor=decompressColor$1(eachMeshMaterial.subarray(_meshIndex3*6,_meshIndex3*6+3));var meshOpacity=eachMeshMaterial[_meshIndex3*6+3]/255.0;var meshMetallic=eachMeshMaterial[_meshIndex3*6+4]/255.0;var meshRoughness=eachMeshMaterial[_meshIndex3*6+5]/255.0;var meshId=manifestCtx.getNextId();if(isReusedGeometry){// Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry
var meshMatrixIndex=eachMeshMatricesPortion[_meshIndex3];var meshMatrix=matrices.slice(meshMatrixIndex,meshMatrixIndex+16);var geometryId="".concat(modelPartId,"-geometry.").concat(tileIndex,".").concat(_geometryIndex3);// These IDs are local to the SceneModel
var geometryArrays=geometryArraysCache[geometryId];if(!geometryArrays){geometryArrays={batchThisMesh:!options.reuseGeometries};var primitiveType=eachGeometryPrimitiveType[_geometryIndex3];var geometryValid=false;switch(primitiveType){case 0:geometryArrays.primitiveName="solid";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryArrays.geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex3],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex3+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex3],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex3+1]);geometryArrays.geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex3],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex3+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 1:geometryArrays.primitiveName="surface";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryArrays.geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex3],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex3+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex3],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex3+1]);geometryArrays.geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex3],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex3+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 2:geometryArrays.primitiveName="points";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryArrays.geometryColors=colors.subarray(eachGeometryColorsPortion[_geometryIndex3],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex3+1]);geometryValid=geometryArrays.geometryPositions.length>0;break;case 3:geometryArrays.primitiveName="lines";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex3],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex3+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;default:continue;}if(!geometryValid){geometryArrays=null;}if(geometryArrays){if(geometryArrays.geometryPositions.length>1000);if(geometryArrays.batchThisMesh){geometryArrays.decompressedPositions=new Float32Array(geometryArrays.geometryPositions.length);geometryArrays.transformedAndRecompressedPositions=new Uint16Array(geometryArrays.geometryPositions.length);var geometryPositions=geometryArrays.geometryPositions;var decompressedPositions=geometryArrays.decompressedPositions;for(var _i560=0,len=geometryPositions.length;_i560<len;_i560+=3){decompressedPositions[_i560+0]=geometryPositions[_i560+0]*reusedGeometriesDecodeMatrix[0]+reusedGeometriesDecodeMatrix[12];decompressedPositions[_i560+1]=geometryPositions[_i560+1]*reusedGeometriesDecodeMatrix[5]+reusedGeometriesDecodeMatrix[13];decompressedPositions[_i560+2]=geometryPositions[_i560+2]*reusedGeometriesDecodeMatrix[10]+reusedGeometriesDecodeMatrix[14];}geometryArrays.geometryPositions=null;geometryArraysCache[geometryId]=geometryArrays;}}}if(geometryArrays){if(geometryArrays.batchThisMesh){var _decompressedPositions2=geometryArrays.decompressedPositions;var transformedAndRecompressedPositions=geometryArrays.transformedAndRecompressedPositions;for(var _i561=0,_len115=_decompressedPositions2.length;_i561<_len115;_i561+=3){tempVec4a$1[0]=_decompressedPositions2[_i561+0];tempVec4a$1[1]=_decompressedPositions2[_i561+1];tempVec4a$1[2]=_decompressedPositions2[_i561+2];tempVec4a$1[3]=1;math.transformVec4(meshMatrix,tempVec4a$1,tempVec4b$1);geometryCompressionUtils.compressPosition(tempVec4b$1,rtcAABB,tempVec4a$1);transformedAndRecompressedPositions[_i561+0]=tempVec4a$1[0];transformedAndRecompressedPositions[_i561+1]=tempVec4a$1[1];transformedAndRecompressedPositions[_i561+2]=tempVec4a$1[2];}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,origin:tileCenter,primitive:geometryArrays.primitiveName,positionsCompressed:transformedAndRecompressedPositions,normalsCompressed:geometryArrays.geometryNormals,colorsCompressed:geometryArrays.geometryColors,indices:geometryArrays.geometryIndices,edgeIndices:geometryArrays.geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}else{if(!geometryCreatedInTile[geometryId]){sceneModel.createGeometry({id:geometryId,primitive:geometryArrays.primitiveName,positionsCompressed:geometryArrays.geometryPositions,normalsCompressed:geometryArrays.geometryNormals,colorsCompressed:geometryArrays.geometryColors,indices:geometryArrays.geometryIndices,edgeIndices:geometryArrays.geometryEdgeIndices,positionsDecodeMatrix:reusedGeometriesDecodeMatrix});geometryCreatedInTile[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,geometryId:geometryId,origin:tileCenter,matrix:meshMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}}}else{var _primitiveType3=eachGeometryPrimitiveType[_geometryIndex3];var primitiveName=void 0;var _geometryPositions3=void 0;var geometryNormals=void 0;var geometryColors=void 0;var geometryIndices=void 0;var geometryEdgeIndices=void 0;var _geometryValid2=false;switch(_primitiveType3){case 0:primitiveName="solid";_geometryPositions3=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex3],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex3+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex3],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex3+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex3],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex3+1]);_geometryValid2=_geometryPositions3.length>0&&geometryIndices.length>0;break;case 1:primitiveName="surface";_geometryPositions3=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex3],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex3+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex3],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex3+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex3],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex3+1]);_geometryValid2=_geometryPositions3.length>0&&geometryIndices.length>0;break;case 2:primitiveName="points";_geometryPositions3=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryColors=colors.subarray(eachGeometryColorsPortion[_geometryIndex3],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex3+1]);_geometryValid2=_geometryPositions3.length>0;break;case 3:primitiveName="lines";_geometryPositions3=positions.subarray(eachGeometryPositionsPortion[_geometryIndex3],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex3+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex3],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex3+1]);_geometryValid2=_geometryPositions3.length>0&&geometryIndices.length>0;break;default:continue;}if(_geometryValid2){sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,origin:tileCenter,primitive:primitiveName,positionsCompressed:_geometryPositions3,normalsCompressed:geometryNormals,colorsCompressed:geometryColors,indices:geometryIndices,edgeIndices:geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}}}if(meshIds.length>0){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,meshIds:meshIds}));}}}}/** @private */var ParserV9={version:9,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract$1(elements);var inflatedData=inflate$1(deflatedData);load$1(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};/*
 Parser for .XKT Format V10
*/var pako=window.pako||p;if(!pako.inflate){// See https://github.com/nodeca/pako/issues/97
pako=pako["default"];}var tempVec4a=math.vec4();var tempVec4b=math.vec4();var NUM_TEXTURE_ATTRIBUTES=9;function extract(elements){var i=0;return{metadata:elements[i++],textureData:elements[i++],eachTextureDataPortion:elements[i++],eachTextureAttributes:elements[i++],positions:elements[i++],normals:elements[i++],colors:elements[i++],uvs:elements[i++],indices:elements[i++],edgeIndices:elements[i++],eachTextureSetTextures:elements[i++],matrices:elements[i++],reusedGeometriesDecodeMatrix:elements[i++],eachGeometryPrimitiveType:elements[i++],eachGeometryPositionsPortion:elements[i++],eachGeometryNormalsPortion:elements[i++],eachGeometryColorsPortion:elements[i++],eachGeometryUVsPortion:elements[i++],eachGeometryIndicesPortion:elements[i++],eachGeometryEdgeIndicesPortion:elements[i++],eachMeshGeometriesPortion:elements[i++],eachMeshMatricesPortion:elements[i++],eachMeshTextureSet:elements[i++],eachMeshMaterialAttributes:elements[i++],eachEntityId:elements[i++],eachEntityMeshesPortion:elements[i++],eachTileAABB:elements[i++],eachTileEntitiesPortion:elements[i++]};}function inflate(deflatedData){function inflate(array,options){return array.length===0?[]:pako.inflate(array,options).buffer;}return{metadata:JSON.parse(pako.inflate(deflatedData.metadata,{to:'string'})),textureData:new Uint8Array(inflate(deflatedData.textureData)),// <<----------------------------- ??? ZIPPing to blame?
eachTextureDataPortion:new Uint32Array(inflate(deflatedData.eachTextureDataPortion)),eachTextureAttributes:new Uint16Array(inflate(deflatedData.eachTextureAttributes)),positions:new Uint16Array(inflate(deflatedData.positions)),normals:new Int8Array(inflate(deflatedData.normals)),colors:new Uint8Array(inflate(deflatedData.colors)),uvs:new Float32Array(inflate(deflatedData.uvs)),indices:new Uint32Array(inflate(deflatedData.indices)),edgeIndices:new Uint32Array(inflate(deflatedData.edgeIndices)),eachTextureSetTextures:new Int32Array(inflate(deflatedData.eachTextureSetTextures)),matrices:new Float32Array(inflate(deflatedData.matrices)),reusedGeometriesDecodeMatrix:new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),eachGeometryPrimitiveType:new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),eachGeometryPositionsPortion:new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),eachGeometryNormalsPortion:new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),eachGeometryColorsPortion:new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),eachGeometryUVsPortion:new Uint32Array(inflate(deflatedData.eachGeometryUVsPortion)),eachGeometryIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),eachGeometryEdgeIndicesPortion:new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),eachMeshGeometriesPortion:new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),eachMeshMatricesPortion:new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),eachMeshTextureSet:new Int32Array(inflate(deflatedData.eachMeshTextureSet)),// Can be -1
eachMeshMaterialAttributes:new Uint8Array(inflate(deflatedData.eachMeshMaterialAttributes)),eachEntityId:JSON.parse(pako.inflate(deflatedData.eachEntityId,{to:'string'})),eachEntityMeshesPortion:new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),eachTileAABB:new Float64Array(inflate(deflatedData.eachTileAABB)),eachTileEntitiesPortion:new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion))};}var decompressColor=function(){var floatColor=new Float32Array(3);return function(intColor){floatColor[0]=intColor[0]/255.0;floatColor[1]=intColor[1]/255.0;floatColor[2]=intColor[2]/255.0;return floatColor;};}();(function(){var canvas=document.createElement('canvas');var context=canvas.getContext('2d');return function(imagedata){canvas.width=imagedata.width;canvas.height=imagedata.height;context.putImageData(imagedata,0,0);return canvas.toDataURL();};})();function load(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx){var modelPartId=manifestCtx.getNextId();var metadata=inflatedData.metadata;var textureData=inflatedData.textureData;var eachTextureDataPortion=inflatedData.eachTextureDataPortion;var eachTextureAttributes=inflatedData.eachTextureAttributes;var positions=inflatedData.positions;var normals=inflatedData.normals;var colors=inflatedData.colors;var uvs=inflatedData.uvs;var indices=inflatedData.indices;var edgeIndices=inflatedData.edgeIndices;var eachTextureSetTextures=inflatedData.eachTextureSetTextures;var matrices=inflatedData.matrices;var reusedGeometriesDecodeMatrix=inflatedData.reusedGeometriesDecodeMatrix;var eachGeometryPrimitiveType=inflatedData.eachGeometryPrimitiveType;var eachGeometryPositionsPortion=inflatedData.eachGeometryPositionsPortion;var eachGeometryNormalsPortion=inflatedData.eachGeometryNormalsPortion;var eachGeometryColorsPortion=inflatedData.eachGeometryColorsPortion;var eachGeometryUVsPortion=inflatedData.eachGeometryUVsPortion;var eachGeometryIndicesPortion=inflatedData.eachGeometryIndicesPortion;var eachGeometryEdgeIndicesPortion=inflatedData.eachGeometryEdgeIndicesPortion;var eachMeshGeometriesPortion=inflatedData.eachMeshGeometriesPortion;var eachMeshMatricesPortion=inflatedData.eachMeshMatricesPortion;var eachMeshTextureSet=inflatedData.eachMeshTextureSet;var eachMeshMaterialAttributes=inflatedData.eachMeshMaterialAttributes;var eachEntityId=inflatedData.eachEntityId;var eachEntityMeshesPortion=inflatedData.eachEntityMeshesPortion;var eachTileAABB=inflatedData.eachTileAABB;var eachTileEntitiesPortion=inflatedData.eachTileEntitiesPortion;var numTextures=eachTextureDataPortion.length;var numTextureSets=eachTextureSetTextures.length/5;var numGeometries=eachGeometryPositionsPortion.length;var numMeshes=eachMeshGeometriesPortion.length;var numEntities=eachEntityMeshesPortion.length;var numTiles=eachTileEntitiesPortion.length;if(metaModel){metaModel.loadData(metadata,{includeTypes:options.includeTypes,excludeTypes:options.excludeTypes,globalizeObjectIds:options.globalizeObjectIds});// Can be empty
}// Create textures
for(var textureIndex=0;textureIndex<numTextures;textureIndex++){var atLastTexture=textureIndex===numTextures-1;var textureDataPortionStart=eachTextureDataPortion[textureIndex];var textureDataPortionEnd=atLastTexture?textureData.length:eachTextureDataPortion[textureIndex+1];var textureDataPortionSize=textureDataPortionEnd-textureDataPortionStart;var textureDataPortionExists=textureDataPortionSize>0;var textureAttrBaseIdx=textureIndex*NUM_TEXTURE_ATTRIBUTES;var compressed=eachTextureAttributes[textureAttrBaseIdx+0]===1;var mediaType=eachTextureAttributes[textureAttrBaseIdx+1];eachTextureAttributes[textureAttrBaseIdx+2];eachTextureAttributes[textureAttrBaseIdx+3];var minFilter=eachTextureAttributes[textureAttrBaseIdx+4];var magFilter=eachTextureAttributes[textureAttrBaseIdx+5];// LinearFilter | NearestFilter
var wrapS=eachTextureAttributes[textureAttrBaseIdx+6];// ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping
var wrapT=eachTextureAttributes[textureAttrBaseIdx+7];// ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping
var wrapR=eachTextureAttributes[textureAttrBaseIdx+8];// ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping
if(textureDataPortionExists){var imageDataSubarray=new Uint8Array(textureData.subarray(textureDataPortionStart,textureDataPortionEnd));var arrayBuffer=imageDataSubarray.buffer;var textureId="".concat(modelPartId,"-texture-").concat(textureIndex);if(compressed){sceneModel.createTexture({id:textureId,buffers:[arrayBuffer],minFilter:minFilter,magFilter:magFilter,wrapS:wrapS,wrapT:wrapT,wrapR:wrapR});}else{var mimeType=mediaType===JPEGMediaType?"image/jpeg":mediaType===PNGMediaType?"image/png":"image/gif";var blob=new Blob([arrayBuffer],{type:mimeType});var urlCreator=window.URL||window.webkitURL;var imageUrl=urlCreator.createObjectURL(blob);var img=document.createElement('img');img.src=imageUrl;sceneModel.createTexture({id:textureId,image:img,//mediaType,
minFilter:minFilter,magFilter:magFilter,wrapS:wrapS,wrapT:wrapT,wrapR:wrapR});}}}// Create texture sets
for(var textureSetIndex=0;textureSetIndex<numTextureSets;textureSetIndex++){var eachTextureSetTexturesIndex=textureSetIndex*5;var textureSetId="".concat(modelPartId,"-textureSet-").concat(textureSetIndex);var colorTextureIndex=eachTextureSetTextures[eachTextureSetTexturesIndex+0];var metallicRoughnessTextureIndex=eachTextureSetTextures[eachTextureSetTexturesIndex+1];var normalsTextureIndex=eachTextureSetTextures[eachTextureSetTexturesIndex+2];var emissiveTextureIndex=eachTextureSetTextures[eachTextureSetTexturesIndex+3];var occlusionTextureIndex=eachTextureSetTextures[eachTextureSetTexturesIndex+4];sceneModel.createTextureSet({id:textureSetId,colorTextureId:colorTextureIndex>=0?"".concat(modelPartId,"-texture-").concat(colorTextureIndex):null,normalsTextureId:normalsTextureIndex>=0?"".concat(modelPartId,"-texture-").concat(normalsTextureIndex):null,metallicRoughnessTextureId:metallicRoughnessTextureIndex>=0?"".concat(modelPartId,"-texture-").concat(metallicRoughnessTextureIndex):null,emissiveTextureId:emissiveTextureIndex>=0?"".concat(modelPartId,"-texture-").concat(emissiveTextureIndex):null,occlusionTextureId:occlusionTextureIndex>=0?"".concat(modelPartId,"-texture-").concat(occlusionTextureIndex):null});}// Count instances of each geometry
var geometryReuseCounts=new Uint32Array(numGeometries);for(var meshIndex=0;meshIndex<numMeshes;meshIndex++){var geometryIndex=eachMeshGeometriesPortion[meshIndex];if(geometryReuseCounts[geometryIndex]!==undefined){geometryReuseCounts[geometryIndex]++;}else{geometryReuseCounts[geometryIndex]=1;}}// Iterate over tiles
var tileCenter=math.vec3();var rtcAABB=math.AABB3();var geometryArraysCache={};for(var tileIndex=0;tileIndex<numTiles;tileIndex++){var lastTileIndex=numTiles-1;var atLastTile=tileIndex===lastTileIndex;var firstTileEntityIndex=eachTileEntitiesPortion[tileIndex];var lastTileEntityIndex=atLastTile?numEntities-1:eachTileEntitiesPortion[tileIndex+1]-1;var tileAABBIndex=tileIndex*6;var tileAABB=eachTileAABB.subarray(tileAABBIndex,tileAABBIndex+6);math.getAABB3Center(tileAABB,tileCenter);rtcAABB[0]=tileAABB[0]-tileCenter[0];rtcAABB[1]=tileAABB[1]-tileCenter[1];rtcAABB[2]=tileAABB[2]-tileCenter[2];rtcAABB[3]=tileAABB[3]-tileCenter[0];rtcAABB[4]=tileAABB[4]-tileCenter[1];rtcAABB[5]=tileAABB[5]-tileCenter[2];var tileDecodeMatrix=geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);var geometryCreatedInTile={};// Iterate over each tile's entities
for(var tileEntityIndex=firstTileEntityIndex;tileEntityIndex<=lastTileEntityIndex;tileEntityIndex++){var xktEntityId=eachEntityId[tileEntityIndex];var entityId=options.globalizeObjectIds?math.globalizeObjectId(sceneModel.id,xktEntityId):xktEntityId;var finalTileEntityIndex=numEntities-1;var atLastTileEntity=tileEntityIndex===finalTileEntityIndex;var firstMeshIndex=eachEntityMeshesPortion[tileEntityIndex];var lastMeshIndex=atLastTileEntity?eachMeshGeometriesPortion.length-1:eachEntityMeshesPortion[tileEntityIndex+1]-1;var meshIds=[];var metaObject=viewer.metaScene.metaObjects[entityId];var entityDefaults={};var meshDefaults={};if(metaObject){// Mask loading of object types
if(options.excludeTypesMap&&metaObject.type&&options.excludeTypesMap[metaObject.type]){continue;}if(options.includeTypesMap&&metaObject.type&&!options.includeTypesMap[metaObject.type]){continue;}// Get initial property values for object types
var props=options.objectDefaults?options.objectDefaults[metaObject.type]||options.objectDefaults["DEFAULT"]:null;if(props){if(props.visible===false){entityDefaults.visible=false;}if(props.pickable===false){entityDefaults.pickable=false;}if(props.colorize){meshDefaults.color=props.colorize;}if(props.opacity!==undefined&&props.opacity!==null){meshDefaults.opacity=props.opacity;}if(props.metallic!==undefined&&props.metallic!==null){meshDefaults.metallic=props.metallic;}if(props.roughness!==undefined&&props.roughness!==null){meshDefaults.roughness=props.roughness;}}}else{if(options.excludeUnclassifiedObjects){continue;}}// Iterate each entity's meshes
for(var _meshIndex4=firstMeshIndex;_meshIndex4<=lastMeshIndex;_meshIndex4++){var _geometryIndex4=eachMeshGeometriesPortion[_meshIndex4];var geometryReuseCount=geometryReuseCounts[_geometryIndex4];var isReusedGeometry=geometryReuseCount>1;var atLastGeometry=_geometryIndex4===numGeometries-1;var _textureSetIndex=eachMeshTextureSet[_meshIndex4];var _textureSetId=_textureSetIndex>=0?"".concat(modelPartId,"-textureSet-").concat(_textureSetIndex):null;var meshColor=decompressColor(eachMeshMaterialAttributes.subarray(_meshIndex4*6,_meshIndex4*6+3));var meshOpacity=eachMeshMaterialAttributes[_meshIndex4*6+3]/255.0;var meshMetallic=eachMeshMaterialAttributes[_meshIndex4*6+4]/255.0;var meshRoughness=eachMeshMaterialAttributes[_meshIndex4*6+5]/255.0;var meshId=manifestCtx.getNextId();if(isReusedGeometry){// Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry
var meshMatrixIndex=eachMeshMatricesPortion[_meshIndex4];var meshMatrix=matrices.slice(meshMatrixIndex,meshMatrixIndex+16);var geometryId="".concat(modelPartId,"-geometry.").concat(tileIndex,".").concat(_geometryIndex4);// These IDs are local to the SceneModel
var geometryArrays=geometryArraysCache[geometryId];if(!geometryArrays){geometryArrays={batchThisMesh:!options.reuseGeometries};var primitiveType=eachGeometryPrimitiveType[_geometryIndex4];var geometryValid=false;switch(primitiveType){case 0:geometryArrays.primitiveName="solid";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryArrays.geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex4],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex4+1]);geometryArrays.geometryUVs=uvs.subarray(eachGeometryUVsPortion[_geometryIndex4],atLastGeometry?uvs.length:eachGeometryUVsPortion[_geometryIndex4+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]);geometryArrays.geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex4],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex4+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 1:geometryArrays.primitiveName="surface";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryArrays.geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex4],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex4+1]);geometryArrays.geometryUVs=uvs.subarray(eachGeometryUVsPortion[_geometryIndex4],atLastGeometry?uvs.length:eachGeometryUVsPortion[_geometryIndex4+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]);geometryArrays.geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex4],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex4+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 2:geometryArrays.primitiveName="points";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryArrays.geometryColors=colors.subarray(eachGeometryColorsPortion[_geometryIndex4],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex4+1]);geometryValid=geometryArrays.geometryPositions.length>0;break;case 3:geometryArrays.primitiveName="lines";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryArrays.geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]);geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;case 4:geometryArrays.primitiveName="lines";geometryArrays.geometryPositions=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryArrays.geometryIndices=lineStripToLines(geometryArrays.geometryPositions,indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]));geometryValid=geometryArrays.geometryPositions.length>0&&geometryArrays.geometryIndices.length>0;break;default:continue;}if(!geometryValid){geometryArrays=null;}if(geometryArrays){if(geometryArrays.geometryPositions.length>1000);if(geometryArrays.batchThisMesh){geometryArrays.decompressedPositions=new Float32Array(geometryArrays.geometryPositions.length);geometryArrays.transformedAndRecompressedPositions=new Uint16Array(geometryArrays.geometryPositions.length);var geometryPositions=geometryArrays.geometryPositions;var decompressedPositions=geometryArrays.decompressedPositions;for(var _i562=0,len=geometryPositions.length;_i562<len;_i562+=3){decompressedPositions[_i562+0]=geometryPositions[_i562+0]*reusedGeometriesDecodeMatrix[0]+reusedGeometriesDecodeMatrix[12];decompressedPositions[_i562+1]=geometryPositions[_i562+1]*reusedGeometriesDecodeMatrix[5]+reusedGeometriesDecodeMatrix[13];decompressedPositions[_i562+2]=geometryPositions[_i562+2]*reusedGeometriesDecodeMatrix[10]+reusedGeometriesDecodeMatrix[14];}geometryArrays.geometryPositions=null;geometryArraysCache[geometryId]=geometryArrays;}}}if(geometryArrays){if(geometryArrays.batchThisMesh){var _decompressedPositions3=geometryArrays.decompressedPositions;var transformedAndRecompressedPositions=geometryArrays.transformedAndRecompressedPositions;for(var _i563=0,_len116=_decompressedPositions3.length;_i563<_len116;_i563+=3){tempVec4a[0]=_decompressedPositions3[_i563+0];tempVec4a[1]=_decompressedPositions3[_i563+1];tempVec4a[2]=_decompressedPositions3[_i563+2];tempVec4a[3]=1;math.transformVec4(meshMatrix,tempVec4a,tempVec4b);geometryCompressionUtils.compressPosition(tempVec4b,rtcAABB,tempVec4a);transformedAndRecompressedPositions[_i563+0]=tempVec4a[0];transformedAndRecompressedPositions[_i563+1]=tempVec4a[1];transformedAndRecompressedPositions[_i563+2]=tempVec4a[2];}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,textureSetId:_textureSetId,origin:tileCenter,primitive:geometryArrays.primitiveName,positionsCompressed:transformedAndRecompressedPositions,normalsCompressed:geometryArrays.geometryNormals,uv:geometryArrays.geometryUVs,colorsCompressed:geometryArrays.geometryColors,indices:geometryArrays.geometryIndices,edgeIndices:geometryArrays.geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}else{if(!geometryCreatedInTile[geometryId]){sceneModel.createGeometry({id:geometryId,primitive:geometryArrays.primitiveName,positionsCompressed:geometryArrays.geometryPositions,normalsCompressed:geometryArrays.geometryNormals,uv:geometryArrays.geometryUVs,colorsCompressed:geometryArrays.geometryColors,indices:geometryArrays.geometryIndices,edgeIndices:geometryArrays.geometryEdgeIndices,positionsDecodeMatrix:reusedGeometriesDecodeMatrix});geometryCreatedInTile[geometryId]=true;}sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,geometryId:geometryId,textureSetId:_textureSetId,matrix:meshMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity,origin:tileCenter}));meshIds.push(meshId);}}}else{// Do not reuse geometry
var _primitiveType4=eachGeometryPrimitiveType[_geometryIndex4];var primitiveName=void 0;var _geometryPositions4=void 0;var geometryNormals=void 0;var geometryUVs=void 0;var geometryColors=void 0;var geometryIndices=void 0;var geometryEdgeIndices=void 0;var _geometryValid3=false;switch(_primitiveType4){case 0:primitiveName="solid";_geometryPositions4=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex4],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex4+1]);geometryUVs=uvs.subarray(eachGeometryUVsPortion[_geometryIndex4],atLastGeometry?uvs.length:eachGeometryUVsPortion[_geometryIndex4+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex4],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex4+1]);_geometryValid3=_geometryPositions4.length>0&&geometryIndices.length>0;break;case 1:primitiveName="surface";_geometryPositions4=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryNormals=normals.subarray(eachGeometryNormalsPortion[_geometryIndex4],atLastGeometry?normals.length:eachGeometryNormalsPortion[_geometryIndex4+1]);geometryUVs=uvs.subarray(eachGeometryUVsPortion[_geometryIndex4],atLastGeometry?uvs.length:eachGeometryUVsPortion[_geometryIndex4+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]);geometryEdgeIndices=edgeIndices.subarray(eachGeometryEdgeIndicesPortion[_geometryIndex4],atLastGeometry?edgeIndices.length:eachGeometryEdgeIndicesPortion[_geometryIndex4+1]);_geometryValid3=_geometryPositions4.length>0&&geometryIndices.length>0;break;case 2:primitiveName="points";_geometryPositions4=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryColors=colors.subarray(eachGeometryColorsPortion[_geometryIndex4],atLastGeometry?colors.length:eachGeometryColorsPortion[_geometryIndex4+1]);_geometryValid3=_geometryPositions4.length>0;break;case 3:primitiveName="lines";_geometryPositions4=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryIndices=indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]);_geometryValid3=_geometryPositions4.length>0&&geometryIndices.length>0;break;case 4:primitiveName="lines";_geometryPositions4=positions.subarray(eachGeometryPositionsPortion[_geometryIndex4],atLastGeometry?positions.length:eachGeometryPositionsPortion[_geometryIndex4+1]);geometryIndices=lineStripToLines(_geometryPositions4,indices.subarray(eachGeometryIndicesPortion[_geometryIndex4],atLastGeometry?indices.length:eachGeometryIndicesPortion[_geometryIndex4+1]));_geometryValid3=_geometryPositions4.length>0&&geometryIndices.length>0;break;default:continue;}if(_geometryValid3){sceneModel.createMesh(utils.apply(meshDefaults,{id:meshId,textureSetId:_textureSetId,origin:tileCenter,primitive:primitiveName,positionsCompressed:_geometryPositions4,normalsCompressed:geometryNormals,uv:geometryUVs&&geometryUVs.length>0?geometryUVs:null,colorsCompressed:geometryColors,indices:geometryIndices,edgeIndices:geometryEdgeIndices,positionsDecodeMatrix:tileDecodeMatrix,color:meshColor,metallic:meshMetallic,roughness:meshRoughness,opacity:meshOpacity}));meshIds.push(meshId);}}}if(meshIds.length>0){sceneModel.createEntity(utils.apply(entityDefaults,{id:entityId,isObject:true,meshIds:meshIds}));}}}}function lineStripToLines(positions,indices){var linesIndices=[];if(indices.length>1){for(var _i564=0,len=indices.length-1;_i564<len;_i564++){linesIndices.push(indices[_i564]);linesIndices.push(indices[_i564+1]);}}else if(positions.length>1){for(var _i565=0,_len117=positions.length/3-1;_i565<_len117;_i565++){linesIndices.push(_i565);linesIndices.push(_i565+1);}}return linesIndices;}/** @private */var ParserV10={version:10,parse:function parse(viewer,options,elements,sceneModel,metaModel,manifestCtx){var deflatedData=extract(elements);var inflatedData=inflate(deflatedData);load(viewer,options,inflatedData,sceneModel,metaModel,manifestCtx);}};var parsers={};parsers[ParserV1.version]=ParserV1;parsers[ParserV2.version]=ParserV2;parsers[ParserV3.version]=ParserV3;parsers[ParserV4.version]=ParserV4;parsers[ParserV5.version]=ParserV5;parsers[ParserV6.version]=ParserV6;parsers[ParserV7.version]=ParserV7;parsers[ParserV8.version]=ParserV8;parsers[ParserV9.version]=ParserV9;parsers[ParserV10.version]=ParserV10;/**
 * {@link Viewer} plugin that loads models from xeokit's optimized *````.XKT````* format.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_OTCConferenceCenter"><img src="http://xeokit.io/img/docs/XKTLoaderPlugin/XKTLoaderPlugin.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_OTCConferenceCenter)]
 *
 * # Overview
 *
 * * XKTLoaderPlugin is the most efficient way to load high-detail models into xeokit.
 * * An *````.XKT````* file is a single BLOB containing a model, compressed using geometry quantization
 * and [pako](https://nodeca.github.io/pako/).
 * * Supports double-precision coordinates.
 * * Supports compressed textures.
 * * Set the position, scale and rotation of each model as you load it.
 * * Filter which IFC types get loaded.
 * * Configure initial default appearances for IFC types.
 * * Set a custom data source for *````.XKT````* and IFC metadata files.
 * * Option to load multiple copies of the same model, without object ID clashes.
 *
 * # Creating *````.XKT````* Files and Metadata
 *
 * We have several sways to convert your files into XKT. See these tutorials for more info:
 *
 * * [Converting Models to XKT with convert2xkt](https://www.notion.so/xeokit/Converting-Models-to-XKT-with-convert2xkt-fa567843313f4db8a7d6535e76da9380) - how to convert various file formats (glTF, IFC, CityJSON, LAS/LAZ...) to XKT using our nodejs-based converter.
 * * [Converting IFC Models to XKT using 3rd-Party Open Source Tools](https://www.notion.so/xeokit/Converting-IFC-Models-to-XKT-using-3rd-Party-Open-Source-Tools-c373e48bc4094ff5b6e5c5700ff580ee) - how to convert IFC files to XKT using 3rd-party open source CLI tools.
 *
 * # Scene representation
 *
 * When loading a model, XKTLoaderPlugin creates an {@link Entity} that represents the model, which
 * will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id}
 * in {@link Scene#models}. The XKTLoaderPlugin also creates an {@link Entity} for each object within the
 * model. Those Entities will have {@link Entity#isObject} set ````true```` and will be registered
 * by {@link Entity#id} in {@link Scene#objects}.
 *
 * # Metadata
 *
 * Since XKT V8, model metadata is included in the XKT file. If the XKT file has metadata, then loading it creates
 * model metadata components within the Viewer, namely a {@link MetaModel} corresponding to the model {@link Entity},
 * and a {@link MetaObject} for each object {@link Entity}.
 *
 * Each {@link MetaObject} has a {@link MetaObject#type}, which indicates the classification of its corresponding
 * {@link Entity}. When loading metadata, we can also configure XKTLoaderPlugin with a custom lookup table of initial
 * values to set on the properties of each type of {@link Entity}. By default, XKTLoaderPlugin uses its own map of
 * default colors and visibilities for IFC element types.
 *
 * For XKT versions prior to V8, we provided the metadata to XKTLoaderPlugin as an accompanying JSON file to load. We can
 * still do that for all XKT versions, and for XKT V8+ it will override any metadata provided within the XKT file.
 *
 * # Usage
 *
 * In the example below we'll load the Schependomlaan model from a [.XKT file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/models/xkt/schependomlaan).
 *
 * This will create a bunch of {@link Entity}s that represents the model and its objects, along with a {@link MetaModel} and {@link MetaObject}s
 * that hold their metadata.
 *
 * Since this model contains IFC types, the XKTLoaderPlugin will set the initial appearance of each object
 * {@link Entity} according to its IFC type in {@link XKTLoaderPlugin#objectDefaults}.
 *
 * Read more about this example in the user guide on [Viewing BIM Models Offline](https://www.notion.so/xeokit/Viewing-an-IFC-Model-with-xeokit-c373e48bc4094ff5b6e5c5700ff580ee).
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_metadata_Schependomlaan)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a Viewer,
 * // 2. Arrange the camera
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // 2
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a XKTLoaderPlugin,
 * // 2. Load a building model and JSON IFC metadata
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * // 2
 * const model = xktLoader.load({          // Returns an Entity that represents the model
 *     id: "myModel",
 *     src: "./models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 *
 * model.on("loaded", () => {
 *
 *     //--------------------------------------------------------------------------------------------------------------
 *     // 1. Find metadata on the third storey
 *     // 2. Select all the objects in the building's third storey
 *     // 3. Fit the camera to all the objects on the third storey
 *     //--------------------------------------------------------------------------------------------------------------
 *
 *     // 1
 *     const metaModel = viewer.metaScene.metaModels["myModel"];       // MetaModel with ID "myModel"
 *     const metaObject
 *          = viewer.metaScene.metaObjects["0u4wgLe6n0ABVaiXyikbkA"];  // MetaObject with ID "0u4wgLe6n0ABVaiXyikbkA"
 *
 *     const name = metaObject.name;                                   // "01 eerste verdieping"
 *     const type = metaObject.type;                                   // "IfcBuildingStorey"
 *     const parent = metaObject.parent;                               // MetaObject with type "IfcBuilding"
 *     const children = metaObject.children;                           // Array of child MetaObjects
 *     const objectId = metaObject.id;                                 // "0u4wgLe6n0ABVaiXyikbkA"
 *     const objectIds = viewer.metaScene.getObjectIDsInSubtree(objectId);   // IDs of leaf sub-objects
 *     const aabb = viewer.scene.getAABB(objectIds);                   // Axis-aligned boundary of the leaf sub-objects
 *
 *     // 2
 *     viewer.scene.setObjectsSelected(objectIds, true);
 *
 *     // 3
 *     viewer.cameraFlight.flyTo(aabb);
 * });
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 *
 * # Loading XKT files containing textures
 *
 * XKTLoaderPlugin uses a {@link KTX2TextureTranscoder} to load textures in XKT files (XKT v10+). An XKTLoaderPlugin has its own
 * default KTX2TextureTranscoder, configured to load the Basis Codec from the CDN. If we wish, we can override that with our own
 * KTX2TextureTranscoder instance that's configured to load the Codec locally.
 *
 * In the example below, we'll create a {@link Viewer} and add an XKTLoaderPlugin
 * configured with a KTX2TextureTranscoder that finds the Codec in our local file system. Then we'll use the
 * XKTLoaderPlugin to load an XKT file that contains KTX2 textures, which the plugin will transcode using
 * its KTX2TextureTranscoder.
 *
 * We'll configure our KTX2TextureTranscoder to load the Basis Codec from a local directory. If we were happy with loading the
 * Codec from our CDN (ie. our app will always have an Internet connection) then we could just leave out the
 * KTX2TextureTranscoder altogether, and let the XKTLoaderPlugin use its internal default KTX2TextureTranscoder, which is configured to
 * load the Codec from the CDN. We'll stick with loading our own Codec, in case we want to run our app without an Internet connection.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_Textures_HousePlan"><img src="https://xeokit.github.io/xeokit-sdk/assets/images/xktWithTextures.png"></a>
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_Textures_HousePlan)]
 *
 * ````javascript
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const textureTranscoder = new KTX2TextureTranscoder({
 *     viewer,
 *     transcoderPath: "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/" // <------ Path to Basis Universal transcoder
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer, {
 *     textureTranscoder // <<------------- Transcodes KTX2 textures in XKT files
 * });
 *
 * const sceneModel = xktLoader.load({
 *     id: "myModel",
 *     src: "./HousePlan.xkt" // <<------ XKT file with KTX2 textures
 * });
 * ````
 *
 * # Transforming
 *
 * We have the option to rotate, scale and translate each  *````.XKT````* model as we load it.
 *
 * This lets us load multiple models, or even multiple copies of the same model, and position them apart from each other.
 *
 * In the example below, we'll scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * translate it 100 units along its X axis.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_Duplex_transform)]
 *
 * ````javascript
 * xktLoader.load({
 *      src: "./models/xkt/Duplex.ifc.xkt",
 *      rotation: [90,0,0],
 *      scale: [0.5, 0.5, 0.5],
 *      position: [100, 0, 0]
 * });
 * ````
 *
 * # Including and excluding IFC types
 *
 * We can also load only those objects that have the specified IFC types.
 *
 * In the example below, we'll load only the objects that represent walls.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_includeTypes)]
 *
 * ````javascript
 * const model2 = xktLoader.load({
 *     id: "myModel2",
 *     src: "./models/xkt/OTCConferenceCenter.xkt",
 *     includeTypes: ["IfcWallStandardCase"]
 * });
 * ````
 *
 * We can also load only those objects that **don't** have the specified IFC types.
 *
 * In the example below, we'll load only the objects that do not represent empty space.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_excludeTypes)]
 *
 * ````javascript
 * const model3 = xktLoader.load({
 *     id: "myModel3",
 *     src: "./models/xkt/OTCConferenceCenter.xkt",
 *     excludeTypes: ["IfcSpace"]
 * });
 * ````
 *
 * # Configuring initial IFC object appearances
 *
 * We can specify the custom initial appearance of loaded objects according to their IFC types.
 *
 * This is useful for things like:
 *
 * * setting the colors to our objects according to their IFC types,
 * * automatically hiding ````IfcSpace```` objects, and
 * * ensuring that ````IfcWindow```` objects are always transparent.
 * <br>
 * In the example below, we'll load a model, while configuring ````IfcSpace```` elements to be always initially invisible,
 * and ````IfcWindow```` types to be always translucent blue.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_objectDefaults)]
 *
 * ````javascript
 * const myObjectDefaults = {
 *
 *      IfcSpace: {
 *          visible: false
 *      },
 *      IfcWindow: {
 *          colorize: [0.337255, 0.303922, 0.870588], // Blue
 *          opacity: 0.3
 *      },
 *
 *      //...
 *
 *      DEFAULT: {
 *          colorize: [0.5, 0.5, 0.5]
 *      }
 * };
 *
 * const model4 = xktLoader.load({
 *      id: "myModel4",
 *      src: "./models/xkt/Duplex.ifc.xkt",
 *      objectDefaults: myObjectDefaults // Use our custom initial default states for object Entities
 * });
 * ````
 *
 * When we don't customize the appearance of IFC types, as just above, then IfcSpace elements tend to obscure other
 * elements, which can be confusing.
 *
 * It's often helpful to make IfcSpaces transparent and unpickable, like this:
 *
 * ````javascript
 * const xktLoader = new XKTLoaderPlugin(viewer, {
 *    objectDefaults: {
 *        IfcSpace: {
 *            pickable: false,
 *            opacity: 0.2
 *        }
 *    }
 * });
 * ````
 *
 * Alternatively, we could just make IfcSpaces invisible, which also makes them unpickable:
 *
 * ````javascript
 * const xktLoader = new XKTLoaderPlugin(viewer, {
 *    objectDefaults: {
 *        IfcSpace: {
 *            visible: false
 *        }
 *    }
 * });
 * ````
 *
 * # Configuring a custom data source
 *
 * By default, XKTLoaderPlugin will load *````.XKT````* files and metadata JSON over HTTP.
 *
 * In the example below, we'll customize the way XKTLoaderPlugin loads the files by configuring it with our own data source
 * object. For simplicity, our custom data source example also uses HTTP, using a couple of xeokit utility functions.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_dataSource)]
 *
 * ````javascript
 * import {utils} from "xeokit-sdk.es.js";
 *
 * class MyDataSource {
 *
 *      constructor() {
 *      }
 *
 *      // Gets metamodel JSON
 *      getMetaModel(metaModelSrc, ok, error) {
 *          console.log("MyDataSource#getMetaModel(" + metaModelSrc + ", ... )");
 *          utils.loadJSON(metaModelSrc,
 *              (json) => {
 *                  ok(json);
 *              },
 *              function (errMsg) {
 *                  error(errMsg);
 *              });
 *      }
 *
 *      // Gets the contents of the given .XKT file in an arraybuffer
 *      getXKT(src, ok, error) {
 *          console.log("MyDataSource#getXKT(" + xKTSrc + ", ... )");
 *          utils.loadArraybuffer(src,
 *              (arraybuffer) => {
 *                  ok(arraybuffer);
 *              },
 *              function (errMsg) {
 *                  error(errMsg);
 *              });
 *      }
 * }
 *
 * const xktLoader2 = new XKTLoaderPlugin(viewer, {
 *       dataSource: new MyDataSource()
 * });
 *
 * const model5 = xktLoader2.load({
 *      id: "myModel5",
 *      src: "./models/xkt/Duplex.ifc.xkt"
 * });
 * ````
 *
 * # Loading multiple copies of a model, without object ID clashes
 *
 * Sometimes we need to load two or more instances of the same model, without having clashes
 * between the IDs of the equivalent objects in the model instances.
 *
 * As shown in the example below, we do this by setting {@link XKTLoaderPlugin#globalizeObjectIds} ````true```` before we load our models.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#TreeViewPlugin_Containment_MultipleModels)]
 *
 * ````javascript
 * xktLoader.globalizeObjectIds = true;
 *
 * const model = xktLoader.load({
 *      id: "model1",
 *      src: "./models/xkt/Schependomlaan.xkt"
 * });
 *
 * const model2 = xktLoader.load({
 *    id: "model2",
 *    src: "./models/xkt/Schependomlaan.xkt"
 * });
 * ````
 *
 * For each {@link Entity} loaded by these two calls, {@link Entity#id} and {@link MetaObject#id} will get prefixed by
 * the ID of their model, in order to avoid ID clashes between the two models.
 *
 * An Entity belonging to the first model will get an ID like this:
 *
 * ````
 * myModel1#0BTBFw6f90Nfh9rP1dlXrb
 * ````
 *
 * The equivalent Entity in the second model will get an ID like this:
 *
 * ````
 * myModel2#0BTBFw6f90Nfh9rP1dlXrb
 * ````
 *
 * Now, to update the visibility of both of those Entities collectively, using {@link Scene#setObjectsVisible}, we can
 * supply just the IFC product ID part to that method:
 *
 * ````javascript
 * myViewer.scene.setObjectVisibilities("0BTBFw6f90Nfh9rP1dlXrb", true);
 * ````
 *
 * The method, along with {@link Scene#setObjectsXRayed}, {@link Scene#setObjectsHighlighted} etc, will internally expand
 * the given ID to refer to the instances of that Entity in both models.
 *
 * We can also, of course, reference each Entity directly, using its globalized ID:
 *
 * ````javascript
 * myViewer.scene.setObjectVisibilities("myModel1#0BTBFw6f90Nfh9rP1dlXrb", true);
 *````
 *
 * We can also provide an HTTP URL to the XKT file:
 *
 * ````javascript
 * const sceneModel = xktLoader.load({
 *   manifestSrc: "https://xeokit.github.io/xeokit-sdk/assets/models/models/xkt/Schependomlaan.xkt",
 *   id: "myModel",
 * });
 * ````
 *
 * # Loading a model from a manifest of XKT files
 *
 * The `ifc2gltf` tool from Creoox, which converts IFC files into glTF geometry and JSON metadata files, has the option to
 * split its output into multiple pairs of glTF and JSON files, accompanied by a JSON manifest that lists the files.
 *
 * To integrate with that option, the `convert2xkt` tool, which converts glTF geometry and JSON metadata files into XKT files,
 * also has the option to batch-convert the glTF+JSON files in the manifest, in one invocation.
 *
 * When we use this option, convert2xkt will output a bunch of XKT files, along with a JSON manifest file that lists those XKT files.
 *
 * Working down the pipeline, the XKTLoaderPlugin has the option batch-load all XKT files listed in that manifest
 * into a xeokit Viewer in one load operation, combining the XKT files into a single SceneModel and MetaModel.
 *
 * You can learn more about this conversion and loading process, with splitting, batch converting and batch loading,
 * in [this tutorial](https://www.notion.so/xeokit/Importing-Huge-IFC-Models-as-Multiple-XKT-Files-165fc022e94742cf966ee50003572259).
 *
 * To show how to use XKTLoaderPlugin to load a manifest of XKT files, let's imagine that we have a set of such XKT files. As
 * described in the tutorial, they were converted by `ifc2gltf` from an IFC file into a set of glTF+JSON files, that were
 * then converted by convert2xkt into this set of XKT files and a manifest, as shown below.
 *
 * ````bash
 * ./
 *  model_1.xkt
 *  model_2.xkt
 *  model_3.xkt
 *  model_4..xkt
 *  model.xkt.manifest.json
 * ````
 *
 * The `model.xkt.manifest.json` XKT manifest would look something like this:
 *
 * ````json
 * {
 *   "inputFile": null,
 *   "converterApplication": "convert2xkt",
 *   "converterApplicationVersion": "v1.1.9",
 *   "conversionDate": "10-08-2023- 02-05-01",
 *   "outputDir": null,
 *   "xktFiles": [
 *     "model_1.xkt",
 *     "model_2.xkt",
 *     "model_3.xkt",
 *     "model_4.xkt"
 *   ]
 * }
 * ````
 *
 * Now, to load all those XKT files into a single SceneModel and MetaModel in one operation, we pass a path to the XKT
 * manifest to `XKTLoaderPlugin.load`, as shown in the example below:
 *
 * ````javascript
 * import {
 *   Viewer,
 *   XKTLoaderPlugin,
 *   TreeViewPlugin,
 * } from "xeokit-sdk.es.js";
 *
 * constviewer = new Viewer({
 *   canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [26.54, 29.29, 36.20,];
 * viewer.scene.camera.look = [-23.51, -8.26, -21.65,];
 * viewer.scene.camera.up = [-0.2, 0.89, -0.33,];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const sceneModel = xktLoader.load({
 *   manifestSrc: "model.xkt.manifest.json",
 *   id: "myModel",
 * });
 *
 * const metaModel = viewer.metaScene.metaModels[sceneModel.id];
 *
 * // Then when we need to, we can destroy the SceneModel
 * // and MetaModel in one shot, like so:
 *
 * sceneModel.destroy();
 * metaModel.destroy();
 * ````
 *
 * The main advantage here, of splitting IFC files like this within the conversion and import pipeline,
 * is to reduce the memory pressure on each of the `ifc2gltf`, `convert2xkt` and XKTLoaderPlugin components.
 * They work much reliably (and faster) when processing smaller files (eg. 20MB) than when processing large files (eg. 500MB), where
 * they have less trouble allocating the system memory they need for conversion and parsing.
 *
 * We can also provide an HTTP URL to the manifest:
 *
 * ````javascript
 * const sceneModel = xktLoader.load({
 *   manifestSrc: "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model.xkt.manifest.json",
 *   id: "myModel",
 * });
 * ````
 *
 * We can also provide the manifest as parameter object:
 *
 * ````javascript
 * const sceneModel = xktLoader.load({
 *   id: "myModel",
 *   manifest: {
 *   inputFile: "assets/models/gltf/Karhumaki/model.glb.manifest.json",
 *   converterApplication: "convert2xkt",
 *   converterApplicationVersion: "v1.1.10",
 *   conversionDate": "09-11-2023- 18-29-01",
 *     xktFiles: [
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_1.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_2.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_3.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_4.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_5.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_6.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_7.xkt",
 *       "../../assets/models/xkt/v10/split/Karhumaki-Bridge/model_8.xkt"
 *     ]
 *   }
 * });
 * ````
 *
 * We can also provide the paths to the XKT files as HTTP URLs:
 *
 * ````javascript
 * const sceneModel = xktLoader.load({
 *   id: "myModel",
 *   manifest: {
 *   inputFile: "assets/models/gltf/Karhumaki/model.glb.manifest.json",
 *   converterApplication: "convert2xkt",
 *   converterApplicationVersion: "v1.1.10",
 *   conversionDate": "09-11-2023- 18-29-01",
 *     xktFiles: [
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_1.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_2.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_3.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_4.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_5.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_6.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_7.xkt",
 *       "https://xeokit.github.io/xeokit-sdk/assets/models/xkt/v10/split/Karhumaki-Bridge/model_8.xkt"
 *     ]
 *   }
 * });
 * ````
 *
 * @class XKTLoaderPlugin
 */var XKTLoaderPlugin=/*#__PURE__*/function(_Plugin17){_inherits(XKTLoaderPlugin,_Plugin17);var _super158=_createSuper(XKTLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="XKTLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Object} [cfg.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object.  Default value is {@link IFCObjectDefaults}.
     * @param {Object} [cfg.dataSource] A custom data source through which the XKTLoaderPlugin can load model and metadata files. Defaults to an instance of {@link XKTDefaultDataSource}, which loads uover HTTP.
     * @param {String[]} [cfg.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {String[]} [cfg.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [cfg.excludeUnclassifiedObjects=false] When loading metadata and this is ````true````, will only load {@link Entity}s that have {@link MetaObject}s (that are not excluded). This is useful when we don't want Entitys in the Scene that are not represented within IFC navigation components, such as {@link TreeViewPlugin}.
     * @param {Boolean} [cfg.reuseGeometries=true] Indicates whether to enable geometry reuse (````true```` by default) or whether to internally expand
     * all geometry instances into batches (````false````), and not use instancing to render them. Setting this ````false```` can significantly
     * improve Viewer performance for models that have a lot of geometry reuse, but may also increase the amount of
     * browser and GPU memory they require. See [#769](https://github.com/xeokit/xeokit-sdk/issues/769) for more info.
     * @param {Number} [cfg.maxGeometryBatchSize=50000000] Maximum geometry batch size, as number of vertices. This is optionally supplied
     * to limit the size of the batched geometry arrays that {@link SceneModel} internally creates for batched geometries.
     * A low value means less heap allocation/de-allocation while loading batched geometries, but more draw calls and
     * slower rendering speed. A high value means larger heap allocation/de-allocation while loading, but less draw calls
     * and faster rendering speed. It's recommended to keep this somewhere roughly between ````50000```` and ````50000000```.
     * @param {KTX2TextureTranscoder} [cfg.textureTranscoder] Transcoder used internally to transcode KTX2
     * textures within the XKT. Only required when the XKT is version 10 or later, and contains KTX2 textures.
     */function XKTLoaderPlugin(viewer){var _this153;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,XKTLoaderPlugin);_this153=_super158.call(this,"XKTLoader",viewer,cfg);_this153._maxGeometryBatchSize=cfg.maxGeometryBatchSize;_this153.textureTranscoder=cfg.textureTranscoder;_this153.dataSource=cfg.dataSource;_this153.objectDefaults=cfg.objectDefaults;_this153.includeTypes=cfg.includeTypes;_this153.excludeTypes=cfg.excludeTypes;_this153.excludeUnclassifiedObjects=cfg.excludeUnclassifiedObjects;_this153.reuseGeometries=cfg.reuseGeometries;return _this153;}/**
     * Gets the ````.xkt```` format versions supported by this XKTLoaderPlugin/
     * @returns {string[]}
     */_createClass(XKTLoaderPlugin,[{key:"supportedVersions",get:function get(){return Object.keys(parsers);}/**
     * Gets the texture transcoder.
     *
     * @type {TextureTranscoder}
     */},{key:"textureTranscoder",get:function get(){return this._textureTranscoder;}/**
     * Sets the texture transcoder.
     *
     * @type {TextureTranscoder}
     */,set:function set(textureTranscoder){this._textureTranscoder=textureTranscoder;}/**
     * Gets the custom data source through which the XKTLoaderPlugin can load models and metadata.
     *
     * Default value is {@link XKTDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */},{key:"dataSource",get:function get(){return this._dataSource;}/**
     * Sets a custom data source through which the XKTLoaderPlugin can load models and metadata.
     *
     * Default value is {@link XKTDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */,set:function set(value){this._dataSource=value||new XKTDefaultDataSource();}/**
     * Gets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */},{key:"objectDefaults",get:function get(){return this._objectDefaults;}/**
     * Sets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */,set:function set(value){this._objectDefaults=value||IFCObjectDefaults;}/**
     * Gets the whitelist of the IFC types loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to only load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */},{key:"includeTypes",get:function get(){return this._includeTypes;}/**
     * Sets the whitelist of the IFC types loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to only load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */,set:function set(value){this._includeTypes=value;}/**
     * Gets the blacklist of IFC types that are never loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to **not** load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */},{key:"excludeTypes",get:function get(){return this._excludeTypes;}/**
     * Sets the blacklist of IFC types that are never loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to **not** load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */,set:function set(value){this._excludeTypes=value;}/**
     * Gets whether we load objects that don't have IFC types.
     *
     * When loading models with metadata and this is ````true````, XKTLoaderPlugin will not load objects
     * that don't have IFC types.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */},{key:"excludeUnclassifiedObjects",get:function get(){return this._excludeUnclassifiedObjects;}/**
     * Sets whether we load objects that don't have IFC types.
     *
     * When loading models with metadata and this is ````true````, XKTLoaderPlugin will not load objects
     * that don't have IFC types.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){this._excludeUnclassifiedObjects=!!value;}/**
     * Gets whether XKTLoaderPlugin globalizes each {@link Entity#id} and {@link MetaObject#id} as it loads a model.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */},{key:"globalizeObjectIds",get:function get(){return this._globalizeObjectIds;}/**
     * Sets whether XKTLoaderPlugin globalizes each {@link Entity#id} and {@link MetaObject#id} as it loads a model.
     *
     * Set  this ````true```` when you need to load multiple instances of the same model, to avoid ID clashes
     * between the objects in the different instances.
     *
     * When we load a model with this set ````true````, then each {@link Entity#id} and {@link MetaObject#id} will be
     * prefixed by the ID of the model, ie. ````<modelId>#<objectId>````.
     *
     * {@link Entity#originalSystemId} and {@link MetaObject#originalSystemId} will always hold the original, un-prefixed, ID values.
     *
     * Default value is ````false````.
     *
     * See the main {@link XKTLoaderPlugin} class documentation for usage info.
     *
     * @type {Boolean}
     */,set:function set(value){this._globalizeObjectIds=!!value;}/**
     * Gets whether XKTLoaderPlugin enables geometry reuse when loading models.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */},{key:"reuseGeometries",get:function get(){return this._reuseGeometries;}/**
     * Sets whether XKTLoaderPlugin enables geometry reuse when loading models.
     *
     * Default value is ````true````.
     *
     * Geometry reuse saves memory, but can impact Viewer performance when there are many reused geometries. For
     * this reason, we can set this ````false```` to disable geometry reuse for models loaded by this XKTLoaderPlugin
     * (which will then "expand" the geometry instances into batches instead).
     *
     * The result will be be less WebGL draw calls (which are expensive), at the cost of increased memory footprint.
     *
     * See [#769](https://github.com/xeokit/xeokit-sdk/issues/769) for more info.
     *
     * @type {Boolean}
     */,set:function set(value){this._reuseGeometries=value!==false;}/**
     * Loads an ````.xkt```` model into this XKTLoaderPlugin's {@link Viewer}.
     *
     * Since xeokit/xeokit-sdk 1.9.0, XKTLoaderPlugin has supported XKT 8, which bundles the metamodel
     * data (eg. an IFC element hierarchy) in the XKT file itself. For XKT 8, we therefore no longer need to
     * load the metamodel data from a separate accompanying JSON file, as we did with previous XKT versions.
     * However, if we do choose to specify a separate metamodel JSON file to load (eg. for backward compatibility
     * in data pipelines), then that metamodel will be loaded and the metamodel in the XKT 8 file will be ignored.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path or URL to an *````.xkt````* file, as an alternative to the ````xkt```` parameter.
     * @param {ArrayBuffer} [params.xkt] The *````.xkt````* file data, as an alternative to the ````src```` parameter.
     * @param {String} [params.metaModelSrc] Path or URL to an optional metadata file, as an alternative to the ````metaModelData```` parameter.
     * @param {*} [params.metaModelData] JSON model metadata, as an alternative to the ````metaModelSrc```` parameter.
     * @param {String} [params.manifestSrc] Path or URL to a JSON manifest file that provides paths to ````.xkt```` files to load as parts of the model. Use this option to load models that have been split into
     * multiple XKT files. See [tutorial](https://www.notion.so/xeokit/Automatically-Splitting-Large-Models-for-Better-Performance-165fc022e94742cf966ee50003572259) for more info.
     * @param {Object} [params.manifest] A JSON manifest object (as an alternative to a path or URL) that provides paths to ````.xkt```` files to load as parts of the model. Use this option to load models that have been split into
     * multiple XKT files. See [tutorial](https://www.notion.so/xeokit/Automatically-Splitting-Large-Models-for-Better-Performance-165fc022e94742cf966ee50003572259) for more info.
     * @param {{String:Object}} [params.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object. Default value is {@link IFCObjectDefaults}.
     * @param {String[]} [params.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {String[]} [params.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the model with edges emphasized.
     * @param {Number[]} [params.origin=[0,0,0]] The model's World-space double-precision 3D origin. Use this to position the model within xeokit's World coordinate system, using double-precision coordinates.
     * @param {Number[]} [params.position=[0,0,0]] The model single-precision 3D position, relative to the ````origin```` parameter.
     * @param {Number[]} [params.scale=[1,1,1]] The model's scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's orientation, given as Euler angles in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters. Relative to ````origin````.
     * @param {Boolean} [params.edges=false] Indicates if the model's edges are initially emphasized.
     * @param {Boolean} [params.saoEnabled=true] Indicates if Scalable Ambient Obscurance (SAO) is enabled for the model. SAO is configured by the Scene's {@link SAO} component. Only works when {@link SAO#enabled} is also ````true````
     * @param {Boolean} [params.pbrEnabled=true] Indicates if physically-based rendering (PBR) is enabled for the model. Overrides ````colorTextureEnabled````. Only works when {@link Scene#pbrEnabled} is also ````true````.
     * @param {Boolean} [params.colorTextureEnabled=true] Indicates if base color texture rendering is enabled for the model. Overridden by ````pbrEnabled````.  Only works when {@link Scene#colorTextureEnabled} is also ````true````.
     * @param {Number} [params.backfaces=false] When we set this ````true````, then we force rendering of backfaces for the model. When
     * we leave this ````false````, then we allow the Viewer to decide when to render backfaces. In that case, the
     * Viewer will hide backfaces on watertight meshes, show backfaces on open meshes, and always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     * @param {Boolean} [params.excludeUnclassifiedObjects=false] When loading metadata and this is ````true````, will only load {@link Entity}s that have {@link MetaObject}s (that are not excluded). This is useful when we don't want Entitys in the Scene that are not represented within IFC navigation components, such as {@link TreeViewPlugin}.
     * @param {Boolean} [params.globalizeObjectIds=false] Indicates whether to globalize each {@link Entity#id} and {@link MetaObject#id}, in case you need to prevent ID clashes with other models. See {@link XKTLoaderPlugin#globalizeObjectIds} for more info.
     * @param {Boolean} [params.reuseGeometries=true] Indicates whether to enable geometry reuse (````true```` by default) or whether to expand
     * all geometry instances into batches (````false````), and not use instancing to render them. Setting this ````false```` can significantly
     * improve Viewer performance for models that have excessive geometry reuse, but may also increases the amount of
     * browser and GPU memory used by the model. See [#769](https://github.com/xeokit/xeokit-sdk/issues/769) for more info.
     * @param {Boolean} [params.dtxEnabled=true] When ````true```` (default) use data textures (DTX), where appropriate, to
     * represent the returned model. Set false to always use vertex buffer objects (VBOs). Note that DTX is only applicable
     * to non-textured triangle meshes, and that VBOs are always used for meshes that have textures, line segments, or point
     * primitives. Only works while {@link DTX#enabled} is also ````true````.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
     */},{key:"load",value:function load(){var _this154=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}if(!params.src&&!params.xkt&&!params.manifestSrc&&!params.manifest){this.error("load() param expected: src, xkt, manifestSrc or manifestData");return sceneModel;// Return new empty model
}var options={};var includeTypes=params.includeTypes||this._includeTypes;var excludeTypes=params.excludeTypes||this._excludeTypes;var objectDefaults=params.objectDefaults||this._objectDefaults;options.reuseGeometries=params.reuseGeometries!==null&&params.reuseGeometries!==undefined?params.reuseGeometries:this._reuseGeometries!==false;if(includeTypes){options.includeTypesMap={};for(var _i566=0,len=includeTypes.length;_i566<len;_i566++){options.includeTypesMap[includeTypes[_i566]]=true;}}if(excludeTypes){options.excludeTypesMap={};for(var _i567=0,_len118=excludeTypes.length;_i567<_len118;_i567++){options.excludeTypesMap[excludeTypes[_i567]]=true;}}if(objectDefaults){options.objectDefaults=objectDefaults;}options.excludeUnclassifiedObjects=params.excludeUnclassifiedObjects!==undefined?!!params.excludeUnclassifiedObjects:this._excludeUnclassifiedObjects;options.globalizeObjectIds=params.globalizeObjectIds!==undefined&&params.globalizeObjectIds!==null?!!params.globalizeObjectIds:this._globalizeObjectIds;var sceneModel=new SceneModel(this.viewer.scene,utils.apply(params,{isModel:true,textureTranscoder:this._textureTranscoder,maxGeometryBatchSize:this._maxGeometryBatchSize,origin:params.origin,disableVertexWelding:params.disableVertexWelding||false,disableIndexRebucketing:params.disableIndexRebucketing||false,dtxEnabled:params.dtxEnabled}));var modelId=sceneModel.id;// In case ID was auto-generated
var metaModel=new MetaModel({metaScene:this.viewer.metaScene,id:modelId});this.viewer.scene.canvas.spinner.processes++;var finish=function finish(){// this._createDefaultMetaModelIfNeeded(sceneModel, params, options);
sceneModel.finalize();metaModel.finalize();_this154.viewer.scene.canvas.spinner.processes--;sceneModel.once("destroyed",function(){_this154.viewer.metaScene.destroyMetaModel(metaModel.id);});_this154.scheduleTask(function(){if(sceneModel.destroyed){return;}sceneModel.scene.fire("modelLoaded",sceneModel.id);// FIXME: Assumes listeners know order of these two events
sceneModel.fire("loaded",true,false);// Don't forget the event, for late subscribers
});};var error=function error(errMsg){_this154.viewer.scene.canvas.spinner.processes--;_this154.error(errMsg);sceneModel.fire("error",errMsg);};var nextId=0;var manifestCtx={getNextId:function getNextId(){return"".concat(modelId,".").concat(nextId++);}};if(params.metaModelSrc||params.metaModelData){if(params.metaModelSrc){var metaModelSrc=params.metaModelSrc;this._dataSource.getMetaModel(metaModelSrc,function(metaModelData){if(sceneModel.destroyed){return;}metaModel.loadData(metaModelData,{includeTypes:includeTypes,excludeTypes:excludeTypes,globalizeObjectIds:options.globalizeObjectIds});if(params.src){_this154._loadModel(params.src,params,options,sceneModel,null,manifestCtx,finish,error);}else{_this154._parseModel(params.xkt,params,options,sceneModel,null,manifestCtx);finish();}},function(errMsg){error("load(): Failed to load model metadata for model '".concat(modelId," from  '").concat(metaModelSrc,"' - ").concat(errMsg));});}else if(params.metaModelData){metaModel.loadData(params.metaModelData,{includeTypes:includeTypes,excludeTypes:excludeTypes,globalizeObjectIds:options.globalizeObjectIds});if(params.src){this._loadModel(params.src,params,options,sceneModel,null,manifestCtx,finish,error);}else{this._parseModel(params.xkt,params,options,sceneModel,null,manifestCtx);finish();}}}else{if(params.src){this._loadModel(params.src,params,options,sceneModel,metaModel,manifestCtx,finish,error);}else if(params.xkt){this._parseModel(params.xkt,params,options,sceneModel,metaModel,manifestCtx);finish();}else if(params.manifestSrc||params.manifest){var baseDir=params.manifestSrc?getBaseDirectory(params.manifestSrc):"";var loadJSONs=function loadJSONs(metaDataFiles,done,error){var i=0;var loadNext=function loadNext(){if(i>=metaDataFiles.length){done();}else{_this154._dataSource.getMetaModel("".concat(baseDir).concat(metaDataFiles[i]),function(metaModelData){metaModel.loadData(metaModelData,{includeTypes:includeTypes,excludeTypes:excludeTypes,globalizeObjectIds:options.globalizeObjectIds});i++;_this154.scheduleTask(loadNext,100);},error);}};loadNext();};var loadXKTs_excludeTheirMetaModels=function loadXKTs_excludeTheirMetaModels(xktFiles,done,error){// Load XKTs, ignore metamodels in the XKT
var i=0;var loadNext=function loadNext(){if(i>=xktFiles.length){done();}else{_this154._dataSource.getXKT("".concat(baseDir).concat(xktFiles[i]),function(arrayBuffer){_this154._parseModel(arrayBuffer,params,options,sceneModel,null/* Ignore metamodel in XKT */,manifestCtx);i++;_this154.scheduleTask(loadNext,100);},error);}};loadNext();};var loadXKTs_includeTheirMetaModels=function loadXKTs_includeTheirMetaModels(xktFiles,done,error){// Load XKTs, parse metamodels from the XKT
var i=0;var loadNext=function loadNext(){if(i>=xktFiles.length){done();}else{_this154._dataSource.getXKT("".concat(baseDir).concat(xktFiles[i]),function(arrayBuffer){_this154._parseModel(arrayBuffer,params,options,sceneModel,metaModel,manifestCtx);i++;_this154.scheduleTask(loadNext,100);},error);}};loadNext();};if(params.manifest){var manifestData=params.manifest;var xktFiles=manifestData.xktFiles;if(!xktFiles||xktFiles.length===0){error("load(): Failed to load model manifest - manifest not valid");return;}var metaModelFiles=manifestData.metaModelFiles;if(metaModelFiles){loadJSONs(metaModelFiles,function(){loadXKTs_excludeTheirMetaModels(xktFiles,finish,error);},error);}else{loadXKTs_includeTheirMetaModels(xktFiles,finish,error);}}else{this._dataSource.getManifest(params.manifestSrc,function(manifestData){if(sceneModel.destroyed){return;}var xktFiles=manifestData.xktFiles;if(!xktFiles||xktFiles.length===0){error("load(): Failed to load model manifest - manifest not valid");return;}var metaModelFiles=manifestData.metaModelFiles;if(metaModelFiles){loadJSONs(metaModelFiles,function(){loadXKTs_excludeTheirMetaModels(xktFiles,finish,error);},error);}else{loadXKTs_includeTheirMetaModels(xktFiles,finish,error);}},error);}}}return sceneModel;}},{key:"_loadModel",value:function _loadModel(src,params,options,sceneModel,metaModel,manifestCtx,done,error){var _this155=this;this._dataSource.getXKT(params.src,function(arrayBuffer){_this155._parseModel(arrayBuffer,params,options,sceneModel,metaModel,manifestCtx);done();},error);}},{key:"_parseModel",value:function _parseModel(arrayBuffer,params,options,sceneModel,metaModel,manifestCtx){if(sceneModel.destroyed){return;}var dataView=new DataView(arrayBuffer);var dataArray=new Uint8Array(arrayBuffer);var xktVersion=dataView.getUint32(0,true);var parser=parsers[xktVersion];if(!parser){this.error("Unsupported .XKT file version: "+xktVersion+" - this XKTLoaderPlugin supports versions "+Object.keys(parsers));return;}this.log("Loading .xkt V"+xktVersion);var numElements=dataView.getUint32(4,true);var elements=[];var byteOffset=(numElements+2)*4;for(var _i568=0;_i568<numElements;_i568++){var elementSize=dataView.getUint32((_i568+2)*4,true);elements.push(dataArray.subarray(byteOffset,byteOffset+elementSize));byteOffset+=elementSize;}parser.parse(this.viewer,options,elements,sceneModel,metaModel,manifestCtx);}}]);return XKTLoaderPlugin;}(Plugin);function getBaseDirectory(filePath){var pathArray=filePath.split('/');pathArray.pop();// Remove the file name or the last segment of the path
return pathArray.join('/')+'/';}/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /**
 * @private
 * @type {{}}
 */var zipLib={};(function(obj){var ERR_BAD_FORMAT="File format is not recognized.";var ERR_CRC="CRC failed.";var ERR_ENCRYPTED="File contains encrypted entry.";var ERR_ZIP64="File is using Zip64 (4gb+ file size).";var ERR_READ="Error while reading zip file.";var ERR_WRITE="Error while writing zip file.";var ERR_WRITE_DATA="Error while writing file data.";var ERR_READ_DATA="Error while reading file data.";var ERR_DUPLICATED_NAME="File already exists.";var CHUNK_SIZE=512*1024;var TEXT_PLAIN="text/plain";var appendABViewSupported;try{appendABViewSupported=new Blob([new DataView(new ArrayBuffer(0))]).size===0;}catch(e){}function Crc32(){this.crc=-1;}Crc32.prototype.append=function append(data){var crc=this.crc|0,table=this.table;for(var offset=0,len=data.length|0;offset<len;offset++){crc=crc>>>8^table[(crc^data[offset])&0xFF];}this.crc=crc;};Crc32.prototype.get=function get(){return~this.crc;};Crc32.prototype.table=function(){var i,j,t,table=[];// Uint32Array is actually slower than []
for(i=0;i<256;i++){t=i;for(j=0;j<8;j++){if(t&1)t=t>>>1^0xEDB88320;else t=t>>>1;}table[i]=t;}return table;}();// "no-op" codec
function NOOP(){}NOOP.prototype.append=function append(bytes,onprogress){return bytes;};NOOP.prototype.flush=function flush(){};function blobSlice(blob,index,length){if(index<0||length<0||index+length>blob.size)throw new RangeError('offset:'+index+', length:'+length+', size:'+blob.size);if(blob.slice)return blob.slice(index,index+length);else if(blob.webkitSlice)return blob.webkitSlice(index,index+length);else if(blob.mozSlice)return blob.mozSlice(index,index+length);else if(blob.msSlice)return blob.msSlice(index,index+length);}function getDataHelper(byteLength,bytes){var dataBuffer,dataArray;dataBuffer=new ArrayBuffer(byteLength);dataArray=new Uint8Array(dataBuffer);if(bytes)dataArray.set(bytes,0);return{buffer:dataBuffer,array:dataArray,view:new DataView(dataBuffer)};}// Readers
function Reader(){}function TextReader(text){var that=this,blobReader;function init(callback,onerror){var blob=new Blob([text],{type:TEXT_PLAIN});blobReader=new BlobReader(blob);blobReader.init(function(){that.size=blobReader.size;callback();},onerror);}function readUint8Array(index,length,callback,onerror){blobReader.readUint8Array(index,length,callback,onerror);}that.size=0;that.init=init;that.readUint8Array=readUint8Array;}TextReader.prototype=new Reader();TextReader.prototype.constructor=TextReader;function Data64URIReader(dataURI){var that=this,dataStart;function init(callback){var dataEnd=dataURI.length;while(dataURI.charAt(dataEnd-1)=="="){dataEnd--;}dataStart=dataURI.indexOf(",")+1;that.size=Math.floor((dataEnd-dataStart)*0.75);callback();}function readUint8Array(index,length,callback){var i,data=getDataHelper(length);var start=Math.floor(index/3)*4;var end=Math.ceil((index+length)/3)*4;var bytes=obj.atob(dataURI.substring(start+dataStart,end+dataStart));var delta=index-Math.floor(start/4)*3;for(i=delta;i<delta+length;i++){data.array[i-delta]=bytes.charCodeAt(i);}callback(data.array);}that.size=0;that.init=init;that.readUint8Array=readUint8Array;}Data64URIReader.prototype=new Reader();Data64URIReader.prototype.constructor=Data64URIReader;function BlobReader(blob){var that=this;function init(callback){that.size=blob.size;callback();}function readUint8Array(index,length,callback,onerror){var reader=new FileReader();reader.onload=function(e){callback(new Uint8Array(e.target.result));};reader.onerror=onerror;try{reader.readAsArrayBuffer(blobSlice(blob,index,length));}catch(e){onerror(e);}}that.size=0;that.init=init;that.readUint8Array=readUint8Array;}BlobReader.prototype=new Reader();BlobReader.prototype.constructor=BlobReader;// Writers
function Writer(){}Writer.prototype.getData=function(callback){callback(this.data);};function TextWriter(encoding){var that=this,blob;function init(callback){blob=new Blob([],{type:TEXT_PLAIN});callback();}function writeUint8Array(array,callback){blob=new Blob([blob,appendABViewSupported?array:array.buffer],{type:TEXT_PLAIN});callback();}function getData(callback,onerror){var reader=new FileReader();reader.onload=function(e){callback(e.target.result);};reader.onerror=onerror;reader.readAsText(blob,encoding);}that.init=init;that.writeUint8Array=writeUint8Array;that.getData=getData;}TextWriter.prototype=new Writer();TextWriter.prototype.constructor=TextWriter;function Data64URIWriter(contentType){var that=this,data="",pending="";function init(callback){data+="data:"+(contentType||"")+";base64,";callback();}function writeUint8Array(array,callback){var i,delta=pending.length,dataString=pending;pending="";for(i=0;i<Math.floor((delta+array.length)/3)*3-delta;i++){dataString+=String.fromCharCode(array[i]);}for(;i<array.length;i++){pending+=String.fromCharCode(array[i]);}if(dataString.length>2)data+=obj.btoa(dataString);else pending=dataString;callback();}function getData(callback){callback(data+obj.btoa(pending));}that.init=init;that.writeUint8Array=writeUint8Array;that.getData=getData;}Data64URIWriter.prototype=new Writer();Data64URIWriter.prototype.constructor=Data64URIWriter;function BlobWriter(contentType){var blob,that=this;function init(callback){blob=new Blob([],{type:contentType});callback();}function writeUint8Array(array,callback){blob=new Blob([blob,appendABViewSupported?array:array.buffer],{type:contentType});callback();}function getData(callback){callback(blob);}that.init=init;that.writeUint8Array=writeUint8Array;that.getData=getData;}BlobWriter.prototype=new Writer();BlobWriter.prototype.constructor=BlobWriter;/**
     * inflate/deflate core functions
     * @param worker {Worker} web worker for the task.
     * @param initialMessage {Object} initial message to be sent to the worker. should contain
     *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
     *   This function may add more properties before sending.
     */function launchWorkerProcess(worker,initialMessage,reader,writer,offset,size,onprogress,onend,onreaderror,onwriteerror){var chunkIndex=0,index,outputSize,sn=initialMessage.sn,crc;function onflush(){worker.removeEventListener('message',onmessage,false);onend(outputSize,crc);}function onmessage(event){var message=event.data,data=message.data,err=message.error;if(err){err.toString=function(){return'Error: '+this.message;};onreaderror(err);return;}if(message.sn!==sn)return;if(typeof message.codecTime==='number')worker.codecTime+=message.codecTime;// should be before onflush()
if(typeof message.crcTime==='number')worker.crcTime+=message.crcTime;switch(message.type){case'append':if(data){outputSize+=data.length;writer.writeUint8Array(data,function(){step();},onwriteerror);}else step();break;case'flush':crc=message.crc;if(data){outputSize+=data.length;writer.writeUint8Array(data,function(){onflush();},onwriteerror);}else onflush();break;case'progress':if(onprogress)onprogress(index+message.loaded,size);break;case'importScripts'://no need to handle here
case'newTask':case'echo':break;default:console.warn('zip.js:launchWorkerProcess: unknown message: ',message);}}function step(){index=chunkIndex*CHUNK_SIZE;// use `<=` instead of `<`, because `size` may be 0.
if(index<=size){reader.readUint8Array(offset+index,Math.min(CHUNK_SIZE,size-index),function(array){if(onprogress)onprogress(index,size);var msg=index===0?initialMessage:{sn:sn};msg.type='append';msg.data=array;// posting a message with transferables will fail on IE10
try{worker.postMessage(msg,[array.buffer]);}catch(ex){worker.postMessage(msg);// retry without transferables
}chunkIndex++;},onreaderror);}else{worker.postMessage({sn:sn,type:'flush'});}}outputSize=0;worker.addEventListener('message',onmessage,false);step();}function launchProcess(process,reader,writer,offset,size,crcType,onprogress,onend,onreaderror,onwriteerror){var chunkIndex=0,index,outputSize=0,crcInput=crcType==='input',crcOutput=crcType==='output',crc=new Crc32();function step(){var outputData;index=chunkIndex*CHUNK_SIZE;if(index<size)reader.readUint8Array(offset+index,Math.min(CHUNK_SIZE,size-index),function(inputData){var outputData;try{outputData=process.append(inputData,function(loaded){if(onprogress)onprogress(index+loaded,size);});}catch(e){onreaderror(e);return;}if(outputData){outputSize+=outputData.length;writer.writeUint8Array(outputData,function(){chunkIndex++;setTimeout(step,1);},onwriteerror);if(crcOutput)crc.append(outputData);}else{chunkIndex++;setTimeout(step,1);}if(crcInput)crc.append(inputData);if(onprogress)onprogress(index,size);},onreaderror);else{try{outputData=process.flush();}catch(e){onreaderror(e);return;}if(outputData){if(crcOutput)crc.append(outputData);outputSize+=outputData.length;writer.writeUint8Array(outputData,function(){onend(outputSize,crc.get());},onwriteerror);}else onend(outputSize,crc.get());}}step();}function inflate(worker,sn,reader,writer,offset,size,computeCrc32,onend,onprogress,onreaderror,onwriteerror){var crcType=computeCrc32?'output':'none';if(obj.zip.useWebWorkers){var initialMessage={sn:sn,codecClass:'Inflater',crcType:crcType};launchWorkerProcess(worker,initialMessage,reader,writer,offset,size,onprogress,onend,onreaderror,onwriteerror);}else launchProcess(new obj.zip.Inflater(),reader,writer,offset,size,crcType,onprogress,onend,onreaderror,onwriteerror);}function deflate(worker,sn,reader,writer,level,onend,onprogress,onreaderror,onwriteerror){var crcType='input';if(obj.zip.useWebWorkers){var initialMessage={sn:sn,options:{level:level},codecClass:'Deflater',crcType:crcType};launchWorkerProcess(worker,initialMessage,reader,writer,0,reader.size,onprogress,onend,onreaderror,onwriteerror);}else launchProcess(new obj.zip.Deflater(),reader,writer,0,reader.size,crcType,onprogress,onend,onreaderror,onwriteerror);}function copy(worker,sn,reader,writer,offset,size,computeCrc32,onend,onprogress,onreaderror,onwriteerror){var crcType='input';if(obj.zip.useWebWorkers&&computeCrc32){var initialMessage={sn:sn,codecClass:'NOOP',crcType:crcType};launchWorkerProcess(worker,initialMessage,reader,writer,offset,size,onprogress,onend,onreaderror,onwriteerror);}else launchProcess(new NOOP(),reader,writer,offset,size,crcType,onprogress,onend,onreaderror,onwriteerror);}// ZipReader
function decodeASCII(str){var i,out="",charCode,extendedASCII=["\xC7","\xFC","\xE9","\xE2","\xE4","\xE0","\xE5","\xE7","\xEA","\xEB","\xE8","\xEF","\xEE","\xEC","\xC4","\xC5","\xC9","\xE6","\xC6","\xF4","\xF6","\xF2","\xFB","\xF9","\xFF","\xD6","\xDC","\xF8","\xA3","\xD8","\xD7","\u0192","\xE1","\xED","\xF3","\xFA","\xF1","\xD1","\xAA","\xBA","\xBF","\xAE","\xAC","\xBD","\xBC","\xA1","\xAB","\xBB",'_','_','_',"\xA6","\xA6","\xC1","\xC2","\xC0","\xA9","\xA6","\xA6",'+','+',"\xA2","\xA5",'+','+','-','-','+','-','+',"\xE3","\xC3",'+','+','-','-',"\xA6",'-','+',"\xA4","\xF0","\xD0","\xCA","\xCB","\xC8",'i',"\xCD","\xCE","\xCF",'+','+','_','_',"\xA6","\xCC",'_',"\xD3","\xDF","\xD4","\xD2","\xF5","\xD5","\xB5","\xFE","\xDE","\xDA","\xDB","\xD9","\xFD","\xDD","\xAF","\xB4","\xAD","\xB1",'_',"\xBE","\xB6","\xA7","\xF7","\xB8","\xB0","\xA8","\xB7","\xB9","\xB3","\xB2",'_',' '];for(i=0;i<str.length;i++){charCode=str.charCodeAt(i)&0xFF;if(charCode>127)out+=extendedASCII[charCode-128];else out+=String.fromCharCode(charCode);}return out;}function decodeUTF8(string){return decodeURIComponent(escape(string));}function getString(bytes){var i,str="";for(i=0;i<bytes.length;i++){str+=String.fromCharCode(bytes[i]);}return str;}function getDate(timeRaw){var date=(timeRaw&0xffff0000)>>16,time=timeRaw&0x0000ffff;try{return new Date(1980+((date&0xFE00)>>9),((date&0x01E0)>>5)-1,date&0x001F,(time&0xF800)>>11,(time&0x07E0)>>5,(time&0x001F)*2,0);}catch(e){}}function readCommonHeader(entry,data,index,centralDirectory,onerror){entry.version=data.view.getUint16(index,true);entry.bitFlag=data.view.getUint16(index+2,true);entry.compressionMethod=data.view.getUint16(index+4,true);entry.lastModDateRaw=data.view.getUint32(index+6,true);entry.lastModDate=getDate(entry.lastModDateRaw);if((entry.bitFlag&0x01)===0x01){onerror(ERR_ENCRYPTED);return;}if(centralDirectory||(entry.bitFlag&0x0008)!=0x0008){entry.crc32=data.view.getUint32(index+10,true);entry.compressedSize=data.view.getUint32(index+14,true);entry.uncompressedSize=data.view.getUint32(index+18,true);}if(entry.compressedSize===0xFFFFFFFF||entry.uncompressedSize===0xFFFFFFFF){onerror(ERR_ZIP64);return;}entry.filenameLength=data.view.getUint16(index+22,true);entry.extraFieldLength=data.view.getUint16(index+24,true);}function createZipReader(reader,callback,onerror){var inflateSN=0;function Entry(){}Entry.prototype.getData=function(writer,onend,onprogress,checkCrc32){var that=this;function testCrc32(crc32){var dataCrc32=getDataHelper(4);dataCrc32.view.setUint32(0,crc32);return that.crc32==dataCrc32.view.getUint32(0);}function getWriterData(uncompressedSize,crc32){if(checkCrc32&&!testCrc32(crc32))onerror(ERR_CRC);else writer.getData(function(data){onend(data);});}function onreaderror(err){onerror(err||ERR_READ_DATA);}function onwriteerror(err){onerror(err||ERR_WRITE_DATA);}reader.readUint8Array(that.offset,30,function(bytes){var data=getDataHelper(bytes.length,bytes),dataOffset;if(data.view.getUint32(0)!=0x504b0304){onerror(ERR_BAD_FORMAT);return;}readCommonHeader(that,data,4,false,onerror);dataOffset=that.offset+30+that.filenameLength+that.extraFieldLength;writer.init(function(){if(that.compressionMethod===0)copy(that._worker,inflateSN++,reader,writer,dataOffset,that.compressedSize,checkCrc32,getWriterData,onprogress,onreaderror,onwriteerror);else inflate(that._worker,inflateSN++,reader,writer,dataOffset,that.compressedSize,checkCrc32,getWriterData,onprogress,onreaderror,onwriteerror);},onwriteerror);},onreaderror);};function seekEOCDR(eocdrCallback){// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
// Zip file comment is the last part of EOCDR and has max length of 64KB,
// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
var EOCDR_MIN=22;if(reader.size<EOCDR_MIN){onerror(ERR_BAD_FORMAT);return;}var ZIP_COMMENT_MAX=256*256,EOCDR_MAX=EOCDR_MIN+ZIP_COMMENT_MAX;// In most cases, the EOCDR is EOCDR_MIN bytes long
doSeek(EOCDR_MIN,function(){// If not found, try within EOCDR_MAX bytes
doSeek(Math.min(EOCDR_MAX,reader.size),function(){onerror(ERR_BAD_FORMAT);});});// seek last length bytes of file for EOCDR
function doSeek(length,eocdrNotFoundCallback){reader.readUint8Array(reader.size-length,length,function(bytes){for(var i=bytes.length-EOCDR_MIN;i>=0;i--){if(bytes[i]===0x50&&bytes[i+1]===0x4b&&bytes[i+2]===0x05&&bytes[i+3]===0x06){eocdrCallback(new DataView(bytes.buffer,i,EOCDR_MIN));return;}}eocdrNotFoundCallback();},function(){onerror(ERR_READ);});}}var zipReader={getEntries:function getEntries(callback){var worker=this._worker;// look for End of central directory record
seekEOCDR(function(dataView){var datalength,fileslength;datalength=dataView.getUint32(16,true);fileslength=dataView.getUint16(8,true);if(datalength<0||datalength>=reader.size){onerror(ERR_BAD_FORMAT);return;}reader.readUint8Array(datalength,reader.size-datalength,function(bytes){var i,index=0,entries=[],entry,filename,comment,data=getDataHelper(bytes.length,bytes);for(i=0;i<fileslength;i++){entry=new Entry();entry._worker=worker;if(data.view.getUint32(index)!=0x504b0102){onerror(ERR_BAD_FORMAT);return;}readCommonHeader(entry,data,index+6,true,onerror);entry.commentLength=data.view.getUint16(index+32,true);entry.directory=(data.view.getUint8(index+38)&0x10)==0x10;entry.offset=data.view.getUint32(index+42,true);filename=getString(data.array.subarray(index+46,index+46+entry.filenameLength));entry.filename=(entry.bitFlag&0x0800)===0x0800?decodeUTF8(filename):decodeASCII(filename);if(!entry.directory&&entry.filename.charAt(entry.filename.length-1)=="/")entry.directory=true;comment=getString(data.array.subarray(index+46+entry.filenameLength+entry.extraFieldLength,index+46+entry.filenameLength+entry.extraFieldLength+entry.commentLength));entry.comment=(entry.bitFlag&0x0800)===0x0800?decodeUTF8(comment):decodeASCII(comment);entries.push(entry);index+=46+entry.filenameLength+entry.extraFieldLength+entry.commentLength;}callback(entries);},function(){onerror(ERR_READ);});});},close:function close(callback){if(this._worker){this._worker.terminate();this._worker=null;}if(callback)callback();},_worker:null};if(!obj.zip.useWebWorkers)callback(zipReader);else{createWorker('inflater',function(worker){zipReader._worker=worker;callback(zipReader);},function(err){onerror(err);});}}// ZipWriter
function encodeUTF8(string){return unescape(encodeURIComponent(string));}function getBytes(str){var i,array=[];for(i=0;i<str.length;i++){array.push(str.charCodeAt(i));}return array;}function createZipWriter(writer,callback,onerror,dontDeflate){var files={},filenames=[],datalength=0;var deflateSN=0;function onwriteerror(err){onerror(err||ERR_WRITE);}function onreaderror(err){onerror(err||ERR_READ_DATA);}var zipWriter={add:function add(name,reader,onend,onprogress,options){var header,filename,date;var worker=this._worker;function writeHeader(callback){var data;date=options.lastModDate||new Date();header=getDataHelper(26);files[name]={headerArray:header.array,directory:options.directory,filename:filename,offset:datalength,comment:getBytes(encodeUTF8(options.comment||""))};header.view.setUint32(0,0x14000808);if(options.version)header.view.setUint8(0,options.version);if(!dontDeflate&&options.level!==0&&!options.directory)header.view.setUint16(4,0x0800);header.view.setUint16(6,(date.getHours()<<6|date.getMinutes())<<5|date.getSeconds()/2,true);header.view.setUint16(8,(date.getFullYear()-1980<<4|date.getMonth()+1)<<5|date.getDate(),true);header.view.setUint16(22,filename.length,true);data=getDataHelper(30+filename.length);data.view.setUint32(0,0x504b0304);data.array.set(header.array,4);data.array.set(filename,30);datalength+=data.array.length;writer.writeUint8Array(data.array,callback,onwriteerror);}function writeFooter(compressedLength,crc32){var footer=getDataHelper(16);datalength+=compressedLength||0;footer.view.setUint32(0,0x504b0708);if(typeof crc32!="undefined"){header.view.setUint32(10,crc32,true);footer.view.setUint32(4,crc32,true);}if(reader){footer.view.setUint32(8,compressedLength,true);header.view.setUint32(14,compressedLength,true);footer.view.setUint32(12,reader.size,true);header.view.setUint32(18,reader.size,true);}writer.writeUint8Array(footer.array,function(){datalength+=16;onend();},onwriteerror);}function writeFile(){options=options||{};name=name.trim();if(options.directory&&name.charAt(name.length-1)!="/")name+="/";if(files.hasOwnProperty(name)){onerror(ERR_DUPLICATED_NAME);return;}filename=getBytes(encodeUTF8(name));filenames.push(name);writeHeader(function(){if(reader){if(dontDeflate||options.level===0)copy(worker,deflateSN++,reader,writer,0,reader.size,true,writeFooter,onprogress,onreaderror,onwriteerror);else deflate(worker,deflateSN++,reader,writer,options.level,writeFooter,onprogress,onreaderror,onwriteerror);}else writeFooter();});}if(reader)reader.init(writeFile,onreaderror);else writeFile();},close:function close(callback){if(this._worker){this._worker.terminate();this._worker=null;}var data,length=0,index=0,indexFilename,file;for(indexFilename=0;indexFilename<filenames.length;indexFilename++){file=files[filenames[indexFilename]];length+=46+file.filename.length+file.comment.length;}data=getDataHelper(length+22);for(indexFilename=0;indexFilename<filenames.length;indexFilename++){file=files[filenames[indexFilename]];data.view.setUint32(index,0x504b0102);data.view.setUint16(index+4,0x1400);data.array.set(file.headerArray,index+6);data.view.setUint16(index+32,file.comment.length,true);if(file.directory)data.view.setUint8(index+38,0x10);data.view.setUint32(index+42,file.offset,true);data.array.set(file.filename,index+46);data.array.set(file.comment,index+46+file.filename.length);index+=46+file.filename.length+file.comment.length;}data.view.setUint32(index,0x504b0506);data.view.setUint16(index+8,filenames.length,true);data.view.setUint16(index+10,filenames.length,true);data.view.setUint32(index+12,length,true);data.view.setUint32(index+16,datalength,true);writer.writeUint8Array(data.array,function(){writer.getData(callback);},onwriteerror);},_worker:null};if(!obj.zip.useWebWorkers)callback(zipWriter);else{createWorker('deflater',function(worker){zipWriter._worker=worker;callback(zipWriter);},function(err){onerror(err);});}}function resolveURLs(urls){var a=document.createElement('a');return urls.map(function(url){a.href=url;return a.href;});}var DEFAULT_WORKER_SCRIPTS={deflater:['z-worker.js','deflate.js'],inflater:['z-worker.js','inflate.js']};function createWorker(type,callback,onerror){if(obj.zip.workerScripts!==null&&obj.zip.workerScriptsPath!==null){onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));return;}var scripts;if(obj.zip.workerScripts){scripts=obj.zip.workerScripts[type];if(!Array.isArray(scripts)){onerror(new Error('zip.workerScripts.'+type+' is not an array!'));return;}scripts=resolveURLs(scripts);}else{scripts=DEFAULT_WORKER_SCRIPTS[type].slice(0);scripts[0]=(obj.zip.workerScriptsPath||'')+scripts[0];}var worker=new Worker(scripts[0]);// record total consumed time by inflater/deflater/crc32 in this worker
worker.codecTime=worker.crcTime=0;worker.postMessage({type:'importScripts',scripts:scripts.slice(1)});worker.addEventListener('message',onmessage);function onmessage(ev){var msg=ev.data;if(msg.error){worker.terminate();// should before onerror(), because onerror() may throw.
onerror(msg.error);return;}if(msg.type==='importScripts'){worker.removeEventListener('message',onmessage);worker.removeEventListener('error',errorHandler);callback(worker);}}// catch entry script loading error and other unhandled errors
worker.addEventListener('error',errorHandler);function errorHandler(err){worker.terminate();onerror(err);}}function onerror_default(error){console.error(error);}obj.zip={Reader:Reader,Writer:Writer,BlobReader:BlobReader,Data64URIReader:Data64URIReader,TextReader:TextReader,BlobWriter:BlobWriter,Data64URIWriter:Data64URIWriter,TextWriter:TextWriter,createReader:function createReader(reader,callback,onerror){onerror=onerror||onerror_default;reader.init(function(){createZipReader(reader,callback,onerror);},onerror);},createWriter:function createWriter(writer,callback,onerror,dontDeflate){onerror=onerror||onerror_default;dontDeflate=!!dontDeflate;writer.init(function(){createZipWriter(writer,callback,onerror,dontDeflate);},onerror);},useWebWorkers:true,/**
         * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
         * E.g.: zip.workerScripts = './';
         */workerScriptsPath:null,/**
         * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
         * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
         * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
         * All urls are relative to current base url.
         * E.g.:
         * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
         */workerScripts:null};})(zipLib);/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /**
 * @private
 */var zipExt=function zipExt(zipObj){var ERR_HTTP_RANGE="HTTP Range not supported.";var Reader=zipObj.Reader;var Writer=zipObj.Writer;var ZipDirectoryEntry;var appendABViewSupported;try{appendABViewSupported=new Blob([new DataView(new ArrayBuffer(0))]).size===0;}catch(e){}function isHttpFamily(url){var a=document.createElement("a");a.href=url;return a.protocol==="http:"||a.protocol==="https:";}function HttpReader(url){var that=this;function getData(callback,onerror){var request;if(!that.data){request=new XMLHttpRequest();request.addEventListener("load",function(){if(!that.size)that.size=Number(request.getResponseHeader("Content-Length"))||Number(request.response.byteLength);that.data=new Uint8Array(request.response);callback();},false);request.addEventListener("error",onerror,false);request.open("GET",url);request.responseType="arraybuffer";request.send();}else callback();}function init(callback,onerror){if(!isHttpFamily(url)){// For schemas other than http(s), HTTP HEAD may be unavailable,
// so use HTTP GET instead.
getData(callback,onerror);return;}var request=new XMLHttpRequest();request.addEventListener("load",function(){that.size=Number(request.getResponseHeader("Content-Length"));// If response header doesn't return size then prefetch the content.
if(!that.size){getData(callback,onerror);}else{callback();}},false);request.addEventListener("error",onerror,false);request.open("HEAD",url);request.send();}function readUint8Array(index,length,callback,onerror){getData(function(){callback(new Uint8Array(that.data.subarray(index,index+length)));},onerror);}that.size=0;that.init=init;that.readUint8Array=readUint8Array;}HttpReader.prototype=new Reader();HttpReader.prototype.constructor=HttpReader;function HttpRangeReader(url){var that=this;function init(callback,onerror){var request=new XMLHttpRequest();request.addEventListener("load",function(){that.size=Number(request.getResponseHeader("Content-Length"));if(request.getResponseHeader("Accept-Ranges")=="bytes")callback();else onerror(ERR_HTTP_RANGE);},false);request.addEventListener("error",onerror,false);request.open("HEAD",url);request.send();}function readArrayBuffer(index,length,callback,onerror){var request=new XMLHttpRequest();request.open("GET",url);request.responseType="arraybuffer";request.setRequestHeader("Range","bytes="+index+"-"+(index+length-1));request.addEventListener("load",function(){callback(request.response);},false);request.addEventListener("error",onerror,false);request.send();}function readUint8Array(index,length,callback,onerror){readArrayBuffer(index,length,function(arraybuffer){callback(new Uint8Array(arraybuffer));},onerror);}that.size=0;that.init=init;that.readUint8Array=readUint8Array;}HttpRangeReader.prototype=new Reader();HttpRangeReader.prototype.constructor=HttpRangeReader;function ArrayBufferReader(arrayBuffer){var that=this;function init(callback,onerror){that.size=arrayBuffer.byteLength;callback();}function readUint8Array(index,length,callback,onerror){callback(new Uint8Array(arrayBuffer.slice(index,index+length)));}that.size=0;that.init=init;that.readUint8Array=readUint8Array;}ArrayBufferReader.prototype=new Reader();ArrayBufferReader.prototype.constructor=ArrayBufferReader;function ArrayBufferWriter(){var array,that=this;function init(callback,onerror){array=new Uint8Array();callback();}function writeUint8Array(arr,callback,onerror){var tmpArray=new Uint8Array(array.length+arr.length);tmpArray.set(array);tmpArray.set(arr,array.length);array=tmpArray;callback();}function getData(callback){callback(array.buffer);}that.init=init;that.writeUint8Array=writeUint8Array;that.getData=getData;}ArrayBufferWriter.prototype=new Writer();ArrayBufferWriter.prototype.constructor=ArrayBufferWriter;function FileWriter(fileEntry,contentType){var writer,that=this;function init(callback,onerror){fileEntry.createWriter(function(fileWriter){writer=fileWriter;callback();},onerror);}function writeUint8Array(array,callback,onerror){var blob=new Blob([appendABViewSupported?array:array.buffer],{type:contentType});writer.onwrite=function(){writer.onwrite=null;callback();};writer.onerror=onerror;writer.write(blob);}function getData(callback){fileEntry.file(callback);}that.init=init;that.writeUint8Array=writeUint8Array;that.getData=getData;}FileWriter.prototype=new Writer();FileWriter.prototype.constructor=FileWriter;zipObj.FileWriter=FileWriter;zipObj.HttpReader=HttpReader;zipObj.HttpRangeReader=HttpRangeReader;zipObj.ArrayBufferReader=ArrayBufferReader;zipObj.ArrayBufferWriter=ArrayBufferWriter;if(zipObj.fs){ZipDirectoryEntry=zipObj.fs.ZipDirectoryEntry;ZipDirectoryEntry.prototype.addHttpContent=function(name,URL,useRangeHeader){function addChild(parent,name,params,directory){if(parent.directory)return directory?new ZipDirectoryEntry(parent.fs,name,params,parent):new zipObj.fs.ZipFileEntry(parent.fs,name,params,parent);else throw"Parent entry is not a directory.";}return addChild(this,name,{data:URL,Reader:useRangeHeader?HttpRangeReader:HttpReader});};ZipDirectoryEntry.prototype.importHttpContent=function(URL,useRangeHeader,onend,onerror){this.importZip(useRangeHeader?new HttpRangeReader(URL):new HttpReader(URL),onend,onerror);};zipObj.fs.FS.prototype.importHttpContent=function(URL,useRangeHeader,onend,onerror){this.entries=[];this.root=new ZipDirectoryEntry(this);this.root.importHttpContent(URL,useRangeHeader,onend,onerror);};}};var zip=zipLib.zip;zipExt(zip);var supportedSchemas=["4.2"];/**
 * @private
 */var XML3DSceneGraphLoader=/*#__PURE__*/function(){function XML3DSceneGraphLoader(plugin){var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,XML3DSceneGraphLoader);/**
         * Supported 3DXML schema versions
         * @property supportedSchemas
         * @type {string[]}
         */this.supportedSchemas=supportedSchemas;this._xrayOpacity=0.7;this._src=null;this._options=cfg;/**
         * Default viewpoint, containing eye, look and up vectors.
         * Only defined if found in the 3DXML file.
         * @property viewpoint
         * @type {Number[]}
         */this.viewpoint=null;if(!cfg.workerScriptsPath){plugin.error("Config expected: workerScriptsPath");return;}zip.workerScriptsPath=cfg.workerScriptsPath;this.src=cfg.src;this.xrayOpacity=0.7;this.displayEffect=cfg.displayEffect;this.createMetaModel=cfg.createMetaModel;}_createClass(XML3DSceneGraphLoader,[{key:"load",value:function load(plugin,modelNode,src,options,ok,error){switch(options.materialType){case"MetallicMaterial":modelNode._defaultMaterial=new MetallicMaterial(modelNode,{baseColor:[1,1,1],metallic:0.6,roughness:0.6});break;case"SpecularMaterial":modelNode._defaultMaterial=new SpecularMaterial(modelNode,{diffuse:[1,1,1],specular:math.vec3([1.0,1.0,1.0]),glossiness:0.5});break;default:modelNode._defaultMaterial=new PhongMaterial(modelNode,{reflectivity:0.75,shiness:100,diffuse:[1,1,1]});}modelNode._wireframeMaterial=new LambertMaterial(modelNode,{color:[0,0,0],lineWidth:2});var spinner=modelNode.scene.canvas.spinner;spinner.processes++;load3DXML(plugin,modelNode,src,options,function(){spinner.processes--;if(ok){ok();}modelNode.fire("loaded",true,false);},function(msg){spinner.processes--;modelNode.error(msg);if(error){error(msg);}/**
                 Fired whenever this XML3D fails to load the 3DXML file
                 specified by {@link XML3D/src}.
                 @event error
                 @param msg {String} Description of the error
                 */modelNode.fire("error",msg);},function(err){console.log("Error, Will Robinson: "+err);});}}]);return XML3DSceneGraphLoader;}();var load3DXML=function(){return function(plugin,modelNode,src,options,ok,error){loadZIP(src,function(zip){// OK
parse3DXML(plugin,zip,options,modelNode,ok,error);},error);};}();var parse3DXML=function(){return function(plugin,zip,options,modelNode,ok){var ctx={plugin:plugin,zip:zip,edgeThreshold:30,// Guess at degrees of normal deviation between adjacent tris below which we remove edge between them
materialType:options.materialType,scene:modelNode.scene,modelNode:modelNode,info:{references:{}},materials:{}};if(options.createMetaModel){ctx.metaModelData={modelId:modelNode.id,metaObjects:[{name:modelNode.id,type:"Default",id:modelNode.id}]};}modelNode.scene.loading++;// Disables (re)compilation
parseDocument(ctx,function(){if(ctx.metaModelData){plugin.viewer.metaScene.createMetaModel(modelNode.id,ctx.metaModelData);}modelNode.scene.loading--;// Re-enables (re)compilation
ok();});};function parseDocument(ctx,ok){ctx.zip.getFile("Manifest.xml",function(xmlDoc,json){var node=json;var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Manifest":parseManifest(ctx,child,ok);break;}}});}function parseManifest(ctx,manifest,ok){var children=manifest.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Root":var rootFileSrc=child.children[0];ctx.zip.getFile(rootFileSrc,function(xmlDoc,json){parseRoot(ctx,json,ok);});break;}}}function parseRoot(ctx,node,ok){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Model_3dxml":parseModel(ctx,child,ok);break;}}}function parseModel(ctx,node,ok){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Header":parseHeader(ctx,child);break;case"ProductStructure":parseProductStructure(ctx,child,ok);break;case"DefaultView":parseDefaultView(ctx,child);break;}}}function parseHeader(ctx,node){var children=node.children;var metaData={};for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"SchemaVersion":metaData.schemaVersion=child.children[0];if(!isSchemaVersionSupported(ctx,metaData.schemaVersion)){ctx.plugin.error("Schema version not supported: "+metaData.schemaVersion+" - supported versions are: "+supportedSchemas.join(","));}break;case"Title":metaData.title=child.children[0];break;case"Author":metaData.author=child.children[0];break;case"Created":metaData.created=child.children[0];break;}}ctx.modelNode.meta=metaData;}function isSchemaVersionSupported(ctx,schemaVersion){for(var i=0,len=supportedSchemas.length;i<len;i++){if(schemaVersion===supportedSchemas[i]){return true;}}return false;}function parseProductStructure(ctx,productStructureNode,ok){parseReferenceReps(ctx,productStructureNode,function(referenceReps){// Parse out an intermediate scene DAG representation, that we can then
// recursive descend through to build a xeokit Object hierarchy.
var children=productStructureNode.children;var reference3Ds={};var instanceReps={};var instance3Ds={};// Map all the elements
for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Reference3D":reference3Ds[child.id]={type:"Reference3D",id:child.id,name:child.name,instance3Ds:{},instanceReps:{}};break;case"InstanceRep":var isAggregatedBy;var isInstanceOf;var relativeMatrix;for(var j=0,lenj=child.children.length;j<lenj;j++){var child2=child.children[j];switch(child2.type){case"IsAggregatedBy":isAggregatedBy=child2.children[0];break;case"IsInstanceOf":isInstanceOf=child2.children[0];break;}}instanceReps[child.id]={type:"InstanceRep",id:child.id,name:child.name,isAggregatedBy:isAggregatedBy,isInstanceOf:isInstanceOf,referenceReps:{}};break;case"Instance3D":var isAggregatedBy;var isInstanceOf;var relativeMatrix;for(var j=0,lenj=child.children.length;j<lenj;j++){var child2=child.children[j];switch(child2.type){case"IsAggregatedBy":isAggregatedBy=child2.children[0];break;case"IsInstanceOf":isInstanceOf=child2.children[0];break;case"RelativeMatrix":relativeMatrix=child2.children[0];break;}}instance3Ds[child.id]={type:"Instance3D",id:child.id,name:child.name,isAggregatedBy:isAggregatedBy,isInstanceOf:isInstanceOf,relativeMatrix:relativeMatrix,reference3Ds:{}};break;}}// Connect Reference3Ds to the Instance3Ds they aggregate
for(var id in instance3Ds){var instance3D=instance3Ds[id];var reference3D=reference3Ds[instance3D.isAggregatedBy];if(reference3D){reference3D.instance3Ds[instance3D.id]=instance3D;}else{alert("foo");}}// Connect Instance3Ds to the Reference3Ds they instantiate
for(var id in instance3Ds){var instance3D=instance3Ds[id];var reference3D=reference3Ds[instance3D.isInstanceOf];instance3D.reference3Ds[reference3D.id]=reference3D;reference3D.instance3D=instance3D;}// Connect InstanceReps to the ReferenceReps they instantiate
for(var id in instanceReps){var instanceRep=instanceReps[id];var referenceRep=referenceReps[instanceRep.isInstanceOf];if(referenceRep){instanceRep.referenceReps[referenceRep.id]=referenceRep;}}// Connect Reference3Ds to the InstanceReps they aggregate
for(var id in instanceReps){var instanceRep=instanceReps[id];var reference3D=reference3Ds[instanceRep.isAggregatedBy];if(reference3D){reference3D.instanceReps[instanceRep.id]=instanceRep;}}function parseReference3D(ctx,reference3D,group){//ctx.plugin.log("parseReference3D( " + reference3D.id + " )");
for(var id in reference3D.instance3Ds){parseInstance3D(ctx,reference3D.instance3Ds[id],group);}for(var id in reference3D.instanceReps){parseInstanceRep(ctx,reference3D.instanceReps[id],group);}}function parseInstance3D(ctx,instance3D,group){//ctx.plugin.log("parseInstance3D( " + instance3D.id + " )");
if(instance3D.relativeMatrix){var matrix=parseFloatArray(instance3D.relativeMatrix,12);var translate=[matrix[9],matrix[10],matrix[11]];var mat3=matrix.slice(0,9);// Rotation matrix
var mat4=math.mat3ToMat4(mat3,math.identityMat4());// Convert rotation matrix to 4x4
var childGroup=new Node$2(ctx.modelNode,{position:translate});if(ctx.metaModelData){ctx.metaModelData.metaObjects.push({id:childGroup.id,type:"Default",name:instance3D.name,parent:group?group.id:ctx.modelNode.id});}if(group){group.addChild(childGroup,true);}else{ctx.modelNode.addChild(childGroup,true);}group=childGroup;childGroup=new Node$2(ctx.modelNode,{matrix:mat4});if(ctx.metaModelData){ctx.metaModelData.metaObjects.push({id:childGroup.id,type:"Default",name:instance3D.name,parent:group?group.id:ctx.modelNode.id});}group.addChild(childGroup,true);group=childGroup;}else{var childGroup=new Node$2(ctx.modelNode,{});if(ctx.metaModelData){ctx.metaModelData.metaObjects.push({id:childGroup.id,type:"Default",name:instance3D.name,parent:group?group.id:ctx.modelNode.id});}if(group){group.addChild(childGroup,true);}else{ctx.modelNode.addChild(childGroup,true);}group=childGroup;}for(var id in instance3D.reference3Ds){parseReference3D(ctx,instance3D.reference3Ds[id],group);}}function parseInstanceRep(ctx,instanceRep,group){//ctx.plugin.log("parseInstanceRep( " + instanceRep.id + " )");
if(instanceRep.referenceReps){for(var id in instanceRep.referenceReps){var referenceRep=instanceRep.referenceReps[id];for(var id2 in referenceRep){if(id2==="id"){continue;// HACK
}var meshCfg=referenceRep[id2];var lines=meshCfg.geometry.primitive==="lines";var material=lines?ctx.modelNode._wireframeMaterial:meshCfg.materialId?ctx.materials[meshCfg.materialId]:null;var colorize=meshCfg.color;var mesh=new Mesh(ctx.modelNode,{isObject:true,geometry:meshCfg.geometry,material:material||ctx.modelNode._defaultMaterial,colorize:colorize,backfaces:false});if(ctx.metaModelData){ctx.metaModelData.metaObjects.push({id:mesh.id,type:"Default",name:instanceRep.name,parent:group?group.id:ctx.modelNode.id});}if(group){group.addChild(mesh,true);}else{ctx.modelNode.addChild(mesh,true);}mesh.colorize=colorize;// HACK: Mesh has inherited modelNode's colorize state, so we need to restore it (we'd better not modify colorize on the modelNode).
}}}}// Find the root Reference3D
for(var id in reference3Ds){var reference3D=reference3Ds[id];if(!reference3D.instance3D){parseReference3D(ctx,reference3D,null);// HACK: Assuming that root has id == "1"
ok();return;}}alert("No root Reference3D element found in this modelNode - can't load.");ok();});}function parseIntArray(str){var parts=str.trim().split(" ");var result=new Int32Array(parts.length);for(var i=0;i<parts.length;i++){result[i]=parseInt(parts[i]);}return result;}function parseReferenceReps(ctx,node,ok){var referenceReps={};var children=node.children;var numToLoad=0;for(var i=0,len=children.length;i<len;i++){var child=children[i];if(child.type==="ReferenceRep"){numToLoad++;}}for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"ReferenceRep":if(child.associatedFile){var src=stripURN(child.associatedFile);(function(){var childId=child.id;ctx.zip.getFile(src,function(xmlDoc,json){var materialIds=xmlDoc.getElementsByTagName("MaterialId");loadCATMaterialRefDocuments(ctx,materialIds,function(){// ctx.plugin.log("reference loaded: " + src);
var referenceRep={id:childId};parse3DRepDocument(ctx,json,referenceRep);referenceReps[childId]=referenceRep;if(--numToLoad===0){ok(referenceReps);}});},function(error){// TODO:
});})();}break;}}}function parseDefaultView(ctx,node){// ctx.plugin.log("parseDefaultView");
var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Viewpoint":var children2=child.children;ctx.modelNode.viewpoint={};for(var i2=0,len2=children2.length;i2<len2;i2++){var child2=children2[i];switch(child2.type){case"Position":ctx.modelNode.viewpoint.eye=parseFloatArray(child2.children[0],3);break;case"Sight":ctx.modelNode.viewpoint.look=parseFloatArray(child2.children[0],3);break;case"Up":ctx.modelNode.viewpoint.up=parseFloatArray(child2.children[0],3);break;}}break;}}}function parse3DRepDocument(ctx,node,result){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"XMLRepresentation":parseXMLRepresentation(ctx,child,result);break;}}}function parseXMLRepresentation(ctx,node,result){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Root":parse3DRepRoot(ctx,child,result);break;}}}function parse3DRepRoot(ctx,node,result){switch(node["xsi:type"]){}var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Rep":parse3DRepRep(ctx,child,result);break;}}}function parse3DRepRep(ctx,node,result){switch(node["xsi:type"]){}var meshesResult={edgeThreshold:ctx.edgeThreshold||30,compressGeometry:true};var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Rep":parse3DRepRep(ctx,child,result);break;case"Edges":// Ignoring edges because we auto-generate our own using xeokit
break;case"Faces":meshesResult.primitive="triangles";parseFaces(ctx,child,meshesResult);break;case"VertexBuffer":parseVertexBuffer(ctx,child,meshesResult);break;case"SurfaceAttributes":parseSurfaceAttributes(ctx,child,meshesResult);break;}}if(meshesResult.positions){var geometry=new ReadableGeometry(ctx.modelNode,meshesResult);result[geometry.id]={geometry:geometry,color:meshesResult.color||[1.0,1.0,1.0,1.0],materialId:meshesResult.materialId};}}function parseFaces(ctx,node,result){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Face":parseFace(ctx,child,result);break;}}}function parseFace(ctx,node,result){var strips=node.strips;if(strips){// Triangle strips
var arrays=parseIntArrays(strips);if(arrays.length>0){result.primitive="triangles";var indices=[];for(var i=0,len=arrays.length;i<len;i++){var array=convertTriangleStrip(arrays[i]);for(var j=0,lenj=array.length;j<lenj;j++){indices.push(array[j]);}}result.indices=indices;// TODO
}}else{// Triangle meshes
var triangles=node.triangles;if(triangles){result.primitive="triangles";result.indices=parseIntArray(triangles);}}// Material
var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"SurfaceAttributes":parseSurfaceAttributes(ctx,child,result);break;}}}function convertTriangleStrip(indices){var indices2=[];for(var i=0,len=indices.length;i<len-2;i++){{if(i&1){//
indices2.push(indices[i]);indices2.push(indices[i+2]);indices2.push(indices[i+1]);}else{indices2.push(indices[i]);indices2.push(indices[i+1]);indices2.push(indices[i+2]);}}}return indices2;}function parseVertexBuffer(ctx,node,result){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Positions":result.positions=parseFloatArray(child.children[0],3);break;case"Normals":result.normals=parseFloatArray(child.children[0],3);break;case"TextureCoordinates":// TODO: Support dimension and channel?
result.uv=parseFloatArray(child.children[0],2);break;}}}function parseIntArrays(str){var coordStrings=str.split(",");var array=[];for(var i=0,len=coordStrings.length;i<len;i++){var coordStr=coordStrings[i].trim();if(coordStr.length>0){var elemStrings=coordStr.trim().split(" ");var arr=new Int16Array(elemStrings.length);var arrIdx=0;for(var j=0,lenj=elemStrings.length;j<lenj;j++){if(elemStrings[j]!==""){arr[arrIdx++]=parseInt(elemStrings[j]);}}array.push(arr);}}return array;}function parseFloatArray(str,numElems){str=str.split(",");var arr=new Float32Array(str.length*numElems);var arrIdx=0;for(var i=0,len=str.length;i<len;i++){var value=str[i];value=value.split(" ");for(var j=0,lenj=value.length;j<lenj;j++){if(value[j]!==""){arr[arrIdx++]=parseFloat(value[j]);}}}return arr;}function parseIntArray(str){str=str.trim().split(" ");var arr=new Int32Array(str.length);for(var i=0,len=str.length;i<len;i++){var value=str[i];arr[i]=parseInt(value);}return arr;}function parseSurfaceAttributes(ctx,node,result){result.color=[1,1,1,1];var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Color":result.color[0]=child.red;result.color[1]=child.green;result.color[2]=child.blue;result.color[3]=child.alpha;break;case"MaterialApplication":var children2=child.children;for(var j=0,lenj=children2.length;j<lenj;j++){var child2=children2[j];switch(child2.type){case"MaterialId":var materialId=getIDFromURI(child2.id);var material=ctx.materials[materialId];if(!material){ctx.plugin.error("material  not found: "+materialId);}result.materialId=materialId;break;}}break;}}}}();function loadCATMaterialRefDocuments(ctx,materialIds,ok){var loaded={};function load(i,done){if(i>=materialIds.length){ok();return;}var materialId=materialIds[i];var src=materialId.id;var colonIdx=src.lastIndexOf(":");if(colonIdx>0){src=src.substring(colonIdx+1);}var hashIdx=src.lastIndexOf("#");if(hashIdx>0){src=src.substring(0,hashIdx);}if(!loaded[src]){loadCATMaterialRefDocument(ctx,src,function(){loaded[src]=true;load(i+1);});}else{load(i+1);}}load(0);}function loadCATMaterialRefDocument(ctx,src,ok){// Loads CATMaterialRef.3dxml
ctx.zip.getFile(src,function(xmlDoc,json){parseCATMaterialRefDocument(ctx,json,ok);});}function parseCATMaterialRefDocument(ctx,node,ok){// Parse CATMaterialRef.3dxml
// ctx.plugin.log("parseCATMaterialRefDocument");
var children=node.children;var child;for(var i=0,len=children.length;i<len;i++){child=children[i];if(child.type==="Model_3dxml"){parseModel_3dxml(ctx,child,ok);}}}function parseModel_3dxml(ctx,node,ok){// Parse CATMaterialRef.3dxml
// ctx.plugin.log("parseModel_3dxml");
var children=node.children;var child;for(var i=0,len=children.length;i<len;i++){child=children[i];if(child.type==="CATMaterialRef"){parseCATMaterialRef(ctx,child,ok);}}}function parseCATMaterialRef(ctx,node,ok){var domainToReferenceMap={};var children=node.children;var numToLoad=0;for(var j=0,lenj=children.length;j<lenj;j++){var child2=children[j];switch(child2.type){case"MaterialDomainInstance":var isAggregatedBy;var isInstanceOf;for(var k=0,lenk=child2.children.length;k<lenk;k++){var child3=child2.children[k];switch(child3.type){case"IsAggregatedBy":isAggregatedBy=child3.children[0];break;case"IsInstanceOf":isInstanceOf=child3.children[0];break;}}domainToReferenceMap[isInstanceOf]=isAggregatedBy;break;}}for(var j=0,lenj=children.length;j<lenj;j++){var child2=children[j];switch(child2.type){case"MaterialDomain":numToLoad++;break;}}// Now load them
for(var j=0,lenj=children.length;j<lenj;j++){var child2=children[j];switch(child2.type){case"MaterialDomain":if(child2.associatedFile){(function(){var childId=child2.id;var src=stripURN(child2.associatedFile);ctx.zip.getFile(src,function(xmlDoc,json){// ctx.plugin.log("Material def loaded: " + src);
ctx.materials[domainToReferenceMap[childId]]=parseMaterialDefDocument(ctx,json);if(--numToLoad===0){//       console.log("All ReferenceReps loaded.");
ok();}},function(error){// TODO:
});})();}break;}}}function parseMaterialDefDocument(ctx,node){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"Osm":return parseMaterialDefDocumentOsm(ctx,child);}}}function parseMaterialDefDocumentOsm(ctx,node){var children=node.children;for(var i=0,len=children.length;i<len;i++){var child=children[i];switch(child.type){case"RenderingRootFeature"://..
break;case"Feature":if(child.Alias==="RenderingFeature"){// Parse the coefficients, then parse the colors, scaling those by their coefficients.
var coeffs={};var materialCfg={};var children2=child.children;var j;var lenj;var child2;for(j=0,lenj=children2.length;j<lenj;j++){child2=children2[j];switch(child2.Name){case"AmbientCoef":coeffs.ambient=parseFloat(child2.Value);break;case"DiffuseCoef":coeffs.diffuse=parseFloat(child2.Value);break;case"EmissiveCoef":coeffs.emissive=parseFloat(child2.Value);break;case"SpecularExponent":coeffs.specular=parseFloat(child2.Value);break;}}for(j=0,lenj=children2.length;j<lenj;j++){child2=children2[j];switch(child2.Name){case"AmbientColor":materialCfg.ambient=parseRGB(child2.Value,coeffs.ambient);break;case"DiffuseColor":materialCfg.diffuse=parseRGB(child2.Value,coeffs.diffuse);break;case"EmissiveColor":materialCfg.emissive=parseRGB(child2.Value,coeffs.emissive);break;case"SpecularColor":materialCfg.specular=parseRGB(child2.Value,coeffs.specular);break;case"Transparency":var alpha=1.0-parseFloat(child2.Value);// GOTCHA: Degree of transparency, not degree of opacity
if(alpha<1.0){materialCfg.alpha=alpha;materialCfg.alphaMode="blend";}break;}}var material;switch(ctx.materialType){case"MetallicMaterial":material=new MetallicMaterial(ctx.modelNode,{baseColor:materialCfg.diffuse,metallic:0.7,roughness:0.5,emissive:materialCfg.emissive,alpha:materialCfg.alpha,alphaMode:materialCfg.alphaMode});break;case"SpecularMaterial":material=new SpecularMaterial(ctx.modelNode,{diffuse:materialCfg.diffuse,specular:materialCfg.specular,glossiness:0.5,emissive:materialCfg.emissive,alpha:materialCfg.alpha,alphaMode:materialCfg.alphaMode});break;default:material=new PhongMaterial(ctx.modelNode,{reflectivity:0.5,ambient:materialCfg.ambient,diffuse:materialCfg.diffuse,specular:materialCfg.specular,// shininess: node.shine,
emissive:materialCfg.emissive,alphaMode:materialCfg.alphaMode,alpha:node.alpha});}return material;}break;}}}function parseRGB(str,coeff){coeff=coeff!==undefined?coeff:0.5;var openBracketIndex=str.indexOf("[");var closeBracketIndex=str.indexOf("]");str=str.substring(openBracketIndex+1,closeBracketIndex-openBracketIndex);str=str.split(",");var arr=new Float32Array(str.length);var arrIdx=0;for(var i=0,len=str.length;i<len;i++){var value=str[i];value=value.trim().split(" ");for(var j=0,lenj=value.length;j<lenj;j++){if(value[j]!==""){arr[arrIdx++]=parseFloat(value[j])*coeff;}}}return arr;}//----------------------------------------------------------------------------------------------------
/**
 * Wraps zip.js to provide an in-memory ZIP archive representing the 3DXML file bundle.
 *
 * Allows us to pluck each file from it as XML and JSON.
 *
 * @constructor
 */var ZIP=function ZIP(){var reader;var files={};/**
     Loads this ZIP

     @param src
     @param ok
     @param error
     */this.load=function(src,ok,error){zip.createReader(new zip.HttpReader(src),function(reader){reader.getEntries(function(entries){if(entries.length>0){for(var i=0,len=entries.length;i<len;i++){var entry=entries[i];files[entry.filename]=entry;}}ok();});},error);};/**
     Gets a file as XML and JSON from this ZIP
     @param src
     @param ok
     @param error
     */this.getFile=function(src,ok,error){var entry=files[src];if(!entry){var errMsg="ZIP entry not found: "+src;console.error(errMsg);if(error){error(errMsg);}return;}entry.getData(new zip.TextWriter(),function(text){// Parse to XML
var parser=new DOMParser();var xmlDoc=parser.parseFromString(text,"text/xml");// Parse to JSON
var json=xmlToJSON(xmlDoc,{});ok(xmlDoc,json);});};function xmlToJSON(node,attributeRenamer){if(node.nodeType===node.TEXT_NODE){var v=node.nodeValue;if(v.match(/^\s+$/)===null){return v;}}else if(node.nodeType===node.ELEMENT_NODE||node.nodeType===node.DOCUMENT_NODE){var json={type:node.nodeName,children:[]};if(node.nodeType===node.ELEMENT_NODE){for(var j=0;j<node.attributes.length;j++){var attribute=node.attributes[j];var nm=attributeRenamer[attribute.nodeName]||attribute.nodeName;json[nm]=attribute.nodeValue;}}for(var i=0;i<node.childNodes.length;i++){var item=node.childNodes[i];var j=xmlToJSON(item,attributeRenamer);if(j)json.children.push(j);}return json;}}/**
     Disposes of this ZIP
     */this.destroy=function(){reader.close(function(){// onclose callback
});};};function loadZIP(src,ok,err){var zip=new ZIP();zip.load(src,function(){ok(zip);},function(errMsg){err("Error loading ZIP archive: "+errMsg);});}function stripURN(str){var subStr="urn:3DXML:";return str.indexOf(subStr)===0?str.substring(subStr.length):str;}function getIDFromURI(str){var hashIdx=str.lastIndexOf("#");return hashIdx!==-1?str.substring(hashIdx+1):str;}/**
 * {@link Viewer} plugin that loads models from [3DXML](https://en.wikipedia.org/wiki/3DXML) files.
 *
 * [<img src="https://xeokit.io/img/docs/XML3DLoaderPlugin/XML3DPluginTreeView.png">](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_TreeView)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_TreeView)]
 *
 * ## Overview
 *
 * * Currently supports 3DXML V4.2.
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 * * Can optionally load a {@link MetaModel} to classify the objects within the model, from which you can create a tree view using the {@link TreeViewPlugin}.
 * <br>
 * Note that the name of this plugin is intentionally munged to "XML3D" because a JavaScript class name cannot begin with a numeral.
 *
 * An 3DXML model is a zip archive that bundles multiple XML files and assets. Internally, the XML3DLoaderPlugin uses the
 * [zip.js](https://gildas-lormeau.github.io/zip.js/) library to unzip them before loading. The zip.js library uses
 * [Web workers](https://www.w3.org/TR/workers/) for fast unzipping, so XML3DLoaderPlugin requires that we configure it
 * with a ````workerScriptsPath```` property specifying the directory where zip.js keeps its Web worker script. See
 * the example for how to do that.
 *
 * ## Usage
 *
 * In the example below, we'll use an XML3DLoaderPlugin to load a 3DXML model. When the model has loaded,
 * we'll use the {@link CameraFlightAnimation} to fly the {@link Camera} to look at boundary of the model. We'll
 * then get the model's {@link Entity} from the {@link Scene} and highlight the whole model.
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_Widget)]
 *
 * ````javascript
 * // Create a xeokit Viewer
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * // Add an XML3DLoaderPlugin to the Viewer
 * var plugin = new XML3DLoaderPlugin(viewer, {
 *      id: "XML3DLoader",  // Default value
 *      workerScriptsPath : "../../src/plugins/XML3DLoader/zipjs/" // Path to zip.js workers dir
 * });
 *
 * // Load the 3DXML model
 * var model = plugin.load({ // Model is an Entity
 *     id: "myModel",
 *     src: "./models/xml3d/3dpreview.3dxml",
 *     scale: [0.1, 0.1, 0.1],
 *     rotate: [90, 0, 0],
 *     translate: [100,0,0],
 *     edges: true
 * });
 *
 * // When the model has loaded, fit it to view
 * model.on("loaded", function() {
 *      viewer.cameraFlight.flyTo(model);
 * });
 *
 * // Update properties of the model via the entity
 * model.highlighted = true;
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 * ## Loading MetaModels
 *
 * We have the option to load a {@link MetaModel} that contains a hierarchy of {@link MetaObject}s that classifes the objects within
 * our 3DXML model.
 *
 * This is useful for building a tree view to navigate the objects, using {@link TreeViewPlugin}.
 *
 * Let's load the model again, this time creating a MetaModel:
 *
 * ````javascript
 * var model = plugin.load({
 *     id: "myModel",
 *     src: "./models/xml3d/3dpreview.3dxml",
 *     scale: [0.1, 0.1, 0.1],
 *     rotate: [90, 0, 0],
 *     translate: [100,0,0],
 *     edges: true,
 *
 *     createMetaModel: true // <<-------- Create a MetaModel
 * });
 * ````
 *
 * The MetaModel can then be found on the {@link Viewer}'s {@link MetaScene}, using the model's ID:
 *
 * ````javascript
 * const metaModel = viewer.metaScene.metaModels["myModel"];
 * ````
 *
 * Now we can use {@link TreeViewPlugin} to create a tree view to navigate our model's objects:
 *
 * ````javascript
 * import {TreeViewPlugin} from "xeokit-sdk.es.js""xeokit-sdk.es.js";
 *
 * const treeView = new TreeViewPlugin(viewer, {
 *     containerElement: document.getElementById("myTreeViewContainer")
 * });
 *
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("treeViewContainer"),
 *      autoExpandDepth: 3, // Initially expand tree three storeys deep
 *      hierarchy: "containment",
 *      autoAddModels: false
 * });
 *
 * model.on("loaded", () => {
 *      treeView.addModel(model.id);
 * });
 * ````
 *
 * Note that only the TreeViewPlugin "containment" hierarchy makes sense for an XML3D model. A "types" hierarchy
 * does not make sense because XML3DLoaderPlugin will set each {@link MetaObject#type} to "Default", and "storeys"
 * does not make sense because that requires some of the MetaObject#type values to be "IfcBuildingStorey".
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_TreeView)]
 *
 * ## Material Type
 *
 * Although 3DXML only supports Phong materials, XML3DLoaderPlugin is able to convert them to physically-based materials.
 *
 * The plugin supports three material types:
 *
 * | Material Type | Material Components Loaded  | Description | Example |
 * |:--------:|:----:|:-----:|:-----:|
 * | "PhongMaterial" (default) | {@link PhongMaterial}  | Non-physically-correct Blinn-Phong shading model | [Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Phong) |
 * | "MetallicMaterial" | {@link MetallicMaterial} | Physically-accurate specular-glossiness shading model | [Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Metallic) |
 * | "SpecularMaterial" | {@link SpecularMaterial} | Physically-accurate metallic-roughness shading model | [Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Specular) |
 *
 * <br>
 * Let's load our model again, this time converting the 3DXML Blinn-Phong materials to {@link SpecularMaterial}s:
 *
 * ````javascript
 * var model = plugin.load({ // Model is an Entity
 *     id: "myModel",
 *     src: "./models/xml3d/3dpreview.3dxml",
 *     materialtype: "SpecularMaterial": true"
 * });
 * ````
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Specular)]
 *
 * @class XML3DLoaderPlugin
 */var XML3DLoaderPlugin=/*#__PURE__*/function(_Plugin18){_inherits(XML3DLoaderPlugin,_Plugin18);var _super159=_createSuper(XML3DLoaderPlugin);/**
     * @constructor
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="XML3DLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {String} cfg.workerScriptsPath Path to the directory that contains the
     * bundled [zip.js](https://gildas-lormeau.github.io/zip.js/) archive, which is a dependency of this plugin. This directory
     * contains the script that is used by zip.js to instantiate Web workers, which assist with unzipping the 3DXML, which is a ZIP archive.
     * @param {String} [cfg.materialType="PhongMaterial"] What type of materials to create while loading: "MetallicMaterial" to create {@link MetallicMaterial}s, "SpecularMaterial" to create {@link SpecularMaterial}s or "PhongMaterial" to create {@link PhongMaterial}s. As it loads XML3D's Phong materials, the XMLLoaderPlugin will do its best approximate conversion of those to the specified workflow.
     * @param {Boolean} [cfg.createMetaModel=false] When true, will create a {@link MetaModel} for the model in {@link MetaScene#metaModels}.
     */function XML3DLoaderPlugin(viewer){var _this156;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,XML3DLoaderPlugin);_this156=_super159.call(this,"XML3DLoader",viewer,cfg);if(!cfg.workerScriptsPath){_this156.error("Config expected: workerScriptsPath");return _possibleConstructorReturn(_this156);}_this156._workerScriptsPath=cfg.workerScriptsPath;/**
         * @private
         */_this156._loader=new XML3DSceneGraphLoader(_assertThisInitialized(_this156),cfg);/**
         * Supported 3DXML schema versions
         * @property supportedSchemas
         * @type {string[]}
         */_this156.supportedSchemas=_this156._loader.supportedSchemas;return _this156;}/**
     * Loads a 3DXML model from a file into this XML3DLoaderPlugin's {@link Viewer}.
     *
     * Creates a tree of {@link Entity}s within the Viewer's {@link Scene} that represents the model.
     *
     * @param {*} params  Loading parameters.
     * @param {String} params.id ID to assign to the model's root {@link Entity}, unique among all components in the Viewer's {@link Scene}.
     * @param {String} [params.src] Path to a 3DXML file.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the {@link Entity} with edges emphasized.
     * @param {Number[]} [params.position=[0,0,0]] The model's World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [params.backfaces=false] When true, allows visible backfaces, wherever specified in the 3DXML. When false, ignores backfaces.
     * @param {Number} [params.edgeThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {String} [params.materialType="PhongMaterial"] What type of materials to create while loading: "MetallicMaterial" to create {@link MetallicMaterial}s, "SpecularMaterial" to create {@link SpecularMaterial}s or "PhongMaterial" to create {@link PhongMaterial}s. As it loads XML3D's Phong materials, the XMLLoaderPlugin will do its best approximate conversion of those to the specified workflow.
     * @param {Boolean} [params.createMetaModel=false] When true, will create a {@link MetaModel} for the model in {@link MetaScene#metaModels}.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */_createClass(XML3DLoaderPlugin,[{key:"load",value:function load(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};params.workerScriptsPath=this._workerScriptsPath;if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var modelNode=new Node$2(this.viewer.scene,utils.apply(params,{isModel:true}));var src=params.src;if(!src){this.error("load() param expected: src");return modelNode;// Return new empty model
}this._loader.load(this,modelNode,src,params);return modelNode;}}]);return XML3DLoaderPlugin;}(Plugin);/**
 * Default data access strategy for {@link WebIFCLoaderPlugin}.
 */var WebIFCDefaultDataSource=/*#__PURE__*/function(){function WebIFCDefaultDataSource(){_classCallCheck(this,WebIFCDefaultDataSource);}/**
     * Gets the contents of the given IFC file in an arraybuffer.
     *
     * @param {String|Number} src Path or ID of an IFC file.
     * @param {Function} ok Callback fired on success, argument is the IFC file in an arraybuffer.
     * @param {Function} error Callback fired on error.
     */_createClass(WebIFCDefaultDataSource,[{key:"getIFC",value:function getIFC(src,ok,error){var defaultCallback=function defaultCallback(){};ok=ok||defaultCallback;error=error||defaultCallback;var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=src.match(dataUriRegex);if(dataUriRegexResult){// Safari can't handle data URIs through XMLHttpRequest
var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64){data=window.atob(data);}try{var buffer=new ArrayBuffer(data.length);var view=new Uint8Array(buffer);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}ok(buffer);}catch(errMsg){error(errMsg);}}else{var request=new XMLHttpRequest();request.open('GET',src,true);request.responseType='arraybuffer';request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){ok(request.response);}else{error('getXKT error : '+request.response);}}};request.send(null);}}}]);return WebIFCDefaultDataSource;}();/**
 * {@link Viewer} plugin that uses [web-ifc](https://github.com/tomvandig/web-ifc) to load BIM models directly from IFC files.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_WebIFCLoaderPlugin_Duplex"><img src="https://xeokit.io/img/docs/WebIFCLoaderPlugin/WebIFCLoaderPlugin.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_WebIFCLoaderPlugin_Duplex)]
 *
 * ## Overview
 *
 * * Loads small-to-medium sized BIM models directly from IFC files.
 * * Uses [web-ifc](https://github.com/tomvandig/web-ifc) to parse IFC files in the browser.
 * * Loads IFC geometry, element structure metadata, and property sets.
 * * Not for large models. For best performance with large models, we recommend using {@link XKTLoaderPlugin}.
 * * Loads double-precision coordinates, enabling models to be viewed at global coordinates without accuracy loss.
 * * Allows to set the position, scale and rotation of each model as you load it.
 * * Filter which IFC types get loaded.
 * * Configure initial appearances of specified IFC types.
 * * Set a custom data source for IFC files.
 * * Load multiple copies of the same model.
 *
 * ## Limitations
 *
 * Loading and parsing huge IFC STEP files can be slow, and can overwhelm the browser, however. To view your
 * largest IFC models, we recommend instead pre-converting those to xeokit's compressed native .XKT format, then
 * loading them with {@link XKTLoaderPlugin} instead.</p>
 *
 * ## Scene representation
 *
 * When loading a model, WebIFCLoaderPlugin creates an {@link Entity} that represents the model, which
 * will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id}
 * in {@link Scene#models}. The WebIFCLoaderPlugin also creates an {@link Entity} for each object within the
 * model. Those Entities will have {@link Entity#isObject} set ````true```` and will be registered
 * by {@link Entity#id} in {@link Scene#objects}.
 *
 * ## Metadata
 *
 * When loading a model, WebIFCLoaderPlugin also creates a {@link MetaModel} that represents the model, which contains
 * a {@link MetaObject} for each IFC element, plus a {@link PropertySet} for each IFC property set. Loading metadata can be very slow, so we can also optionally disable it if we
 * don't need it.
 *
 * ## Usage
 *
 * In the example below we'll load the Duplex BIM model from
 * an [IFC file](https://github.com/xeokit/xeokit-sdk/tree/master/assets/models/ifc). Within our {@link Viewer}, this will create a bunch of {@link Entity}s that represents the model and its objects, along with a {@link MetaModel}, {@link MetaObject}s and {@link PropertySet}s
 * that hold their metadata.
 *
 * Since this model contains IFC types, the WebIFCLoaderPlugin will set the initial appearance of each object
 * {@link Entity} according to its IFC type in {@link WebIFCLoaderPlugin#objectDefaults}.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_WebIFCLoaderPlugin_isolateStorey)]
 *
 * ````javascript
 * import {Viewer, WebIFCLoaderPlugin} from "xeokit-sdk.es.js";
 * import * as WebIFC from "https://cdn.jsdelivr.net/npm/web-ifc@0.0.51/web-ifc-api.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a Viewer,
 * // 2. Arrange the camera
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // 2
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a web-ifc API, which will parse IFC for our WebIFCLoaderPlugin
 * // 2. Connect the API to the web-ifc WASM module, which powers the parsing
 * // 3. Initialize the web-ifc API
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 *
 * const IfcAPI = new this._webIFC.IfcAPI();
 *
 * // 2
 *
 * IfcAPI.SetWasmPath("https://cdn.jsdelivr.net/npm/web-ifc@0.0.51/");
 *
 * // 3
 *
 * IfcAPI.Init().then(() => {
 *
 *      //------------------------------------------------------------------------------------------------------------
 *      // 1. Create a WebIFCLoaderPlugin, configured with the web-ifc module and a web-ifc API instance
 *      // 2. Load a BIM model fom an IFC file, excluding its IfcSpace elements, and highlighting edges
 *      //------------------------------------------------------------------------------------------------------------
 *
 *     const ifcLoader = new WebIFCLoaderPlugin(viewer, {
 *         WebIFC,
 *         IfcAPI
 *     });
 *
 *     // 2
 *     const model = ifcLoader.load({          // Returns an Entity that represents the model
 *         id: "myModel",
 *         src: "../assets/models/ifc/Duplex.ifc",
 *         excludeTypes: ["IfcSpace"],
 *         edges: true
 *     });
 *
 *     model.on("loaded", () => {
 *
 *         //----------------------------------------------------------------------------------------------------------
 *         // 1. Find metadata on the bottom storey
 *         // 2. X-ray all the objects except for the bottom storey
 *         // 3. Fit the bottom storey in view
 *         //----------------------------------------------------------------------------------------------------------
 *
 *         // 1
 *         const metaModel = viewer.metaScene.metaModels["myModel"];       // MetaModel with ID "myModel"
 *         const metaObject
 *                 = viewer.metaScene.metaObjects["1xS3BCk291UvhgP2dvNsgp"];  // MetaObject with ID "1xS3BCk291UvhgP2dvNsgp"
 *
 *         const name = metaObject.name;                                   // "01 eerste verdieping"
 *         const type = metaObject.type;                                   // "IfcBuildingStorey"
 *         const parent = metaObject.parent;                               // MetaObject with type "IfcBuilding"
 *         const children = metaObject.children;                           // Array of child MetaObjects
 *         const objectId = metaObject.id;                                 // "1xS3BCk291UvhgP2dvNsgp"
 *         const objectIds = viewer.metaScene.getObjectIDsInSubtree(objectId);   // IDs of leaf sub-objects
 *         const aabb = viewer.scene.getAABB(objectIds);                   // Axis-aligned boundary of the leaf sub-objects
 *
 *         // 2
 *         viewer.scene.setObjectsXRayed(viewer.scene.objectIds, true);
 *         viewer.scene.setObjectsXRayed(objectIds, false);
 *
 *         // 3
 *         viewer.cameraFlight.flyTo(aabb);
 *
 *         // Find the model Entity by ID
 *         model = viewer.scene.models["myModel"];
 *
 *         // Destroy the model
 *         model.destroy();
 *     });
 * });
 * ````
 *
 * ## Transforming
 *
 * We have the option to rotate, scale and translate each  IFC model as we load it.
 *
 * This lets us load multiple models, or even multiple copies of the same model, and position them apart from each other.
 *
 * In the example below, we'll scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * translate it 100 units along its X axis.
 *
 * ````javascript
 * ifcLoader.load({
 *      src: "../assets/models/ifc/Duplex.ifc",
 *      rotation: [90,0,0],
 *      scale: [0.5, 0.5, 0.5],
 *      origin: [100, 0, 0]
 * });
 * ````
 *
 * ## Including and excluding IFC types
 *
 * We can also load only those objects that have the specified IFC types.
 *
 * In the example below, we'll load only the objects that represent walls.
 *
 * ````javascript
 * const model2 = ifcLoader.load({
 *     id: "myModel2",
 *     src: "../assets/models/ifc/Duplex.ifc",
 *     includeTypes: ["IfcWallStandardCase"]
 * });
 * ````
 *
 * We can also load only those objects that **don't** have the specified IFC types.
 *
 * In the example below, we'll load only the objects that do not represent empty space.
 *
 * ````javascript
 * const model3 = ifcLoader.load({
 *     id: "myModel3",
 *     src: "../assets/models/ifc/Duplex.ifc",
 *     excludeTypes: ["IfcSpace"]
 * });
 * ````
 *
 * ## Configuring initial IFC object appearances
 *
 * We can specify the custom initial appearance of loaded objects according to their IFC types.
 *
 * This is useful for things like:
 *
 * * setting the colors to our objects according to their IFC types,
 * * automatically hiding ````IfcSpace```` objects, and
 * * ensuring that ````IfcWindow```` objects are always transparent.
 * <br>
 * In the example below, we'll load a model, while configuring ````IfcSpace```` elements to be always initially invisible,
 * and ````IfcWindow```` types to be always translucent blue.
 *
 * ````javascript
 * const myObjectDefaults = {
 *
 *      IfcSpace: {
 *          visible: false
 *      },
 *      IfcWindow: {
 *          colorize: [0.337255, 0.303922, 0.870588], // Blue
 *          opacity: 0.3
 *      },
 *
 *      //...
 *
 *      DEFAULT: {
 *          colorize: [0.5, 0.5, 0.5]
 *      }
 * };
 *
 * const model4 = ifcLoader.load({
 *      id: "myModel4",
 *      src: "../assets/models/ifc/Duplex.ifc",
 *      objectDefaults: myObjectDefaults // Use our custom initial default states for object Entities
 * });
 * ````
 *
 * When we don't customize the appearance of IFC types, as just above, then IfcSpace elements tend to obscure other
 * elements, which can be confusing.
 *
 * It's often helpful to make IfcSpaces transparent and unpickable, like this:
 *
 * ````javascript
 * const ifcLoader = new WebIFCLoaderPlugin(viewer, {
 *    wasmPath: "../dist/",
 *    objectDefaults: {
 *        IfcSpace: {
 *            pickable: false,
 *            opacity: 0.2
 *        }
 *    }
 * });
 * ````
 *
 * Alternatively, we could just make IfcSpaces invisible, which also makes them unpickable:
 *
 * ````javascript
 * const ifcLoader = new WebIFCLoaderPlugin(viewer, {
 *    wasmPath: "../dist/",
 *    objectDefaults: {
 *        IfcSpace: {
 *            visible: false
 *        }
 *    }
 * });
 * ````
 *
 * ## Configuring a custom data source
 *
 * By default, WebIFCLoaderPlugin will load IFC files over HTTP.
 *
 * In the example below, we'll customize the way WebIFCLoaderPlugin loads the files by configuring it with our own data source
 * object. For simplicity, our custom data source example also uses HTTP, using a couple of xeokit utility functions.
 *
 * ````javascript
 * import {utils} from "xeokit-sdk.es.js";
 *
 * class MyDataSource {
 *
 *      constructor() {
 *      }
 *
 *      // Gets the contents of the given IFC file in an arraybuffer
 *      getIFC(src, ok, error) {
 *          console.log("MyDataSource#getIFC(" + IFCSrc + ", ... )");
 *          utils.loadArraybuffer(src,
 *              (arraybuffer) => {
 *                  ok(arraybuffer);
 *              },
 *              function (errMsg) {
 *                  error(errMsg);
 *              });
 *      }
 * }
 *
 * const ifcLoader2 = new WebIFCLoaderPlugin(viewer, {
 *       dataSource: new MyDataSource()
 * });
 *
 * const model5 = ifcLoader2.load({
 *      id: "myModel5",
 *      src: "../assets/models/ifc/Duplex.ifc"
 * });
 * ````
 *
 * ## Loading multiple copies of a model, without object ID clashes
 *
 * Sometimes we need to load two or more instances of the same model, without having clashes
 * between the IDs of the equivalent objects in the model instances.
 *
 * As shown in the example below, we do this by setting {@link WebIFCLoaderPlugin#globalizeObjectIds} ````true```` before we load our models.
 *
 * ````javascript
 * ifcLoader.globalizeObjectIds = true;
 *
 * const model = ifcLoader.load({
 *      id: "model1",
 *      src: "../assets/models/ifc/Duplex.ifc"
 * });
 *
 * const model2 = ifcLoader.load({
 *    id: "model2",
 *    src: "../assets/models/ifc/Duplex.ifc"
 * });
 * ````
 *
 * For each {@link Entity} loaded by these two calls, {@link Entity#id} and {@link MetaObject#id} will get prefixed by
 * the ID of their model, in order to avoid ID clashes between the two models.
 *
 * An Entity belonging to the first model will get an ID like this:
 *
 * ````
 * myModel1#0BTBFw6f90Nfh9rP1dlXrb
 * ````
 *
 * The equivalent Entity in the second model will get an ID like this:
 *
 * ````
 * myModel2#0BTBFw6f90Nfh9rP1dlXrb
 * ````
 *
 * Now, to update the visibility of both of those Entities collectively, using {@link Scene#setObjectsVisible}, we can
 * supply just the IFC product ID part to that method:
 *
 * ````javascript
 * myViewer.scene.setObjectVisibilities("0BTBFw6f90Nfh9rP1dlXrb", true);
 * ````
 *
 * The method, along with {@link Scene#setObjectsXRayed}, {@link Scene#setObjectsHighlighted} etc, will internally expand
 * the given ID to refer to the instances of that Entity in both models.
 *
 * We can also, of course, reference each Entity directly, using its globalized ID:
 *
 * ````javascript
 * myViewer.scene.setObjectVisibilities("myModel1#0BTBFw6f90Nfh9rP1dlXrb", true);
 *````
 *
 * @class WebIFCLoaderPlugin
 * @since 2.0.13
 */var WebIFCLoaderPlugin=/*#__PURE__*/function(_Plugin19){_inherits(WebIFCLoaderPlugin,_Plugin19);var _super160=_createSuper(WebIFCLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="ifcLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Object} cfg.WebIFC The web-ifc module, required by WebIFCLoaderPlugin. WebIFCLoaderPlugin uses various IFC type constants defined on this module.
     * @param {Object} cfg.IfcAPI A pre-initialized instance of the web-ifc API. WebIFCLoaderPlugin uses this to parse IFC.  * @param {Object} [cfg.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object.  Default value is {@link IFCObjectDefaults}.
     * @param {Object} [cfg.dataSource] A custom data source through which the WebIFCLoaderPlugin can load model and metadata files. Defaults to an instance of {@link WebIFCDefaultDataSource}, which loads over HTTP.
     * @param {String[]} [cfg.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {String[]} [cfg.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [cfg.excludeUnclassifiedObjects=false] When loading metadata and this is ````true````, will only load {@link Entity}s that have {@link MetaObject}s (that are not excluded). This is useful when we don't want Entitys in the Scene that are not represented within IFC navigation components, such as {@link TreeViewPlugin}.
     */function WebIFCLoaderPlugin(viewer){var _this157;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,WebIFCLoaderPlugin);_this157=_super160.call(this,"ifcLoader",viewer,cfg);_this157.dataSource=cfg.dataSource;_this157.objectDefaults=cfg.objectDefaults;_this157.includeTypes=cfg.includeTypes;_this157.excludeTypes=cfg.excludeTypes;_this157.excludeUnclassifiedObjects=cfg.excludeUnclassifiedObjects;if(!cfg.WebIFC){throw"Parameter expected: WebIFC";}if(!cfg.IfcAPI){throw"Parameter expected: IfcAPI";}_this157._webIFC=cfg.WebIFC;_this157._ifcAPI=cfg.IfcAPI;return _this157;}/**
     * Gets the ````IFC```` format versions supported by this WebIFCLoaderPlugin.
     * @returns {string[]}
     */_createClass(WebIFCLoaderPlugin,[{key:"supportedVersions",get:function get(){return["2x3","4"];}/**
     * Gets the custom data source through which the WebIFCLoaderPlugin can load IFC files.
     *
     * Default value is {@link WebIFCDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */},{key:"dataSource",get:function get(){return this._dataSource;}/**
     * Sets a custom data source through which the WebIFCLoaderPlugin can load IFC files.
     *
     * Default value is {@link WebIFCDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */,set:function set(value){this._dataSource=value||new WebIFCDefaultDataSource();}/**
     * Gets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */},{key:"objectDefaults",get:function get(){return this._objectDefaults;}/**
     * Sets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */,set:function set(value){this._objectDefaults=value||IFCObjectDefaults;}/**
     * Gets the whitelist of the IFC types loaded by this WebIFCLoaderPlugin.
     *
     * When loading IFC models, causes this WebIFCLoaderPlugin to only load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */},{key:"includeTypes",get:function get(){return this._includeTypes;}/**
     * Sets the whitelist of the IFC types loaded by this WebIFCLoaderPlugin.
     *
     * When loading IFC models, causes this WebIFCLoaderPlugin to only load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */,set:function set(value){this._includeTypes=value;}/**
     * Gets the blacklist of IFC types that are never loaded by this WebIFCLoaderPlugin.
     *
     * When loading IFC models, causes this WebIFCLoaderPlugin to **not** load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */},{key:"excludeTypes",get:function get(){return this._excludeTypes;}/**
     * Sets the blacklist of IFC types that are never loaded by this WebIFCLoaderPlugin.
     *
     * When IFC models, causes this WebIFCLoaderPlugin to **not** load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */,set:function set(value){this._excludeTypes=value;}/**
     * Gets whether we load objects that don't have IFC types.
     *
     * When loading IFC models and this is ````true````, WebIFCLoaderPlugin will not load objects
     * that don't have IFC types.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */},{key:"excludeUnclassifiedObjects",get:function get(){return this._excludeUnclassifiedObjects;}/**
     * Sets whether we load objects that don't have IFC types.
     *
     * When loading IFC models and this is ````true````, WebIFCLoaderPlugin will not load objects
     * that don't have IFC types.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */,set:function set(value){this._excludeUnclassifiedObjects=!!value;}/**
     * Gets whether WebIFCLoaderPlugin globalizes each {@link Entity#id} and {@link MetaObject#id} as it loads a model.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */},{key:"globalizeObjectIds",get:function get(){return this._globalizeObjectIds;}/**
     * Sets whether WebIFCLoaderPlugin globalizes each {@link Entity#id} and {@link MetaObject#id} as it loads a model.
     *
     * Set  this ````true```` when you need to load multiple instances of the same model, to avoid ID clashes
     * between the objects in the different instances.
     *
     * When we load a model with this set ````true````, then each {@link Entity#id} and {@link MetaObject#id} will be
     * prefixed by the ID of the model, ie. ````<modelId>#<objectId>````.
     *
     * {@link Entity#originalSystemId} and {@link MetaObject#originalSystemId} will always hold the original, un-prefixed, ID values.
     *
     * Default value is ````false````.
     *
     * See the main {@link WebIFCLoaderPlugin} class documentation for usage info.
     *
     * @type {Boolean}
     */,set:function set(value){this._globalizeObjectIds=!!value;}/**
     * Loads an ````IFC```` model into this WebIFCLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path to a IFC file, as an alternative to the ````ifc```` parameter.
     * @param {ArrayBuffer} [params.ifc] The IFC file data, as an alternative to the ````src```` parameter.
     * @param {Boolean} [params.loadMetadata=true] Whether to load IFC metadata (metaobjects and property sets).
     * @param {{String:Object}} [params.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object. Default value is {@link IFCObjectDefaults}.
     * @param {String[]} [params.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {String[]} [params.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the model with edges emphasized.
     * @param {Number[]} [params.origin=[0,0,0]] The model's World-space double-precision 3D origin. Use this to position the model within xeokit's World coordinate system, using double-precision coordinates.
     * @param {Number[]} [params.position=[0,0,0]] The model single-precision 3D position, relative to the ````origin```` parameter.
     * @param {Number[]} [params.scale=[1,1,1]] The model's scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's orientation, given as Euler angles in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters. Relative to ````origin````.
     * @param {Boolean} [params.edges=false] Indicates if the model's edges are initially emphasized.
     * @param {Boolean} [params.saoEnabled=true] Indicates if Scalable Ambient Obscurance (SAO) will apply to the model. SAO is configured by the Scene's {@link SAO} component. Only works when {@link SAO#enabled} is also ````true````
     * @param {Boolean} [params.pbrEnabled=false] Indicates if physically-based rendering (PBR) will apply to the model. Only works when {@link Scene#pbrEnabled} is also ````true````.
     * @param {Number} [params.backfaces=false] When we set this ````true````, then we force rendering of backfaces for the model. When we leave this ````false````, then we allow the Viewer to decide when to render backfaces. In that case, the Viewer will hide backfaces on watertight meshes, show backfaces on open meshes, and always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     * @param {Boolean} [params.excludeUnclassifiedObjects=false] When loading metadata and this is ````true````, will only load {@link Entity}s that have {@link MetaObject}s (that are not excluded). This is useful when we don't want Entitys in the Scene that are not represented within IFC navigation components, such as {@link TreeViewPlugin}.
     * @param {Boolean} [params.globalizeObjectIds=false] Indicates whether to globalize each {@link Entity#id} and {@link MetaObject#id}, in case you need to prevent ID clashes with other models. See {@link WebIFCLoaderPlugin#globalizeObjectIds} for more info.
     * @param {Object} [params.stats] Collects model statistics.
     * @param {Boolean} [params.dtxEnabled=true] When ````true```` (default) use data textures (DTX), where appropriate, to
     * represent the returned model. Set false to always use vertex buffer objects (VBOs). Note that DTX is only applicable
     * to non-textured triangle meshes, and that VBOs are always used for meshes that have textures, line segments, or point
     * primitives. Only works while {@link DTX#enabled} is also ````true````.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
     */},{key:"load",value:function load(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var sceneModel=new SceneModel(this.viewer.scene,utils.apply(params,{isModel:true}));if(!params.src&&!params.ifc){this.error("load() param expected: src or IFC");return sceneModel;// Return new empty model
}var options={autoNormals:true};if(params.loadMetadata!==false){var includeTypes=params.includeTypes||this._includeTypes;var excludeTypes=params.excludeTypes||this._excludeTypes;var objectDefaults=params.objectDefaults||this._objectDefaults;if(includeTypes){options.includeTypesMap={};for(var _i569=0,len=includeTypes.length;_i569<len;_i569++){options.includeTypesMap[includeTypes[_i569]]=true;}}if(excludeTypes){options.excludeTypesMap={};for(var _i570=0,_len119=excludeTypes.length;_i570<_len119;_i570++){options.excludeTypesMap[excludeTypes[_i570]]=true;}}if(objectDefaults){options.objectDefaults=objectDefaults;}options.excludeUnclassifiedObjects=params.excludeUnclassifiedObjects!==undefined?!!params.excludeUnclassifiedObjects:this._excludeUnclassifiedObjects;options.globalizeObjectIds=params.globalizeObjectIds!==undefined?!!params.globalizeObjectIds:this._globalizeObjectIds;}try{if(params.src){this._loadModel(params.src,params,options,sceneModel);}else{this._parseModel(params.ifc,params,options,sceneModel);}}catch(e){this.error(e);sceneModel.fire("error",e);}return sceneModel;}},{key:"_loadModel",value:function _loadModel(src,params,options,sceneModel){var _this158=this;var spinner=this.viewer.scene.canvas.spinner;spinner.processes++;this._dataSource.getIFC(params.src,function(arrayBuffer){_this158._parseModel(arrayBuffer,params,options,sceneModel);spinner.processes--;},function(errMsg){spinner.processes--;_this158.error(errMsg);sceneModel.fire("error",errMsg);});}},{key:"_parseModel",value:function _parseModel(arrayBuffer,params,options,sceneModel){if(sceneModel.destroyed){return;}var stats=params.stats||{};stats.sourceFormat="IFC";stats.schemaVersion="";stats.title="";stats.author="";stats.created="";stats.numMetaObjects=0;stats.numPropertySets=0;stats.numObjects=0;stats.numGeometries=0;stats.numTriangles=0;stats.numVertices=0;if(!this._ifcAPI){throw"WebIFCLoaderPlugin has no WebIFC instance configured - please inject via WebIFCLoaderPlugin constructor";}var dataArray=new Uint8Array(arrayBuffer);var modelID=this._ifcAPI.OpenModel(dataArray);var modelSchema=this._ifcAPI.GetModelSchema(modelID);var lines=this._ifcAPI.GetLineIDsWithType(modelID,this._webIFC.IFCPROJECT);var ifcProjectId=lines.get(0);var loadMetadata=params.loadMetadata!==false;var metadata=loadMetadata?{id:"",projectId:""+ifcProjectId,author:"",createdAt:"",schema:"",creatingApplication:"",metaObjects:[],propertySets:[]}:null;var ctx={modelID:modelID,modelSchema:modelSchema,sceneModel:sceneModel,loadMetadata:loadMetadata,metadata:metadata,metaObjects:{},options:options,log:function log(msg){},nextId:0,stats:stats};if(loadMetadata){if(options.includeTypes){ctx.includeTypes={};for(var _i571=0,len=options.includeTypes.length;_i571<len;_i571++){ctx.includeTypes[options.includeTypes[_i571]]=true;}}if(options.excludeTypes){ctx.excludeTypes={};for(var _i572=0,_len120=options.excludeTypes.length;_i572<_len120;_i572++){ctx.excludeTypes[options.excludeTypes[_i572]]=true;}}this._parseMetaObjects(ctx);this._parsePropertySets(ctx);}this._parseGeometry(ctx);sceneModel.finalize();if(loadMetadata){var metaModelId=sceneModel.id;this.viewer.metaScene.createMetaModel(metaModelId,ctx.metadata,options);}sceneModel.scene.once("tick",function(){if(sceneModel.destroyed){return;}sceneModel.scene.fire("modelLoaded",sceneModel.id);// FIXME: Assumes listeners know order of these two events
sceneModel.fire("loaded",true,false);// Don't forget the event, for late subscribers
});}},{key:"_parseMetaObjects",value:function _parseMetaObjects(ctx){var lines=this._ifcAPI.GetLineIDsWithType(ctx.modelID,this._webIFC.IFCPROJECT);var ifcProjectId=lines.get(0);var ifcProject=this._ifcAPI.GetLine(ctx.modelID,ifcProjectId);this._parseSpatialChildren(ctx,ifcProject);}},{key:"_parseSpatialChildren",value:function _parseSpatialChildren(ctx,ifcElement,parentMetaObjectId){var metaObjectType=this._ifcAPI.GetNameFromTypeCode(ifcElement.type);if(ctx.includeTypes&&!ctx.includeTypes[metaObjectType]){return;}if(ctx.excludeTypes&&ctx.excludeTypes[metaObjectType]){return;}this._createMetaObject(ctx,ifcElement,parentMetaObjectId);var metaObjectId=ifcElement.GlobalId.value;this._parseRelatedItemsOfType(ctx,ifcElement.expressID,'RelatingObject','RelatedObjects',this._webIFC.IFCRELAGGREGATES,metaObjectId);this._parseRelatedItemsOfType(ctx,ifcElement.expressID,'RelatingStructure','RelatedElements',this._webIFC.IFCRELCONTAINEDINSPATIALSTRUCTURE,metaObjectId);}},{key:"_createMetaObject",value:function _createMetaObject(ctx,ifcElement,parentMetaObjectId){var id=ifcElement.GlobalId.value;var metaObjectType=this._ifcAPI.GetNameFromTypeCode(ifcElement.type);var metaObjectName=ifcElement.Name&&ifcElement.Name.value!==""?ifcElement.Name.value:metaObjectType;var metaObject={id:id,name:metaObjectName,type:metaObjectType,parent:parentMetaObjectId};ctx.metadata.metaObjects.push(metaObject);ctx.metaObjects[id]=metaObject;ctx.stats.numMetaObjects++;}},{key:"_parseRelatedItemsOfType",value:function _parseRelatedItemsOfType(ctx,id,relation,related,type,parentMetaObjectId){var _this159=this;var lines=this._ifcAPI.GetLineIDsWithType(ctx.modelID,type);for(var _i573=0;_i573<lines.size();_i573++){var relID=lines.get(_i573);var rel=this._ifcAPI.GetLine(ctx.modelID,relID);var relatedItems=rel[relation];var foundElement=false;if(Array.isArray(relatedItems)){var values=relatedItems.map(function(item){return item.value;});foundElement=values.includes(id);}else{foundElement=relatedItems.value===id;}if(foundElement){var element=rel[related];if(!Array.isArray(element)){var ifcElement=this._ifcAPI.GetLine(ctx.modelID,element.value);this._parseSpatialChildren(ctx,ifcElement,parentMetaObjectId);}else{element.forEach(function(element2){var ifcElement=_this159._ifcAPI.GetLine(ctx.modelID,element2.value);_this159._parseSpatialChildren(ctx,ifcElement,parentMetaObjectId);});}}}}},{key:"_parsePropertySets",value:function _parsePropertySets(ctx){var lines=this._ifcAPI.GetLineIDsWithType(ctx.modelID,this._webIFC.IFCRELDEFINESBYPROPERTIES);for(var _i574=0;_i574<lines.size();_i574++){var relID=lines.get(_i574);var rel=this._ifcAPI.GetLine(ctx.modelID,relID,true);if(rel){var relatingPropertyDefinition=rel.RelatingPropertyDefinition;if(!relatingPropertyDefinition){continue;}var propertySetId=relatingPropertyDefinition.GlobalId.value;var props=relatingPropertyDefinition.HasProperties;if(props&&props.length>0){var propertySetType="Default";var propertySetName=relatingPropertyDefinition.Name.value;var properties=[];for(var _i575=0,len=props.length;_i575<len;_i575++){var prop=props[_i575];var _name8=prop.Name;var nominalValue=prop.NominalValue;if(_name8&&nominalValue){var property={name:_name8.value,type:nominalValue.type,value:nominalValue.value,valueType:nominalValue.valueType};if(prop.Description){property.description=prop.Description.value;}else if(nominalValue.description){property.description=nominalValue.description;}properties.push(property);}}var propertySet={id:propertySetId,type:propertySetType,name:propertySetName,properties:properties};ctx.metadata.propertySets.push(propertySet);ctx.stats.numPropertySets++;var relatedObjects=rel.RelatedObjects;if(!relatedObjects||relatedObjects.length===0){return;}for(var _i576=0,_len121=relatedObjects.length;_i576<_len121;_i576++){var relatedObject=relatedObjects[_i576];var metaObjectId=relatedObject.GlobalId.value;var metaObject=ctx.metaObjects[metaObjectId];if(metaObject){if(!metaObject.propertySetIds){metaObject.propertySetIds=[];}metaObject.propertySetIds.push(propertySetId);}}}}}}},{key:"_parseGeometry",value:function _parseGeometry(ctx){var _this160=this;this._ifcAPI.StreamAllMeshes(ctx.modelID,function(flatMesh){// TODO: Can we do geometry reuse with web-ifc?
var flatMeshExpressID=flatMesh.expressID;var placedGeometries=flatMesh.geometries;var meshIds=[];var properties=_this160._ifcAPI.GetLine(ctx.modelID,flatMeshExpressID);var globalId=properties.GlobalId.value;if(ctx.loadMetadata){var metaObjectId=globalId;var metaObject=ctx.metaObjects[metaObjectId];if(ctx.includeTypes&&(!metaObject||!ctx.includeTypes[metaObject.type])){return;}if(ctx.excludeTypes&&(!metaObject||ctx.excludeTypes[metaObject.type])){return;}}var matrix=math.mat4();var origin=math.vec3();for(var j=0,lenj=placedGeometries.size();j<lenj;j++){var placedGeometry=placedGeometries.get(j);var geometry=_this160._ifcAPI.GetGeometry(ctx.modelID,placedGeometry.geometryExpressID);var vertexData=_this160._ifcAPI.GetVertexArray(geometry.GetVertexData(),geometry.GetVertexDataSize());var indices=_this160._ifcAPI.GetIndexArray(geometry.GetIndexData(),geometry.GetIndexDataSize());// De-interleave vertex arrays
var positions=new Float64Array(vertexData.length/2);var normals=new Float32Array(vertexData.length/2);for(var k=0,_l3=0,lenk=vertexData.length/6;k<lenk;k++,_l3+=3){positions[_l3+0]=vertexData[k*6+0];positions[_l3+1]=vertexData[k*6+1];positions[_l3+2]=vertexData[k*6+2];}matrix.set(placedGeometry.flatTransformation);math.transformPositions3(matrix,positions);var rtcNeeded=worldToRTCPositions(positions,positions,origin);if(!ctx.options.autoNormals){for(var _k2=0,_l4=0,_lenk=vertexData.length/6;_k2<_lenk;_k2++,_l4+=3){normals[_l4+0]=vertexData[_k2*6+3];normals[_l4+1]=vertexData[_k2*6+4];normals[_l4+2]=vertexData[_k2*6+5];}}ctx.stats.numGeometries++;ctx.stats.numVertices+=positions.length/3;ctx.stats.numTriangles+=indices.length/3;var meshId="mesh"+ctx.nextId++;ctx.sceneModel.createMesh({id:meshId,primitive:"triangles",// TODO
origin:rtcNeeded?origin:null,positions:positions,normals:ctx.options.autoNormals?null:normals,indices:indices,color:[placedGeometry.color.x,placedGeometry.color.y,placedGeometry.color.z],opacity:placedGeometry.color.w});meshIds.push(meshId);}var entityId=ctx.options.globalizeObjectIds?math.globalizeObjectId(ctx.sceneModel.id,globalId):globalId;ctx.sceneModel.createEntity({id:entityId,meshIds:meshIds,isObject:true});ctx.stats.numObjects++;});}}]);return WebIFCLoaderPlugin;}(Plugin);/**
 * Default data access strategy for {@link LASLoaderPlugin}.
 */var LASDefaultDataSource=/*#__PURE__*/function(){function LASDefaultDataSource(){_classCallCheck(this,LASDefaultDataSource);}/**
     * Gets the contents of the given LAS file in an arraybuffer.
     *
     * @param {String|Number} src Path or ID of an LAS file.
     * @param {Function} ok Callback fired on success, argument is the LAS file in an arraybuffer.
     * @param {Function} error Callback fired on error.
     */_createClass(LASDefaultDataSource,[{key:"getLAS",value:function getLAS(src,ok,error){var defaultCallback=function defaultCallback(){};ok=ok||defaultCallback;error=error||defaultCallback;var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=src.match(dataUriRegex);if(dataUriRegexResult){// Safari can't handle data URIs through XMLHttpRequest
var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64){data=window.atob(data);}try{var buffer=new ArrayBuffer(data.length);var view=new Uint8Array(buffer);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}ok(buffer);}catch(errMsg){error(errMsg);}}else{var request=new XMLHttpRequest();request.open('GET',src,true);request.responseType='arraybuffer';request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){ok(request.response);}else{error('getXKT error : '+request.response);}}};request.send(null);}}}]);return LASDefaultDataSource;}();var VERSION="3.2.6";var DEFAULT_LAS_OPTIONS={las:{shape:'mesh',fp64:false,skip:1,colorDepth:8}};var LASLoader={name:'LAS',id:'las',module:'las',version:VERSION,worker:true,extensions:['las','laz'],mimeTypes:['application/octet-stream'],text:true,binary:true,tests:['LAS'],options:DEFAULT_LAS_OPTIONS};//import * as epsgCheck from 'epsg-index/all.json';
var headerBlockItems=[{item:'FileSignature',format:'char',size:4},{item:'FileSoureceID',format:'uShort',size:2},{item:'GlobalEncoding',format:'uShort',size:2},{item:'ProjectID1',format:'notUsed',size:4},{item:'ProjectID2',format:'notUsed',size:2},{item:'ProjectID3',format:'notUsed',size:2},{item:'ProjectID4',format:'notUsed',size:8},{item:'VersionMajor',format:'uChar',size:1},{item:'VersionMinor',format:'uChar',size:1},{item:'SystemIdentifier',format:'char',size:32},{item:'GeneratingSoftware',format:'char',size:32},{item:'CreationDay',format:'uShort',size:2},{item:'CreationYear',format:'uShort',size:2},{item:'HeaderSize',format:'uShort',size:2},{item:'OffsetToPointData',format:'uLong',size:4},{item:'NumberOfVariableLengthRecords',format:'uLong',size:4},{item:'PointDataFormatID',format:'uChar',size:1},{item:'PointDataRecordLength',format:'uShort',size:2},{item:'NumberOfPoints',format:'uLong',size:4},{item:'NumberOfPointByReturn',format:'uLong',size:20},{item:'ScaleFactorX',format:'double',size:8},{item:'ScaleFactorY',format:'double',size:8},{item:'ScaleFactorZ',format:'double',size:8},{item:'OffsetX',format:'double',size:8},{item:'OffsetY',format:'double',size:8},{item:'OffsetZ',format:'double',size:8},{item:'MaxX',format:'double',size:8},{item:'MinX',format:'double',size:8},{item:'MaxY',format:'double',size:8},{item:'MinY',format:'double',size:8},{item:'MaxZ',format:'double',size:8},{item:'MinZ',format:'double',size:8}];var variableLengthRecord=[{item:'Reserved',format:'uShort',size:2},{item:'UserId',format:'char',size:16},{item:'RecordId',format:'uShort',size:2},{item:'RecordLengthAfterHeader',format:'uShort',size:2},{item:'Description',format:'char',size:32}];/**
 * @private
 * @param arrayBuffer
 * @returns {{}}
 */var loadLASHeader=function loadLASHeader(arrayBuffer){var currentByte=0;var numOfVarLenRecords=0;var projectionStart=0;var dataView=new DataView(arrayBuffer);var buffer=new Uint8Array(6000);var getGeoKeys=function getGeoKeys(geoRecord){if(geoRecord===undefined){return undefined;}var projectionEnd=projectionStart+geoRecord["RecordLengthAfterHeader"];var geoTag=buffer.slice(projectionStart,projectionEnd);var arrayBuffer=bufferFlipper(geoTag);var dataView=new DataView(arrayBuffer);var byteCount=6;var numberOfKeys=Number(dataView.getUint16(byteCount,true));var geoKeys=[];while(numberOfKeys--){var keyTmp={};keyTmp.key=dataView.getUint16(byteCount+=2,true);keyTmp.tiffTagLocation=dataView.getUint16(byteCount+=2,true);keyTmp.count=dataView.getUint16(byteCount+=2,true);keyTmp.valueOffset=dataView.getUint16(byteCount+=2,true);geoKeys.push(keyTmp);}var projRecord=geoKeys.find(function(x){return x.key===3072;});if(projRecord&&projRecord.hasOwnProperty('valueOffset')){var epsg=projRecord.valueOffset;{return epsg;}}return undefined;};var getValue=function getValue(_ref21){var item=_ref21.item,format=_ref21.format,size=_ref21.size;var str,array;switch(format){case'char':array=new Uint8Array(arrayBuffer,currentByte,size);currentByte+=size;str=uint8arrayToString(array);return[item,str];case'uShort':str=dataView.getUint16(currentByte,true);currentByte+=size;return[item,str];case'uLong':str=dataView.getUint32(currentByte,true);if(item==='NumberOfVariableLengthRecords'){numOfVarLenRecords=str;}currentByte+=size;return[item,str];case'uChar':str=dataView.getUint8(currentByte);currentByte+=size;return[item,str];case'double':str=dataView.getFloat64(currentByte,true);currentByte+=size;return[item,str];default:currentByte+=size;}};var getValues=function getValues(){var publicHeaderBlock={};headerBlockItems.forEach(function(obj){var myObj=getValue(_objectSpread({},obj));if(myObj!==undefined){if(myObj[0]==='FileSignature'&&myObj[1]!=='LASF'){throw new Error('Ivalid FileSignature. Is this a LAS/LAZ file');}publicHeaderBlock[myObj[0]]=myObj[1];}});var variableRecords=[];var variableLengthRecords=numOfVarLenRecords;var _loop7=function _loop7(){var variableObj={};variableLengthRecord.forEach(function(obj){var myObj=getValue(_objectSpread({},obj));variableObj[myObj[0]]=myObj[1];if(myObj[0]==='UserId'&&myObj[1]==='LASF_Projection'){projectionStart=currentByte-18+54;}});variableRecords.push(variableObj);};while(variableLengthRecords--){_loop7();}var geoRecord=variableRecords.find(function(x){return x.UserId==='LASF_Projection';});var epsg=getGeoKeys(geoRecord);if(epsg){publicHeaderBlock['epsg']=epsg;}return publicHeaderBlock;};return getValues();};var bufferFlipper=function bufferFlipper(buf){var ab=new ArrayBuffer(buf.length);var view=new Uint8Array(ab);for(var _i577=0;_i577<buf.length;++_i577){view[_i577]=buf[_i577];}return ab;};var uint8arrayToString=function uint8arrayToString(array){var str='';array.forEach(function(item){var c=String.fromCharCode(item);if(c!=="\0"){str+=c;}});return str.trim();};var MAX_VERTICES=500000;// TODO: Rough estimate
/**
 * {@link Viewer} plugin that loads lidar point cloud geometry from LAS files.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#loading_LASLoaderPlugin_Autzen"><img src="https://xeokit.github.io/xeokit-sdk/assets/images/autzen.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_LASLoaderPlugin_Autzen)]
 *
 * ## Summary
 *
 * * Loads [LAS Formats](https://www.asprs.org/divisions-committees/lidar-division/laser-las-file-format-exchange-activities) up to v1.3 from both *.las* and *.laz* files. It does not support LAS v1.4.
 * * Loads lidar point cloud positions, colors and intensities.
 * * Supports 32 and 64-bit positions.
 * * Supports 8 and 16-bit color depths.
 * * Option to load every *n* points.
 * * Does not (yet) load [point classifications](https://www.usna.edu/Users/oceano/pguth/md_help/html/las_format_classification_codes.htm).
 *
 * ## Performance
 *
 * If you need faster loading, consider pre-converting your LAS files to XKT format using [xeokit-convert](https://github.com/xeokit/xeokit-convert), then loading them
 * with {@link XKTLoaderPlugin}.
 *
 * ## Scene and metadata representation
 *
 * When LASLoaderPlugin loads a LAS file, it creates two {@link Entity}s, a {@link MetaModel} and a {@link MetaObject}.
 *
 * The first Entity represents the file as a model within the Viewer's {@link Scene}. To indicate that it represents a model,
 * this Entity will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 *
 * The second Entity represents the the point cloud itself, as an object within the Scene. To indicate that it
 * represents an object, this Entity will have {@link Entity#isObject} set ````true```` and will be registered
 * by {@link Entity#id} in {@link Scene#objects}.
 *
 * The MetaModel registers the LAS file as a model within the Viewer's {@link MetaScene}. The MetaModel will be registered
 * by {@link MetaModel#id} in {@link MetaScene#metaModels} .
 *
 * Finally, the MetaObject registers the point cloud as an object within the {@link MetaScene}. The MetaObject will be registered
 * by {@link MetaObject#id} in {@link MetaScene#metaObjects}.
 *
 * ## Usage
 *
 * In the example below we'll load the Autzen model from
 * a [LAS file](/assets/models/las/). Once the model has
 * loaded, we'll then find its {@link MetaModel}, and the {@link MetaObject} and {@link Entity} that represent its point cloud.
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_LASLoaderPlugin_Autzen)]
 *
 * ````javascript
 * import {Viewer, LASLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const lasLoader = new LASLoaderPlugin(viewer, {
 *     colorDepth: 8, // Default
 *     fp64: false,   // Default
 *     skip: 1        // Default
 * });
 *
 * const modelEntity = lasLoader.load({
 *     id: "myModel",
 *     src: "../assets/models/las/autzen.laz"
 * });
 *
 * modelEntity.on("loaded", () => {
 *
 *      const metaModel = viewer.metaScene.metaModels[modelEntity.id];
 *      const pointCloudMetaObject = metaModel.rootMetaObject;
 *
 *      const pointCloudEntity = viewer.scene.objects[pointCloudMetaObject.id];
 *
 *      //...
 * });
 * ````
 *
 * ## Transforming
 *
 * We have the option to rotate, scale and translate each LAS model as we load it.
 *
 * In the example below, we'll scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * position it at [1842022, 10, -5173301] within xeokit's world coordinate system.
 *
 * ````javascript
 * const modelEntity = lasLoader.load({
 *      id: "myModel",
 *      src: "../assets/models/las/autzen.laz"
 *      rotation: [90,0,0],
 *      scale: [0.5, 0.5, 0.5],
 *      origin: [1842022, 10, -5173301]
 * });
 * ````
 *
 * ## Configuring a custom data source
 *
 * By default, LASLoaderPlugin will load LAS files over HTTP.
 *
 * In the example below, we'll customize the way LASLoaderPlugin loads the files by configuring it with our own data source
 * object. For simplicity, our custom data source example also uses HTTP, using a couple of xeokit utility functions.
 *
 * ````javascript
 * import {utils} from "xeokit-sdk.es.js";
 *
 * class MyDataSource {
 *
 *      constructor() {
 *      }
 *
 *      // Gets the contents of the given LAS file in an arraybuffer
 *      getLAS(src, ok, error) {
 *          utils.loadArraybuffer(src,
 *              (arraybuffer) => {
 *                  ok(arraybuffer);
 *              },
 *              (errMsg) => {
 *                  error(errMsg);
 *              });
 *      }
 * }
 *
 * const lasLoader = new LASLoaderPlugin(viewer, {
 *       dataSource: new MyDataSource()
 * });
 *
 * const modelEntity = lasLoader.load({
 *      id: "myModel",
 *      src: "../assets/models/las/autzen.laz"
 * });
 * ````
 *
 * @class LASLoaderPlugin
 * @since 2.0.17
 */var LASLoaderPlugin=/*#__PURE__*/function(_Plugin20){_inherits(LASLoaderPlugin,_Plugin20);var _super161=_createSuper(LASLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="lasLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Object} [cfg.dataSource] A custom data source through which the LASLoaderPlugin can load model and metadata files. Defaults to an instance of {@link LASDefaultDataSource}, which loads over HTTP.
     * @param {Number} [cfg.skip=1] Configures LASLoaderPlugin to load every **n** points.
     * @param {Number} [cfg.fp64=false] Configures if LASLoaderPlugin assumes that LAS positions are stored in 64-bit floats instead of 32-bit.
     * @param {Number} [cfg.colorDepth=8] Configures whether LASLoaderPlugin assumes that LAS colors are encoded using 8 or 16 bits. Accepted values are 8, 16 an "auto".
     */function LASLoaderPlugin(viewer){var _this161;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,LASLoaderPlugin);_this161=_super161.call(this,"lasLoader",viewer,cfg);_this161.dataSource=cfg.dataSource;_this161.skip=cfg.skip;_this161.fp64=cfg.fp64;_this161.colorDepth=cfg.colorDepth;return _this161;}/**
     * Gets the custom data source through which the LASLoaderPlugin can load LAS files.
     *
     * Default value is {@link LASDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */_createClass(LASLoaderPlugin,[{key:"dataSource",get:function get(){return this._dataSource;}/**
     * Sets a custom data source through which the LASLoaderPlugin can load LAS files.
     *
     * Default value is {@link LASDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */,set:function set(value){this._dataSource=value||new LASDefaultDataSource();}/**
     * When LASLoaderPlugin is configured to load every **n** points, returns the value of **n**.
     *
     * Default value is ````1````.
     *
     * @returns {Number} The **n**th point that LASLoaderPlugin will read.
     */},{key:"skip",get:function get(){return this._skip;}/**
     * Configures LASLoaderPlugin to load every **n** points.
     *
     * Default value is ````1````.
     *
     * @param {Number} value The **n**th point that LASLoaderPlugin will read.
     */,set:function set(value){this._skip=value||1;}/**
     * Gets if LASLoaderPlugin assumes that LAS positions are stored in 64-bit floats instead of 32-bit.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} True if LASLoaderPlugin assumes that positions are stored in 64-bit floats instead of 32-bit.
     */},{key:"fp64",get:function get(){return this._fp64;}/**
     * Configures if LASLoaderPlugin assumes that LAS positions are stored in 64-bit floats instead of 32-bit.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} value True if LASLoaderPlugin assumes that positions are stored in 64-bit floats instead of 32-bit.
     */,set:function set(value){this._fp64=!!value;}/**
     * Gets whether LASLoaderPlugin assumes that LAS colors are encoded using 8 or 16 bits.
     *
     * Default value is ````8````.
     *
     * Note: LAS specification recommends 16 bits.
     *
     * @returns {Number|String} Possible returned values are 8, 16 and "auto".
     */},{key:"colorDepth",get:function get(){return this._colorDepth;}/**
     * Configures whether LASLoaderPlugin assumes that LAS colors are encoded using 8 or 16 bits.
     *
     * Default value is ````8````.
     *
     * Note: LAS specification recommends 16 bits.
     *
     * @param {Number|String} value Valid values are 8, 16 and "auto".
     */,set:function set(value){this._colorDepth=value||"auto";}/**
     * Loads an ````LAS```` model into this LASLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path to a LAS file, as an alternative to the ````las```` parameter.
     * @param {ArrayBuffer} [params.las] The LAS file data, as an alternative to the ````src```` parameter.
     * @param {Boolean} [params.loadMetadata=true] Whether to load metadata for the LAS model.
     * @param {Number[]} [params.origin=[0,0,0]] The model's World-space double-precision 3D origin. Use this to position the model within xeokit's World coordinate system, using double-precision coordinates.
     * @param {Number[]} [params.position=[0,0,0]] The model single-precision 3D position, relative to the ````origin```` parameter.
     * @param {Number[]} [params.scale=[1,1,1]] The model's scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's orientation, given as Euler angles in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters. Relative to ````origin````.
     * @param {Object} [params.stats] Collects model statistics.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
     */},{key:"load",value:function load(){var _this162=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var sceneModel=new SceneModel(this.viewer.scene,utils.apply(params,{isModel:true}));if(!params.src&&!params.las){this.error("load() param expected: src or las");return sceneModel;// Return new empty model
}var options={las:{skip:this._skip,fp64:this._fp64,colorDepth:this._colorDepth}};if(params.src){this._loadModel(params.src,params,options,sceneModel);}else{var spinner=this.viewer.scene.canvas.spinner;spinner.processes++;this._parseModel(params.las,params,options,sceneModel).then(function(){spinner.processes--;},function(errMsg){spinner.processes--;_this162.error(errMsg);sceneModel.fire("error",errMsg);});}return sceneModel;}},{key:"_loadModel",value:function _loadModel(src,params,options,sceneModel){var _this163=this;var spinner=this.viewer.scene.canvas.spinner;spinner.processes++;this._dataSource.getLAS(params.src,function(arrayBuffer){_this163._parseModel(arrayBuffer,params,options,sceneModel).then(function(){spinner.processes--;},function(errMsg){spinner.processes--;_this163.error(errMsg);sceneModel.fire("error",errMsg);});},function(errMsg){spinner.processes--;_this163.error(errMsg);sceneModel.fire("error",errMsg);});}},{key:"_parseModel",value:function _parseModel(arrayBuffer,params,options,sceneModel){var _this164=this;function readPositions(attributesPosition){var positionsValue=attributesPosition.value;if(params.rotateX){if(positionsValue){for(var _i578=0,len=positionsValue.length;_i578<len;_i578+=3){var temp=positionsValue[_i578+1];positionsValue[_i578+1]=positionsValue[_i578+2];positionsValue[_i578+2]=temp;}}}return positionsValue;}function readColorsAndIntensities(attributesColor,attributesIntensity){var colors=attributesColor.value;var colorSize=attributesColor.size;var intensities=attributesIntensity.value;var colorsCompressedSize=intensities.length*4;var colorsCompressed=new Uint8Array(colorsCompressedSize);for(var _i579=0,j=0,k=0,len=intensities.length;_i579<len;_i579++,k+=colorSize,j+=4){colorsCompressed[j+0]=colors[k+0];colorsCompressed[j+1]=colors[k+1];colorsCompressed[j+2]=colors[k+2];colorsCompressed[j+3]=Math.round(intensities[_i579]/65536*255);}return colorsCompressed;}function readIntensities(attributesIntensity){var intensities=attributesIntensity.intensity;var colorsCompressedSize=intensities.length*4;var colorsCompressed=new Uint8Array(colorsCompressedSize);for(var _i580=0,j=0,len=intensities.length;_i580<len;_i580++,j+=4){colorsCompressed[j+0]=0;colorsCompressed[j+1]=0;colorsCompressed[j+2]=0;colorsCompressed[j+3]=Math.round(intensities[_i580]/65536*255);}return colorsCompressed;}return new Promise(function(resolve,reject){if(sceneModel.destroyed){reject();return;}var stats=params.stats||{};stats.sourceFormat="LAS";stats.schemaVersion="";stats.title="";stats.author="";stats.created="";stats.numMetaObjects=0;stats.numPropertySets=0;stats.numObjects=0;stats.numGeometries=0;stats.numTriangles=0;stats.numVertices=0;try{var lasHeader=loadLASHeader(arrayBuffer);parse$3(arrayBuffer,LASLoader,options).then(function(parsedData){var attributes=parsedData.attributes;var loaderData=parsedData.loaderData;var pointsFormatId=loaderData.pointsFormatId!==undefined?loaderData.pointsFormatId:-1;if(!attributes.POSITION){sceneModel.finalize();reject("No positions found in file");return;}var positionsValue;var colorsCompressed;switch(pointsFormatId){case 0:positionsValue=readPositions(attributes.POSITION);colorsCompressed=readIntensities(attributes.intensity);break;case 1:if(!attributes.intensity){sceneModel.finalize();reject("No positions found in file");return;}positionsValue=readPositions(attributes.POSITION);colorsCompressed=readIntensities(attributes.intensity);break;case 2:if(!attributes.intensity){sceneModel.finalize();reject("No positions found in file");return;}positionsValue=readPositions(attributes.POSITION);colorsCompressed=readColorsAndIntensities(attributes.COLOR_0,attributes.intensity);break;case 3:if(!attributes.intensity){sceneModel.finalize();reject("No positions found in file");return;}positionsValue=readPositions(attributes.POSITION);colorsCompressed=readColorsAndIntensities(attributes.COLOR_0,attributes.intensity);break;}var pointsChunks=chunkArray(positionsValue,MAX_VERTICES*3);var colorsChunks=chunkArray(colorsCompressed,MAX_VERTICES*4);var meshIds=[];for(var _i581=0,len=pointsChunks.length;_i581<len;_i581++){var meshId="pointsMesh".concat(_i581);meshIds.push(meshId);sceneModel.createMesh({id:meshId,primitive:"points",positions:pointsChunks[_i581],colorsCompressed:_i581<colorsChunks.length?colorsChunks[_i581]:null});}/*
                                const pointsChunks = chunkArray(positionsValue, MAX_VERTICES * 3);
                    const colorsChunks = chunkArray(colorsCompressed, MAX_VERTICES * 4);
                    const meshIds = [];

                    for (let i = 0, len = pointsChunks.length; i < len; i++) {

                        const geometryId = `geometryMesh${i}`;
                        const meshId = `pointsMesh${i}`;
                        meshIds.push(meshId);

                        sceneModel.createGeometry({
                            id: geometryId,
                            primitive: "points",
                            positions: pointsChunks[i],
                            colorsCompressed: (i < colorsChunks.length) ? colorsChunks[i] : null
                        });

                        sceneModel.createMesh({
                            id: meshId,
                            geometryId
                        });
                    }
                     */var pointsObjectId=math.createUUID();sceneModel.createEntity({id:pointsObjectId,meshIds:meshIds,isObject:true});sceneModel.finalize();if(params.loadMetadata!==false){var rootMetaObjectId=math.createUUID();var metadata={projectId:"",author:"",createdAt:"",schema:"",creatingApplication:"",metaObjects:[{id:rootMetaObjectId,name:"Model",type:"Model"},{id:pointsObjectId,name:"PointCloud (LAS)",type:"PointCloud",parent:rootMetaObjectId,attributes:lasHeader||{}}],propertySets:[]};var metaModelId=sceneModel.id;_this164.viewer.metaScene.createMetaModel(metaModelId,metadata,options);}sceneModel.scene.once("tick",function(){if(sceneModel.destroyed){return;}sceneModel.scene.fire("modelLoaded",sceneModel.id);// FIXME: Assumes listeners know order of these two events
sceneModel.fire("loaded",true,false);// Don't forget the event, for late subscribers
});resolve();});}catch(e){sceneModel.finalize();reject(e);}});}}]);return LASLoaderPlugin;}(Plugin);function chunkArray(array,chunkSize){if(chunkSize>=array.length){return array;}var result=[];for(var _i582=0;_i582<array.length;_i582+=chunkSize){result.push(array.slice(_i582,_i582+chunkSize));}return result;}/**
 * Default data access strategy for {@link CityJSONLoaderPlugin}.
 */var CityJSONDefaultDataSource=/*#__PURE__*/function(){function CityJSONDefaultDataSource(){_classCallCheck(this,CityJSONDefaultDataSource);}/**
     * Gets the contents of the given CityJSON file.
     *
     * @param {String|Number} src Path or ID of an CityJSON file.
     * @param {Function} ok Callback fired on success, argument is the CityJSON JSON.
     * @param {Function} error Callback fired on error.
     */_createClass(CityJSONDefaultDataSource,[{key:"getCityJSON",value:function getCityJSON(src,ok,error){utils.loadJSON(src,function(json){ok(json);},function(errMsg){error(errMsg);});}}]);return CityJSONDefaultDataSource;}();/** @private */function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else{for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertex leads to less sliver triangles
ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
if(ear===stop){// try filtering points and slicing again
if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
}else if(pass===1){ear=cureLocalIntersections(filterPoints(ear),triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);var p=ear.prevZ,n=ear.nextZ;// look for points inside the triangle in both directions
while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}// look for remaining points in decreasing z-order
while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}// look for remaining points in increasing z-order
while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return filterPoints(p);}// try splitting polygon into two and triangulate them independently
function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
var c=splitPolygon(a,b);// filter colinear points around the cuts
a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);// filter collinear points around the cuts
filterPoints(outerNode,outerNode.next);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m;// hole touches outer segment; pick leftmost endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m;do{if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
if(locallyInside(p,hole)&&(tan<tanMin||tan===tanMin&&(p.x>m.x||p.x===m.x&&sectorContainsSector(m,p)))){m=p;tanMin=tan;}}p=p.next;}while(p!==stop);return m;}// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m,p){return area(m.prev,m,p.prev)<0&&area(p.next,m,m.next)<0;}// interlink polygon nodes in z-order
function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&(// dones't intersect other edges
locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b)&&(// locally visible
area(a.prev,a,b.prev)||area(a,b.prev,b))||// does not create opposite-facing sectors
equals(a,b)&&area(a.prev,a,a.next)>0&&area(b.prev,b,b.next)>0);// special zero-length case
}// signed area of a triangle
function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
function intersects(p1,q1,p2,q2){var o1=sign(area(p1,q1,p2));var o2=sign(area(p1,q1,q2));var o3=sign(area(p2,q2,p1));var o4=sign(area(p2,q2,q1));if(o1!==o2&&o3!==o4)return true;// general case
if(o1===0&&onSegment(p1,p2,q1))return true;// p1, q1 and p2 are collinear and p2 lies on p1q1
if(o2===0&&onSegment(p1,q2,q1))return true;// p1, q1 and q2 are collinear and q2 lies on p1q1
if(o3===0&&onSegment(p2,p1,q2))return true;// p2, q2 and p1 are collinear and p1 lies on p2q2
if(o4===0&&onSegment(p2,q1,q2))return true;// p2, q2 and q1 are collinear and q1 lies on p2q2
return false;}// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y);}function sign(num){return num>0?1:num<0?-1:0;}// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a,b){var a2=new Node$1(a.i,a.x,a.y),b2=new Node$1(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i,x,y,last){var p=new Node$1(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node$1(i,x,y){// vertex index in coordinates array
this.i=i;// vertex coordinates
this.x=x;this.y=y;// previous and next vertex nodes in a polygon ring
this.prev=null;this.next=null;// z-order curve value
this.z=null;// previous and next nodes in z-order
this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
this.steiner=false;}// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation=function(data,holeIndices,dim,triangles){var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var polygonArea=Math.abs(signedArea(data,0,outerLen,dim));if(hasHoles){for(var i=0,len=holeIndices.length;i<len;i++){var start=holeIndices[i]*dim;var end=i<len-1?holeIndices[i+1]*dim:data.length;polygonArea-=Math.abs(signedArea(data,start,end,dim));}}var trianglesArea=0;for(i=0;i<triangles.length;i+=3){var a=triangles[i]*dim;var b=triangles[i+1]*dim;var c=triangles[i+2]*dim;trianglesArea+=Math.abs((data[a]-data[c])*(data[b+1]-data[a+1])-(data[a]-data[b])*(data[c+1]-data[a+1]));}return polygonArea===0&&trianglesArea===0?0:Math.abs((trianglesArea-polygonArea)/polygonArea);};function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten=function(data){var dim=data[0][0].length,result={vertices:[],holes:[],dimensions:dim},holeIndex=0;for(var i=0;i<data.length;i++){for(var j=0;j<data[i].length;j++){for(var d=0;d<dim;d++){result.vertices.push(data[i][j][d]);}}if(i>0){holeIndex+=data[i-1].length;result.holes.push(holeIndex);}}return result;};var tempVec2a=math.vec2();var tempVec3a=math.vec3();var tempVec3b=math.vec3();var tempVec3c=math.vec3();/**
 * {@link Viewer} plugin that loads models from CityJSON files.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#loading_CityJSONLoaderPlugin_Railway"><img src="https://xeokit.io/img/docs/CityJSONLoaderPlugin/CityJSONLoaderPlugin.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_CityJSONLoaderPlugin_Railway)]
 *
 * ## Overview
 *
 * * Loads small-to-medium sized models directly from [CityJSON 1.0.0](https://www.cityjson.org/specs/1.0.0/) files.
 * * Loads double-precision coordinates, enabling models to be viewed at global coordinates without accuracy loss.
 * * Allows to set the position, scale and rotation of each model as you load it.
 * * Not recommended for large models. For best performance with large CityJSON datasets, we recommend
 * converting them to ````.xkt```` format (eg. using [convert2xkt](https://github.com/xeokit/xeokit-convert)), then loading
 * the ````.xkt```` using {@link XKTLoaderPlugin}.
 *
 * ## Limitations
 *
 * Loading and parsing huge CityJSON files can be slow, and can overwhelm the browser, however. To view your
 * largest CityJSON models, we recommend instead pre-converting those to xeokit's compressed native .XKT format, then
 * loading them with {@link XKTLoaderPlugin} instead.</p>
 *
 * ## Scene representation
 *
 * When loading a model, CityJSONLoaderPlugin creates an {@link Entity} that represents the model, which
 * will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id}
 * in {@link Scene#models}. The CityJSONLoaderPlugin also creates an {@link Entity} for each object within the
 * model. Those Entities will have {@link Entity#isObject} set ````true```` and will be registered
 * by {@link Entity#id} in {@link Scene#objects}.
 *
 * ## Metadata
 *
 * When loading a model, CityJSONLoaderPlugin also creates a {@link MetaModel} that represents the model, which contains
 * a tree of {@link MetaObject}s that represent the CityJSON objects. .
 *
 * ## Usage
 *
 * In the example below we'll load the LOD 3 Railway model from
 * a [CityJSON file](https://github.com/xeokit/xeokit-sdk/tree/master/assets/models/cityjson/LoD3_Railway.json). Within
 * our {@link Viewer}, this will create a bunch of {@link Entity}s that represents the model and its objects, along with
 * a {@link MetaModel} and {@link MetaObject}s that hold their metadata.
 *
 * We'll also scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * translate it 100 units along its X axis.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_CityJSONLoaderPlugin_Railway)]
 *
 * ````javascript
 * import {Viewer, CityJSONLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.scene.camera.eye = [14.915582703146043, 14.396781491179095, 5.431098754133695];
 * viewer.scene.camera.look = [6.599999999999998, 8.34099990051474, -4.159999575600315];
 * viewer.scene.camera.up = [-0.2820584034861215, 0.9025563895259413, -0.3253229483893775];
 *
 * const cityJSONLoader = new CityJSONLoaderPlugin(viewer);
 *
 * const model = cityJSONLoader.load({ // Returns an Entity that represents the model
 *     id: "myModel1",
 *     src: "../assets/models/cityjson/LoD3_Railway.json",
 *     saoEnabled: true,
 *     edges: false,
 *     rotation: [-90,0,0],
 *     scale: [0.5, 0.5, 0.5],
 *     origin: [100, 0, 0]
 * });
 * ````
 *
 * ## Configuring a custom data source
 *
 * By default, CityJSONLoaderPlugin will load CityJSON files over HTTP.
 *
 * In the example below, we'll customize the way CityJSONLoaderPlugin loads the files by configuring it with our own data source
 * object. For simplicity, our custom data source example also uses HTTP, using a couple of xeokit utility functions.
 *
 * ````javascript
 * import {utils} from "xeokit-sdk.es.js";
 *
 * class MyDataSource {
 *
 *      constructor() {
 *      }
 *
 *      getCityJSON(src, ok, error) {
 *          console.log("MyDataSource#getCityJSON(" + CityJSONSrc + ", ... )");
 *          utils.loadJSON(src,
 *              (cityJSON) => {
 *                  ok(cityJSON);
 *              },
 *              function (errMsg) {
 *                  error(errMsg);
 *              });
 *      }
 * }
 * ````
 *
 * @class CityJSONLoaderPlugin
 * @since 2.0.13
 */var CityJSONLoaderPlugin=/*#__PURE__*/function(_Plugin21){_inherits(CityJSONLoaderPlugin,_Plugin21);var _super162=_createSuper(CityJSONLoaderPlugin);/**
     * @constructor
     *
     * @param {Viewer} viewer The Viewer.
     * @param {Object} cfg  Plugin configuration.
     * @param {String} [cfg.id="cityJSONLoader"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.
     * @param {Object} [cfg.dataSource] A custom data source through which the CityJSONLoaderPlugin can load model and
     * metadata files. Defaults to an instance of {@link CityJSONDefaultDataSource}, which loads over HTTP.
     */function CityJSONLoaderPlugin(viewer){var _this165;var cfg=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CityJSONLoaderPlugin);_this165=_super162.call(this,"cityJSONLoader",viewer,cfg);_this165.dataSource=cfg.dataSource;return _this165;}/**
     * Gets the custom data source through which the CityJSONLoaderPlugin can load CityJSON files.
     *
     * Default value is {@link CityJSONDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */_createClass(CityJSONLoaderPlugin,[{key:"dataSource",get:function get(){return this._dataSource;}/**
     * Sets a custom data source through which the CityJSONLoaderPlugin can load CityJSON files.
     *
     * Default value is {@link CityJSONDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */,set:function set(value){this._dataSource=value||new CityJSONDefaultDataSource();}/**
     * Loads an ````CityJSON```` model into this CityJSONLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path to a CityJSON file, as an alternative to the ````cityJSON```` parameter.
     * @param {ArrayBuffer} [params.cityJSON] The CityJSON file data, as an alternative to the ````src```` parameter.
     * @param {Boolean} [params.loadMetadata=true] Whether to load metadata on CityJSON objects.
     * @param {Number[]} [params.origin=[0,0,0]] The model's World-space double-precision 3D origin. Use this to position the model within xeokit's World coordinate system, using double-precision coordinates.
     * @param {Number[]} [params.position=[0,0,0]] The model single-precision 3D position, relative to the ````origin```` parameter.
     * @param {Number[]} [params.scale=[1,1,1]] The model's scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's orientation, given as Euler angles in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters. Relative to ````origin````.
     * @param {Object} [params.stats] Collects model statistics.
     * @param {Boolean} [params.dtxEnabled=true] When ````true```` (default) use data textures (DTX), where appropriate, to
     * represent the returned model. Set false to always use vertex buffer objects (VBOs). Note that DTX is only applicable
     * to non-textured triangle meshes, and that VBOs are always used for meshes that have textures, line segments, or point
     * primitives. Only works while {@link DTX#enabled} is also ````true````.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
     */},{key:"load",value:function load(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(params.id&&this.viewer.scene.components[params.id]){this.error("Component with this ID already exists in viewer: "+params.id+" - will autogenerate this ID");delete params.id;}var sceneModel=new SceneModel(this.viewer.scene,utils.apply(params,{isModel:true,edges:true}));if(!params.src&&!params.cityJSON){this.error("load() param expected: src or cityJSON");return sceneModel;// Return new empty model
}var options={};if(params.src){this._loadModel(params.src,params,options,sceneModel);}else{var spinner=this.viewer.scene.canvas.spinner;spinner.processes++;this._parseModel(params.cityJSON,params,options,sceneModel);spinner.processes--;}return sceneModel;}},{key:"_loadModel",value:function _loadModel(src,params,options,sceneModel){var _this166=this;var spinner=this.viewer.scene.canvas.spinner;spinner.processes++;this._dataSource.getCityJSON(params.src,function(data){_this166._parseModel(data,params,options,sceneModel);spinner.processes--;},function(errMsg){spinner.processes--;_this166.error(errMsg);sceneModel.fire("error",errMsg);});}},{key:"_parseModel",value:function _parseModel(data,params,options,sceneModel){if(sceneModel.destroyed){return;}var vertices=data.transform?this._transformVertices(data.vertices,data.transform,options.rotateX):data.vertices;var stats=params.stats||{};stats.sourceFormat=data.type||"CityJSON";stats.schemaVersion=data.version||"";stats.title="";stats.author="";stats.created="";stats.numMetaObjects=0;stats.numPropertySets=0;stats.numObjects=0;stats.numGeometries=0;stats.numTriangles=0;stats.numVertices=0;var loadMetadata=params.loadMetadata!==false;var rootMetaObject=loadMetadata?{id:math.createUUID(),name:"Model",type:"Model"}:null;var metadata=loadMetadata?{id:"",projectId:"",author:"",createdAt:"",schema:data.version||"",creatingApplication:"",metaObjects:[rootMetaObject],propertySets:[]}:null;var ctx={data:data,vertices:vertices,sceneModel:sceneModel,loadMetadata:loadMetadata,metadata:metadata,rootMetaObject:rootMetaObject,nextId:0,stats:stats};this._parseCityJSON(ctx);sceneModel.finalize();if(loadMetadata){var metaModelId=sceneModel.id;this.viewer.metaScene.createMetaModel(metaModelId,ctx.metadata,options);}sceneModel.scene.once("tick",function(){if(sceneModel.destroyed){return;}sceneModel.scene.fire("modelLoaded",sceneModel.id);// FIXME: Assumes listeners know order of these two events
sceneModel.fire("loaded",true,false);// Don't forget the event, for late subscribers
});}},{key:"_transformVertices",value:function _transformVertices(vertices,transform,rotateX){var transformedVertices=[];var scale=transform.scale||math.vec3([1,1,1]);var translate=transform.translate||math.vec3([0,0,0]);for(var _i583=0,j=0;_i583<vertices.length;_i583++,j+=3){var x=vertices[_i583][0]*scale[0]+translate[0];var y=vertices[_i583][1]*scale[1]+translate[1];var _z5=vertices[_i583][2]*scale[2]+translate[2];if(rotateX){transformedVertices.push([x,_z5,y]);}else{transformedVertices.push([x,y,_z5]);}}return transformedVertices;}},{key:"_parseCityJSON",value:function _parseCityJSON(ctx){var data=ctx.data;var cityObjects=data.CityObjects;for(var objectId in cityObjects){if(cityObjects.hasOwnProperty(objectId)){var cityObject=cityObjects[objectId];this._parseCityObject(ctx,cityObject,objectId);}}}},{key:"_parseCityObject",value:function _parseCityObject(ctx,cityObject,objectId){var sceneModel=ctx.sceneModel;var data=ctx.data;if(ctx.loadMetadata){var metaObjectId=objectId;var metaObjectType=cityObject.type;var metaObjectName=metaObjectType+" : "+objectId;var parentMetaObjectId=cityObject.parents?cityObject.parents[0]:ctx.rootMetaObject.id;ctx.metadata.metaObjects.push({id:metaObjectId,name:metaObjectName,type:metaObjectType,parent:parentMetaObjectId});}ctx.stats.numMetaObjects++;if(!(cityObject.geometry&&cityObject.geometry.length>0)){return;}var meshIds=[];for(var _i584=0,len=cityObject.geometry.length;_i584<len;_i584++){var geometry=cityObject.geometry[_i584];var objectMaterial=void 0;var surfaceMaterials=void 0;var appearance=data.appearance;if(appearance){var materials=appearance.materials;if(materials){var geometryMaterial=geometry.material;if(geometryMaterial){var themeIds=Object.keys(geometryMaterial);if(themeIds.length>0){var themeId=themeIds[0];var theme=geometryMaterial[themeId];if(theme.value!==undefined){objectMaterial=materials[theme.value];}else{var values=theme.values;if(values){surfaceMaterials=[];for(var j=0,lenj=values.length;j<lenj;j++){var value=values[_i584];var surfaceMaterial=materials[value];surfaceMaterials.push(surfaceMaterial);}}}}}}}if(surfaceMaterials){this._parseGeometrySurfacesWithOwnMaterials(ctx,geometry,surfaceMaterials,meshIds);}else{this._parseGeometrySurfacesWithSharedMaterial(ctx,geometry,objectMaterial,meshIds);}}if(meshIds.length>0){sceneModel.createEntity({id:objectId,meshIds:meshIds,isObject:true});ctx.stats.numObjects++;}}},{key:"_parseGeometrySurfacesWithOwnMaterials",value:function _parseGeometrySurfacesWithOwnMaterials(ctx,geometry,surfaceMaterials,meshIds){var geomType=geometry.type;switch(geomType){case"MultiPoint":break;case"MultiLineString":break;case"MultiSurface":case"CompositeSurface":var surfaces=geometry.boundaries;this._parseSurfacesWithOwnMaterials(ctx,surfaceMaterials,surfaces,meshIds);break;case"Solid":var shells=geometry.boundaries;for(var j=0;j<shells.length;j++){var _surfaces=shells[j];this._parseSurfacesWithOwnMaterials(ctx,surfaceMaterials,_surfaces,meshIds);}break;case"MultiSolid":case"CompositeSolid":var solids=geometry.boundaries;for(var _j4=0;_j4<solids.length;_j4++){for(var k=0;k<solids[_j4].length;k++){var _surfaces2=solids[_j4][k];this._parseSurfacesWithOwnMaterials(ctx,surfaceMaterials,_surfaces2,meshIds);}}break;}}},{key:"_parseSurfacesWithOwnMaterials",value:function _parseSurfacesWithOwnMaterials(ctx,surfaceMaterials,surfaces,meshIds){var vertices=ctx.vertices;var sceneModel=ctx.sceneModel;for(var _i585=0;_i585<surfaces.length;_i585++){var surface=surfaces[_i585];var surfaceMaterial=surfaceMaterials[_i585]||{diffuseColor:[0.8,0.8,0.8],transparency:1.0};var face=[];var holes=[];var sharedIndices=[];var geometryCfg={positions:[],indices:[]};for(var j=0;j<surface.length;j++){if(face.length>0){holes.push(face.length);}var newFace=this._extractLocalIndices(ctx,surface[j],sharedIndices,geometryCfg);face.push.apply(face,_toConsumableArray(newFace));}if(face.length===3){// Triangle
geometryCfg.indices.push(face[0]);geometryCfg.indices.push(face[1]);geometryCfg.indices.push(face[2]);}else if(face.length>3){// Polygon
// Prepare to triangulate
var pList=[];for(var k=0;k<face.length;k++){pList.push({x:vertices[sharedIndices[face[k]]][0],y:vertices[sharedIndices[face[k]]][1],z:vertices[sharedIndices[face[k]]][2]});}var normal=this._getNormalOfPositions(pList,math.vec3());// Convert to 2D
var pv=[];for(var _k3=0;_k3<pList.length;_k3++){this._to2D(pList[_k3],normal,tempVec2a);pv.unshift(tempVec2a[0]);pv.unshift(tempVec2a[1]);}// Triangulate
var tr=earcut(pv,holes,2);// Create triangles
for(var _k4=0;_k4<tr.length;_k4+=3){geometryCfg.indices.unshift(face[tr[_k4]]);geometryCfg.indices.unshift(face[tr[_k4+1]]);geometryCfg.indices.unshift(face[tr[_k4+2]]);}}var meshId=""+ctx.nextId++;sceneModel.createMesh({id:meshId,primitive:"triangles",positions:geometryCfg.positions,indices:geometryCfg.indices,color:surfaceMaterial&&surfaceMaterial.diffuseColor?surfaceMaterial.diffuseColor:[0.8,0.8,0.8],opacity:surfaceMaterial&&surfaceMaterial.transparency!==undefined?1.0-surfaceMaterial.transparency:1.0});meshIds.push(meshId);ctx.stats.numGeometries++;ctx.stats.numVertices+=geometryCfg.positions.length/3;ctx.stats.numTriangles+=geometryCfg.indices.length/3;}}},{key:"_parseGeometrySurfacesWithSharedMaterial",value:function _parseGeometrySurfacesWithSharedMaterial(ctx,geometry,objectMaterial,meshIds){var sceneModel=ctx.sceneModel;var sharedIndices=[];var geometryCfg={positions:[],indices:[]};var geomType=geometry.type;switch(geomType){case"MultiPoint":break;case"MultiLineString":break;case"MultiSurface":case"CompositeSurface":var surfaces=geometry.boundaries;this._parseSurfacesWithSharedMaterial(ctx,surfaces,sharedIndices,geometryCfg);break;case"Solid":var shells=geometry.boundaries;for(var j=0;j<shells.length;j++){var _surfaces3=shells[j];this._parseSurfacesWithSharedMaterial(ctx,_surfaces3,sharedIndices,geometryCfg);}break;case"MultiSolid":case"CompositeSolid":var solids=geometry.boundaries;for(var _j5=0;_j5<solids.length;_j5++){for(var k=0;k<solids[_j5].length;k++){var _surfaces4=solids[_j5][k];this._parseSurfacesWithSharedMaterial(ctx,_surfaces4,sharedIndices,geometryCfg);}}break;}if(geometryCfg.positions.length>0&&geometryCfg.indices.length>0){var meshId=""+ctx.nextId++;sceneModel.createMesh({id:meshId,primitive:"triangles",positions:geometryCfg.positions,indices:geometryCfg.indices,color:objectMaterial&&objectMaterial.diffuseColor?objectMaterial.diffuseColor:[0.8,0.8,0.8],opacity:1.0//opacity: (objectMaterial && objectMaterial.transparency !== undefined) ? (1.0 - objectMaterial.transparency) : 1.0
});meshIds.push(meshId);ctx.stats.numGeometries++;ctx.stats.numVertices+=geometryCfg.positions.length/3;ctx.stats.numTriangles+=geometryCfg.indices.length/3;}}},{key:"_parseSurfacesWithSharedMaterial",value:function _parseSurfacesWithSharedMaterial(ctx,surfaces,sharedIndices,primitiveCfg){var vertices=ctx.vertices;for(var _i586=0;_i586<surfaces.length;_i586++){var boundary=[];var holes=[];for(var j=0;j<surfaces[_i586].length;j++){if(boundary.length>0){holes.push(boundary.length);}var newBoundary=this._extractLocalIndices(ctx,surfaces[_i586][j],sharedIndices,primitiveCfg);boundary.push.apply(boundary,_toConsumableArray(newBoundary));}if(boundary.length===3){// Triangle
primitiveCfg.indices.push(boundary[0]);primitiveCfg.indices.push(boundary[1]);primitiveCfg.indices.push(boundary[2]);}else if(boundary.length>3){// Polygon
var pList=[];for(var k=0;k<boundary.length;k++){pList.push({x:vertices[sharedIndices[boundary[k]]][0],y:vertices[sharedIndices[boundary[k]]][1],z:vertices[sharedIndices[boundary[k]]][2]});}var normal=this._getNormalOfPositions(pList,math.vec3());var pv=[];for(var _k5=0;_k5<pList.length;_k5++){this._to2D(pList[_k5],normal,tempVec2a);pv.unshift(tempVec2a[0]);pv.unshift(tempVec2a[1]);}var tr=earcut(pv,holes,2);for(var _k6=0;_k6<tr.length;_k6+=3){primitiveCfg.indices.unshift(boundary[tr[_k6]]);primitiveCfg.indices.unshift(boundary[tr[_k6+1]]);primitiveCfg.indices.unshift(boundary[tr[_k6+2]]);}}}}},{key:"_extractLocalIndices",value:function _extractLocalIndices(ctx,boundary,sharedIndices,geometryCfg){var vertices=ctx.vertices;var newBoundary=[];for(var _i587=0,len=boundary.length;_i587<len;_i587++){var index=boundary[_i587];if(sharedIndices.includes(index)){var vertexIndex=sharedIndices.indexOf(index);newBoundary.push(vertexIndex);}else{geometryCfg.positions.push(vertices[index][0]);geometryCfg.positions.push(vertices[index][1]);geometryCfg.positions.push(vertices[index][2]);newBoundary.push(sharedIndices.length);sharedIndices.push(index);}}return newBoundary;}},{key:"_getNormalOfPositions",value:function _getNormalOfPositions(positions,normal){for(var _i588=0;_i588<positions.length;_i588++){var nexti=_i588+1;if(nexti===positions.length){nexti=0;}normal[0]+=(positions[_i588].y-positions[nexti].y)*(positions[_i588].z+positions[nexti].z);normal[1]+=(positions[_i588].z-positions[nexti].z)*(positions[_i588].x+positions[nexti].x);normal[2]+=(positions[_i588].x-positions[nexti].x)*(positions[_i588].y+positions[nexti].y);}return math.normalizeVec3(normal);}},{key:"_to2D",value:function _to2D(_p,_n,re){var p=tempVec3a;var n=tempVec3b;var x3=tempVec3c;p[0]=_p.x;p[1]=_p.y;p[2]=_p.z;n[0]=_n.x;n[1]=_n.y;n[2]=_n.z;x3[0]=1.1;x3[1]=1.1;x3[2]=1.1;var dist=math.lenVec3(math.subVec3(x3,n));if(dist<0.01){x3[0]+=1.0;x3[1]+=2.0;x3[2]+=3.0;}var dot=math.dotVec3(x3,n);var tmp2=math.mulVec3Scalar(n,dot,math.vec3());x3[0]-=tmp2[0];x3[1]-=tmp2[1];x3[2]-=tmp2[2];math.normalizeVec3(x3);var y3=math.cross3Vec3(n,x3,math.vec3());var x=math.dotVec3(p,x3);var y=math.dotVec3(p,y3);re[0]=x;re[1]=y;}}]);return CityJSONLoaderPlugin;}(Plugin);export{AlphaFormat,AmbientLight,AngleMeasurementsControl,AngleMeasurementsMouseControl,AngleMeasurementsPlugin,AnnotationsPlugin,AxisGizmoPlugin,BCFViewpointsPlugin,Bitmap,ByteType,CameraMemento,CameraPath,CameraPathAnimation,CityJSONLoaderPlugin,ClampToEdgeWrapping,Component,CompressedMediaType,Configs,ContextMenu,CubicBezierCurve,Curve,DefaultLoadingManager,DepthFormat,DepthStencilFormat,DirLight,DistanceMeasurementsControl,DistanceMeasurementsMouseControl,DistanceMeasurementsPlugin,EdgeMaterial,EmphasisMaterial,FaceAlignedSectionPlanesPlugin,FastNavPlugin,FloatType,Fresnel,Frustum$1 as Frustum,FrustumPlane,GIFMediaType,GLTFDefaultDataSource,GLTFLoaderPlugin,HalfFloatType,ImagePlane,IntType,JPEGMediaType,KTX2TextureTranscoder,LASLoaderPlugin,LambertMaterial,LightMap,LineSet,LinearEncoding,LinearFilter,LinearMipMapLinearFilter,LinearMipMapNearestFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,Loader,LoadingManager,LocaleService,LuminanceAlphaFormat,LuminanceFormat,Map$1 as Map,Marker,MarqueePicker,MarqueePickerMouseControl,Mesh,MetallicMaterial,MirroredRepeatWrapping,ModelMemento,NavCubePlugin,NearestFilter,NearestMipMapLinearFilter,NearestMipMapNearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,Node$2 as Node,OBJLoaderPlugin,ObjectsKdTree3,ObjectsMemento,PNGMediaType,Path,PerformanceModel,PhongMaterial,Plugin,PointLight,PointerLens,QuadraticBezierCurve,Queue,RGBAFormat,RGBAIntegerFormat,RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format,RGBFormat,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format,RGFormat,RGIntegerFormat,ReadableGeometry,RedFormat,RedIntegerFormat,ReflectionMap,RepeatWrapping,STLDefaultDataSource,STLLoaderPlugin,SceneModel,SceneModelMesh,SceneModelTransform,SectionPlane,SectionPlanesPlugin,ShortType,Skybox,SkyboxesPlugin,SpecularMaterial,SplineCurve,SpriteMarker,StoreyViewsPlugin,Texture,TextureTranscoder,TreeViewPlugin,UnsignedByteType,UnsignedInt248Type,UnsignedIntType,UnsignedShort4444Type,UnsignedShort5551Type,UnsignedShortType,VBOGeometry,ViewCullPlugin,Viewer,WebIFCLoaderPlugin,WorkerPool$1 as WorkerPool,XKTDefaultDataSource,XKTLoaderPlugin,XML3DLoaderPlugin,buildBoxGeometry,buildBoxLinesGeometry,buildBoxLinesGeometryFromAABB,buildCylinderGeometry,buildGridGeometry,buildPlaneGeometry,buildPolylineGeometry,buildPolylineGeometryFromCurve,buildSphereGeometry,buildTorusGeometry,buildVectorTextGeometry,createRTCViewMat,frustumIntersectsAABB3,getKTX2TextureTranscoder,getPlaneRTCPos,load3DSGeometry,loadOBJGeometry,math,rtcToWorldPos,sRGBEncoding,setFrustum,stats,utils,worldToRTCPos,worldToRTCPositions};
