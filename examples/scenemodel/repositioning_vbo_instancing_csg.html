<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>xeokit Example</title>
    <link href="../css/pageStyle.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>
    <!-- <script src="./csg.js"></script> -->
</head>

<body>
    <input type="checkbox" id="info-button" />
    <label for="info-button" class="info-button"><i class="far fa-3x fa-question-circle"></i></label>
    <canvas id="myCanvas"></canvas>
    <div class="slideout-sidebar">
        <img class="info-icon" src="../../assets/images/performance_model_icon.png" />
        <h1>SceneModel</h1>
        <h2>Non-realistic rendering, geometry reuse, triangle primitives</h2>
        <p>
            <a href="../../docs/class/src/viewer/scene/model/SceneModel.js~SceneModel.html"
                target="_other">SceneModel</a> is a WebGL2-based <a
                href="../../docs/class/src/viewer/scene/model/SceneModel.js~SceneModel.html"
                target="_other">SceneModel</a> implementation that stores model geometry as data textures on the GPU.
        </p>
        <h3>Components Used</h3>
        <ul>
            <li>
                <a href="../../docs/class/src/viewer/Viewer.js~Viewer.html" target="_other">Viewer</a>
            </li>
            <li>
                <a href="../../docs/class/src/viewer/scene/model/SceneModel.js~SceneModel.html"
                    target="_other">SceneModel</a>
            </li>
        </ul>
    </div>
</body>

<script type="module">

    // console.log("csg: ", CSG);
    import CSG from './csg.js';
    import { Viewer, SceneModel, math, SectionPlanesPlugin } from "../../dist/xeokit-sdk.min.es.js";
    let sceneModel;

    const cubePositions = [
        1, 1, 1,
        -1, 1, 1,
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        1, -1, 1,
        1, -1, -1,
        1, 1, -1,
        1, 1, 1,
        1, 1, -1,
        -1, 1, -1,
        -1, 1, 1,
        -1, 1, 1,
        -1, 1, -1,
        -1, -1, -1,
        -1, -1, 1,
        -1, -1, -1,
        1, -1, -1,
        1, -1, 1,
        -1, -1, 1,
        1, -1, -1,
        -1, -1, -1,
        -1, 1, -1,
        1, 1, -1
    ]

    const planePositions = [
        2, 2, 0.01,
        -2, 2, 0.01,
        -2, -2, 0.01,
        2, -2, 0.01,
        2, 2, 0.01,
        2, -2, 0.01,
        2, -2, -0.01,
        2, 2, -0.01,
        2, 2, 0.01,
        2, 2, -0.01,
        -2, 2, -0.01,
        -2, 2, 0.01,
        -2, 2, 0.01,
        -2, 2, -0.01,
        -2, -2, -0.01,
        -2, -2, 0.01,
        -2, -2, -0.01,
        2, -2, -0.01,
        2, -2, 0.01,
        -2, -2, 0.01,
        2, -2, -0.01,
        -2, -2, -0.01,
        -2, 2, -0.01,
        2, 2, -0.01
    ]

    const indices = [
        0, 1, 2, 0, 2, 3,            // front
        4, 5, 6, 4, 6, 7,            // right
        8, 9, 10, 8, 10, 11,         // top
        12, 13, 14, 12, 14, 15,      // left
        16, 17, 18, 16, 18, 19,      // bottom
        20, 21, 22, 20, 22, 23
    ]

    const viewer = new Viewer({
        canvasId: "myCanvas",
        transparent: true
    });

    viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
    viewer.scene.camera.look = [0, -5.75, 0];
    viewer.scene.camera.up = [0.37, 0.91, -0.11];

    createSceneModel(cubePositions, indices);

    const cubeTransformMatrix = getTransformationMatrix([0, 0, 0], [0, 0, 0]);
    const cubeTransformedVertices = transformVertices(cubePositions, cubeTransformMatrix);

    const planeCorners = createSectionPlanes();

    console.log('planeCorners: ', planeCorners);

    // let csgGeometry = createCSGObject(positions, indices);
    // console.log('csgGeometry: ', csgGeometry);

    // const planePositions = [
    //     ...planeCorners.corner1,
    //     ...planeCorners.corner2,
    //     ...planeCorners.corner3,
    //     ...planeCorners.corner4,
    //     ...planeCorners.corner5,
    //     ...planeCorners.corner6,
    //     ...planeCorners.corner7,
    //     ...planeCorners.corner8
    // ];
    // const planePositions = [
    //     3, -5, -3,
    //     -3, -5, 3,
    //     3, 4, -3,
    //     -3, 4, 3
    // ]


    //6   7
    //4   5
    //2   3
    //0   1
    const planeIndices = [
        0, 1, 2,
        2, 3, 1,
        1, 5, 7,
        7, 3, 1,
        4, 5, 6,
        6, 7, 5,
        0, 4, 6,
        6, 2, 0,
        6, 2, 3,
        3, 7, 6,
        4, 0, 1,
        1, 5, 4
    ];

    const planeNormal = getObjectNormal(planePositions, indices);
    const normalizedDir = math.normalizeVec3([1.0, 0.01, 1.0]);
    const rotationQuaternion = computeQuaternionFromVectors(planeNormal, normalizedDir);

    // const euler = math.vec3();
    // math.quaternionToEuler(rotationQuaternion, 'XYZ', euler)
    // console.log('euler: ', euler);
    // createSceneModel(planePositions, indices, [0, 0, 0], rotationQuaternion, false, true);

    const planeTransformMatrix = getTransformationMatrix([0, 0, 0], rotationQuaternion, true);
    const planeTransformedVertices = transformVertices(planePositions, planeTransformMatrix);

    let csgCube = createCSGObject(cubePositions, indices);
    let csgPlane = createCSGObject(planeTransformedVertices, indices);
    // let csgPlane = createCSGObject(planePositions, indices);



    // const intersectionCSG = csgCube.intersect(csgPlane);
    const intersectionCSG = csgPlane.intersect(csgCube);
    // console.log('intersection: ', intersectionCSG, intersectionCSG.toPolygons());

    addIntersectedGeometry(intersectionCSG);

    // let cubeCSG = createCSGObject(cubeTransformedVertices, indices);
    // let planeCSG = createCSGObject(planeTransformedVertices, indices);
    // const intersectionCSG = cubeCSG.intersect(planeCSG);
    // console.log('intersectionCSG: ', intersectionCSG);


    function createSceneModel(positions, indices, _position = null, _rotation = null, _isClippable = true, _isQuat = false) {

        let sceneModelCfg = {
            id: "table",
            position: _position ? _position : [0, 0, 0],
            scale: [1, 1, 1],
            // rotation: _rotation ? _rotation : [0, 0, 0],
            edges: true
        };

        if (_isQuat) {
            sceneModelCfg = {
                ...sceneModelCfg,
                quaternion: _rotation ? _rotation : [0, 0, 0, 0]
            }
        }
        else {
            sceneModelCfg = {
                ...sceneModelCfg,
                rotation: _rotation ? _rotation : [0, 0, 0]
            }
        }

        console.log('creating scene model with cfg: ', sceneModelCfg)

        sceneModel = new SceneModel(viewer.scene, sceneModelCfg);

        sceneModel.createGeometry({
            id: "myBoxGeometry",
            primitive: "triangles",
            positions,
            indices
        });

        sceneModel.createMesh({
            id: "purpleTableTopMesh",
            geometryId: "myBoxGeometry",
            // position: [0, -3, 0],
            // scale: [6, 0.5, 6],
            position: [0, 0, 0],
            scale: [1, 1, 1],
            rotation: [0, 0, 0],
            color: [1.0, 0.3, 1.0]
        });

        sceneModel.createEntity({
            id: "purpleTableTop",
            meshIds: ["purpleTableTopMesh"],
            clippable: _isClippable,
        });

        sceneModel.finalize();
    }

    function createCSGObject(positions, indices) {
        let polygons = [];
        for (let i = 0; i < indices.length; i += 3) {
            let points = [];
            for (let j = 0; j < 3; j++) {
                let vertexIndex = indices[i + j];
                points.push(new CSG.Vertex(
                    {
                        x: positions[vertexIndex * 3],
                        y: positions[vertexIndex * 3 + 1],
                        z: positions[vertexIndex * 3 + 2]
                    }
                ));
            }
            polygons.push(new CSG.Polygon(points));
        }
        return CSG.fromPolygons(polygons);
    }

    function createSectionPlanes() {
        const sectionPlanes = new SectionPlanesPlugin(viewer, {
            overviewCanvasId: "mySectionPlanesOverviewCanvas",
            overviewVisible: true
        });

        const sectionPlane = sectionPlanes.createSectionPlane({
            id: "mySectionPlane",

            pos: viewer.scene.center,
            dir: math.normalizeVec3([1.0, 0.01, 1.0])
        });

        console.log('sectionPlane: ', sectionPlane);

    }

    // Convert CSG to WebGL-compatible geometry
    function csgToWebGLGeometry(csgGeometry) {
        const vertices = [];
        const indices = [];
        let index = 0;
        csgGeometry.polygons.forEach(polygon => {
            const vertexStartIndex = vertices.length / 3;
            polygon.vertices.forEach(vertex => {
                vertices.push(vertex.pos.x, vertex.pos.y, vertex.pos.z);
            });
            for (let i = 2; i < polygon.vertices.length; i++) {
                indices.push(vertexStartIndex, vertexStartIndex + i - 1, vertexStartIndex + i);
            }
        });
        return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices) };
    }

    function addIntersectedGeometry(geometry) {
        const webglGeometry = csgToWebGLGeometry(geometry);

        const intersectedModel = new SceneModel(viewer.scene, {
            id: "intersected",
            position: [0, 0, 0],
            scale: [1, 1, 1],
            rotation: [0, 0, 0],
            edges: true
        });

        intersectedModel.createGeometry({
            id: "myIntersectionGeometry",
            primitive: "triangles",
            positions: webglGeometry.vertices,
            indices: webglGeometry.indices
        });

        intersectedModel.createMesh({
            id: "redIntersectionMesh",
            geometryId: "myIntersectionGeometry",
            // position: [0, -3, 0],
            // scale: [6, 0.5, 6],
            position: [0, 0, 0],
            scale: [1, 1, 1],
            rotation: [0, 0, 0],
            color: [1.0, 0.0, 0.0]
        });

        intersectedModel.createEntity({
            id: "redIntersection",
            meshIds: ["redIntersectionMesh"],
            clippable: false,
        });

        intersectedModel.finalize();
    }

    function getTransformationMatrix(position, rotation, _isQuat = false) {
        const quat = _isQuat ? rotation : math.eulerToQuaternion(rotation, 'XYZ');
        // console.log('quat: ', quat);
        const mat4 = math.rotationTranslationMat4(quat, position);
        // console.log('mat4: ', mat4);
        return mat4;
    }

    function transformVertices(vertices, transformationMatrix) {
        const transformedVertices = [];
        for (let i = 0; i < vertices.length; i += 3) {
            const vertex = [vertices[i], vertices[i + 1], vertices[i + 2], 1];
            const transformedVertex = multiplyMatrixAndPoint(transformationMatrix, vertex);
            transformedVertices.push(transformedVertex[0], transformedVertex[1], transformedVertex[2]);
        }
        return new Float32Array(transformedVertices);
    }

    function multiplyMatrixAndPoint(matrix, point) {
        const result = [];
        for (let i = 0; i < 4; i++) {
            result[i] = matrix[i] * point[0] + matrix[i + 4] * point[1] + matrix[i + 8] * point[2] + matrix[i + 12] * point[3];
        }
        return result;
    }

    function getObjectNormal(positions, indices) {
        const v0 = getVertex(planePositions, indices[0]);
        const v1 = getVertex(planePositions, indices[1]);
        const v2 = getVertex(planePositions, indices[2]);

        const edge1 = math.subVec3(v1, v0);
        const edge2 = math.subVec3(v2, v0);

        const normal = math.cross3Vec3(edge1, edge2);

        return math.normalizeVec3(normal)
    }

    function getVertex(positionArray, index) {
        return [
            positionArray[3 * index],
            positionArray[3 * index + 1],
            positionArray[3 * index + 2]
        ];
    }

    function computeQuaternionFromVectors(v1, v2) {
        const dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        const cross = {
            x: v1[1] * v2[2] - v1[2] * v2[1],
            y: v1[2] * v2[0] - v1[0] * v2[2],
            z: v1[0] * v2[1] - v1[1] * v2[2]
        };
        const s = Math.sqrt((1 + dot) * 2);
        const invs = 1 / s;

        return [
            cross.x * invs,
            cross.y * invs,
            cross.z * invs,
            s * 0.5
        ]
    }
</script>

</html>