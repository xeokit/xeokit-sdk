<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>xeokit Example</title>
    <link href="../css/pageStyle.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>
    <style>
        /* ----------------------------------------------------------------------------------------------------------*/
        /* NavCubePlugin */
        /* ----------------------------------------------------------------------------------------------------------*/

        #myNavCubeCanvas {
            position: absolute;
            width: 250px;
            height: 250px;
            bottom: 50px;
            right: 10px;
            z-index: 200000;
        }

        /* ----------------------------------------------------------------------------------------------------------*/
        /* TreeViewPlugin */
        /* ----------------------------------------------------------------------------------------------------------*/

        #treeViewContainer {
            pointer-events: all;
            height: 100%;
            overflow-y: scroll;
            overflow-x: hidden;
            position: absolute;
            background-color: rgba(255, 255, 255, 0.2);
            color: black;
            top: 80px;
            z-index: 200000;
            float: left;
            left: 0;
            padding-left: 10px;
            font-family: 'Roboto', sans-serif;
            font-size: 15px;
            user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            width: 350px;
        }

        #treeViewContainer ul {
            list-style: none;
            padding-left: 1.75em;
            pointer-events: none;
        }

        #treeViewContainer ul li {
            position: relative;
            width: 500px;
            pointer-events: none;
            padding-top: 3px;
            padding-bottom: 3px;
            vertical-align: middle;
        }

        #treeViewContainer ul li a {
            background-color: #eee;
            border-radius: 50%;
            color: #000;
            display: inline-block;
            height: 1.5em;
            left: -1.5em;
            position: absolute;
            text-align: center;
            text-decoration: none;
            width: 1.5em;
            pointer-events: all;
        }

        #treeViewContainer ul li a.plus {
            background-color: #ded;
            pointer-events: all;
        }

        #treeViewContainer ul li a.minus {
            background-color: #eee;
            pointer-events: all;
        }

        #treeViewContainer ul li a:active {
            top: 1px;
            pointer-events: all;
        }

        #treeViewContainer ul li span:hover {
            color: white;
            cursor: pointer;
            background: black;
            padding-left: 2px;
            pointer-events: all;
        }

        #treeViewContainer ul li span {
            display: inline-block;
            width: calc(100% - 50px);
            padding-left: 2px;
            pointer-events: all;
            height: 23px;
        }

        #treeViewContainer .highlighted-node {
            /* Appearance of node highlighted with TreeViewPlugin#showNode() */
            border: black solid 1px;
            background: yellow;
            color: black;
            padding-left: 1px;
            padding-right: 5px;
            pointer-events: all;
        }
    </style>
</head>

<body>
    <input type="checkbox" id="info-button" />
    <label for="info-button" class="info-button"><i class="far fa-3x fa-question-circle"></i></label>
    <canvas id="myCanvas"></canvas>
    <canvas id="myNavCubeCanvas"></canvas>
    <div id="treeViewContainer"></div>
    <div class="slideout-sidebar">
        <img class="info-icon" src="../../assets/images/bim_icon.png" />
        <h1>IfcOpenShell loader</h1>
        <h3>Limitations</h3>
        <p>Loading and parsing huge IFC STEP files can be slow, and can overwhelm the browser, however. To view your
            largest IFC models, we recommend instead pre-converting those to xeokit's compressed native .XKT format,
            then
            loading them with <a
                href="../../docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html"
                target="_other">XKTLoaderPlugin</a>.</p>
        <h3>Stats</h3>
        <ul>
            <li>
                <div id="time">Loading JavaScript modules...</div>
            </li>
        </ul>
        <h3>Components used</h3>
        <ul>
            <li>
                <a href="../../docs/class/src/viewer/Viewer.js~Viewer.html" target="_other">Viewer</a>
            </li>
            <li>
                <a href="../../docs/class/src/plugins/TreeViewPlugin/TreeViewPlugin.js~TreeViewPlugin.html"
                    target="_other">TreeViewPlugin</a>
            </li>
            <li>
                <a href="../../docs/class/src/plugins/NavCubePlugin/NavCubePlugin.js~NavCubePlugin.html"
                    target="_other">NavCubePlugin</a>
            </li>
        </ul>
        <h3>Assets</h3>
        <ul>
            <li>
                <a href="http://openifcmodel.cs.auckland.ac.nz/Model/Details/274" target="_other">Model source</a>
            </li>
        </ul>
    </div>
</body>

<script type="text/javascript" src="https://cdn.jsdelivr.net/pyodide/v0.28.0a3/full/pyodide.js"></script>


<script type="module">

    import { Viewer, NavCubePlugin, TreeViewPlugin, Plugin, ReadableGeometry, PhongMaterial, Mesh, Node, math, worldToRTCPositions } from "../../dist/xeokit-sdk.min.es.js";

    async function setupPyodide(scene, fn) {
        const pyodide = await loadPyodide();
        await pyodide.loadPackage("micropip");
        await pyodide.loadPackage("numpy");
        await pyodide.loadPackage("shapely");
        const micropip = pyodide.pyimport("micropip");
        await micropip.install("typing-extensions");
        await micropip.install("../../dist/ifcopenshell-0.8.3+34a1bc6-cp313-cp313-emscripten_4_0_9_wasm32.whl");

        let ifcopenshell = pyodide.pyimport('ifcopenshell');
        let ifcopenshell_geom = pyodide.pyimport('ifcopenshell.geom');
        let settings = ifcopenshell_geom.settings();
        settings.set(settings.WELD_VERTICES, false);

        return { pyodide, ifcopenshell, ifcopenshell_geom, settings };
    }

    async function loadIfc(state, scene, fn) {
        const { pyodide, ifcopenshell, ifcopenshell_geom, settings } = state;
        const resp = await fetch(fn);
        const text = await resp.text();
        console.log(text.slice(0, 500));

        const ifc = ifcopenshell.file.from_string(text);
        const it = ifcopenshell_geom.iterator.callKwargs({
            'settings': settings,
            'file_or_filename': ifc,
            'exclude': ['IfcSpace', 'IfcOpeningElement'],
            'geometry_library': 'hybrid-cgal-simple-opencascade'
        });

        let last_mesh_id = null;
        let cache = {};
        let meshes = [];

        if (it.initialize()) {
            while (true) {
                let obj = it.get();

                // obj.type appears to be overwritten by pyodide, returning the typename of the C++ class?
                let ty = ifc.by_id(obj.id).is_a()
                meshes.push(generateMesh(scene, last_mesh_id, obj, cache));

                if (!it.next()) {
                    break;
                }
            }
        }

        return meshes;
    }

    function generateMesh(scene, last_mesh_id, obj, cache) {
        let bundles;

        if (cache.last_mesh_id === obj.geometry.id) {
            bundles = cache.last_bundles;
        } else {
            bundles = [];

            const srcMaterials = obj.geometry.materials.toJs();
            const materials = srcMaterials.map(e => new PhongMaterial(scene, {
                diffuse: e.diffuse.components.toJs(),
                backfaces: true
            }));
            const materialOpacities = srcMaterials.map(e => 1.0 - (e.transparency ?? 0));

            const mapping = {};
            obj.geometry.material_ids.toJs().forEach((matId, faceIdx) => {
                (mapping[matId] ||= []).push(faceIdx);
            });

            const vs = new Float32Array(obj.geometry.verts.toJs());
            const ns = new Float32Array(obj.geometry.normals.toJs());
            const es = new Uint32Array(obj.geometry.edges.toJs());
            const fs = obj.geometry.faces.toJs(); // triangles index buffer (flat)

            let offset = 0;
            if (mapping[-1]) {
                materials.unshift(new PhongMaterial(scene, { diffuse: [0.6, 0.6, 0.6], backfaces: true }));
                materialOpacities.unshift(1.0);
                offset = 1;
            }

            materials.forEach((mat, mi) => {
                const faceList = mapping[mi - offset];
                if (!faceList || faceList.length === 0) return;

                const triIndices = new Uint32Array(faceList.length * 3);
                let k = 0;
                for (const f of faceList) {
                    triIndices[k++] = fs[3 * f + 0];
                    triIndices[k++] = fs[3 * f + 1];
                    triIndices[k++] = fs[3 * f + 2];
                }

                const geom = new ReadableGeometry(scene, {
                    primitive: "triangles",
                    positions: vs,
                    normals: ns,
                    indices: triIndices
                });

                bundles.push({
                    geometry: geom,
                    material: mat,
                    kind: "tri",
                    opacity: materialOpacities[mi]
                });
            });

            const edgeGeom = new ReadableGeometry(scene, {
                primitive: "lines",
                positions: vs,
                indices: es
            });
            const edgeMat = new PhongMaterial(scene, { emissive: [0, 0, 0], lineWidth: 1 });

            bundles.push({ geometry: edgeGeom, material: edgeMat, kind: "line", opacity: 1.0 });

            cache.last_mesh_id = obj.geometry.id;
            cache.last_bundles = bundles;
        }

        const M = obj.transformation.data().components.toJs(); // 4x4 array
        const matrix = [
            M[0][0], M[2][0], -M[1][0], M[3][0],
            M[0][1], M[2][1], -M[1][1], M[3][1],
            M[0][2], M[2][2], -M[1][2], M[3][2],
            M[0][3], M[2][3], -M[1][3], M[3][3]
        ];

        // Move translation component into offset
        const origin = math.vec3();
        const worldOrigin = matrix.slice(12, 15);
        worldToRTCPositions(worldOrigin, worldOrigin, origin);
        matrix.splice(12, 3, ...worldOrigin);
        
        const parent = new Node(scene, {
            id: obj.guid || `obj_${obj.geometry.id}`,
            isObject: true,
            matrix,
            origin,
            children: bundles.map((b, i) => {
                const mesh = new Mesh(scene, {
                    id: `${obj.guid || obj.geometry.id}_${b.kind}_${i}`,
                    isObject: true,
                    geometry: b.geometry,
                    material: b.material
                });
                mesh.opacity = b.opacity;
                return mesh;
            })
        });

        return parent;
    }


    class IfcOpenShellLoaderPlugin extends Plugin {
        static _pyodidePromise = null;

        constructor(viewer, cfg = {}) {
            super(cfg.id || "IfcOpenShellLoaderPlugin", viewer, cfg);

            IfcOpenShellLoaderPlugin._pyodidePromise ??= (async () => {
                try {
                    const pyodide = await setupPyodide(
                        cfg.indexURL ? { indexURL: cfg.indexURL } : undefined
                    );
                    return pyodide;
                } catch (err) {
                    IfcOpenShellLoaderPlugin._pyodidePromise = null;
                    throw err;
                }
            })();
        }

        async load(params = {}) {
            const {
                id = "cubeModel",
            } = params;

            const pyodide = await IfcOpenShellLoaderPlugin._pyodidePromise;

            const scene = this.viewer.scene;
            const model = new Node(scene, {
                id,
                isModel: true,
                children: await loadIfc(pyodide, scene, "../../assets/models/ifc/Duplex.ifc")
            });

            this.fire("loaded", { id, model });
            return model;
        }
    }

    const viewer = new Viewer({
        canvasId: "myCanvas",
        transparent: true
    });

    viewer.camera.eye = [-3.933, 2.855, 27.018];
    viewer.camera.look = [4.400, 3.724, 8.899];
    viewer.camera.up = [-0.018, 0.999, 0.039];

    new NavCubePlugin(viewer, {
        canvasId: "myNavCubeCanvas",
        visible: true,
        size: 250,
        alignment: "bottomRight",
        bottomMargin: 100,
        rightMargin: 10
    });

    const loader = new IfcOpenShellLoaderPlugin(viewer);
    const sceneModel = loader.load();

</script>

</html>